
Output/Debug/Exe/demo.elf:     file format elf32-littleriscv


Disassembly of section .init._start:

80003000 <_start>:
#define L(label) .L_start_##label

START_FUNC _start
        .option push
        .option norelax
        lui     gp,     %hi(__global_pointer$)
80003000:	012091b7          	lui	gp,0x1209
        addi    gp, gp, %lo(__global_pointer$)
80003004:	37818193          	add	gp,gp,888 # 1209378 <sMbxSendQueue>
        lui     tp,     %hi(__thread_pointer$)
80003008:	01201237          	lui	tp,0x1201
        addi    tp, tp, %lo(__thread_pointer$)
8000300c:	80020213          	add	tp,tp,-2048 # 1200800 <GenObjDic>
        .option pop

        csrw    mstatus, zero
80003010:	30001073          	csrw	mstatus,zero
        csrw    mcause, zero
80003014:	34201073          	csrw	mcause,zero

    /* Initialize FCSR */
    fscsr zero
#endif

        lui     t0,     %hi(__stack_end__)
80003018:	002202b7          	lui	t0,0x220
        addi    sp, t0, %lo(__stack_end__)
8000301c:	00028113          	mv	sp,t0

#ifdef CONFIG_NOT_ENABLE_ICACHE
        call    l1c_ic_disable
#else
        call    l1c_ic_enable
80003020:	4a8090ef          	jal	8000c4c8 <l1c_ic_enable>
#endif
#ifdef CONFIG_NOT_ENABLE_DCACHE
        call    l1c_dc_invalidate_all
        call    l1c_dc_disable
#else
        call    l1c_dc_enable
80003024:	470090ef          	jal	8000c494 <l1c_dc_enable>
        call    l1c_dc_invalidate_all
80003028:	7cb0e0ef          	jal	80011ff2 <l1c_dc_invalidate_all>

#ifndef __NO_SYSTEM_INIT
        //
        // Call _init
        //
        call    _init
8000302c:	5150e0ef          	jal	80011d40 <_init>

80003030 <.Lpcrel_hi0>:
        // Call linker init functions which in turn performs the following:
        // * Perform segment init
        // * Perform heap init (if used)
        // * Call constructors of global Objects (if any exist)
        //
        la      s0, __SEGGER_init_table__       // Set table pointer to start of initialization table
80003030:	80015437          	lui	s0,0x80015
80003034:	91040413          	add	s0,s0,-1776 # 80014910 <.L155+0x2>

80003038 <.L_start_RunInit>:
L(RunInit):
        lw      a0, (s0)                        // Get next initialization function from table
80003038:	4008                	lw	a0,0(s0)
        add     s0, s0, 4                       // Increment table pointer to point to function arguments
8000303a:	0411                	add	s0,s0,4
        jalr    a0                              // Call initialization function
8000303c:	9502                	jalr	a0
        j       L(RunInit)
8000303e:	bfed                	j	80003038 <.L_start_RunInit>

80003040 <__SEGGER_init_done>:
        // Time to call main(), the application entry point.
        //

#ifndef NO_CLEANUP_AT_START
    /* clean up */
    call _clean_up
80003040:	65d080ef          	jal	8000be9c <_clean_up>

80003044 <.Lpcrel_hi1>:
    #define HANDLER_S_TRAP irq_handler_s_trap
#endif

#if !defined(USE_NONVECTOR_MODE) || (USE_NONVECTOR_MODE == 0)
    /* Initial machine trap-vector Base */
    la t0, __vector_table
80003044:	000002b7          	lui	t0,0x0
80003048:	00028293          	mv	t0,t0
    csrw mtvec, t0
8000304c:	30529073          	csrw	mtvec,t0
#if defined (USE_S_MODE_IRQ)
    la t0, __vector_s_table
    csrw stvec, t0
#endif
    /* Enable vectored external PLIC interrupt */
    csrsi CSR_MMISC_CTL, 2
80003050:	7d016073          	csrs	0x7d0,2

80003054 <start>:
        //
        // In a real embedded application ("Free-standing environment"),
        // main() does not get any arguments,
        // which means it is not necessary to init a0 and a1.
        //
        call    APP_ENTRY_POINT
80003054:	4d50e0ef          	jal	80011d28 <reset_handler>
        tail    exit
80003058:	a009                	j	8000305a <exit>

8000305a <exit>:
MARK_FUNC exit
        //
        // In a free-standing environment, if returned from application:
        // Loop forever.
        //
        j       .
8000305a:	a001                	j	8000305a <exit>
        la      a1, args
        call    debug_getargs
        li      a0, ARGSSPACE
        la      a1, args
#else
        li      a0, 0
8000305c:	4501                	li	a0,0
        li      a1, 0
8000305e:	4581                	li	a1,0
#endif

        call    APP_ENTRY_POINT
80003060:	4c90e0ef          	jal	80011d28 <reset_handler>
        tail    exit
80003064:	bfdd                	j	8000305a <exit>

Disassembly of section .text.libc.__SEGGER_RTL_SIGNAL_SIG_DFL:

80003066 <__SEGGER_RTL_SIGNAL_SIG_DFL>:
80003066:	8082                	ret

Disassembly of section .text.gpio_write_pin:

80005d1a <gpio_write_pin>:
 * @param port Port index
 * @param pin Pin index
 * @param high Pin level set to high when it is set to true
 */
static inline void gpio_write_pin(GPIO_Type *ptr, uint32_t port, uint8_t pin, uint8_t high)
{
80005d1a:	1141                	add	sp,sp,-16
80005d1c:	c62a                	sw	a0,12(sp)
80005d1e:	c42e                	sw	a1,8(sp)
80005d20:	87b2                	mv	a5,a2
80005d22:	8736                	mv	a4,a3
80005d24:	00f103a3          	sb	a5,7(sp)
80005d28:	87ba                	mv	a5,a4
80005d2a:	00f10323          	sb	a5,6(sp)
    if (high) {
80005d2e:	00614783          	lbu	a5,6(sp)
80005d32:	cf91                	beqz	a5,80005d4e <.L2>
        ptr->DO[port].SET = 1 << pin;
80005d34:	00714783          	lbu	a5,7(sp)
80005d38:	4705                	li	a4,1
80005d3a:	00f717b3          	sll	a5,a4,a5
80005d3e:	86be                	mv	a3,a5
80005d40:	4732                	lw	a4,12(sp)
80005d42:	47a2                	lw	a5,8(sp)
80005d44:	07c1                	add	a5,a5,16
80005d46:	0792                	sll	a5,a5,0x4
80005d48:	97ba                	add	a5,a5,a4
80005d4a:	c3d4                	sw	a3,4(a5)
    } else {
        ptr->DO[port].CLEAR = 1 << pin;
    }
}
80005d4c:	a829                	j	80005d66 <.L4>

80005d4e <.L2>:
        ptr->DO[port].CLEAR = 1 << pin;
80005d4e:	00714783          	lbu	a5,7(sp)
80005d52:	4705                	li	a4,1
80005d54:	00f717b3          	sll	a5,a4,a5
80005d58:	86be                	mv	a3,a5
80005d5a:	4732                	lw	a4,12(sp)
80005d5c:	47a2                	lw	a5,8(sp)
80005d5e:	07c1                	add	a5,a5,16
80005d60:	0792                	sll	a5,a5,0x4
80005d62:	97ba                	add	a5,a5,a4
80005d64:	c794                	sw	a3,8(a5)

80005d66 <.L4>:
}
80005d66:	0001                	nop
80005d68:	0141                	add	sp,sp,16
80005d6a:	8082                	ret

Disassembly of section .text.OLED_ColorTurn:

80005d72 <OLED_ColorTurn>:

uint8_t OLED_GRAM[144][8];

// 反显函数
void OLED_ColorTurn(uint8_t i)
{
80005d72:	1101                	add	sp,sp,-32
80005d74:	ce06                	sw	ra,28(sp)
80005d76:	87aa                	mv	a5,a0
80005d78:	00f107a3          	sb	a5,15(sp)
	if (i == 0)
80005d7c:	00f14783          	lbu	a5,15(sp)
80005d80:	e789                	bnez	a5,80005d8a <.L6>
	{
		OLED_WR_Byte(0xA6, OLED_CMD); // 正常显示
80005d82:	4581                	li	a1,0
80005d84:	0a600513          	li	a0,166
80005d88:	2a9d                	jal	80005efe <OLED_WR_Byte>

80005d8a <.L6>:
	}
	if (i == 1)
80005d8a:	00f14703          	lbu	a4,15(sp)
80005d8e:	4785                	li	a5,1
80005d90:	00f71663          	bne	a4,a5,80005d9c <.L8>
	{
		OLED_WR_Byte(0xA7, OLED_CMD); // 反色显示
80005d94:	4581                	li	a1,0
80005d96:	0a700513          	li	a0,167
80005d9a:	2295                	jal	80005efe <OLED_WR_Byte>

80005d9c <.L8>:
	}
}
80005d9c:	0001                	nop
80005d9e:	40f2                	lw	ra,28(sp)
80005da0:	6105                	add	sp,sp,32
80005da2:	8082                	ret

Disassembly of section .text.OLED_DisplayTurn:

80005daa <OLED_DisplayTurn>:

// 屏幕旋转180度
void OLED_DisplayTurn(uint8_t i)
{
80005daa:	1101                	add	sp,sp,-32
80005dac:	ce06                	sw	ra,28(sp)
80005dae:	87aa                	mv	a5,a0
80005db0:	00f107a3          	sb	a5,15(sp)
	if (i == 0)
80005db4:	00f14783          	lbu	a5,15(sp)
80005db8:	eb89                	bnez	a5,80005dca <.L10>
	{
		OLED_WR_Byte(0xC8, OLED_CMD); // 正常显示
80005dba:	4581                	li	a1,0
80005dbc:	0c800513          	li	a0,200
80005dc0:	2a3d                	jal	80005efe <OLED_WR_Byte>
		OLED_WR_Byte(0xA1, OLED_CMD);
80005dc2:	4581                	li	a1,0
80005dc4:	0a100513          	li	a0,161
80005dc8:	2a1d                	jal	80005efe <OLED_WR_Byte>

80005dca <.L10>:
	}
	if (i == 1)
80005dca:	00f14703          	lbu	a4,15(sp)
80005dce:	4785                	li	a5,1
80005dd0:	00f71a63          	bne	a4,a5,80005de4 <.L12>
	{
		OLED_WR_Byte(0xC0, OLED_CMD); // 反转显示
80005dd4:	4581                	li	a1,0
80005dd6:	0c000513          	li	a0,192
80005dda:	2215                	jal	80005efe <OLED_WR_Byte>
		OLED_WR_Byte(0xA0, OLED_CMD);
80005ddc:	4581                	li	a1,0
80005dde:	0a000513          	li	a0,160
80005de2:	2a31                	jal	80005efe <OLED_WR_Byte>

80005de4 <.L12>:
	}
}
80005de4:	0001                	nop
80005de6:	40f2                	lw	ra,28(sp)
80005de8:	6105                	add	sp,sp,32
80005dea:	8082                	ret

Disassembly of section .text.I2C_Stop:

80005dfe <I2C_Stop>:
	IIC_delay();
}

// 结束信号
void I2C_Stop(void)
{
80005dfe:	1141                	add	sp,sp,-16
80005e00:	c606                	sw	ra,12(sp)
	OLED_SDA_Clr();
80005e02:	4681                	li	a3,0
80005e04:	4619                	li	a2,6
80005e06:	458d                	li	a1,3
80005e08:	f00d0537          	lui	a0,0xf00d0
80005e0c:	3739                	jal	80005d1a <gpio_write_pin>
	OLED_SCL_Set();
80005e0e:	4685                	li	a3,1
80005e10:	461d                	li	a2,7
80005e12:	458d                	li	a1,3
80005e14:	f00d0537          	lui	a0,0xf00d0
80005e18:	3709                	jal	80005d1a <gpio_write_pin>
	IIC_delay();
80005e1a:	054080ef          	jal	8000de6e <IIC_delay>
	OLED_SDA_Set();
80005e1e:	4685                	li	a3,1
80005e20:	4619                	li	a2,6
80005e22:	458d                	li	a1,3
80005e24:	f00d0537          	lui	a0,0xf00d0
80005e28:	3dcd                	jal	80005d1a <gpio_write_pin>
}
80005e2a:	0001                	nop
80005e2c:	40b2                	lw	ra,12(sp)
80005e2e:	0141                	add	sp,sp,16
80005e30:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_SIGNAL_SIG_IGN:

80005e32 <__SEGGER_RTL_SIGNAL_SIG_IGN>:
80005e32:	8082                	ret

Disassembly of section .text.I2C_WaitAck:

80005e3a <I2C_WaitAck>:

// 等待信号响应
void I2C_WaitAck(void) // 测数据信号的电平
{
80005e3a:	1141                	add	sp,sp,-16
80005e3c:	c606                	sw	ra,12(sp)
	OLED_SDA_Set();
80005e3e:	4685                	li	a3,1
80005e40:	4619                	li	a2,6
80005e42:	458d                	li	a1,3
80005e44:	f00d0537          	lui	a0,0xf00d0
80005e48:	3dc9                	jal	80005d1a <gpio_write_pin>
	IIC_delay();
80005e4a:	024080ef          	jal	8000de6e <IIC_delay>
	OLED_SCL_Set();
80005e4e:	4685                	li	a3,1
80005e50:	461d                	li	a2,7
80005e52:	458d                	li	a1,3
80005e54:	f00d0537          	lui	a0,0xf00d0
80005e58:	35c9                	jal	80005d1a <gpio_write_pin>
	IIC_delay();
80005e5a:	014080ef          	jal	8000de6e <IIC_delay>
	OLED_SCL_Clr();
80005e5e:	4681                	li	a3,0
80005e60:	461d                	li	a2,7
80005e62:	458d                	li	a1,3
80005e64:	f00d0537          	lui	a0,0xf00d0
80005e68:	3d4d                	jal	80005d1a <gpio_write_pin>
	IIC_delay();
80005e6a:	004080ef          	jal	8000de6e <IIC_delay>
}
80005e6e:	0001                	nop
80005e70:	40b2                	lw	ra,12(sp)
80005e72:	0141                	add	sp,sp,16
80005e74:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_SIGNAL_SIG_ERR:

80005e76 <__SEGGER_RTL_SIGNAL_SIG_ERR>:
80005e76:	8082                	ret

Disassembly of section .text.Send_Byte:

80005e7e <Send_Byte>:

// 写入一个字节
void Send_Byte(uint8_t dat)
{
80005e7e:	7179                	add	sp,sp,-48
80005e80:	d606                	sw	ra,44(sp)
80005e82:	87aa                	mv	a5,a0
80005e84:	00f107a3          	sb	a5,15(sp)
	uint8_t i;
	for (i = 0; i < 8; i++)
80005e88:	00010fa3          	sb	zero,31(sp)
80005e8c:	a8a1                	j	80005ee4 <.L19>

80005e8e <.L22>:
	{
		if (dat & 0x80) // 将dat的8位从最高位依次写入
80005e8e:	00f10783          	lb	a5,15(sp)
80005e92:	0007d963          	bgez	a5,80005ea4 <.L20>
		{
			OLED_SDA_Set();
80005e96:	4685                	li	a3,1
80005e98:	4619                	li	a2,6
80005e9a:	458d                	li	a1,3
80005e9c:	f00d0537          	lui	a0,0xf00d0
80005ea0:	3dad                	jal	80005d1a <gpio_write_pin>
80005ea2:	a039                	j	80005eb0 <.L21>

80005ea4 <.L20>:
		}
		else
		{
			OLED_SDA_Clr();
80005ea4:	4681                	li	a3,0
80005ea6:	4619                	li	a2,6
80005ea8:	458d                	li	a1,3
80005eaa:	f00d0537          	lui	a0,0xf00d0
80005eae:	35b5                	jal	80005d1a <gpio_write_pin>

80005eb0 <.L21>:
		}
		IIC_delay();
80005eb0:	7bf070ef          	jal	8000de6e <IIC_delay>
		OLED_SCL_Set();
80005eb4:	4685                	li	a3,1
80005eb6:	461d                	li	a2,7
80005eb8:	458d                	li	a1,3
80005eba:	f00d0537          	lui	a0,0xf00d0
80005ebe:	3db1                	jal	80005d1a <gpio_write_pin>
		IIC_delay();
80005ec0:	7af070ef          	jal	8000de6e <IIC_delay>
		OLED_SCL_Clr(); // 将时钟信号设置为低电平
80005ec4:	4681                	li	a3,0
80005ec6:	461d                	li	a2,7
80005ec8:	458d                	li	a1,3
80005eca:	f00d0537          	lui	a0,0xf00d0
80005ece:	35b1                	jal	80005d1a <gpio_write_pin>
		dat <<= 1;
80005ed0:	00f14783          	lbu	a5,15(sp)
80005ed4:	0786                	sll	a5,a5,0x1
80005ed6:	00f107a3          	sb	a5,15(sp)
	for (i = 0; i < 8; i++)
80005eda:	01f14783          	lbu	a5,31(sp)
80005ede:	0785                	add	a5,a5,1
80005ee0:	00f10fa3          	sb	a5,31(sp)

80005ee4 <.L19>:
80005ee4:	01f14703          	lbu	a4,31(sp)
80005ee8:	479d                	li	a5,7
80005eea:	fae7f2e3          	bgeu	a5,a4,80005e8e <.L22>
	}
}
80005eee:	0001                	nop
80005ef0:	0001                	nop
80005ef2:	50b2                	lw	ra,44(sp)
80005ef4:	6145                	add	sp,sp,48
80005ef6:	8082                	ret

Disassembly of section .text.OLED_WR_Byte:

80005efe <OLED_WR_Byte>:

// 发送一个字节
// mode:数据/命令标志 0,表示命令;1,表示数据;
void OLED_WR_Byte(uint8_t dat, uint8_t mode)
{
80005efe:	1101                	add	sp,sp,-32
80005f00:	ce06                	sw	ra,28(sp)
80005f02:	87aa                	mv	a5,a0
80005f04:	872e                	mv	a4,a1
80005f06:	00f107a3          	sb	a5,15(sp)
80005f0a:	87ba                	mv	a5,a4
80005f0c:	00f10723          	sb	a5,14(sp)
	I2C_Start();
80005f10:	77f070ef          	jal	8000de8e <I2C_Start>
	Send_Byte(0x78);
80005f14:	07800513          	li	a0,120
80005f18:	379d                	jal	80005e7e <Send_Byte>
	I2C_WaitAck();
80005f1a:	3705                	jal	80005e3a <I2C_WaitAck>
	if (mode)
80005f1c:	00e14783          	lbu	a5,14(sp)
80005f20:	c789                	beqz	a5,80005f2a <.L24>
	{
		Send_Byte(0x40);
80005f22:	04000513          	li	a0,64
80005f26:	3fa1                	jal	80005e7e <Send_Byte>
80005f28:	a019                	j	80005f2e <.L25>

80005f2a <.L24>:
	}
	else
	{
		Send_Byte(0x00);
80005f2a:	4501                	li	a0,0
80005f2c:	3f89                	jal	80005e7e <Send_Byte>

80005f2e <.L25>:
	}
	I2C_WaitAck();
80005f2e:	3731                	jal	80005e3a <I2C_WaitAck>
	Send_Byte(dat);
80005f30:	00f14783          	lbu	a5,15(sp)
80005f34:	853e                	mv	a0,a5
80005f36:	37a1                	jal	80005e7e <Send_Byte>
	I2C_WaitAck();
80005f38:	3709                	jal	80005e3a <I2C_WaitAck>
	I2C_Stop();
80005f3a:	35d1                	jal	80005dfe <I2C_Stop>
}
80005f3c:	0001                	nop
80005f3e:	40f2                	lw	ra,28(sp)
80005f40:	6105                	add	sp,sp,32
80005f42:	8082                	ret

Disassembly of section .text.OLED_ShowString:

80005f4a <OLED_ShowString>:
// x,y:起点坐标
// size1:字体大小
//*chr:字符串起始地址
// mode:0,反色显示;1,正常显示
void OLED_ShowString(uint8_t x, uint8_t y, uint8_t *chr, uint8_t size1, uint8_t mode)
{
80005f4a:	1101                	add	sp,sp,-32
80005f4c:	ce06                	sw	ra,28(sp)
80005f4e:	87aa                	mv	a5,a0
80005f50:	c432                	sw	a2,8(sp)
80005f52:	00f107a3          	sb	a5,15(sp)
80005f56:	87ae                	mv	a5,a1
80005f58:	00f10723          	sb	a5,14(sp)
80005f5c:	87b6                	mv	a5,a3
80005f5e:	00f106a3          	sb	a5,13(sp)
80005f62:	87ba                	mv	a5,a4
80005f64:	00f10623          	sb	a5,12(sp)
	while ((*chr >= ' ') && (*chr <= '~')) // 判断是不是非法字符!
80005f68:	a0b9                	j	80005fb6 <.L76>

80005f6a <.L80>:
	{
		OLED_ShowChar(x, y, *chr, size1, mode);
80005f6a:	47a2                	lw	a5,8(sp)
80005f6c:	0007c603          	lbu	a2,0(a5)
80005f70:	00c14703          	lbu	a4,12(sp)
80005f74:	00d14683          	lbu	a3,13(sp)
80005f78:	00e14583          	lbu	a1,14(sp)
80005f7c:	00f14783          	lbu	a5,15(sp)
80005f80:	853e                	mv	a0,a5
80005f82:	16a080ef          	jal	8000e0ec <OLED_ShowChar>
		if (size1 == 8)
80005f86:	00d14703          	lbu	a4,13(sp)
80005f8a:	47a1                	li	a5,8
80005f8c:	00f71863          	bne	a4,a5,80005f9c <.L77>
			x += 6;
80005f90:	00f14783          	lbu	a5,15(sp)
80005f94:	0799                	add	a5,a5,6
80005f96:	00f107a3          	sb	a5,15(sp)
80005f9a:	a819                	j	80005fb0 <.L78>

80005f9c <.L77>:
		else
			x += size1 / 2;
80005f9c:	00d14783          	lbu	a5,13(sp)
80005fa0:	8385                	srl	a5,a5,0x1
80005fa2:	0ff7f793          	zext.b	a5,a5
80005fa6:	00f14703          	lbu	a4,15(sp)
80005faa:	97ba                	add	a5,a5,a4
80005fac:	00f107a3          	sb	a5,15(sp)

80005fb0 <.L78>:
		chr++;
80005fb0:	47a2                	lw	a5,8(sp)
80005fb2:	0785                	add	a5,a5,1
80005fb4:	c43e                	sw	a5,8(sp)

80005fb6 <.L76>:
	while ((*chr >= ' ') && (*chr <= '~')) // 判断是不是非法字符!
80005fb6:	47a2                	lw	a5,8(sp)
80005fb8:	0007c703          	lbu	a4,0(a5)
80005fbc:	47fd                	li	a5,31
80005fbe:	00e7f963          	bgeu	a5,a4,80005fd0 <.L81>
80005fc2:	47a2                	lw	a5,8(sp)
80005fc4:	0007c703          	lbu	a4,0(a5)
80005fc8:	07e00793          	li	a5,126
80005fcc:	f8e7ffe3          	bgeu	a5,a4,80005f6a <.L80>

80005fd0 <.L81>:
	}
}
80005fd0:	0001                	nop
80005fd2:	40f2                	lw	ra,28(sp)
80005fd4:	6105                	add	sp,sp,32
80005fd6:	8082                	ret

Disassembly of section .text.OLED_ShowNum:

80005ff6 <OLED_ShowNum>:
// num :要显示的数字
// len :数字的位数
// size:字体大小
// mode:0,反色显示;1,正常显示
void OLED_ShowNum(uint8_t x, uint8_t y, uint32_t num, uint8_t len, uint8_t size1, uint8_t mode)
{
80005ff6:	7179                	add	sp,sp,-48
80005ff8:	d606                	sw	ra,44(sp)
80005ffa:	c432                	sw	a2,8(sp)
80005ffc:	8636                	mv	a2,a3
80005ffe:	86ba                	mv	a3,a4
80006000:	873e                	mv	a4,a5
80006002:	87aa                	mv	a5,a0
80006004:	00f107a3          	sb	a5,15(sp)
80006008:	87ae                	mv	a5,a1
8000600a:	00f10723          	sb	a5,14(sp)
8000600e:	87b2                	mv	a5,a2
80006010:	00f106a3          	sb	a5,13(sp)
80006014:	87b6                	mv	a5,a3
80006016:	00f10623          	sb	a5,12(sp)
8000601a:	87ba                	mv	a5,a4
8000601c:	00f103a3          	sb	a5,7(sp)
	uint8_t t, temp, m = 0;
80006020:	00010f23          	sb	zero,30(sp)
	if (size1 == 8)
80006024:	00c14703          	lbu	a4,12(sp)
80006028:	47a1                	li	a5,8
8000602a:	00f71563          	bne	a4,a5,80006034 <.L87>
		m = 2;
8000602e:	4789                	li	a5,2
80006030:	00f10f23          	sb	a5,30(sp)

80006034 <.L87>:
	for (t = 0; t < len; t++)
80006034:	00010fa3          	sb	zero,31(sp)
80006038:	a0f9                	j	80006106 <.L88>

8000603a <.L91>:
	{
		temp = (num / OLED_Pow(10, len - t - 1)) % 10;
8000603a:	00d14783          	lbu	a5,13(sp)
8000603e:	873e                	mv	a4,a5
80006040:	01f14783          	lbu	a5,31(sp)
80006044:	40f707b3          	sub	a5,a4,a5
80006048:	0ff7f793          	zext.b	a5,a5
8000604c:	17fd                	add	a5,a5,-1
8000604e:	0ff7f793          	zext.b	a5,a5
80006052:	85be                	mv	a1,a5
80006054:	4529                	li	a0,10
80006056:	2aa080ef          	jal	8000e300 <OLED_Pow>
8000605a:	872a                	mv	a4,a0
8000605c:	47a2                	lw	a5,8(sp)
8000605e:	02e7d733          	divu	a4,a5,a4
80006062:	47a9                	li	a5,10
80006064:	02f777b3          	remu	a5,a4,a5
80006068:	00f10ea3          	sb	a5,29(sp)
		if (temp == 0)
8000606c:	01d14783          	lbu	a5,29(sp)
80006070:	e3b1                	bnez	a5,800060b4 <.L89>
		{
			OLED_ShowChar(x + (size1 / 2 + m) * t, y, '0', size1, mode);
80006072:	00c14783          	lbu	a5,12(sp)
80006076:	8385                	srl	a5,a5,0x1
80006078:	0ff7f793          	zext.b	a5,a5
8000607c:	01e14703          	lbu	a4,30(sp)
80006080:	97ba                	add	a5,a5,a4
80006082:	0ff7f793          	zext.b	a5,a5
80006086:	01f14703          	lbu	a4,31(sp)
8000608a:	02e787b3          	mul	a5,a5,a4
8000608e:	0ff7f793          	zext.b	a5,a5
80006092:	00f14703          	lbu	a4,15(sp)
80006096:	97ba                	add	a5,a5,a4
80006098:	0ff7f793          	zext.b	a5,a5
8000609c:	00714703          	lbu	a4,7(sp)
800060a0:	00c14683          	lbu	a3,12(sp)
800060a4:	00e14583          	lbu	a1,14(sp)
800060a8:	03000613          	li	a2,48
800060ac:	853e                	mv	a0,a5
800060ae:	03e080ef          	jal	8000e0ec <OLED_ShowChar>
800060b2:	a0a9                	j	800060fc <.L90>

800060b4 <.L89>:
		}
		else
		{
			OLED_ShowChar(x + (size1 / 2 + m) * t, y, temp + '0', size1, mode);
800060b4:	00c14783          	lbu	a5,12(sp)
800060b8:	8385                	srl	a5,a5,0x1
800060ba:	0ff7f793          	zext.b	a5,a5
800060be:	01e14703          	lbu	a4,30(sp)
800060c2:	97ba                	add	a5,a5,a4
800060c4:	0ff7f793          	zext.b	a5,a5
800060c8:	01f14703          	lbu	a4,31(sp)
800060cc:	02e787b3          	mul	a5,a5,a4
800060d0:	0ff7f793          	zext.b	a5,a5
800060d4:	00f14703          	lbu	a4,15(sp)
800060d8:	97ba                	add	a5,a5,a4
800060da:	0ff7f793          	zext.b	a5,a5
800060de:	01d14703          	lbu	a4,29(sp)
800060e2:	03070713          	add	a4,a4,48
800060e6:	0ff77613          	zext.b	a2,a4
800060ea:	00714703          	lbu	a4,7(sp)
800060ee:	00c14683          	lbu	a3,12(sp)
800060f2:	00e14583          	lbu	a1,14(sp)
800060f6:	853e                	mv	a0,a5
800060f8:	7f5070ef          	jal	8000e0ec <OLED_ShowChar>

800060fc <.L90>:
	for (t = 0; t < len; t++)
800060fc:	01f14783          	lbu	a5,31(sp)
80006100:	0785                	add	a5,a5,1
80006102:	00f10fa3          	sb	a5,31(sp)

80006106 <.L88>:
80006106:	01f14703          	lbu	a4,31(sp)
8000610a:	00d14783          	lbu	a5,13(sp)
8000610e:	f2f766e3          	bltu	a4,a5,8000603a <.L91>
		}
	}
}
80006112:	0001                	nop
80006114:	0001                	nop
80006116:	50b2                	lw	ra,44(sp)
80006118:	6145                	add	sp,sp,48
8000611a:	8082                	ret

Disassembly of section .text.OLED_Init:

80006122 <OLED_Init>:
		}
	}
}
// OLED的初始化
void OLED_Init(void)
{
80006122:	1101                	add	sp,sp,-32
80006124:	ce06                	sw	ra,28(sp)
	uint32_t pad_ctl = IOC_PAD_PAD_CTL_OD_SET(1);
80006126:	10000793          	li	a5,256
8000612a:	c63e                	sw	a5,12(sp)

	/* SDA */
	HPM_IOC->PAD[IOC_PAD_PD06].FUNC_CTL = IOC_PD06_FUNC_CTL_GPIO_D_06;
8000612c:	f40407b7          	lui	a5,0xf4040
80006130:	3207a823          	sw	zero,816(a5) # f4040330 <__AHB_SRAM_segment_end__+0x3e38330>
	HPM_IOC->PAD[IOC_PAD_PD06].PAD_CTL = pad_ctl;
80006134:	f40407b7          	lui	a5,0xf4040
80006138:	4732                	lw	a4,12(sp)
8000613a:	32e7aa23          	sw	a4,820(a5) # f4040334 <__AHB_SRAM_segment_end__+0x3e38334>
	/* SCL */
	HPM_IOC->PAD[IOC_PAD_PD07].FUNC_CTL = IOC_PD07_FUNC_CTL_GPIO_D_07;
8000613e:	f40407b7          	lui	a5,0xf4040
80006142:	3207ac23          	sw	zero,824(a5) # f4040338 <__AHB_SRAM_segment_end__+0x3e38338>
	HPM_IOC->PAD[IOC_PAD_PD07].PAD_CTL = pad_ctl;
80006146:	f40407b7          	lui	a5,0xf4040
8000614a:	4732                	lw	a4,12(sp)
8000614c:	32e7ae23          	sw	a4,828(a5) # f404033c <__AHB_SRAM_segment_end__+0x3e3833c>
	gpio_set_pin_output_with_initial(HPM_GPIO0, GPIO_DO_GPIOD, 6U, 0);
80006150:	4681                	li	a3,0
80006152:	4619                	li	a2,6
80006154:	458d                	li	a1,3
80006156:	f00d0537          	lui	a0,0xf00d0
8000615a:	153060ef          	jal	8000caac <gpio_set_pin_output_with_initial>
	gpio_set_pin_output_with_initial(HPM_GPIO0, GPIO_DO_GPIOD, 7U, 0);
8000615e:	4681                	li	a3,0
80006160:	461d                	li	a2,7
80006162:	458d                	li	a1,3
80006164:	f00d0537          	lui	a0,0xf00d0
80006168:	145060ef          	jal	8000caac <gpio_set_pin_output_with_initial>

	board_delay_ms(200);
8000616c:	0c800513          	li	a0,200
80006170:	0880c0ef          	jal	800121f8 <board_delay_ms>

	OLED_WR_Byte(0xAE, OLED_CMD); //--turn off oled panel
80006174:	4581                	li	a1,0
80006176:	0ae00513          	li	a0,174
8000617a:	3351                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x00, OLED_CMD); //---set low column address
8000617c:	4581                	li	a1,0
8000617e:	4501                	li	a0,0
80006180:	3bbd                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x10, OLED_CMD); //---set high column address
80006182:	4581                	li	a1,0
80006184:	4541                	li	a0,16
80006186:	3ba5                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x40, OLED_CMD); //--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
80006188:	4581                	li	a1,0
8000618a:	04000513          	li	a0,64
8000618e:	3b85                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x81, OLED_CMD); //--set contrast control register
80006190:	4581                	li	a1,0
80006192:	08100513          	li	a0,129
80006196:	33a5                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xCF, OLED_CMD); // Set SEG Output Current Brightness
80006198:	4581                	li	a1,0
8000619a:	0cf00513          	li	a0,207
8000619e:	3385                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xA1, OLED_CMD); //--Set SEG/Column Mapping     0xa0左右反置 0xa1正常
800061a0:	4581                	li	a1,0
800061a2:	0a100513          	li	a0,161
800061a6:	3ba1                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xC8, OLED_CMD); // Set COM/Row Scan Direction   0xc0上下反置 0xc8正常
800061a8:	4581                	li	a1,0
800061aa:	0c800513          	li	a0,200
800061ae:	3b81                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xA6, OLED_CMD); //--set normal display
800061b0:	4581                	li	a1,0
800061b2:	0a600513          	li	a0,166
800061b6:	33a1                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xA8, OLED_CMD); //--set multiplex ratio(1 to 64)
800061b8:	4581                	li	a1,0
800061ba:	0a800513          	li	a0,168
800061be:	3381                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x3f, OLED_CMD); //--1/64 duty
800061c0:	4581                	li	a1,0
800061c2:	03f00513          	li	a0,63
800061c6:	3b25                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xD3, OLED_CMD); //-set display offset	Shift Mapping RAM Counter (0x00~0x3F)
800061c8:	4581                	li	a1,0
800061ca:	0d300513          	li	a0,211
800061ce:	3b05                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x00, OLED_CMD); //-not offset
800061d0:	4581                	li	a1,0
800061d2:	4501                	li	a0,0
800061d4:	332d                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xd5, OLED_CMD); //--set display clock divide ratio/oscillator frequency
800061d6:	4581                	li	a1,0
800061d8:	0d500513          	li	a0,213
800061dc:	330d                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x80, OLED_CMD); //--set divide ratio, Set Clock as 100 Frames/Sec
800061de:	4581                	li	a1,0
800061e0:	08000513          	li	a0,128
800061e4:	3b29                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xD9, OLED_CMD); //--set pre-charge period
800061e6:	4581                	li	a1,0
800061e8:	0d900513          	li	a0,217
800061ec:	3b09                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xF1, OLED_CMD); // Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
800061ee:	4581                	li	a1,0
800061f0:	0f100513          	li	a0,241
800061f4:	3329                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xDA, OLED_CMD); //--set com pins hardware configuration
800061f6:	4581                	li	a1,0
800061f8:	0da00513          	li	a0,218
800061fc:	3309                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x12, OLED_CMD);
800061fe:	4581                	li	a1,0
80006200:	4549                	li	a0,18
80006202:	39f5                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0xDB, OLED_CMD); //--set vcomh
80006204:	4581                	li	a1,0
80006206:	0db00513          	li	a0,219
8000620a:	39d5                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x30, OLED_CMD); // Set VCOM Deselect Level
8000620c:	4581                	li	a1,0
8000620e:	03000513          	li	a0,48
80006212:	31f5                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x20, OLED_CMD); //-Set Page Addressing Mode (0x00/0x01/0x02)
80006214:	4581                	li	a1,0
80006216:	02000513          	li	a0,32
8000621a:	31d5                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x02, OLED_CMD); //
8000621c:	4581                	li	a1,0
8000621e:	4509                	li	a0,2
80006220:	39f9                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x8D, OLED_CMD); //--set Charge Pump enable/disable
80006222:	4581                	li	a1,0
80006224:	08d00513          	li	a0,141
80006228:	39d9                	jal	80005efe <OLED_WR_Byte>
	OLED_WR_Byte(0x14, OLED_CMD); //--set(0x10) disable
8000622a:	4581                	li	a1,0
8000622c:	4551                	li	a0,20
8000622e:	39c1                	jal	80005efe <OLED_WR_Byte>
	OLED_Clear();
80006230:	54b070ef          	jal	8000df7a <OLED_Clear>
	OLED_WR_Byte(0xAF, OLED_CMD);
80006234:	4581                	li	a1,0
80006236:	0af00513          	li	a0,175
8000623a:	31d1                	jal	80005efe <OLED_WR_Byte>
}
8000623c:	0001                	nop
8000623e:	40f2                	lw	ra,28(sp)
80006240:	6105                	add	sp,sp,32
80006242:	8082                	ret

Disassembly of section .text.main:

80006262 <main>:
#include "hpm_ecat_hw.h"
#include "hpm_l1c_drv.h"
#include "oled.h"

int main(void)
{
80006262:	1101                	add	sp,sp,-32
80006264:	ce06                	sw	ra,28(sp)
    hpm_stat_t stat;
    board_init();
80006266:	77b0b0ef          	jal	800121e0 <board_init>
    board_init_led_pins();
8000626a:	7a30b0ef          	jal	8001220c <board_init_led_pins>
    OLED_Init();
8000626e:	3d55                	jal	80006122 <OLED_Init>
    OLED_ColorTurn(0);    //0正常显示，1 反色显示
80006270:	4501                	li	a0,0
80006272:	3601                	jal	80005d72 <OLED_ColorTurn>
    OLED_DisplayTurn(0);  //0正常显示 1 屏幕翻转显示
80006274:	4501                	li	a0,0
80006276:	3e15                	jal	80005daa <OLED_DisplayTurn>
    OLED_ShowString(20,0,"[EtherCAT]",16,1);
80006278:	4705                	li	a4,1
8000627a:	46c1                	li	a3,16
8000627c:	800077b7          	lui	a5,0x80007
80006280:	e4878613          	add	a2,a5,-440 # 80006e48 <.LC0>
80006284:	4581                	li	a1,0
80006286:	4551                	li	a0,20
80006288:	31c9                	jal	80005f4a <OLED_ShowString>
    OLED_ShowString(0,16,"InputCounter",16,1);
8000628a:	4705                	li	a4,1
8000628c:	46c1                	li	a3,16
8000628e:	800077b7          	lui	a5,0x80007
80006292:	e5478613          	add	a2,a5,-428 # 80006e54 <.LC1>
80006296:	45c1                	li	a1,16
80006298:	4501                	li	a0,0
8000629a:	3945                	jal	80005f4a <OLED_ShowString>
    OLED_Refresh();
8000629c:	43d070ef          	jal	8000ded8 <OLED_Refresh>

    board_init_ethercat(HPM_ESC); /* init ESC function pins */
800062a0:	f1700537          	lui	a0,0xf1700
800062a4:	1760c0ef          	jal	8001241a <board_init_ethercat>
    printf("EtherCAT IO sample\n");
800062a8:	800077b7          	lui	a5,0x80007
800062ac:	e6478513          	add	a0,a5,-412 # 80006e64 <.LC2>
800062b0:	311070ef          	jal	8000ddc0 <printf>

    /* hardware init */
    stat = ecat_hardware_init(HPM_ESC);
800062b4:	f1700537          	lui	a0,0xf1700
800062b8:	5f40b0ef          	jal	800118ac <ecat_hardware_init>
800062bc:	c62a                	sw	a0,12(sp)
    if (stat != status_success) {
800062be:	47b2                	lw	a5,12(sp)
800062c0:	cb89                	beqz	a5,800062d2 <.L2>
        printf("Init ESC peripheral and related devices(EEPROM/PHY) failed!\n");
800062c2:	800077b7          	lui	a5,0x80007
800062c6:	e7878513          	add	a0,a5,-392 # 80006e78 <.LC3>
800062ca:	2f7070ef          	jal	8000ddc0 <printf>
        return 0;
800062ce:	4781                	li	a5,0
800062d0:	a8a9                	j	8000632a <.L3>

800062d2 <.L2>:
    }

    MainInit(); /* SSC Initilize the stack */
800062d2:	3e5000ef          	jal	80006eb6 <MainInit>

#if defined(ESC_EEPROM_EMULATION) && ESC_EEPROM_EMULATION
    pAPPL_EEPROM_Read  = ecat_eeprom_emulation_read;
800062d6:	00001737          	lui	a4,0x1
800062da:	64a70713          	add	a4,a4,1610 # 164a <ecat_eeprom_emulation_read>
800062de:	10e1a023          	sw	a4,256(gp) # 1209478 <pAPPL_EEPROM_Read>
    pAPPL_EEPROM_Write = ecat_eeprom_emulation_write;
800062e2:	00001737          	lui	a4,0x1
800062e6:	72670713          	add	a4,a4,1830 # 1726 <ecat_eeprom_emulation_write>
800062ea:	0ee1aa23          	sw	a4,244(gp) # 120946c <pAPPL_EEPROM_Write>
    pAPPL_EEPROM_Reload = ecat_eeprom_emulation_reload;
800062ee:	00001737          	lui	a4,0x1
800062f2:	78670713          	add	a4,a4,1926 # 1786 <ecat_eeprom_emulation_reload>
800062f6:	0ee1ae23          	sw	a4,252(gp) # 1209474 <pAPPL_EEPROM_Reload>
    pAPPL_EEPROM_Store  = ecat_eeprom_emulation_store;
800062fa:	80012737          	lui	a4,0x80012
800062fe:	b2070713          	add	a4,a4,-1248 # 80011b20 <ecat_eeprom_emulation_store>
80006302:	0ee1ac23          	sw	a4,248(gp) # 1209470 <pAPPL_EEPROM_Store>
#endif

    /* Create basic mapping */
    APPL_GenerateMapping(&nPdInputSize, &nPdOutputSize);
80006306:	16218593          	add	a1,gp,354 # 12094da <nPdOutputSize>
8000630a:	16418513          	add	a0,gp,356 # 12094dc <nPdInputSize>
8000630e:	038050ef          	jal	8000b346 <APPL_GenerateMapping>

    /* Set stack run flag */
    bRunApplication = TRUE;
80006312:	4705                	li	a4,1
80006314:	18e18aa3          	sb	a4,405(gp) # 120950d <bRunApplication>
    /* Execute the stack */
    while (bRunApplication == TRUE) {
80006318:	a019                	j	8000631e <.L4>

8000631a <.L5>:
        MainLoop();
8000631a:	4c1000ef          	jal	80006fda <MainLoop>

8000631e <.L4>:
    while (bRunApplication == TRUE) {
8000631e:	1951c703          	lbu	a4,405(gp) # 120950d <bRunApplication>
80006322:	4785                	li	a5,1
80006324:	fef70be3          	beq	a4,a5,8000631a <.L5>
    }

    /* hardware deinit */

    return 0;
80006328:	4781                	li	a5,0

8000632a <.L3>:
}
8000632a:	853e                	mv	a0,a5
8000632c:	40f2                	lw	ra,28(sp)
8000632e:	6105                	add	sp,sp,32
80006330:	8082                	ret

Disassembly of section .text.Read0x10F8:

80006352 <Read0x10F8>:
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0x10F8(UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 MBXMEM * pData, UINT8 bCompleteAccess)
{
80006352:	1101                	add	sp,sp,-32
80006354:	ce06                	sw	ra,28(sp)
80006356:	87aa                	mv	a5,a0
80006358:	c432                	sw	a2,8(sp)
8000635a:	c236                	sw	a3,4(sp)
8000635c:	00f11723          	sh	a5,14(sp)
80006360:	87ae                	mv	a5,a1
80006362:	00f106a3          	sb	a5,13(sp)
80006366:	87ba                	mv	a5,a4
80006368:	00f10623          	sb	a5,12(sp)

    if (index != 0x10F8)
8000636c:	00e15703          	lhu	a4,14(sp)
80006370:	6785                	lui	a5,0x1
80006372:	0f878793          	add	a5,a5,248 # 10f8 <.L89+0x1a>
80006376:	00f70463          	beq	a4,a5,8000637e <.L2>
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
8000637a:	47ad                	li	a5,11
8000637c:	a815                	j	800063b0 <.L3>

8000637e <.L2>:
    }

    
    if (bCompleteAccess)
8000637e:	00c14783          	lbu	a5,12(sp)
80006382:	c399                	beqz	a5,80006388 <.L4>
    {
         /* Complete Access is not supported for object 0x10F8 */
        return ABORTIDX_UNSUPPORTED_ACCESS;
80006384:	4795                	li	a5,5
80006386:	a02d                	j	800063b0 <.L3>

80006388 <.L4>:
    }

    if (subindex > 0)
80006388:	00d14783          	lbu	a5,13(sp)
8000638c:	c399                	beqz	a5,80006392 <.L5>
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
8000638e:	47c5                	li	a5,17
80006390:	a005                	j	800063b0 <.L3>

80006392 <.L5>:
    }

    if (dataSize > 8)
80006392:	4722                	lw	a4,8(sp)
80006394:	47a1                	li	a5,8
80006396:	00e7f463          	bgeu	a5,a4,8000639e <.L6>
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
8000639a:	47bd                	li	a5,15
8000639c:	a811                	j	800063b0 <.L3>

8000639e <.L6>:
    }


    COE_SyncTimeStamp();
8000639e:	79b070ef          	jal	8000e338 <COE_SyncTimeStamp>

    MEMCPY(pData, &u64Timestamp, dataSize);
800063a2:	4622                	lw	a2,8(sp)
800063a4:	37020593          	add	a1,tp,880 # 370 <default_isr_62+0x7a>
800063a8:	4512                	lw	a0,4(sp)
800063aa:	0b3070ef          	jal	8000dc5c <memcpy>
    return 0;
800063ae:	4781                	li	a5,0

800063b0 <.L3>:
}
800063b0:	853e                	mv	a0,a5
800063b2:	40f2                	lw	ra,28(sp)
800063b4:	6105                	add	sp,sp,32
800063b6:	8082                	ret

Disassembly of section .text.COE_UpdateSyncErrorStatus:

800063ca <COE_UpdateSyncErrorStatus>:
/**
\brief     Update the Sync Error Indication
*////////////////////////////////////////////////////////////////////////////////////////
void COE_UpdateSyncErrorStatus(void)
{
    if (sSyncManOutPar.u16CycleExceededCounter > 0 || sSyncManOutPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
800063ca:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800063ce:	0267c703          	lbu	a4,38(a5)
800063d2:	0277c783          	lbu	a5,39(a5)
800063d6:	07a2                	sll	a5,a5,0x8
800063d8:	8fd9                	or	a5,a5,a4
800063da:	0807c7b3          	zext.h	a5,a5
800063de:	e79d                	bnez	a5,8000640c <.L14>
800063e0:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800063e4:	0247c703          	lbu	a4,36(a5)
800063e8:	0257c783          	lbu	a5,37(a5)
800063ec:	07a2                	sll	a5,a5,0x8
800063ee:	8fd9                	or	a5,a5,a4
800063f0:	0807c733          	zext.h	a4,a5
800063f4:	1a818793          	add	a5,gp,424 # 1209520 <sErrorSettings>
800063f8:	0067c683          	lbu	a3,6(a5)
800063fc:	0077c783          	lbu	a5,7(a5)
80006400:	07a2                	sll	a5,a5,0x8
80006402:	8fd5                	or	a5,a5,a3
80006404:	0807c7b3          	zext.h	a5,a5
80006408:	00e7f863          	bgeu	a5,a4,80006418 <.L15>

8000640c <.L14>:
    {
        sSyncManOutPar.u8SyncError = 1;
8000640c:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006410:	4705                	li	a4,1
80006412:	02e78e23          	sb	a4,60(a5)
80006416:	a029                	j	80006420 <.L16>

80006418 <.L15>:
    }
    else
    {
        sSyncManOutPar.u8SyncError = 0;
80006418:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000641c:	02078e23          	sb	zero,60(a5)

80006420 <.L16>:
    }


    if (sSyncManInPar.u16CycleExceededCounter > 0 || sSyncManInPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
80006420:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006424:	0267c703          	lbu	a4,38(a5)
80006428:	0277c783          	lbu	a5,39(a5)
8000642c:	07a2                	sll	a5,a5,0x8
8000642e:	8fd9                	or	a5,a5,a4
80006430:	0807c7b3          	zext.h	a5,a5
80006434:	e79d                	bnez	a5,80006462 <.L17>
80006436:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000643a:	0247c703          	lbu	a4,36(a5)
8000643e:	0257c783          	lbu	a5,37(a5)
80006442:	07a2                	sll	a5,a5,0x8
80006444:	8fd9                	or	a5,a5,a4
80006446:	0807c733          	zext.h	a4,a5
8000644a:	1a818793          	add	a5,gp,424 # 1209520 <sErrorSettings>
8000644e:	0067c683          	lbu	a3,6(a5)
80006452:	0077c783          	lbu	a5,7(a5)
80006456:	07a2                	sll	a5,a5,0x8
80006458:	8fd5                	or	a5,a5,a3
8000645a:	0807c7b3          	zext.h	a5,a5
8000645e:	00e7f863          	bgeu	a5,a4,8000646e <.L18>

80006462 <.L17>:
    {
        sSyncManInPar.u8SyncError = 1;
80006462:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006466:	4705                	li	a4,1
80006468:	02e78e23          	sb	a4,60(a5)
8000646c:	a031                	j	80006478 <.L19>

8000646e <.L18>:
    }
    else
    {
        sSyncManInPar.u8SyncError = 0;
8000646e:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006472:	02078e23          	sb	zero,60(a5)
    }

}
80006476:	0001                	nop

80006478 <.L19>:
80006478:	0001                	nop
8000647a:	8082                	ret

Disassembly of section .text.COE_AddObjectToDic:

80006482 <COE_AddObjectToDic>:
            ALSTATUSCODE_XX add object failed

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
80006482:	1101                	add	sp,sp,-32
80006484:	c62a                	sw	a0,12(sp)
    if(pNewObjEntry != NULL)
80006486:	47b2                	lw	a5,12(sp)
80006488:	c7f1                	beqz	a5,80006554 <.L25>
    {
        if(ObjDicList == NULL)
8000648a:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
8000648e:	ef91                	bnez	a5,800064aa <.L26>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
80006490:	4732                	lw	a4,12(sp)
80006492:	12e1aa23          	sw	a4,308(gp) # 12094ac <ObjDicList>
            ObjDicList->pNext = NULL;
80006496:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
8000649a:	0007a223          	sw	zero,4(a5)
            ObjDicList->pPrev = NULL;
8000649e:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
800064a2:	0007a023          	sw	zero,0(a5)
            return 0;
800064a6:	4781                	li	a5,0
800064a8:	a07d                	j	80006556 <.L27>

800064aa <.L26>:
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
800064aa:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
800064ae:	0087d703          	lhu	a4,8(a5)
800064b2:	47b2                	lw	a5,12(sp)
800064b4:	0087d783          	lhu	a5,8(a5)
800064b8:	02e7f263          	bgeu	a5,a4,800064dc <.L28>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
800064bc:	47b2                	lw	a5,12(sp)
800064be:	0007a023          	sw	zero,0(a5)
            pNewObjEntry->pNext = ObjDicList;
800064c2:	1341a703          	lw	a4,308(gp) # 12094ac <ObjDicList>
800064c6:	47b2                	lw	a5,12(sp)
800064c8:	c3d8                	sw	a4,4(a5)
            ObjDicList->pPrev = pNewObjEntry;
800064ca:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
800064ce:	4732                	lw	a4,12(sp)
800064d0:	c398                	sw	a4,0(a5)
            ObjDicList = pNewObjEntry;
800064d2:	4732                	lw	a4,12(sp)
800064d4:	12e1aa23          	sw	a4,308(gp) # 12094ac <ObjDicList>
            return 0;
800064d8:	4781                	li	a5,0
800064da:	a8b5                	j	80006556 <.L27>

800064dc <.L28>:
        }
        else
        {
            TOBJECT    OBJMEM * pDicEntry = ObjDicList;
800064dc:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
800064e0:	ce3e                	sw	a5,28(sp)
            while(pDicEntry != NULL)
800064e2:	a0bd                	j	80006550 <.L29>

800064e4 <.L34>:
            {
                if(pDicEntry->Index == pNewObjEntry->Index)
800064e4:	47f2                	lw	a5,28(sp)
800064e6:	0087d703          	lhu	a4,8(a5)
800064ea:	47b2                	lw	a5,12(sp)
800064ec:	0087d783          	lhu	a5,8(a5)
800064f0:	00f71463          	bne	a4,a5,800064f8 <.L30>
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
800064f4:	4785                	li	a5,1
800064f6:	a085                	j	80006556 <.L27>

800064f8 <.L30>:
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
800064f8:	47f2                	lw	a5,28(sp)
800064fa:	0087d703          	lhu	a4,8(a5)
800064fe:	47b2                	lw	a5,12(sp)
80006500:	0087d783          	lhu	a5,8(a5)
80006504:	02e7f563          	bgeu	a5,a4,8000652e <.L31>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
80006508:	47f2                	lw	a5,28(sp)
8000650a:	4398                	lw	a4,0(a5)
8000650c:	47b2                	lw	a5,12(sp)
8000650e:	c398                	sw	a4,0(a5)
                    pNewObjEntry->pNext = pDicEntry;
80006510:	47b2                	lw	a5,12(sp)
80006512:	4772                	lw	a4,28(sp)
80006514:	c3d8                	sw	a4,4(a5)

                    if(pDicEntry->pPrev != NULL)
80006516:	47f2                	lw	a5,28(sp)
80006518:	439c                	lw	a5,0(a5)
8000651a:	c789                	beqz	a5,80006524 <.L32>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
8000651c:	47f2                	lw	a5,28(sp)
8000651e:	439c                	lw	a5,0(a5)
80006520:	4732                	lw	a4,12(sp)
80006522:	c3d8                	sw	a4,4(a5)

80006524 <.L32>:

                    pDicEntry->pPrev = pNewObjEntry;
80006524:	47f2                	lw	a5,28(sp)
80006526:	4732                	lw	a4,12(sp)
80006528:	c398                	sw	a4,0(a5)

                    return 0;
8000652a:	4781                	li	a5,0
8000652c:	a02d                	j	80006556 <.L27>

8000652e <.L31>:
                }
                else if(pDicEntry->pNext == NULL)
8000652e:	47f2                	lw	a5,28(sp)
80006530:	43dc                	lw	a5,4(a5)
80006532:	ef81                	bnez	a5,8000654a <.L33>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
80006534:	47f2                	lw	a5,28(sp)
80006536:	4732                	lw	a4,12(sp)
80006538:	c3d8                	sw	a4,4(a5)
                    pNewObjEntry->pPrev = pDicEntry;
8000653a:	47b2                	lw	a5,12(sp)
8000653c:	4772                	lw	a4,28(sp)
8000653e:	c398                	sw	a4,0(a5)
                    pNewObjEntry->pNext = NULL;
80006540:	47b2                	lw	a5,12(sp)
80006542:	0007a223          	sw	zero,4(a5)
                    return 0;
80006546:	4781                	li	a5,0
80006548:	a039                	j	80006556 <.L27>

8000654a <.L33>:
                }
                else
                {
                    /*The new object index is smaller than the current index. Get next object handle.*/
                    pDicEntry = pDicEntry->pNext;
8000654a:	47f2                	lw	a5,28(sp)
8000654c:	43dc                	lw	a5,4(a5)
8000654e:	ce3e                	sw	a5,28(sp)

80006550 <.L29>:
            while(pDicEntry != NULL)
80006550:	47f2                	lw	a5,28(sp)
80006552:	fbc9                	bnez	a5,800064e4 <.L34>

80006554 <.L25>:
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
80006554:	4785                	li	a5,1

80006556 <.L27>:
}
80006556:	853e                	mv	a0,a5
80006558:	6105                	add	sp,sp,32
8000655a:	8082                	ret

Disassembly of section .text.COE_RemoveDicEntry:

8000656e <COE_RemoveDicEntry>:
/**

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
8000656e:	1101                	add	sp,sp,-32
80006570:	87aa                	mv	a5,a0
80006572:	00f11723          	sh	a5,14(sp)
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
80006576:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
8000657a:	ce3e                	sw	a5,28(sp)

    while(pDicEntry != NULL)
8000657c:	a8b1                	j	800065d8 <.L36>

8000657e <.L42>:
    {
        if(pDicEntry->Index == index)
8000657e:	47f2                	lw	a5,28(sp)
80006580:	0087d783          	lhu	a5,8(a5)
80006584:	00e15703          	lhu	a4,14(sp)
80006588:	04f71563          	bne	a4,a5,800065d2 <.L37>

8000658c <.LBB6>:
        {
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
8000658c:	47f2                	lw	a5,28(sp)
8000658e:	439c                	lw	a5,0(a5)
80006590:	cc3e                	sw	a5,24(sp)
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
80006592:	47f2                	lw	a5,28(sp)
80006594:	43dc                	lw	a5,4(a5)
80006596:	ca3e                	sw	a5,20(sp)

            if(pPrevEntry != NULL)
80006598:	47e2                	lw	a5,24(sp)
8000659a:	c781                	beqz	a5,800065a2 <.L38>
            {
                pPrevEntry->pNext = pNextEntry;
8000659c:	47e2                	lw	a5,24(sp)
8000659e:	4752                	lw	a4,20(sp)
800065a0:	c3d8                	sw	a4,4(a5)

800065a2 <.L38>:
            }

            if(pNextEntry != NULL)
800065a2:	47d2                	lw	a5,20(sp)
800065a4:	c781                	beqz	a5,800065ac <.L39>
            {
                pNextEntry->pPrev = pPrevEntry;
800065a6:	47d2                	lw	a5,20(sp)
800065a8:	4762                	lw	a4,24(sp)
800065aa:	c398                	sw	a4,0(a5)

800065ac <.L39>:
            }

            pDicEntry->pPrev = NULL;
800065ac:	47f2                	lw	a5,28(sp)
800065ae:	0007a023          	sw	zero,0(a5)
            pDicEntry->pNext = NULL;
800065b2:	47f2                	lw	a5,28(sp)
800065b4:	0007a223          	sw	zero,4(a5)
            /*Update Object dictionary pointer if list head was removed*/
            if(pDicEntry->Index == ObjDicList->Index)
800065b8:	47f2                	lw	a5,28(sp)
800065ba:	0087d703          	lhu	a4,8(a5)
800065be:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
800065c2:	0087d783          	lhu	a5,8(a5)
800065c6:	00f71c63          	bne	a4,a5,800065de <.L43>
            {
                ObjDicList = pNextEntry;
800065ca:	4752                	lw	a4,20(sp)
800065cc:	12e1aa23          	sw	a4,308(gp) # 12094ac <ObjDicList>
            }
            return;
800065d0:	a039                	j	800065de <.L43>

800065d2 <.L37>:
        }

        pDicEntry = pDicEntry->pNext;
800065d2:	47f2                	lw	a5,28(sp)
800065d4:	43dc                	lw	a5,4(a5)
800065d6:	ce3e                	sw	a5,28(sp)

800065d8 <.L36>:
    while(pDicEntry != NULL)
800065d8:	47f2                	lw	a5,28(sp)
800065da:	f3d5                	bnez	a5,8000657e <.L42>
800065dc:	a011                	j	800065e0 <.L35>

800065de <.L43>:
            return;
800065de:	0001                	nop

800065e0 <.L35>:
    }
}
800065e0:	6105                	add	sp,sp,32
800065e2:	8082                	ret

Disassembly of section .text.COE_ClearObjDictionary:

800066aa <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
800066aa:	1101                	add	sp,sp,-32
800066ac:	ce06                	sw	ra,28(sp)
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
800066ae:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
800066b2:	c63e                	sw	a5,12(sp)
    UINT16 Index = 0;
800066b4:	00011523          	sh	zero,10(sp)

    while(pObjEntry != NULL)
800066b8:	a829                	j	800066d2 <.L45>

800066ba <.L46>:
    {
        Index = pObjEntry->Index;
800066ba:	47b2                	lw	a5,12(sp)
800066bc:	0087d783          	lhu	a5,8(a5)
800066c0:	00f11523          	sh	a5,10(sp)
        pObjEntry = pObjEntry->pNext;
800066c4:	47b2                	lw	a5,12(sp)
800066c6:	43dc                	lw	a5,4(a5)
800066c8:	c63e                	sw	a5,12(sp)

        COE_RemoveDicEntry(Index);
800066ca:	00a15783          	lhu	a5,10(sp)
800066ce:	853e                	mv	a0,a5
800066d0:	3d79                	jal	8000656e <COE_RemoveDicEntry>

800066d2 <.L45>:
    while(pObjEntry != NULL)
800066d2:	47b2                	lw	a5,12(sp)
800066d4:	f3fd                	bnez	a5,800066ba <.L46>
    }
    ObjDicList = NULL;
800066d6:	1201aa23          	sw	zero,308(gp) # 12094ac <ObjDicList>
}
800066da:	0001                	nop
800066dc:	40f2                	lw	ra,28(sp)
800066de:	6105                	add	sp,sp,32
800066e0:	8082                	ret

Disassembly of section .text.AddObjectsToObjDictionary:

800066e6 <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
800066e6:	7179                	add	sp,sp,-48
800066e8:	d606                	sw	ra,44(sp)
800066ea:	c62a                	sw	a0,12(sp)
    UINT16 result = 0;
800066ec:	00011f23          	sh	zero,30(sp)
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;
800066f0:	47b2                	lw	a5,12(sp)
800066f2:	cc3e                	sw	a5,24(sp)

    while(pEntry->Index != 0xFFFF)
800066f4:	a005                	j	80006714 <.L48>

800066f6 <.L51>:
    {
        result = COE_AddObjectToDic(pEntry);
800066f6:	4562                	lw	a0,24(sp)
800066f8:	3369                	jal	80006482 <COE_AddObjectToDic>
800066fa:	87aa                	mv	a5,a0
800066fc:	00f11f23          	sh	a5,30(sp)

        if(result != 0)
80006700:	01e15783          	lhu	a5,30(sp)
80006704:	c781                	beqz	a5,8000670c <.L49>
        {
            return result;
80006706:	01e15783          	lhu	a5,30(sp)
8000670a:	a831                	j	80006726 <.L50>

8000670c <.L49>:
        }

        pEntry++;
8000670c:	47e2                	lw	a5,24(sp)
8000670e:	02878793          	add	a5,a5,40
80006712:	cc3e                	sw	a5,24(sp)

80006714 <.L48>:
    while(pEntry->Index != 0xFFFF)
80006714:	47e2                	lw	a5,24(sp)
80006716:	0087d703          	lhu	a4,8(a5)
8000671a:	67c1                	lui	a5,0x10
8000671c:	17fd                	add	a5,a5,-1 # ffff <__AXI_SRAM_segment_used_size__+0x6aa3>
8000671e:	fcf71ce3          	bne	a4,a5,800066f6 <.L51>
    }

    return result;
80006722:	01e15783          	lhu	a5,30(sp)

80006726 <.L50>:

}
80006726:	853e                	mv	a0,a5
80006728:	50b2                	lw	ra,44(sp)
8000672a:	6145                	add	sp,sp,48
8000672c:	8082                	ret

Disassembly of section .text.COE_Main:

800067ea <COE_Main>:
 \brief    is called for background calculations which should not influence the
             ECAT_Application in synchronous modes
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Main(void)
{
800067ea:	1101                	add	sp,sp,-32
800067ec:	ce06                	sw	ra,28(sp)
     UINT8 abort = 0;
800067ee:	000107a3          	sb	zero,15(sp)
     
    if(pSdoPendFunc != NULL)
800067f2:	0dc1a783          	lw	a5,220(gp) # 1209454 <pSdoPendFunc>
800067f6:	c3cd                	beqz	a5,80006898 <.L60>
    {
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
800067f8:	0dc1a783          	lw	a5,220(gp) # 1209454 <pSdoPendFunc>
800067fc:	34625503          	lhu	a0,838(tp) # 346 <default_isr_62+0x50>
80006800:	35524583          	lbu	a1,853(tp) # 355 <default_isr_62+0x5f>
80006804:	0a01a603          	lw	a2,160(gp) # 1209418 <u32StoreDataSize>
80006808:	0cc1a683          	lw	a3,204(gp) # 1209444 <pStoreData>
8000680c:	18e1c703          	lbu	a4,398(gp) # 1209506 <bStoreCompleteAccess>
80006810:	9782                	jalr	a5
80006812:	87aa                	mv	a5,a0
80006814:	00f107a3          	sb	a5,15(sp)

        if(abort != ABORTIDX_WORKING)
80006818:	00f14703          	lbu	a4,15(sp)
8000681c:	0ff00793          	li	a5,255
80006820:	06f70c63          	beq	a4,a5,80006898 <.L60>
        {
            switch(u8PendingSdo)
80006824:	36f24783          	lbu	a5,879(tp) # 36f <default_isr_62+0x79>
80006828:	4711                	li	a4,4
8000682a:	04f74963          	blt	a4,a5,8000687c <.L57>
8000682e:	470d                	li	a4,3
80006830:	02e7da63          	bge	a5,a4,80006864 <.L58>
80006834:	4705                	li	a4,1
80006836:	00e78f63          	beq	a5,a4,80006854 <.L59>
8000683a:	4709                	li	a4,2
8000683c:	04e79063          	bne	a5,a4,8000687c <.L57>
            {
                case SDO_PENDING_SEG_WRITE:
                    if(pSdoSegData)
80006840:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
80006844:	cb81                	beqz	a5,80006854 <.L59>
                    {
                        /* the allocated buffer can be released */
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
80006846:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
8000684a:	853e                	mv	a0,a5
8000684c:	01a0e0ef          	jal	80014866 <free>
                        pSdoSegData = NULL;
80006850:	0c01aa23          	sw	zero,212(gp) # 120944c <pSdoSegData>

80006854 <.L59>:
                    }
                case SDO_PENDING_WRITE:
                     /*send SDO Download Response*/
                    SDOS_SdoRes(abort, 0, NULL);
80006854:	00f14783          	lbu	a5,15(sp)
80006858:	4601                	li	a2,0
8000685a:	4581                	li	a1,0
8000685c:	853e                	mv	a0,a5
8000685e:	4580a0ef          	jal	80010cb6 <SDOS_SdoRes>
                break;
80006862:	a829                	j	8000687c <.L57>

80006864 <.L58>:

                case SDO_PENDING_SEG_READ:
                case SDO_PENDING_READ:
                    /* send SDO upload response */
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
80006864:	0a01a703          	lw	a4,160(gp) # 1209418 <u32StoreDataSize>
80006868:	0cc1a683          	lw	a3,204(gp) # 1209444 <pStoreData>
8000686c:	00f14783          	lbu	a5,15(sp)
80006870:	8636                	mv	a2,a3
80006872:	85ba                	mv	a1,a4
80006874:	853e                	mv	a0,a5
80006876:	4400a0ef          	jal	80010cb6 <SDOS_SdoRes>
                    break;
8000687a:	0001                	nop

8000687c <.L57>:

            }

            u8PendingSdo = 0;
8000687c:	360207a3          	sb	zero,879(tp) # 36f <default_isr_62+0x79>
            u16StoreIndex = 0;
80006880:	34021323          	sh	zero,838(tp) # 346 <default_isr_62+0x50>
            u8StoreSubindex = 0;
80006884:	34020aa3          	sb	zero,853(tp) # 355 <default_isr_62+0x5f>
            u32StoreDataSize = 0;
80006888:	0a01a023          	sw	zero,160(gp) # 1209418 <u32StoreDataSize>
            pStoreData = NULL;
8000688c:	0c01a623          	sw	zero,204(gp) # 1209444 <pStoreData>
            bStoreCompleteAccess = 0;
80006890:	18018723          	sb	zero,398(gp) # 1209506 <bStoreCompleteAccess>
            pSdoPendFunc = NULL;
80006894:	0c01ae23          	sw	zero,220(gp) # 1209454 <pSdoPendFunc>

80006898 <.L60>:
        }
    }
}
80006898:	0001                	nop
8000689a:	40f2                	lw	ra,28(sp)
8000689c:	6105                	add	sp,sp,32
8000689e:	8082                	ret

Disassembly of section .text.PDO_InputMapping:

800068be <PDO_InputMapping>:
/////////////////////////////////////////////////////////////////////////////////////////
/**
\brief      This function will copies the inputs from the local memory to the ESC memory
*////////////////////////////////////////////////////////////////////////////////////////
void PDO_InputMapping(void)
{
800068be:	1101                	add	sp,sp,-32
800068c0:	ce06                	sw	ra,28(sp)

#if ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0))
    UINT32 u32TimeValue = 0;
800068c2:	c602                	sw	zero,12(sp)
    UINT16 ALEvent = HW_GetALEventRegister_Isr();
800068c4:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
800068c8:	22078793          	add	a5,a5,544
800068cc:	0007d783          	lhu	a5,0(a5)
800068d0:	00f11523          	sh	a5,10(sp)
    ALEvent = SWAPWORD(ALEvent);

    if (MEASUREMENT_ACTIVE)
800068d4:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800068d8:	01a7c703          	lbu	a4,26(a5)
800068dc:	01b7c783          	lbu	a5,27(a5)
800068e0:	07a2                	sll	a5,a5,0x8
800068e2:	8fd9                	or	a5,a5,a4
800068e4:	0807c7b3          	zext.h	a5,a5
800068e8:	8b85                	and	a5,a5,1
800068ea:	ef89                	bnez	a5,80006904 <.L2>
800068ec:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
800068f0:	01a7c703          	lbu	a4,26(a5)
800068f4:	01b7c783          	lbu	a5,27(a5)
800068f8:	07a2                	sll	a5,a5,0x8
800068fa:	8fd9                	or	a5,a5,a4
800068fc:	0807c7b3          	zext.h	a5,a5
80006900:	8b85                	and	a5,a5,1
80006902:	c781                	beqz	a5,8000690a <.L3>

80006904 <.L2>:
    {
        u32TimeValue = GetSystemTimeDelay(0);
80006904:	4501                	li	a0,0
80006906:	2c31                	jal	80006b22 <GetSystemTimeDelay>
80006908:	c62a                	sw	a0,12(sp)

8000690a <.L3>:




  
    APPL_InputMapping((UINT16*)aPdInputData);
8000690a:	f4018513          	add	a0,gp,-192 # 12092b8 <aPdInputData>
8000690e:	403040ef          	jal	8000b510 <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
80006912:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006916:	16a1d783          	lhu	a5,362(gp) # 12094e2 <nEscAddrInputData>
8000691a:	8389                	srl	a5,a5,0x2
8000691c:	0807c7b3          	zext.h	a5,a5
80006920:	078a                	sll	a5,a5,0x2
80006922:	973e                	add	a4,a4,a5
80006924:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80006928:	863e                	mv	a2,a5
8000692a:	f4018593          	add	a1,gp,-192 # 12092b8 <aPdInputData>
8000692e:	853a                	mv	a0,a4
80006930:	32c070ef          	jal	8000dc5c <memcpy>

    

#if ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0))

    if (MEASUREMENT_ACTIVE)
80006934:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006938:	01a7c703          	lbu	a4,26(a5)
8000693c:	01b7c783          	lbu	a5,27(a5)
80006940:	07a2                	sll	a5,a5,0x8
80006942:	8fd9                	or	a5,a5,a4
80006944:	0807c7b3          	zext.h	a5,a5
80006948:	8b85                	and	a5,a5,1
8000694a:	ef89                	bnez	a5,80006964 <.L4>
8000694c:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006950:	01a7c703          	lbu	a4,26(a5)
80006954:	01b7c783          	lbu	a5,27(a5)
80006958:	07a2                	sll	a5,a5,0x8
8000695a:	8fd9                	or	a5,a5,a4
8000695c:	0807c7b3          	zext.h	a5,a5
80006960:	8b85                	and	a5,a5,1
80006962:	cfbd                	beqz	a5,800069e0 <.L6>

80006964 <.L4>:
    {
        u32TimeValue = GetSystemTimeDelay(u32TimeValue);
80006964:	4532                	lw	a0,12(sp)
80006966:	2a75                	jal	80006b22 <GetSystemTimeDelay>
80006968:	c62a                	sw	a0,12(sp)

#if (PD_INPUT_CALC_AND_COPY_TIME == 0)
        if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
8000696a:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000696e:	0127c703          	lbu	a4,18(a5)
80006972:	0137c683          	lbu	a3,19(a5)
80006976:	06a2                	sll	a3,a3,0x8
80006978:	8f55                	or	a4,a4,a3
8000697a:	0147c683          	lbu	a3,20(a5)
8000697e:	06c2                	sll	a3,a3,0x10
80006980:	8f55                	or	a4,a4,a3
80006982:	0157c783          	lbu	a5,21(a5)
80006986:	07e2                	sll	a5,a5,0x18
80006988:	8fd9                	or	a5,a5,a4
8000698a:	873e                	mv	a4,a5
8000698c:	47b2                	lw	a5,12(sp)
8000698e:	04f77963          	bgeu	a4,a5,800069e0 <.L6>
        {
            sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
80006992:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006996:	4732                	lw	a4,12(sp)
80006998:	0ff77713          	zext.b	a4,a4
8000699c:	0127c683          	lbu	a3,18(a5)
800069a0:	8a81                	and	a3,a3,0
800069a2:	8f55                	or	a4,a4,a3
800069a4:	00e78923          	sb	a4,18(a5)
800069a8:	4732                	lw	a4,12(sp)
800069aa:	8321                	srl	a4,a4,0x8
800069ac:	0ff77713          	zext.b	a4,a4
800069b0:	0137c683          	lbu	a3,19(a5)
800069b4:	8a81                	and	a3,a3,0
800069b6:	8f55                	or	a4,a4,a3
800069b8:	00e789a3          	sb	a4,19(a5)
800069bc:	4732                	lw	a4,12(sp)
800069be:	8341                	srl	a4,a4,0x10
800069c0:	0ff77713          	zext.b	a4,a4
800069c4:	0147c683          	lbu	a3,20(a5)
800069c8:	8a81                	and	a3,a3,0
800069ca:	8f55                	or	a4,a4,a3
800069cc:	00e78a23          	sb	a4,20(a5)
800069d0:	4732                	lw	a4,12(sp)
800069d2:	8361                	srl	a4,a4,0x18
800069d4:	0157c683          	lbu	a3,21(a5)
800069d8:	8a81                	and	a3,a3,0
800069da:	8f55                	or	a4,a4,a3
800069dc:	00e78aa3          	sb	a4,21(a5)

800069e0 <.L6>:
#endif /* (MIN_PD_CYCLE_TIME == 0) */
    }

#endif /* ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0)) */

}
800069e0:	0001                	nop
800069e2:	40f2                	lw	ra,28(sp)
800069e4:	6105                	add	sp,sp,32
800069e6:	8082                	ret

Disassembly of section .text.PDO_OutputMapping:

800069f2 <PDO_OutputMapping>:
/**
\brief    This function will copies the outputs from the ESC memory to the local memory.
        This function is only called in case of an SM2 (output process data) event.
*////////////////////////////////////////////////////////////////////////////////////////
void PDO_OutputMapping(void)
{
800069f2:	1101                	add	sp,sp,-32
800069f4:	ce06                	sw	ra,28(sp)
   UINT32 u32TimeValue = 0;
800069f6:	c602                	sw	zero,12(sp)
   if (MEASUREMENT_ACTIVE)
800069f8:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800069fc:	01a7c703          	lbu	a4,26(a5)
80006a00:	01b7c783          	lbu	a5,27(a5)
80006a04:	07a2                	sll	a5,a5,0x8
80006a06:	8fd9                	or	a5,a5,a4
80006a08:	0807c7b3          	zext.h	a5,a5
80006a0c:	8b85                	and	a5,a5,1
80006a0e:	ef89                	bnez	a5,80006a28 <.L8>
80006a10:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006a14:	01a7c703          	lbu	a4,26(a5)
80006a18:	01b7c783          	lbu	a5,27(a5)
80006a1c:	07a2                	sll	a5,a5,0x8
80006a1e:	8fd9                	or	a5,a5,a4
80006a20:	0807c7b3          	zext.h	a5,a5
80006a24:	8b85                	and	a5,a5,1
80006a26:	cf91                	beqz	a5,80006a42 <.L9>

80006a28 <.L8>:
   {
#if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0))
      u32TimeValue = GetSystemTimeDelay(0);
80006a28:	4501                	li	a0,0
80006a2a:	28e5                	jal	80006b22 <GetSystemTimeDelay>
80006a2c:	c62a                	sw	a0,12(sp)
      u32MinCycleTimeStartValue = u32TimeValue;
80006a2e:	4732                	lw	a4,12(sp)
80006a30:	0ae1a423          	sw	a4,168(gp) # 1209420 <u32MinCycleTimeStartValue>

      bMinCycleTimeMeasurementStarted = TRUE;
80006a34:	4705                	li	a4,1
80006a36:	18e18c23          	sb	a4,408(gp) # 1209510 <bMinCycleTimeMeasurementStarted>
      u32MinCycleTimeValue = 0;
80006a3a:	0a01a223          	sw	zero,164(gp) # 120941c <u32MinCycleTimeValue>

#endif /* ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0)) */

      HandleCycleTimeMeasurement();
80006a3e:	66b070ef          	jal	8000e8a8 <HandleCycleTimeMeasurement>

80006a42 <.L9>:

   }

    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
80006a42:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006a46:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
80006a4a:	8389                	srl	a5,a5,0x2
80006a4c:	0807c7b3          	zext.h	a5,a5
80006a50:	078a                	sll	a5,a5,0x2
80006a52:	973e                	add	a4,a4,a5
80006a54:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80006a58:	863e                	mv	a2,a5
80006a5a:	85ba                	mv	a1,a4
80006a5c:	f0018513          	add	a0,gp,-256 # 1209278 <aPdOutputData>
80006a60:	1fc070ef          	jal	8000dc5c <memcpy>
    APPL_OutputMapping((UINT16*) aPdOutputData);
80006a64:	f0018513          	add	a0,gp,-256 # 1209278 <aPdOutputData>
80006a68:	2c3040ef          	jal	8000b52a <APPL_OutputMapping>


#if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0))
    if (MEASUREMENT_ACTIVE)
80006a6c:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006a70:	01a7c703          	lbu	a4,26(a5)
80006a74:	01b7c783          	lbu	a5,27(a5)
80006a78:	07a2                	sll	a5,a5,0x8
80006a7a:	8fd9                	or	a5,a5,a4
80006a7c:	0807c7b3          	zext.h	a5,a5
80006a80:	8b85                	and	a5,a5,1
80006a82:	ef89                	bnez	a5,80006a9c <.L10>
80006a84:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006a88:	01a7c703          	lbu	a4,26(a5)
80006a8c:	01b7c783          	lbu	a5,27(a5)
80006a90:	07a2                	sll	a5,a5,0x8
80006a92:	8fd9                	or	a5,a5,a4
80006a94:	0807c7b3          	zext.h	a5,a5
80006a98:	8b85                	and	a5,a5,1
80006a9a:	cfbd                	beqz	a5,80006b18 <.L12>

80006a9c <.L10>:
    {
       u32TimeValue = GetSystemTimeDelay(u32TimeValue);
80006a9c:	4532                	lw	a0,12(sp)
80006a9e:	2051                	jal	80006b22 <GetSystemTimeDelay>
80006aa0:	c62a                	sw	a0,12(sp)

#if (PD_OUTPUT_CALC_AND_COPY_TIME == 0)
       if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
80006aa2:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006aa6:	0127c703          	lbu	a4,18(a5)
80006aaa:	0137c683          	lbu	a3,19(a5)
80006aae:	06a2                	sll	a3,a3,0x8
80006ab0:	8f55                	or	a4,a4,a3
80006ab2:	0147c683          	lbu	a3,20(a5)
80006ab6:	06c2                	sll	a3,a3,0x10
80006ab8:	8f55                	or	a4,a4,a3
80006aba:	0157c783          	lbu	a5,21(a5)
80006abe:	07e2                	sll	a5,a5,0x18
80006ac0:	8fd9                	or	a5,a5,a4
80006ac2:	873e                	mv	a4,a5
80006ac4:	47b2                	lw	a5,12(sp)
80006ac6:	04f77963          	bgeu	a4,a5,80006b18 <.L12>
       {
          sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
80006aca:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006ace:	4732                	lw	a4,12(sp)
80006ad0:	0ff77713          	zext.b	a4,a4
80006ad4:	0127c683          	lbu	a3,18(a5)
80006ad8:	8a81                	and	a3,a3,0
80006ada:	8f55                	or	a4,a4,a3
80006adc:	00e78923          	sb	a4,18(a5)
80006ae0:	4732                	lw	a4,12(sp)
80006ae2:	8321                	srl	a4,a4,0x8
80006ae4:	0ff77713          	zext.b	a4,a4
80006ae8:	0137c683          	lbu	a3,19(a5)
80006aec:	8a81                	and	a3,a3,0
80006aee:	8f55                	or	a4,a4,a3
80006af0:	00e789a3          	sb	a4,19(a5)
80006af4:	4732                	lw	a4,12(sp)
80006af6:	8341                	srl	a4,a4,0x10
80006af8:	0ff77713          	zext.b	a4,a4
80006afc:	0147c683          	lbu	a3,20(a5)
80006b00:	8a81                	and	a3,a3,0
80006b02:	8f55                	or	a4,a4,a3
80006b04:	00e78a23          	sb	a4,20(a5)
80006b08:	4732                	lw	a4,12(sp)
80006b0a:	8361                	srl	a4,a4,0x18
80006b0c:	0157c683          	lbu	a3,21(a5)
80006b10:	8a81                	and	a3,a3,0
80006b12:	8f55                	or	a4,a4,a3
80006b14:	00e78aa3          	sb	a4,21(a5)

80006b18 <.L12>:
       /* add the first part of the min cycle time */
       u32MinCycleTimeValue = u32TimeValue;
#endif
    }
#endif /* #if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0)) */
}
80006b18:	0001                	nop
80006b1a:	40f2                	lw	ra,28(sp)
80006b1c:	6105                	add	sp,sp,32
80006b1e:	8082                	ret

Disassembly of section .text.GetSystemTimeDelay:

80006b22 <GetSystemTimeDelay>:
\brief    Calculates the difference between the old and current system time value in ns.
          NOTE: This function only handles a 32Bit system time values (therefore the maximum delay about 4sec).
*////////////////////////////////////////////////////////////////////////////////////////

UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
{
80006b22:	1101                	add	sp,sp,-32
80006b24:	c62a                	sw	a0,12(sp)
   UINT32 u32CurValue = 0;
80006b26:	cc02                	sw	zero,24(sp)
   UINT32 u32Delta = 0;
80006b28:	ce02                	sw	zero,28(sp)

   
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
80006b2a:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006b2e:	6785                	lui	a5,0x1
80006b30:	91078793          	add	a5,a5,-1776 # 910 <e2p_data_crc_calc>
80006b34:	97ba                	add	a5,a5,a4
80006b36:	439c                	lw	a5,0(a5)
80006b38:	cc3e                	sw	a5,24(sp)

   if (u32CurValue > 0)
80006b3a:	47e2                	lw	a5,24(sp)
80006b3c:	c38d                	beqz	a5,80006b5e <.L28>
   {
      if (u32StartTime <= u32CurValue)
80006b3e:	4732                	lw	a4,12(sp)
80006b40:	47e2                	lw	a5,24(sp)
80006b42:	00e7e863          	bltu	a5,a4,80006b52 <.L29>
      {
         u32Delta = u32CurValue - u32StartTime;
80006b46:	4762                	lw	a4,24(sp)
80006b48:	47b2                	lw	a5,12(sp)
80006b4a:	40f707b3          	sub	a5,a4,a5
80006b4e:	ce3e                	sw	a5,28(sp)
80006b50:	a039                	j	80006b5e <.L28>

80006b52 <.L29>:
      }
      else
      {
         //The 32Bit timer is wrapped around
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
80006b52:	4762                	lw	a4,24(sp)
80006b54:	47b2                	lw	a5,12(sp)
80006b56:	40f707b3          	sub	a5,a4,a5
80006b5a:	17fd                	add	a5,a5,-1
80006b5c:	ce3e                	sw	a5,28(sp)

80006b5e <.L28>:
      }
   }// current value successfully read out

   if (u32StartTime > 0)
80006b5e:	47b2                	lw	a5,12(sp)
80006b60:	cf91                	beqz	a5,80006b7c <.L30>
   {

       /*the difference between two timestamps are calculated => subtract measurement failure*/
       if (u32SystemTimeReadFailure < u32Delta)
80006b62:	09c1a783          	lw	a5,156(gp) # 1209414 <u32SystemTimeReadFailure>
80006b66:	4772                	lw	a4,28(sp)
80006b68:	00e7f963          	bgeu	a5,a4,80006b7a <.L31>
       {
           u32Delta = u32Delta - u32SystemTimeReadFailure;
80006b6c:	09c1a783          	lw	a5,156(gp) # 1209414 <u32SystemTimeReadFailure>
80006b70:	4772                	lw	a4,28(sp)
80006b72:	40f707b3          	sub	a5,a4,a5
80006b76:	ce3e                	sw	a5,28(sp)
80006b78:	a011                	j	80006b7c <.L30>

80006b7a <.L31>:
       }
       else
       {
           /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
           u32Delta = 0;
80006b7a:	ce02                	sw	zero,28(sp)

80006b7c <.L30>:
       }
   }
   return u32Delta;
80006b7c:	47f2                	lw	a5,28(sp)
}
80006b7e:	853e                	mv	a0,a5
80006b80:	6105                	add	sp,sp,32
80006b82:	8082                	ret

Disassembly of section .text.PDI_Isr:

80006bbe <PDI_Isr>:

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
void PDI_Isr(void)
{
80006bbe:	1101                	add	sp,sp,-32
80006bc0:	ce06                	sw	ra,28(sp)
    /*ECATCHANGE_START(V5.13) ECAT1*/
    BOOL SyncAcknowledgePending = FALSE;
80006bc2:	000107a3          	sb	zero,15(sp)

    /* get the AL event register */
    UINT16  ALEvent = HW_GetALEventRegister_Isr();
80006bc6:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80006bca:	22078793          	add	a5,a5,544
80006bce:	0007d783          	lhu	a5,0(a5)
80006bd2:	00f11623          	sh	a5,12(sp)
    ALEvent = SWAPWORD(ALEvent);


    /* Check if Sync1 Isr has to be called */

    if (ALEvent & SYNC1_EVENT)
80006bd6:	00c15783          	lhu	a5,12(sp)
80006bda:	8ba1                	and	a5,a5,8
80006bdc:	c791                	beqz	a5,80006be8 <.L34>
    {
        Sync1_Isr();
80006bde:	036080ef          	jal	8000ec14 <Sync1_Isr>

        SyncAcknowledgePending = TRUE;
80006be2:	4785                	li	a5,1
80006be4:	00f107a3          	sb	a5,15(sp)

80006be8 <.L34>:
    }
    /*ECATCHANGE_END(V5.13) ECAT1*/
    

    if(bEscIntEnabled)
80006be8:	19d1c783          	lbu	a5,413(gp) # 1209515 <bEscIntEnabled>
80006bec:	22078263          	beqz	a5,80006e10 <.L35>
    {
        if ( ALEvent & PROCESS_OUTPUT_EVENT )
80006bf0:	00c15783          	lhu	a5,12(sp)
80006bf4:	4007f793          	and	a5,a5,1024
80006bf8:	0e078563          	beqz	a5,80006ce2 <.L36>
        {
            if(bDcRunning && bDcSyncActive)
80006bfc:	1a31c783          	lbu	a5,419(gp) # 120951b <bDcRunning>
80006c00:	c791                	beqz	a5,80006c0c <.L37>
80006c02:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
80006c06:	c399                	beqz	a5,80006c0c <.L37>
            {
                /* Reset SM/Sync0 counter. Will be incremented on every Sync0 event*/
                u16SmSync0Counter = 0;
80006c08:	fa019f23          	sh	zero,-66(gp) # 1209336 <u16SmSync0Counter>

80006c0c <.L37>:
            }
            if(sSyncManOutPar.u16SmEventMissedCounter > 0)
80006c0c:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006c10:	0247c703          	lbu	a4,36(a5)
80006c14:	0257c783          	lbu	a5,37(a5)
80006c18:	07a2                	sll	a5,a5,0x8
80006c1a:	8fd9                	or	a5,a5,a4
80006c1c:	0807c7b3          	zext.h	a5,a5
80006c20:	c3a9                	beqz	a5,80006c62 <.L38>
            {
                sSyncManOutPar.u16SmEventMissedCounter--;
80006c22:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006c26:	0247c703          	lbu	a4,36(a5)
80006c2a:	0257c783          	lbu	a5,37(a5)
80006c2e:	07a2                	sll	a5,a5,0x8
80006c30:	8fd9                	or	a5,a5,a4
80006c32:	0807c7b3          	zext.h	a5,a5
80006c36:	17fd                	add	a5,a5,-1
80006c38:	0807c733          	zext.h	a4,a5
80006c3c:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006c40:	0ff77693          	zext.b	a3,a4
80006c44:	0247c603          	lbu	a2,36(a5)
80006c48:	8a01                	and	a2,a2,0
80006c4a:	8ed1                	or	a3,a3,a2
80006c4c:	02d78223          	sb	a3,36(a5)
80006c50:	8321                	srl	a4,a4,0x8
80006c52:	08074733          	zext.h	a4,a4
80006c56:	0257c683          	lbu	a3,37(a5)
80006c5a:	8a81                	and	a3,a3,0
80006c5c:	8f55                	or	a4,a4,a3
80006c5e:	02e782a3          	sb	a4,37(a5)

80006c62 <.L38>:
            }

            sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
80006c62:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006c66:	0247c703          	lbu	a4,36(a5)
80006c6a:	0257c783          	lbu	a5,37(a5)
80006c6e:	07a2                	sll	a5,a5,0x8
80006c70:	8fd9                	or	a5,a5,a4
80006c72:	0807c733          	zext.h	a4,a5
80006c76:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006c7a:	0ff77693          	zext.b	a3,a4
80006c7e:	0247c603          	lbu	a2,36(a5)
80006c82:	8a01                	and	a2,a2,0
80006c84:	8ed1                	or	a3,a3,a2
80006c86:	02d78223          	sb	a3,36(a5)
80006c8a:	8321                	srl	a4,a4,0x8
80006c8c:	08074733          	zext.h	a4,a4
80006c90:	0257c683          	lbu	a3,37(a5)
80006c94:	8a81                	and	a3,a3,0
80006c96:	8f55                	or	a4,a4,a3
80006c98:	02e782a3          	sb	a4,37(a5)



        /* Outputs were updated, set flag for watchdog monitoring */
        bEcatFirstOutputsReceived = TRUE;
80006c9c:	4705                	li	a4,1
80006c9e:	1ae180a3          	sb	a4,417(gp) # 1209519 <bEcatFirstOutputsReceived>


        /*
            handle output process data event
        */
        if ( bEcatOutputUpdateRunning )
80006ca2:	19f1c783          	lbu	a5,415(gp) # 1209517 <bEcatOutputUpdateRunning>
80006ca6:	c399                	beqz	a5,80006cac <.L39>
        {
            /* slave is in OP, update the outputs */
            PDO_OutputMapping();
80006ca8:	33a9                	jal	800069f2 <PDO_OutputMapping>
80006caa:	a825                	j	80006ce2 <.L36>

80006cac <.L39>:
        }
        else
        {
            /* Just acknowledge the process data event in the INIT,PreOP and SafeOP state */
            HW_EscReadDWordIsr(u32dummy,nEscAddrOutputData);
80006cac:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006cb0:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
80006cb4:	8389                	srl	a5,a5,0x2
80006cb6:	0807c7b3          	zext.h	a5,a5
80006cba:	078a                	sll	a5,a5,0x2
80006cbc:	97ba                	add	a5,a5,a4
80006cbe:	4398                	lw	a4,0(a5)
80006cc0:	08e1ac23          	sw	a4,152(gp) # 1209410 <u32dummy>
            HW_EscReadDWordIsr(u32dummy,(nEscAddrOutputData+nPdOutputSize-4));
80006cc4:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006cc8:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
80006ccc:	86be                	mv	a3,a5
80006cce:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80006cd2:	97b6                	add	a5,a5,a3
80006cd4:	17f1                	add	a5,a5,-4
80006cd6:	8789                	sra	a5,a5,0x2
80006cd8:	078a                	sll	a5,a5,0x2
80006cda:	97ba                	add	a5,a5,a4
80006cdc:	4398                	lw	a4,0(a5)
80006cde:	08e1ac23          	sw	a4,152(gp) # 1209410 <u32dummy>

80006ce2 <.L36>:
        }

        /*
            Call ECAT_Application() in SM Sync mode
        */
        if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
80006ce2:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006ce6:	0027c703          	lbu	a4,2(a5)
80006cea:	0037c783          	lbu	a5,3(a5)
80006cee:	07a2                	sll	a5,a5,0x8
80006cf0:	8fd9                	or	a5,a5,a4
80006cf2:	0807c733          	zext.h	a4,a5
80006cf6:	4785                	li	a5,1
80006cf8:	00f71363          	bne	a4,a5,80006cfe <.L40>
        {
            /* The Application is synchronized to process data Sync Manager event*/
            ECAT_Application();
80006cfc:	23b9                	jal	8000724a <ECAT_Application>

80006cfe <.L40>:
        }

/*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
80006cfe:	1a01c703          	lbu	a4,416(gp) # 1209518 <bEcatInputUpdateRunning>
80006d02:	4785                	li	a5,1
80006d04:	04f71163          	bne	a4,a5,80006d46 <.L41>
80006d08:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80006d0c:	cf8d                	beqz	a5,80006d46 <.L41>
/*ECATCHANGE_END(V5.13) ECAT 5*/
       && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
80006d0e:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006d12:	0027c703          	lbu	a4,2(a5)
80006d16:	0037c783          	lbu	a5,3(a5)
80006d1a:	07a2                	sll	a5,a5,0x8
80006d1c:	8fd9                	or	a5,a5,a4
80006d1e:	0807c733          	zext.h	a4,a5
80006d22:	4785                	li	a5,1
80006d24:	02f70063          	beq	a4,a5,80006d44 <.L42>
80006d28:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006d2c:	0027c703          	lbu	a4,2(a5)
80006d30:	0037c783          	lbu	a5,3(a5)
80006d34:	07a2                	sll	a5,a5,0x8
80006d36:	8fd9                	or	a5,a5,a4
80006d38:	0807c733          	zext.h	a4,a5
80006d3c:	02200793          	li	a5,34
80006d40:	00f71363          	bne	a4,a5,80006d46 <.L41>

80006d44 <.L42>:
        )
    {
        /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
        PDO_InputMapping();
80006d44:	3ead                	jal	800068be <PDO_InputMapping>

80006d46 <.L41>:

    /*
      Check if cycle exceed
    */
    /*if next SM event was triggered during runtime increment cycle exceed counter*/
    ALEvent = HW_GetALEventRegister_Isr();
80006d46:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80006d4a:	22078793          	add	a5,a5,544
80006d4e:	0007d783          	lhu	a5,0(a5)
80006d52:	00f11623          	sh	a5,12(sp)
    ALEvent = SWAPWORD(ALEvent);

    if ( ALEvent & PROCESS_OUTPUT_EVENT )
80006d56:	00c15783          	lhu	a5,12(sp)
80006d5a:	4007f793          	and	a5,a5,1024
80006d5e:	cbcd                	beqz	a5,80006e10 <.L35>
    {
        sSyncManOutPar.u16CycleExceededCounter++;
80006d60:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006d64:	0267c703          	lbu	a4,38(a5)
80006d68:	0277c783          	lbu	a5,39(a5)
80006d6c:	07a2                	sll	a5,a5,0x8
80006d6e:	8fd9                	or	a5,a5,a4
80006d70:	0807c7b3          	zext.h	a5,a5
80006d74:	0785                	add	a5,a5,1
80006d76:	0807c733          	zext.h	a4,a5
80006d7a:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006d7e:	0ff77693          	zext.b	a3,a4
80006d82:	0267c603          	lbu	a2,38(a5)
80006d86:	8a01                	and	a2,a2,0
80006d88:	8ed1                	or	a3,a3,a2
80006d8a:	02d78323          	sb	a3,38(a5)
80006d8e:	8321                	srl	a4,a4,0x8
80006d90:	08074733          	zext.h	a4,a4
80006d94:	0277c683          	lbu	a3,39(a5)
80006d98:	8a81                	and	a3,a3,0
80006d9a:	8f55                	or	a4,a4,a3
80006d9c:	02e783a3          	sb	a4,39(a5)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
80006da0:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80006da4:	0267c703          	lbu	a4,38(a5)
80006da8:	0277c783          	lbu	a5,39(a5)
80006dac:	07a2                	sll	a5,a5,0x8
80006dae:	8fd9                	or	a5,a5,a4
80006db0:	0807c733          	zext.h	a4,a5
80006db4:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80006db8:	0ff77693          	zext.b	a3,a4
80006dbc:	0267c603          	lbu	a2,38(a5)
80006dc0:	8a01                	and	a2,a2,0
80006dc2:	8ed1                	or	a3,a3,a2
80006dc4:	02d78323          	sb	a3,38(a5)
80006dc8:	8321                	srl	a4,a4,0x8
80006dca:	08074733          	zext.h	a4,a4
80006dce:	0277c683          	lbu	a3,39(a5)
80006dd2:	8a81                	and	a3,a3,0
80006dd4:	8f55                	or	a4,a4,a3
80006dd6:	02e783a3          	sb	a4,39(a5)

      /* Acknowledge the process data event*/
            HW_EscReadDWordIsr(u32dummy,nEscAddrOutputData);
80006dda:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006dde:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
80006de2:	8389                	srl	a5,a5,0x2
80006de4:	0807c7b3          	zext.h	a5,a5
80006de8:	078a                	sll	a5,a5,0x2
80006dea:	97ba                	add	a5,a5,a4
80006dec:	4398                	lw	a4,0(a5)
80006dee:	08e1ac23          	sw	a4,152(gp) # 1209410 <u32dummy>
            HW_EscReadDWordIsr(u32dummy,(nEscAddrOutputData+nPdOutputSize-4));
80006df2:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006df6:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
80006dfa:	86be                	mv	a3,a5
80006dfc:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80006e00:	97b6                	add	a5,a5,a3
80006e02:	17f1                	add	a5,a5,-4
80006e04:	8789                	sra	a5,a5,0x2
80006e06:	078a                	sll	a5,a5,0x2
80006e08:	97ba                	add	a5,a5,a4
80006e0a:	4398                	lw	a4,0(a5)
80006e0c:	08e1ac23          	sw	a4,152(gp) # 1209410 <u32dummy>

80006e10 <.L35>:
    }
    } //if(bEscIntEnabled)

      /*ECATCHANGE_START(V5.13) ECAT1*/
    if (ALEvent & SYNC0_EVENT)
80006e10:	00c15783          	lhu	a5,12(sp)
80006e14:	8b91                	and	a5,a5,4
80006e16:	c791                	beqz	a5,80006e22 <.L43>
    {
        Sync0_Isr();
80006e18:	3fd070ef          	jal	8000ea14 <Sync0_Isr>

        SyncAcknowledgePending = TRUE;
80006e1c:	4785                	li	a5,1
80006e1e:	00f107a3          	sb	a5,15(sp)

80006e22 <.L43>:
    }

    /* Read Sync0/1 Status Register to acknowledge the event bit in the AL Event register */
    if (SyncAcknowledgePending)
80006e22:	00f14783          	lbu	a5,15(sp)
80006e26:	cb91                	beqz	a5,80006e3a <.L44>

80006e28 <.LBB2>:
    {
        volatile UINT32 SyncState = 0;
80006e28:	c402                	sw	zero,8(sp)
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
80006e2a:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006e2e:	6785                	lui	a5,0x1
80006e30:	98c78793          	add	a5,a5,-1652 # 98c <.L26+0x2>
80006e34:	97ba                	add	a5,a5,a4
80006e36:	439c                	lw	a5,0(a5)
80006e38:	c43e                	sw	a5,8(sp)

80006e3a <.L44>:

    }
    /*ECATCHANGE_END(V5.13) ECAT1*/

    COE_UpdateSyncErrorStatus();
80006e3a:	d90ff0ef          	jal	800063ca <COE_UpdateSyncErrorStatus>

}
80006e3e:	0001                	nop
80006e40:	40f2                	lw	ra,28(sp)
80006e42:	6105                	add	sp,sp,32
80006e44:	8082                	ret

Disassembly of section .text.MainInit:

80006eb6 <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
80006eb6:	7179                	add	sp,sp,-48
80006eb8:	d606                	sw	ra,44(sp)
    UINT16 Error = 0;
80006eba:	00011b23          	sh	zero,22(sp)
/*Hardware init function need to be called from the application layer*/

#ifdef SET_EEPROM_PTR
    SET_EEPROM_PTR
80006ebe:	80020713          	add	a4,tp,-2048 # fffff800 <__AHB_SRAM_segment_end__+0xfdf7800>
80006ec2:	0ee1a423          	sw	a4,232(gp) # 1209460 <pEEPROM>
#endif


/* Reset application function pointer*/
pAPPL_EEPROM_Read = NULL;
80006ec6:	1001a023          	sw	zero,256(gp) # 1209478 <pAPPL_EEPROM_Read>
    pAPPL_EEPROM_Write = NULL;
80006eca:	0e01aa23          	sw	zero,244(gp) # 120946c <pAPPL_EEPROM_Write>
    pAPPL_EEPROM_Reload = NULL;
80006ece:	0e01ae23          	sw	zero,252(gp) # 1209474 <pAPPL_EEPROM_Reload>
    pAPPL_EEPROM_Store = NULL;
80006ed2:	0e01ac23          	sw	zero,248(gp) # 1209470 <pAPPL_EEPROM_Store>




    /* ECATCHANGE_START(V5.13) COE4*/
    pAPPL_CoeReadInd = NULL;
80006ed6:	1001a423          	sw	zero,264(gp) # 1209480 <pAPPL_CoeReadInd>
    pAPPL_CoeWriteInd = NULL;
80006eda:	1001a223          	sw	zero,260(gp) # 120947c <pAPPL_CoeWriteInd>
    /* ECATCHANGE_END(V5.13) COE4*/

    pAPPL_MainLoop = NULL;
80006ede:	0e01a823          	sw	zero,240(gp) # 1209468 <pAPPL_MainLoop>

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
80006ee2:	564020ef          	jal	80009446 <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
80006ee6:	508070ef          	jal	8000e3ee <COE_ObjInit>


    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
80006eea:	4705                	li	a4,1
80006eec:	18e18da3          	sb	a4,411(gp) # 1209513 <bInitFinished>


    bMinCycleTimeMeasurementStarted = FALSE;
80006ef0:	18018c23          	sb	zero,408(gp) # 1209510 <bMinCycleTimeMeasurementStarted>
    u32CycleTimeStartValue = 0;
80006ef4:	0a01a823          	sw	zero,176(gp) # 1209428 <u32CycleTimeStartValue>
    u32MinCycleTimeStartValue = 0;
80006ef8:	0a01a423          	sw	zero,168(gp) # 1209420 <u32MinCycleTimeStartValue>

    u32SystemTimeReadFailure = 0;
80006efc:	0801ae23          	sw	zero,156(gp) # 1209414 <u32SystemTimeReadFailure>

80006f00 <.LBB6>:

    /* Get the System Time read failure */
    {
       UINT32 u32TimeValue = 0;
80006f00:	c802                	sw	zero,16(sp)
       UINT32 u32Cnt = 0;
80006f02:	ce02                	sw	zero,28(sp)
       UINT32 u32Delta = 0;
80006f04:	cc02                	sw	zero,24(sp)

       while (u32Cnt < 1000)
80006f06:	a09d                	j	80006f6c <.L59>

80006f08 <.L64>:
       {
           HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
80006f08:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006f0c:	6785                	lui	a5,0x1
80006f0e:	91078793          	add	a5,a5,-1776 # 910 <e2p_data_crc_calc>
80006f12:	97ba                	add	a5,a5,a4
80006f14:	439c                	lw	a5,0(a5)
80006f16:	c83e                	sw	a5,16(sp)
           HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
80006f18:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80006f1c:	6785                	lui	a5,0x1
80006f1e:	91078793          	add	a5,a5,-1776 # 910 <e2p_data_crc_calc>
80006f22:	97ba                	add	a5,a5,a4
80006f24:	439c                	lw	a5,0(a5)
80006f26:	cc3e                	sw	a5,24(sp)

            if (u32TimeValue <= u32Delta)
80006f28:	4742                	lw	a4,16(sp)
80006f2a:	47e2                	lw	a5,24(sp)
80006f2c:	00e7e863          	bltu	a5,a4,80006f3c <.L60>
            {
                    u32Delta = u32Delta - u32TimeValue;
80006f30:	4762                	lw	a4,24(sp)
80006f32:	47c2                	lw	a5,16(sp)
80006f34:	40f707b3          	sub	a5,a4,a5
80006f38:	cc3e                	sw	a5,24(sp)
80006f3a:	a039                	j	80006f48 <.L61>

80006f3c <.L60>:
            }
            else
            {
                //The 32Bit timer is wrapped around
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
80006f3c:	4762                	lw	a4,24(sp)
80006f3e:	47c2                	lw	a5,16(sp)
80006f40:	40f707b3          	sub	a5,a4,a5
80006f44:	17fd                	add	a5,a5,-1
80006f46:	cc3e                	sw	a5,24(sp)

80006f48 <.L61>:
            }


            if (u32SystemTimeReadFailure == 0)
80006f48:	09c1a783          	lw	a5,156(gp) # 1209414 <u32SystemTimeReadFailure>
80006f4c:	e789                	bnez	a5,80006f56 <.L62>
            {
                u32SystemTimeReadFailure = u32Delta;
80006f4e:	4762                	lw	a4,24(sp)
80006f50:	08e1ae23          	sw	a4,156(gp) # 1209414 <u32SystemTimeReadFailure>
80006f54:	a809                	j	80006f66 <.L63>

80006f56 <.L62>:
            }
            else if (u32SystemTimeReadFailure > u32Delta)
80006f56:	09c1a783          	lw	a5,156(gp) # 1209414 <u32SystemTimeReadFailure>
80006f5a:	4762                	lw	a4,24(sp)
80006f5c:	00f77563          	bgeu	a4,a5,80006f66 <.L63>
            {
                u32SystemTimeReadFailure = u32Delta;
80006f60:	4762                	lw	a4,24(sp)
80006f62:	08e1ae23          	sw	a4,156(gp) # 1209414 <u32SystemTimeReadFailure>

80006f66 <.L63>:
            }

          u32Cnt++;
80006f66:	47f2                	lw	a5,28(sp)
80006f68:	0785                	add	a5,a5,1
80006f6a:	ce3e                	sw	a5,28(sp)

80006f6c <.L59>:
       while (u32Cnt < 1000)
80006f6c:	4772                	lw	a4,28(sp)
80006f6e:	3e700793          	li	a5,999
80006f72:	f8e7fbe3          	bgeu	a5,a4,80006f08 <.L64>

80006f76 <.LBB7>:
    }



    {
        UINT32 TmpData = 0;
80006f76:	c602                	sw	zero,12(sp)
        HW_EscReadDWord(TmpData, ESC_EEPROM_CONFIG_OFFSET);
80006f78:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80006f7c:	50078793          	add	a5,a5,1280
80006f80:	439c                	lw	a5,0(a5)
80006f82:	c63e                	sw	a5,12(sp)
        TmpData = SWAPDWORD(TmpData);
        //get bit6 of register 0x502
        if ((TmpData & ESC_EEPROM_SUPPORTED_READBYTES_MASK) > 0)
80006f84:	4732                	lw	a4,12(sp)
80006f86:	004007b7          	lui	a5,0x400
80006f8a:	8ff9                	and	a5,a5,a4
80006f8c:	c789                	beqz	a5,80006f96 <.L65>
        {
            //8Bytes EEPROM read access
            EepromReadSize = 8;
80006f8e:	4721                	li	a4,8
80006f90:	18e19023          	sh	a4,384(gp) # 12094f8 <EepromReadSize>
80006f94:	a021                	j	80006f9c <.L66>

80006f96 <.L65>:
        }
        else
        {
            //4Bytes EEPROM read access
            EepromReadSize = 4;
80006f96:	4711                	li	a4,4
80006f98:	18e19023          	sh	a4,384(gp) # 12094f8 <EepromReadSize>

80006f9c <.L66>:
        }
    }

/*Application Init need to be called from the application layer*/
     return Error;
80006f9c:	01615783          	lhu	a5,22(sp)
}
80006fa0:	853e                	mv	a0,a5
80006fa2:	50b2                	lw	ra,44(sp)
80006fa4:	6145                	add	sp,sp,48
80006fa6:	8082                	ret

Disassembly of section .text.MainLoop:

80006fda <MainLoop>:
 \brief    This function shall be called cyclically from main

*////////////////////////////////////////////////////////////////////////////////////////

void MainLoop(void)
{
80006fda:	1101                	add	sp,sp,-32
80006fdc:	ce06                	sw	ra,28(sp)
    
    /*return if initialization not finished */
    if(bInitFinished == FALSE)
80006fde:	19b1c783          	lbu	a5,411(gp) # 1209513 <bInitFinished>
80006fe2:	0a078c63          	beqz	a5,8000709a <.L78>

        /* FreeRun-Mode:  bEscIntEnabled = FALSE, bDcSyncActive = FALSE
           Synchron-Mode: bEscIntEnabled = TRUE, bDcSyncActive = FALSE
           DC-Mode:       bEscIntEnabled = TRUE, bDcSyncActive = TRUE */
        if (
            (!bEscIntEnabled || !bEcatFirstOutputsReceived)     /* SM-Synchronous, but not SM-event received */
80006fe6:	19d1c783          	lbu	a5,413(gp) # 1209515 <bEscIntEnabled>
        if (
80006fea:	c781                	beqz	a5,80006ff2 <.L71>
            (!bEscIntEnabled || !bEcatFirstOutputsReceived)     /* SM-Synchronous, but not SM-event received */
80006fec:	1a11c783          	lbu	a5,417(gp) # 1209519 <bEcatFirstOutputsReceived>
80006ff0:	e7b5                	bnez	a5,8000705c <.L72>

80006ff2 <.L71>:
          && !bDcSyncActive                                               /* DC-Synchronous */
80006ff2:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
80006ff6:	e3bd                	bnez	a5,8000705c <.L72>
               from the ESC interrupt routine,
               in ECAT Synchron Mode it should be additionally checked, if the SM-event is received
               at least once (bEcatFirstOutputsReceived = 1), otherwise no interrupt is generated
               and the function ECAT_Application has to be called here (with interrupts disabled,
               because the SM-event could be generated while executing ECAT_Application) */
            if ( !bEscIntEnabled )
80006ff8:	19d1c783          	lbu	a5,413(gp) # 1209515 <bEscIntEnabled>
80006ffc:	e3b1                	bnez	a5,80007040 <.L73>

80006ffe <.LBB8>:
            {
                /* application is running in ECAT FreeRun Mode,
                   first we have to check, if outputs were received */
                UINT16 ALEvent = HW_GetALEventRegister();
80006ffe:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80007002:	22078793          	add	a5,a5,544 # 400220 <__DLM_segment_end__+0x1e0220>
80007006:	0007d783          	lhu	a5,0(a5)
8000700a:	00f11723          	sh	a5,14(sp)
                ALEvent = SWAPWORD(ALEvent);

                if ( ALEvent & PROCESS_OUTPUT_EVENT )
8000700e:	00e15783          	lhu	a5,14(sp)
80007012:	4007f793          	and	a5,a5,1024
80007016:	cb89                	beqz	a5,80007028 <.L74>
                {
                    /* set the flag for the state machine behavior */
                    bEcatFirstOutputsReceived = TRUE;
80007018:	4705                	li	a4,1
8000701a:	1ae180a3          	sb	a4,417(gp) # 1209519 <bEcatFirstOutputsReceived>
                    if ( bEcatOutputUpdateRunning )
8000701e:	19f1c783          	lbu	a5,415(gp) # 1209517 <bEcatOutputUpdateRunning>
80007022:	cf99                	beqz	a5,80007040 <.L73>
                    {
                        /* update the outputs */
                        PDO_OutputMapping();
80007024:	32f9                	jal	800069f2 <PDO_OutputMapping>
80007026:	a829                	j	80007040 <.L73>

80007028 <.L74>:
                    }
                }
                else if ( nPdOutputSize == 0 )
80007028:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000702c:	eb91                	bnez	a5,80007040 <.L73>
                {
                    /* if no outputs are transmitted, the watchdog must be reset, when the inputs were read */
                    if ( ALEvent & PROCESS_INPUT_EVENT )
8000702e:	00e15703          	lhu	a4,14(sp)
80007032:	28b01793          	bset	a5,zero,0xb
80007036:	8ff9                	and	a5,a5,a4
80007038:	c781                	beqz	a5,80007040 <.L73>
                    {
                        /* Outputs were updated, set flag for watchdog monitoring */
                        bEcatFirstOutputsReceived = TRUE;
8000703a:	4705                	li	a4,1
8000703c:	1ae180a3          	sb	a4,417(gp) # 1209519 <bEcatFirstOutputsReceived>

80007040 <.L73>:
                    }
                }
            }

            DISABLE_ESC_INT();
80007040:	16d0a0ef          	jal	800119ac <DISABLE_ESC_INT>
             ECAT_Application();
80007044:	2419                	jal	8000724a <ECAT_Application>

/*ECATCHANGE_START(V5.13) ECAT 5*/
             if ( (bEcatInputUpdateRunning  == TRUE) && (nPdInputSize > 0))
80007046:	1a01c703          	lbu	a4,416(gp) # 1209518 <bEcatInputUpdateRunning>
8000704a:	4785                	li	a5,1
8000704c:	00f71663          	bne	a4,a5,80007058 <.L75>
80007050:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80007054:	c391                	beqz	a5,80007058 <.L75>
/*ECATCHANGE_END(V5.13) ECAT 5*/
             {
                /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
                PDO_InputMapping();
80007056:	30a5                	jal	800068be <PDO_InputMapping>

80007058 <.L75>:
            }
            ENABLE_ESC_INT();
80007058:	77c040ef          	jal	8000b7d4 <ENABLE_ESC_INT>

8000705c <.L72>:
        }

        /* there is no interrupt routine for the hardware timer so check the timer register if the desired cycle elapsed*/
        {
            UINT32 CurTimer = (UINT32)HW_GetTimer();
8000705c:	1410a0ef          	jal	8001199c <HW_GetTimer>
80007060:	c42a                	sw	a0,8(sp)

            if(CurTimer>= ECAT_TIMER_INC_P_MS)
80007062:	47a2                	lw	a5,8(sp)
80007064:	c789                	beqz	a5,8000706e <.L76>
            {
                ECAT_CheckTimer();
80007066:	756070ef          	jal	8000e7bc <ECAT_CheckTimer>

                HW_ClearTimer();
8000706a:	13b0a0ef          	jal	800119a4 <HW_ClearTimer>

8000706e <.L76>:
            }
        }

        if (u32CheckForDcOverrunCnt >= CHECK_DC_OVERRUN_IN_MS)
8000706e:	0b41a703          	lw	a4,180(gp) # 120942c <u32CheckForDcOverrunCnt>
80007072:	6785                	lui	a5,0x1
80007074:	f9f78793          	add	a5,a5,-97 # f9f <.L75+0xd>
80007078:	00e7f463          	bgeu	a5,a4,80007080 <.L77>
        {
            COE_SyncTimeStamp();
8000707c:	2bc070ef          	jal	8000e338 <COE_SyncTimeStamp>

80007080 <.L77>:
        }

        /* call EtherCAT functions */
        ECAT_Main();
80007080:	296080ef          	jal	8000f316 <ECAT_Main>

        /* call lower prior application part */
       COE_Main();
80007084:	f66ff0ef          	jal	800067ea <COE_Main>
       CheckIfEcatError();
80007088:	222080ef          	jal	8000f2aa <CheckIfEcatError>


    if (pAPPL_MainLoop != NULL)
8000708c:	0f01a783          	lw	a5,240(gp) # 1209468 <pAPPL_MainLoop>
80007090:	c791                	beqz	a5,8000709c <.L68>
    {
        pAPPL_MainLoop();
80007092:	0f01a783          	lw	a5,240(gp) # 1209468 <pAPPL_MainLoop>
80007096:	9782                	jalr	a5
80007098:	a011                	j	8000709c <.L68>

8000709a <.L78>:
        return;
8000709a:	0001                	nop

8000709c <.L68>:
    }
}
8000709c:	40f2                	lw	ra,28(sp)
8000709e:	6105                	add	sp,sp,32
800070a0:	8082                	ret

Disassembly of section .text.ECAT_Application:

8000724a <ECAT_Application>:
/**
 \brief    ECAT_Application (prev. SSC versions "COE_Application")
 this function calculates and the physical process signals and triggers the input mapping
*////////////////////////////////////////////////////////////////////////////////////////
void ECAT_Application(void)
{
8000724a:	1141                	add	sp,sp,-16
8000724c:	c606                	sw	ra,12(sp)
            u32MinCycleTimeValue = 0;
        }
    } /* measurement started*/
#endif /* (MIN_PD_CYCLE_TIME == 0)*/

    if (MEASUREMENT_ACTIVE)
8000724e:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80007252:	01a7c703          	lbu	a4,26(a5)
80007256:	01b7c783          	lbu	a5,27(a5)
8000725a:	07a2                	sll	a5,a5,0x8
8000725c:	8fd9                	or	a5,a5,a4
8000725e:	0807c7b3          	zext.h	a5,a5
80007262:	8b85                	and	a5,a5,1
80007264:	ef89                	bnez	a5,8000727e <.L80>
80007266:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000726a:	01a7c703          	lbu	a4,26(a5)
8000726e:	01b7c783          	lbu	a5,27(a5)
80007272:	07a2                	sll	a5,a5,0x8
80007274:	8fd9                	or	a5,a5,a4
80007276:	0807c7b3          	zext.h	a5,a5
8000727a:	8b85                	and	a5,a5,1
8000727c:	c791                	beqz	a5,80007288 <.L81>

8000727e <.L80>:
    {
        if (nPdOutputSize == 0)
8000727e:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80007282:	e399                	bnez	a5,80007288 <.L81>
        {
            /* in case of an input only device the cycle starts with an ECAT_Application call*/
            HandleCycleTimeMeasurement();
80007284:	624070ef          	jal	8000e8a8 <HandleCycleTimeMeasurement>

80007288 <.L81>:


    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 application from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/
    APPL_Application();
80007288:	3060a0ef          	jal	8001158e <APPL_Application>
            }
        }

    }/* measurement started*/
#endif /* #if MIN_PD_CYCLE_TIME == 0 */
}
8000728c:	0001                	nop
8000728e:	40b2                	lw	ra,12(sp)
80007290:	0141                	add	sp,sp,16
80007292:	8082                	ret

Disassembly of section .text.EEPROM_CommandHandler:

80007382 <EEPROM_CommandHandler>:


void EEPROM_CommandHandler(void)
{
80007382:	7139                	add	sp,sp,-64
80007384:	de06                	sw	ra,60(sp)
   UINT16 Result = 0;
80007386:	02011323          	sh	zero,38(sp)
    UINT32 EEPROMReg = 0; //Regvalue 0x500 - 0x5003
8000738a:	d602                	sw	zero,44(sp)

    HW_EscReadDWord(EEPROMReg,ESC_EEPROM_CONFIG_OFFSET);
8000738c:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80007390:	50078793          	add	a5,a5,1280
80007394:	439c                	lw	a5,0(a5)
80007396:	d63e                	sw	a5,44(sp)
    EEPROMReg = SWAPDWORD(EEPROMReg);

    if (EEPROMReg & ESC_EEPROM_BUSY_MASK) 
80007398:	57b2                	lw	a5,44(sp)
8000739a:	2a07d163          	bgez	a5,8000763c <.L108>

8000739e <.LBB10>:
    {
        UINT32 cmd = EEPROMReg  & ESC_EEPROM_CMD_MASK;
8000739e:	5732                	lw	a4,44(sp)
800073a0:	070007b7          	lui	a5,0x7000
800073a4:	8ff9                	and	a5,a5,a4
800073a6:	d03e                	sw	a5,32(sp)
        UINT32 addr;
        
        
        HW_EscReadDWord(addr,ESC_EEPROM_ADDRESS_OFFSET);
800073a8:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
800073ac:	50478793          	add	a5,a5,1284 # 7000504 <__AXI_SRAM_segment_end__+0x5dc0504>
800073b0:	439c                	lw	a5,0(a5)
800073b2:	d43e                	sw	a5,40(sp)
        addr = SWAPDWORD(addr);

        //Clear error bits (except the eeprom crc error)
        EEPROMReg &= ~(ESC_EEPROM_ERROR_MASK & ~ESC_EEPROM_ERROR_CRC);
800073b4:	5732                	lw	a4,44(sp)
800073b6:	900007b7          	lui	a5,0x90000
800073ba:	17fd                	add	a5,a5,-1 # 8fffffff <__FLASH_segment_end__+0xfefffff>
800073bc:	8ff9                	and	a5,a5,a4
800073be:	d63e                	sw	a5,44(sp)
        switch (cmd) {
800073c0:	5702                	lw	a4,32(sp)
800073c2:	040007b7          	lui	a5,0x4000
800073c6:	10f70563          	beq	a4,a5,800074d0 <.L84>
800073ca:	5702                	lw	a4,32(sp)
800073cc:	040007b7          	lui	a5,0x4000
800073d0:	24e7e363          	bltu	a5,a4,80007616 <.L85>
800073d4:	5702                	lw	a4,32(sp)
800073d6:	020007b7          	lui	a5,0x2000
800073da:	08f70563          	beq	a4,a5,80007464 <.L86>
800073de:	5702                	lw	a4,32(sp)
800073e0:	020007b7          	lui	a5,0x2000
800073e4:	22e7e963          	bltu	a5,a4,80007616 <.L85>
800073e8:	5782                	lw	a5,32(sp)
800073ea:	22078c63          	beqz	a5,80007622 <.L109>
800073ee:	5702                	lw	a4,32(sp)
800073f0:	010007b7          	lui	a5,0x1000
800073f4:	22f71163          	bne	a4,a5,80007616 <.L85>
        case 0x00: //IDLE
            break;
        case ESC_EEPROM_CMD_READ_MASK:
        {
           if (pAPPL_EEPROM_Read != NULL)
800073f8:	1001a783          	lw	a5,256(gp) # 1209478 <pAPPL_EEPROM_Read>
800073fc:	c395                	beqz	a5,80007420 <.L90>
           {
              Result = pAPPL_EEPROM_Read(addr);
800073fe:	1001a783          	lw	a5,256(gp) # 1209478 <pAPPL_EEPROM_Read>
80007402:	5522                	lw	a0,40(sp)
80007404:	9782                	jalr	a5
80007406:	87aa                	mv	a5,a0
80007408:	02f11323          	sh	a5,38(sp)
              if (Result > 0)
8000740c:	02615783          	lhu	a5,38(sp)
80007410:	20078b63          	beqz	a5,80007626 <.L110>
              {
                 //Set Error
                 EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
80007414:	5732                	lw	a4,44(sp)
80007416:	200007b7          	lui	a5,0x20000
8000741a:	8fd9                	or	a5,a5,a4
8000741c:	d63e                	sw	a5,44(sp)
                 //Set Error
                 EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
              }
           }
        }
        break;
8000741e:	a421                	j	80007626 <.L110>

80007420 <.L90>:
              if (addr <= ESC_EEPROM_SIZE && (pEEPROM != NULL))
80007420:	5722                	lw	a4,40(sp)
80007422:	28b01793          	bset	a5,zero,0xb
80007426:	02e7e963          	bltu	a5,a4,80007458 <.L92>
8000742a:	0e81a783          	lw	a5,232(gp) # 1209460 <pEEPROM>
8000742e:	c78d                	beqz	a5,80007458 <.L92>

80007430 <.LBB11>:
                 UINT16 *pData = (UINT16 *)pEEPROM;
80007430:	0e81a783          	lw	a5,232(gp) # 1209460 <pEEPROM>
80007434:	c83e                	sw	a5,16(sp)
                 HW_EscWrite((MEM_ADDR *)&pData[(addr)], ESC_EEPROM_DATA_OFFSET, EepromReadSize);
80007436:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000743a:	50878693          	add	a3,a5,1288 # 20000508 <__AXI_SRAM_segment_end__+0x1edc0508>
8000743e:	57a2                	lw	a5,40(sp)
80007440:	0786                	sll	a5,a5,0x1
80007442:	4742                	lw	a4,16(sp)
80007444:	973e                	add	a4,a4,a5
80007446:	1801d783          	lhu	a5,384(gp) # 12094f8 <EepromReadSize>
8000744a:	863e                	mv	a2,a5
8000744c:	85ba                	mv	a1,a4
8000744e:	8536                	mv	a0,a3
80007450:	00d060ef          	jal	8000dc5c <memcpy>

80007454 <.LBE11>:
              {
80007454:	0001                	nop
        break;
80007456:	aac1                	j	80007626 <.L110>

80007458 <.L92>:
                 EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
80007458:	5732                	lw	a4,44(sp)
8000745a:	200007b7          	lui	a5,0x20000
8000745e:	8fd9                	or	a5,a5,a4
80007460:	d63e                	sw	a5,44(sp)
        break;
80007462:	a2d1                	j	80007626 <.L110>

80007464 <.L86>:
        case ESC_EEPROM_CMD_WRITE_MASK:
            {
                 if (pAPPL_EEPROM_Write != NULL)
80007464:	0f41a783          	lw	a5,244(gp) # 120946c <pAPPL_EEPROM_Write>
80007468:	c38d                	beqz	a5,8000748a <.L93>
                 {
                    Result = pAPPL_EEPROM_Write(addr);
8000746a:	0f41a783          	lw	a5,244(gp) # 120946c <pAPPL_EEPROM_Write>
8000746e:	5522                	lw	a0,40(sp)
80007470:	9782                	jalr	a5
80007472:	87aa                	mv	a5,a0
80007474:	02f11323          	sh	a5,38(sp)
                    if (Result > 0)
80007478:	02615783          	lhu	a5,38(sp)
8000747c:	c7a9                	beqz	a5,800074c6 <.L94>
                    {
                       //Set Error
                       EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
8000747e:	5732                	lw	a4,44(sp)
80007480:	200007b7          	lui	a5,0x20000
80007484:	8fd9                	or	a5,a5,a4
80007486:	d63e                	sw	a5,44(sp)
80007488:	a83d                	j	800074c6 <.L94>

8000748a <.L93>:
                    }
                 }
                 else
                 {

                    if (addr <= ESC_EEPROM_SIZE && (pEEPROM != NULL))
8000748a:	5722                	lw	a4,40(sp)
8000748c:	28b01793          	bset	a5,zero,0xb
80007490:	02e7e663          	bltu	a5,a4,800074bc <.L95>
80007494:	0e81a783          	lw	a5,232(gp) # 1209460 <pEEPROM>
80007498:	c395                	beqz	a5,800074bc <.L95>

8000749a <.LBB12>:
                    {
                       UINT16 *pData = (UINT16 *)pEEPROM;
8000749a:	0e81a783          	lw	a5,232(gp) # 1209460 <pEEPROM>
8000749e:	ca3e                	sw	a5,20(sp)
                       HW_EscRead((MEM_ADDR *)&pData[(addr)], ESC_EEPROM_DATA_OFFSET, EEPROM_WRITE_SIZE);
800074a0:	57a2                	lw	a5,40(sp)
800074a2:	0786                	sll	a5,a5,0x1
800074a4:	4752                	lw	a4,20(sp)
800074a6:	973e                	add	a4,a4,a5
800074a8:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
800074ac:	50878793          	add	a5,a5,1288 # 20000508 <__AXI_SRAM_segment_end__+0x1edc0508>
800074b0:	4609                	li	a2,2
800074b2:	85be                	mv	a1,a5
800074b4:	853a                	mv	a0,a4
800074b6:	7a6060ef          	jal	8000dc5c <memcpy>

800074ba <.LBE12>:
                    {
800074ba:	a031                	j	800074c6 <.L94>

800074bc <.L95>:
                    }
                    else
                    {
                       //Set Error
                       EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
800074bc:	5732                	lw	a4,44(sp)
800074be:	200007b7          	lui	a5,0x20000
800074c2:	8fd9                	or	a5,a5,a4
800074c4:	d63e                	sw	a5,44(sp)

800074c6 <.L94>:
                    }
                 }

                 /* init the Store EEPROM timeout value (will be reset after the timer has expired)*/
                 u16EepromStoreTimeoutValue = 1000;
800074c6:	3e800713          	li	a4,1000
800074ca:	14e19b23          	sh	a4,342(gp) # 12094ce <u16EepromStoreTimeoutValue>

            }
            break;
800074ce:	aaa9                	j	80007628 <.L89>

800074d0 <.L84>:
        case ESC_EEPROM_CMD_RELOAD_MASK:
            if (EepromReadSize == 8)
800074d0:	1801d703          	lhu	a4,384(gp) # 12094f8 <EepromReadSize>
800074d4:	47a1                	li	a5,8
800074d6:	0cf71663          	bne	a4,a5,800075a2 <.L96>

800074da <.L102>:
            {
                /* "full" EEPROM emulation ( 8Bytes EEPROM data) */
                do
                {
                    if (addr > ESC_EEPROM_SIZE)
800074da:	5722                	lw	a4,40(sp)
800074dc:	28b01793          	bset	a5,zero,0xb
800074e0:	00e7f863          	bgeu	a5,a4,800074f0 <.L97>
                    {
                        //Set Error
                        EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
800074e4:	5732                	lw	a4,44(sp)
800074e6:	200007b7          	lui	a5,0x20000
800074ea:	8fd9                	or	a5,a5,a4
800074ec:	d63e                	sw	a5,44(sp)
                        break;
800074ee:	a21d                	j	80007614 <.L103>

800074f0 <.L97>:
                    }
                    else
                    {
                        if (pAPPL_EEPROM_Read != NULL)
800074f0:	1001a783          	lw	a5,256(gp) # 1209478 <pAPPL_EEPROM_Read>
800074f4:	c38d                	beqz	a5,80007516 <.L99>
                        {
                            Result = pAPPL_EEPROM_Read(addr);
800074f6:	1001a783          	lw	a5,256(gp) # 1209478 <pAPPL_EEPROM_Read>
800074fa:	5522                	lw	a0,40(sp)
800074fc:	9782                	jalr	a5
800074fe:	87aa                	mv	a5,a0
80007500:	02f11323          	sh	a5,38(sp)
                            if (Result > 0)
80007504:	02615783          	lhu	a5,38(sp)
80007508:	cba1                	beqz	a5,80007558 <.L100>
                            {
                                //Set Error
                                EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
8000750a:	5732                	lw	a4,44(sp)
8000750c:	200007b7          	lui	a5,0x20000
80007510:	8fd9                	or	a5,a5,a4
80007512:	d63e                	sw	a5,44(sp)
                                break;
80007514:	a201                	j	80007614 <.L103>

80007516 <.L99>:
                            }
                        }
                        else
                        {
                            if (addr <= ESC_EEPROM_SIZE && (pEEPROM != NULL))
80007516:	5722                	lw	a4,40(sp)
80007518:	28b01793          	bset	a5,zero,0xb
8000751c:	02e7e863          	bltu	a5,a4,8000754c <.L101>
80007520:	0e81a783          	lw	a5,232(gp) # 1209460 <pEEPROM>
80007524:	c785                	beqz	a5,8000754c <.L101>

80007526 <.LBB13>:
                            {
                                UINT16 *pData = (UINT16 *)pEEPROM;
80007526:	0e81a783          	lw	a5,232(gp) # 1209460 <pEEPROM>
8000752a:	ce3e                	sw	a5,28(sp)
                                HW_EscWrite((MEM_ADDR *)&pData[(addr)], ESC_EEPROM_DATA_OFFSET, EepromReadSize);
8000752c:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80007530:	50878693          	add	a3,a5,1288 # 20000508 <__AXI_SRAM_segment_end__+0x1edc0508>
80007534:	57a2                	lw	a5,40(sp)
80007536:	0786                	sll	a5,a5,0x1
80007538:	4772                	lw	a4,28(sp)
8000753a:	973e                	add	a4,a4,a5
8000753c:	1801d783          	lhu	a5,384(gp) # 12094f8 <EepromReadSize>
80007540:	863e                	mv	a2,a5
80007542:	85ba                	mv	a1,a4
80007544:	8536                	mv	a0,a3
80007546:	716060ef          	jal	8000dc5c <memcpy>

8000754a <.LBE13>:
                            {
8000754a:	a039                	j	80007558 <.L100>

8000754c <.L101>:
                            }
                            else
                            {
                                //Set Error
                                EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
8000754c:	5732                	lw	a4,44(sp)
8000754e:	200007b7          	lui	a5,0x20000
80007552:	8fd9                	or	a5,a5,a4
80007554:	d63e                	sw	a5,44(sp)
                                break;
80007556:	a87d                	j	80007614 <.L103>

80007558 <.L100>:
                            }
                        }

                        //Clear error bits
                        EEPROMReg &= ~(ESC_EEPROM_ERROR_MASK);
80007558:	5732                	lw	a4,44(sp)
8000755a:	880007b7          	lui	a5,0x88000
8000755e:	17fd                	add	a5,a5,-1 # 87ffffff <__FLASH_segment_end__+0x7efffff>
80007560:	8ff9                	and	a5,a5,a4
80007562:	d63e                	sw	a5,44(sp)

80007564 <.LBB14>:

                        //ack current reload segment
                        {
                            UINT32 TmpData = SWAPDWORD(EEPROMReg);
80007564:	57b2                	lw	a5,44(sp)
80007566:	cc3e                	sw	a5,24(sp)
                            HW_EscWriteDWord(TmpData, ESC_EEPROM_CONFIG_OFFSET);
80007568:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000756c:	50078793          	add	a5,a5,1280
80007570:	4762                	lw	a4,24(sp)
80007572:	c398                	sw	a4,0(a5)

80007574 <.LBE14>:
                        }

                        // read EEPROM control (to check if the reload is still pending)
                        HW_EscReadDWord(EEPROMReg, ESC_EEPROM_CONFIG_OFFSET);
80007574:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80007578:	50078793          	add	a5,a5,1280
8000757c:	439c                	lw	a5,0(a5)
8000757e:	d63e                	sw	a5,44(sp)
                        EEPROMReg = SWAPDWORD(EEPROMReg);
                        cmd = EEPROMReg  & ESC_EEPROM_CMD_MASK;
80007580:	5732                	lw	a4,44(sp)
80007582:	070007b7          	lui	a5,0x7000
80007586:	8ff9                	and	a5,a5,a4
80007588:	d03e                	sw	a5,32(sp)

                        HW_EscReadDWord(addr, ESC_EEPROM_ADDRESS_OFFSET);
8000758a:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000758e:	50478793          	add	a5,a5,1284 # 7000504 <__AXI_SRAM_segment_end__+0x5dc0504>
80007592:	439c                	lw	a5,0(a5)
80007594:	d43e                	sw	a5,40(sp)
                        addr = SWAPDWORD(addr);
                    }


                } while (cmd == ESC_EEPROM_CMD_RELOAD_MASK);
80007596:	5702                	lw	a4,32(sp)
80007598:	040007b7          	lui	a5,0x4000
8000759c:	f2f70fe3          	beq	a4,a5,800074da <.L102>

                        EEPROMReg &= ~ESC_EEPROM_ERROR_CRC;
                    }
                }
            }
         break;
800075a0:	a061                	j	80007628 <.L89>

800075a2 <.L96>:
                if (pAPPL_EEPROM_Reload != NULL)
800075a2:	0fc1a783          	lw	a5,252(gp) # 1209474 <pAPPL_EEPROM_Reload>
800075a6:	c79d                	beqz	a5,800075d4 <.L104>
                    Result = pAPPL_EEPROM_Reload();
800075a8:	0fc1a783          	lw	a5,252(gp) # 1209474 <pAPPL_EEPROM_Reload>
800075ac:	9782                	jalr	a5
800075ae:	87aa                	mv	a5,a0
800075b0:	02f11323          	sh	a5,38(sp)
                    if (Result > 0)
800075b4:	02615783          	lhu	a5,38(sp)
800075b8:	c799                	beqz	a5,800075c6 <.L105>
                        EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
800075ba:	5732                	lw	a4,44(sp)
800075bc:	200007b7          	lui	a5,0x20000
800075c0:	8fd9                	or	a5,a5,a4
800075c2:	d63e                	sw	a5,44(sp)
         break;
800075c4:	a095                	j	80007628 <.L89>

800075c6 <.L105>:
                        EEPROMReg &= ~ESC_EEPROM_ERROR_CRC;
800075c6:	5732                	lw	a4,44(sp)
800075c8:	f80007b7          	lui	a5,0xf8000
800075cc:	17fd                	add	a5,a5,-1 # f7ffffff <__AHB_SRAM_segment_end__+0x7df7fff>
800075ce:	8ff9                	and	a5,a5,a4
800075d0:	d63e                	sw	a5,44(sp)
         break;
800075d2:	a899                	j	80007628 <.L89>

800075d4 <.L104>:
                    Result = HW_EepromReload();
800075d4:	42a040ef          	jal	8000b9fe <HW_EepromReload>
800075d8:	87aa                	mv	a5,a0
800075da:	02f11323          	sh	a5,38(sp)
                    if (Result != 0 || (pEEPROM == NULL))
800075de:	02615783          	lhu	a5,38(sp)
800075e2:	e781                	bnez	a5,800075ea <.L106>
800075e4:	0e81a783          	lw	a5,232(gp) # 1209460 <pEEPROM>
800075e8:	e799                	bnez	a5,800075f6 <.L107>

800075ea <.L106>:
                        EEPROMReg |= ESC_EEPROM_ERROR_CRC;
800075ea:	5732                	lw	a4,44(sp)
800075ec:	080007b7          	lui	a5,0x8000
800075f0:	8fd9                	or	a5,a5,a4
800075f2:	d63e                	sw	a5,44(sp)
800075f4:	a005                	j	80007614 <.L103>

800075f6 <.L107>:
                        HW_EscWriteDWord(((UINT32 *)pEEPROM)[0x2], ESC_EEPROM_DATA_OFFSET);
800075f6:	0e81a703          	lw	a4,232(gp) # 1209460 <pEEPROM>
800075fa:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
800075fe:	50878793          	add	a5,a5,1288 # 8000508 <__AXI_SRAM_segment_end__+0x6dc0508>
80007602:	4718                	lw	a4,8(a4)
80007604:	c398                	sw	a4,0(a5)
                        EEPROMReg &= ~ESC_EEPROM_ERROR_CRC;
80007606:	5732                	lw	a4,44(sp)
80007608:	f80007b7          	lui	a5,0xf8000
8000760c:	17fd                	add	a5,a5,-1 # f7ffffff <__AHB_SRAM_segment_end__+0x7df7fff>
8000760e:	8ff9                	and	a5,a5,a4
80007610:	d63e                	sw	a5,44(sp)
         break;
80007612:	a819                	j	80007628 <.L89>

80007614 <.L103>:
80007614:	a811                	j	80007628 <.L89>

80007616 <.L85>:
        default:
            EEPROMReg |= ESC_EEPROM_ERROR_CMD_ACK;
80007616:	5732                	lw	a4,44(sp)
80007618:	200007b7          	lui	a5,0x20000
8000761c:	8fd9                	or	a5,a5,a4
8000761e:	d63e                	sw	a5,44(sp)
            break;
80007620:	a021                	j	80007628 <.L89>

80007622 <.L109>:
            break;
80007622:	0001                	nop
80007624:	a011                	j	80007628 <.L89>

80007626 <.L110>:
        break;
80007626:	0001                	nop

80007628 <.L89>:
        }

        /* reset the store eeprom timeout counter*/
        u16EepromStoreTimeoutCounter = 0;
80007628:	14019c23          	sh	zero,344(gp) # 12094d0 <u16EepromStoreTimeoutCounter>

8000762c <.LBB15>:

        {
        UINT32 TmpData = SWAPDWORD(EEPROMReg);
8000762c:	57b2                	lw	a5,44(sp)
8000762e:	c63e                	sw	a5,12(sp)
        HW_EscWriteDWord(TmpData,ESC_EEPROM_CONFIG_OFFSET);
80007630:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80007634:	50078793          	add	a5,a5,1280 # 20000500 <__AXI_SRAM_segment_end__+0x1edc0500>
80007638:	4732                	lw	a4,12(sp)
8000763a:	c398                	sw	a4,0(a5)

8000763c <.L108>:
        }
    }
}
8000763c:	0001                	nop
8000763e:	50f2                	lw	ra,60(sp)
80007640:	6121                	add	sp,sp,64
80007642:	8082                	ret

Disassembly of section .text.COE_ServiceInd:

800076aa <COE_ServiceInd>:
 \brief    This function is called when a CoE (CAN application layer over EtherCAT) service is received from
             the master.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx)
{
800076aa:	7179                	add	sp,sp,-48
800076ac:	d606                	sw	ra,44(sp)
800076ae:	c62a                	sw	a0,12(sp)
    UINT8 result = 0;
800076b0:	00010fa3          	sb	zero,31(sp)

    switch ((pCoeMbx->CoeHeader & COEHEADER_COESERVICEMASK) >> COEHEADER_COESERVICESHIFT)
800076b4:	47b2                	lw	a5,12(sp)
800076b6:	0067c703          	lbu	a4,6(a5)
800076ba:	0077c783          	lbu	a5,7(a5)
800076be:	07a2                	sll	a5,a5,0x8
800076c0:	8fd9                	or	a5,a5,a4
800076c2:	0807c7b3          	zext.h	a5,a5
800076c6:	83b1                	srl	a5,a5,0xc
800076c8:	0807c7b3          	zext.h	a5,a5
800076cc:	4721                	li	a4,8
800076ce:	02e78863          	beq	a5,a4,800076fe <.L3>
800076d2:	4721                	li	a4,8
800076d4:	04f74063          	blt	a4,a5,80007714 <.L4>
800076d8:	471d                	li	a4,7
800076da:	02f74d63          	blt	a4,a5,80007714 <.L4>
800076de:	470d                	li	a4,3
800076e0:	02e7d663          	bge	a5,a4,8000770c <.L5>
800076e4:	4705                	li	a4,1
800076e6:	02e78363          	beq	a5,a4,8000770c <.L5>
800076ea:	4709                	li	a4,2
800076ec:	02e79463          	bne	a5,a4,80007714 <.L4>
    {
    case COESERVICE_SDOREQUEST:
        /* SDO-Request received, call SDOS_SdoInd to process the SDO-Request
           if an existing SDO-Stack shall be used, the corresponding function
            should be called */
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
800076f0:	4532                	lw	a0,12(sp)
800076f2:	7ff080ef          	jal	800106f0 <SDOS_SdoInd>
800076f6:	87aa                	mv	a5,a0
800076f8:	00f10fa3          	sb	a5,31(sp)
        break;
800076fc:	a005                	j	8000771c <.L6>

800076fe <.L3>:

    case COESERVICE_SDOINFO:
        /* SDO-Information Request received, call SDOS_SdoInfoInd to process the SDO-Request */
        result = SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pCoeMbx );
800076fe:	4532                	lw	a0,12(sp)
80007700:	6be090ef          	jal	80010dbe <SDOS_SdoInfoInd>
80007704:	87aa                	mv	a5,a0
80007706:	00f10fa3          	sb	a5,31(sp)
        /*NOERROR_INWORK is never returned by SDOS_SdoInfoInd() => delete return code handling*/
        break;
8000770a:	a809                	j	8000771c <.L6>

8000770c <.L5>:
    case COESERVICE_TXPDO:
    case COESERVICE_RXPDO:
    case COESERVICE_TXPDOREMREQ:
    case COESERVICE_RXPDOREMREQ:
        /* these CoE services are not supported yet */
        result = MBXERR_SERVICENOTSUPPORTED;
8000770c:	4791                	li	a5,4
8000770e:	00f10fa3          	sb	a5,31(sp)
        break;
80007712:	a029                	j	8000771c <.L6>

80007714 <.L4>:

    default:
        result = MBXERR_INVALIDHEADER;
80007714:	4795                	li	a5,5
80007716:	00f10fa3          	sb	a5,31(sp)
        break;
8000771a:	0001                	nop

8000771c <.L6>:
    }
    return result;
8000771c:	01f14783          	lbu	a5,31(sp)
}
80007720:	853e                	mv	a0,a5
80007722:	50b2                	lw	ra,44(sp)
80007724:	6145                	add	sp,sp,48
80007726:	8082                	ret

Disassembly of section .text.ResetALEventMask:

8000772a <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
8000772a:	7179                	add	sp,sp,-48
8000772c:	d606                	sw	ra,44(sp)
8000772e:	87aa                	mv	a5,a0
80007730:	00f11723          	sh	a5,14(sp)
    UINT32 u32Mask = 0;
80007734:	ce02                	sw	zero,28(sp)
    HW_EscReadDWord(u32Mask, ESC_AL_EVENTMASK_OFFSET);
80007736:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000773a:	20478793          	add	a5,a5,516
8000773e:	439c                	lw	a5,0(a5)
80007740:	ce3e                	sw	a5,28(sp)
    u32Mask &= (UINT32)intMask;
80007742:	00e15783          	lhu	a5,14(sp)
80007746:	4772                	lw	a4,28(sp)
80007748:	8ff9                	and	a5,a5,a4
8000774a:	ce3e                	sw	a5,28(sp)



    DISABLE_ESC_INT();
8000774c:	2600a0ef          	jal	800119ac <DISABLE_ESC_INT>

    HW_EscWriteDWord(u32Mask, ESC_AL_EVENTMASK_OFFSET);
80007750:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80007754:	20478793          	add	a5,a5,516
80007758:	4772                	lw	a4,28(sp)
8000775a:	c398                	sw	a4,0(a5)
    ENABLE_ESC_INT();
8000775c:	078040ef          	jal	8000b7d4 <ENABLE_ESC_INT>
}
80007760:	0001                	nop
80007762:	50b2                	lw	ra,44(sp)
80007764:	6145                	add	sp,sp,48
80007766:	8082                	ret

Disassembly of section .text.SetALEventMask:

8000779a <SetALEventMask>:
 \param    intMask        interrupt mask (enabled interrupt shall be one)

  \brief    This function makes an logical or with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void SetALEventMask(UINT16 intMask)
{
8000779a:	7179                	add	sp,sp,-48
8000779c:	d606                	sw	ra,44(sp)
8000779e:	87aa                	mv	a5,a0
800077a0:	00f11723          	sh	a5,14(sp)
    UINT32 u32Mask = 0;
800077a4:	ce02                	sw	zero,28(sp)
    HW_EscReadDWord(u32Mask, ESC_AL_EVENTMASK_OFFSET);
800077a6:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
800077aa:	20478793          	add	a5,a5,516
800077ae:	439c                	lw	a5,0(a5)
800077b0:	ce3e                	sw	a5,28(sp)
    u32Mask |= (UINT32)intMask;
800077b2:	00e15783          	lhu	a5,14(sp)
800077b6:	4772                	lw	a4,28(sp)
800077b8:	8fd9                	or	a5,a5,a4
800077ba:	ce3e                	sw	a5,28(sp)


    DISABLE_ESC_INT();
800077bc:	1f00a0ef          	jal	800119ac <DISABLE_ESC_INT>

    HW_EscWriteDWord(u32Mask, ESC_AL_EVENTMASK_OFFSET);
800077c0:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
800077c4:	20478793          	add	a5,a5,516
800077c8:	4772                	lw	a4,28(sp)
800077ca:	c398                	sw	a4,0(a5)
    ENABLE_ESC_INT();
800077cc:	008040ef          	jal	8000b7d4 <ENABLE_ESC_INT>
}
800077d0:	0001                	nop
800077d2:	50b2                	lw	ra,44(sp)
800077d4:	6145                	add	sp,sp,48
800077d6:	8082                	ret

Disassembly of section .text.GetSyncMan:

800077f6 <GetSyncMan>:
 \brief    This function is called to read the SYNC Manager channel descriptions of the
             process data SYNC Managers.
*////////////////////////////////////////////////////////////////////////////////////////

TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
{
800077f6:	1101                	add	sp,sp,-32
800077f8:	ce06                	sw	ra,28(sp)
800077fa:	87aa                	mv	a5,a0
800077fc:	00f107a3          	sb	a5,15(sp)
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
80007800:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80007804:	00f14783          	lbu	a5,15(sp)
80007808:	10078793          	add	a5,a5,256
8000780c:	078e                	sll	a5,a5,0x3
8000780e:	8789                	sra	a5,a5,0x2
80007810:	078a                	sll	a5,a5,0x2
80007812:	97ba                	add	a5,a5,a4
80007814:	4621                	li	a2,8
80007816:	85be                	mv	a1,a5
80007818:	09018513          	add	a0,gp,144 # 1209408 <SyncManInfo>
8000781c:	440060ef          	jal	8000dc5c <memcpy>



    return &SyncManInfo;
80007820:	09018793          	add	a5,gp,144 # 1209408 <SyncManInfo>
}
80007824:	853e                	mv	a0,a5
80007826:	40f2                	lw	ra,28(sp)
80007828:	6105                	add	sp,sp,32
8000782a:	8082                	ret

Disassembly of section .text.DisableSyncManChannel:

8000783a <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
8000783a:	1101                	add	sp,sp,-32
8000783c:	87aa                	mv	a5,a0
8000783e:	00f107a3          	sb	a5,15(sp)
    UINT16 Offset;
    //The registers from 0x804 to 0x806 are only readable from PDI => writing 0 for all registers is valid
    VARVOLATILE UINT32 smStatus = SM_SETTING_PDI_DISABLE;
80007842:	010007b7          	lui	a5,0x1000
80007846:	cc3e                	sw	a5,24(sp)
    Offset = (ESC_SYNCMAN_CONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
80007848:	00f14783          	lbu	a5,15(sp)
8000784c:	0807c7b3          	zext.h	a5,a5
80007850:	078e                	sll	a5,a5,0x3
80007852:	0807c733          	zext.h	a4,a5
80007856:	6785                	lui	a5,0x1
80007858:	80478793          	add	a5,a5,-2044 # 804 <.L13+0x2a>
8000785c:	97ba                	add	a5,a5,a4
8000785e:	00f11f23          	sh	a5,30(sp)

    HW_EscWriteDWord(smStatus,Offset);
80007862:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80007866:	01e15783          	lhu	a5,30(sp)
8000786a:	8389                	srl	a5,a5,0x2
8000786c:	0807c7b3          	zext.h	a5,a5
80007870:	078a                	sll	a5,a5,0x2
80007872:	97ba                	add	a5,a5,a4
80007874:	4762                	lw	a4,24(sp)
80007876:	c398                	sw	a4,0(a5)

80007878 <.L10>:


    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadDWord(smStatus, Offset);
80007878:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000787c:	01e15783          	lhu	a5,30(sp)
80007880:	8389                	srl	a5,a5,0x2
80007882:	0807c7b3          	zext.h	a5,a5
80007886:	078a                	sll	a5,a5,0x2
80007888:	97ba                	add	a5,a5,a4
8000788a:	439c                	lw	a5,0(a5)
8000788c:	cc3e                	sw	a5,24(sp)
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
8000788e:	4762                	lw	a4,24(sp)
80007890:	010007b7          	lui	a5,0x1000
80007894:	8ff9                	and	a5,a5,a4
80007896:	d3ed                	beqz	a5,80007878 <.L10>
}
80007898:	0001                	nop
8000789a:	0001                	nop
8000789c:	6105                	add	sp,sp,32
8000789e:	8082                	ret

Disassembly of section .text.EnableSyncManChannel:

800078aa <EnableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function enables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void EnableSyncManChannel(UINT8 channel)
{
800078aa:	1101                	add	sp,sp,-32
800078ac:	87aa                	mv	a5,a0
800078ae:	00f107a3          	sb	a5,15(sp)
    UINT16 Offset;
    //The registers from 0x804 to 0x806 are only readable from PDI => writing 0 for all registers is valid
    VARVOLATILE UINT32 smStatus = 0x00000000;
800078b2:	cc02                	sw	zero,24(sp)
    Offset = (ESC_SYNCMAN_CONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
800078b4:	00f14783          	lbu	a5,15(sp)
800078b8:	0807c7b3          	zext.h	a5,a5
800078bc:	078e                	sll	a5,a5,0x3
800078be:	0807c733          	zext.h	a4,a5
800078c2:	6785                	lui	a5,0x1
800078c4:	80478793          	add	a5,a5,-2044 # 804 <.L13+0x2a>
800078c8:	97ba                	add	a5,a5,a4
800078ca:	00f11f23          	sh	a5,30(sp)



    HW_EscWriteDWord(smStatus,Offset);
800078ce:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
800078d2:	01e15783          	lhu	a5,30(sp)
800078d6:	8389                	srl	a5,a5,0x2
800078d8:	0807c7b3          	zext.h	a5,a5
800078dc:	078a                	sll	a5,a5,0x2
800078de:	97ba                	add	a5,a5,a4
800078e0:	4762                	lw	a4,24(sp)
800078e2:	c398                	sw	a4,0(a5)

800078e4 <.L12>:

    /*wait until SyncManager is enabled*/
    do
    {
        HW_EscReadDWord(smStatus,Offset);
800078e4:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
800078e8:	01e15783          	lhu	a5,30(sp)
800078ec:	8389                	srl	a5,a5,0x2
800078ee:	0807c7b3          	zext.h	a5,a5
800078f2:	078a                	sll	a5,a5,0x2
800078f4:	97ba                	add	a5,a5,a4
800078f6:	439c                	lw	a5,0(a5)
800078f8:	cc3e                	sw	a5,24(sp)
    }while((smStatus & SM_SETTING_PDI_DISABLE));
800078fa:	4762                	lw	a4,24(sp)
800078fc:	010007b7          	lui	a5,0x1000
80007900:	8ff9                	and	a5,a5,a4
80007902:	f3ed                	bnez	a5,800078e4 <.L12>
}
80007904:	0001                	nop
80007906:	0001                	nop
80007908:	6105                	add	sp,sp,32
8000790a:	8082                	ret

Disassembly of section .text.CheckSmSettings:

80007916 <CheckSmSettings>:
 \brief    This function checks all SM channels

*////////////////////////////////////////////////////////////////////////////////////////

UINT8    CheckSmSettings(UINT8 maxChannel)
{
80007916:	7179                	add	sp,sp,-48
80007918:	d606                	sw	ra,44(sp)
8000791a:	87aa                	mv	a5,a0
8000791c:	00f107a3          	sb	a5,15(sp)
    UINT8 i;
    UINT8 result = 0;
80007920:	00010f23          	sb	zero,30(sp)
    TSYNCMAN ESCMEM *pSyncMan;
    UINT16 SMLength = 0;
80007924:	00011e23          	sh	zero,28(sp)
    UINT16 SMAddress = 0;
80007928:	00011d23          	sh	zero,26(sp)


        //Check if max address defines are within the available ESC address range
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
8000792c:	1661d703          	lhu	a4,358(gp) # 12094de <nMaxEscAddress>
80007930:	678d                	lui	a5,0x3
80007932:	17f9                	add	a5,a5,-2 # 2ffe <__BOOT_HEADER_segment_size__+0xffe>
80007934:	02e7f463          	bgeu	a5,a4,8000795c <.L14>
            || (nMaxEscAddress < MAX_PD_READ_ADDRESS)
80007938:	1661d703          	lhu	a4,358(gp) # 12094de <nMaxEscAddress>
8000793c:	678d                	lui	a5,0x3
8000793e:	17f9                	add	a5,a5,-2 # 2ffe <__BOOT_HEADER_segment_size__+0xffe>
80007940:	00e7fe63          	bgeu	a5,a4,8000795c <.L14>
            || (nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
80007944:	1661d703          	lhu	a4,358(gp) # 12094de <nMaxEscAddress>
80007948:	678d                	lui	a5,0x3
8000794a:	17f9                	add	a5,a5,-2 # 2ffe <__BOOT_HEADER_segment_size__+0xffe>
8000794c:	00e7f863          	bgeu	a5,a4,8000795c <.L14>
            || (nMaxEscAddress < MAX_MBX_READ_ADDRESS))
80007950:	1661d703          	lhu	a4,358(gp) # 12094de <nMaxEscAddress>
80007954:	678d                	lui	a5,0x3
80007956:	17f9                	add	a5,a5,-2 # 2ffe <__BOOT_HEADER_segment_size__+0xffe>
80007958:	00e7e463          	bltu	a5,a4,80007960 <.L15>

8000795c <.L14>:
        {
            /*The defines for maximum SM addresses are invalid for the used ESC (change the defines in the file ecat_def.h or the SSC Tool)
            It may be also required to adapt the SM settings in the ESI file*/


                return ALSTATUSCODE_NOVALIDFIRMWARE;
8000795c:	47d1                	li	a5,20
8000795e:	a3f5                	j	80007f4a <.L16>

80007960 <.L15>:
        }

    /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
    pSyncMan = GetSyncMan(MAILBOX_WRITE);
80007960:	4501                	li	a0,0
80007962:	3d51                	jal	800077f6 <GetSyncMan>
80007964:	ca2a                	sw	a0,20(sp)

    SMLength = (UINT16)((pSyncMan->AddressLength & SM_LENGTH_MASK) >> SM_LENGTH_SHIFT);
80007966:	47d2                	lw	a5,20(sp)
80007968:	0007c703          	lbu	a4,0(a5)
8000796c:	0017c683          	lbu	a3,1(a5)
80007970:	06a2                	sll	a3,a3,0x8
80007972:	8f55                	or	a4,a4,a3
80007974:	0027c683          	lbu	a3,2(a5)
80007978:	06c2                	sll	a3,a3,0x10
8000797a:	8f55                	or	a4,a4,a3
8000797c:	0037c783          	lbu	a5,3(a5)
80007980:	07e2                	sll	a5,a5,0x18
80007982:	8fd9                	or	a5,a5,a4
80007984:	83c1                	srl	a5,a5,0x10
80007986:	00f11e23          	sh	a5,28(sp)
    SMAddress = (UINT16)(pSyncMan->AddressLength & SM_ADDRESS_MASK);
8000798a:	47d2                	lw	a5,20(sp)
8000798c:	0007c703          	lbu	a4,0(a5)
80007990:	0017c683          	lbu	a3,1(a5)
80007994:	06a2                	sll	a3,a3,0x8
80007996:	8f55                	or	a4,a4,a3
80007998:	0027c683          	lbu	a3,2(a5)
8000799c:	06c2                	sll	a3,a3,0x10
8000799e:	8f55                	or	a4,a4,a3
800079a0:	0037c783          	lbu	a5,3(a5)
800079a4:	07e2                	sll	a5,a5,0x18
800079a6:	8fd9                	or	a5,a5,a4
800079a8:	00f11d23          	sh	a5,26(sp)


    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
800079ac:	47d2                	lw	a5,20(sp)
800079ae:	0047c703          	lbu	a4,4(a5)
800079b2:	0057c683          	lbu	a3,5(a5)
800079b6:	06a2                	sll	a3,a3,0x8
800079b8:	8f55                	or	a4,a4,a3
800079ba:	0067c683          	lbu	a3,6(a5)
800079be:	06c2                	sll	a3,a3,0x10
800079c0:	8f55                	or	a4,a4,a3
800079c2:	0077c783          	lbu	a5,7(a5)
800079c6:	07e2                	sll	a5,a5,0x18
800079c8:	8fd9                	or	a5,a5,a4
800079ca:	873e                	mv	a4,a5
800079cc:	67c1                	lui	a5,0x10
800079ce:	8ff9                	and	a5,a5,a4
800079d0:	e789                	bnez	a5,800079da <.L17>
    {
        /* receive mailbox is not enabled */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
800079d2:	47d9                	li	a5,22
800079d4:	00f10f23          	sb	a5,30(sp)
800079d8:	a05d                	j	80007a7e <.L18>

800079da <.L17>:
    }
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
800079da:	47d2                	lw	a5,20(sp)
800079dc:	0047c703          	lbu	a4,4(a5) # 10004 <__AXI_SRAM_segment_used_size__+0x6aa8>
800079e0:	0057c683          	lbu	a3,5(a5)
800079e4:	06a2                	sll	a3,a3,0x8
800079e6:	8f55                	or	a4,a4,a3
800079e8:	0067c683          	lbu	a3,6(a5)
800079ec:	06c2                	sll	a3,a3,0x10
800079ee:	8f55                	or	a4,a4,a3
800079f0:	0077c783          	lbu	a5,7(a5)
800079f4:	07e2                	sll	a5,a5,0x18
800079f6:	8fd9                	or	a5,a5,a4
800079f8:	00c7f713          	and	a4,a5,12
800079fc:	4791                	li	a5,4
800079fe:	00f70663          	beq	a4,a5,80007a0a <.L19>
    {
        /* receive mailbox is not writable by the master*/
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007a02:	47d9                	li	a5,22
80007a04:	00f10f23          	sb	a5,30(sp)
80007a08:	a89d                	j	80007a7e <.L18>

80007a0a <.L19>:
    }
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
80007a0a:	47d2                	lw	a5,20(sp)
80007a0c:	0047c703          	lbu	a4,4(a5)
80007a10:	0057c683          	lbu	a3,5(a5)
80007a14:	06a2                	sll	a3,a3,0x8
80007a16:	8f55                	or	a4,a4,a3
80007a18:	0067c683          	lbu	a3,6(a5)
80007a1c:	06c2                	sll	a3,a3,0x10
80007a1e:	8f55                	or	a4,a4,a3
80007a20:	0077c783          	lbu	a5,7(a5)
80007a24:	07e2                	sll	a5,a5,0x18
80007a26:	8fd9                	or	a5,a5,a4
80007a28:	8b89                	and	a5,a5,2
80007a2a:	e789                	bnez	a5,80007a34 <.L20>
    {
        /* receive mailbox is not in one buffer mode */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007a2c:	47d9                	li	a5,22
80007a2e:	00f10f23          	sb	a5,30(sp)
80007a32:	a0b1                	j	80007a7e <.L18>

80007a34 <.L20>:
    }
    else if (SMLength < MIN_MBX_SIZE)
80007a34:	01c15703          	lhu	a4,28(sp)
80007a38:	02300793          	li	a5,35
80007a3c:	00e7e663          	bltu	a5,a4,80007a48 <.L21>
    {
        /* receive mailbox size is too small */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007a40:	47d9                	li	a5,22
80007a42:	00f10f23          	sb	a5,30(sp)
80007a46:	a825                	j	80007a7e <.L18>

80007a48 <.L21>:
    }
    else if (SMLength > MAX_MBX_SIZE)
80007a48:	01c15703          	lhu	a4,28(sp)
80007a4c:	08000793          	li	a5,128
80007a50:	00e7f663          	bgeu	a5,a4,80007a5c <.L22>
    {
        /* receive mailbox size is too great */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007a54:	47d9                	li	a5,22
80007a56:	00f10f23          	sb	a5,30(sp)
80007a5a:	a015                	j	80007a7e <.L18>

80007a5c <.L22>:
    }
    else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
80007a5c:	01a15703          	lhu	a4,26(sp)
80007a60:	6785                	lui	a5,0x1
80007a62:	00f77663          	bgeu	a4,a5,80007a6e <.L23>
    {
        /* receive mailbox address is too small */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007a66:	47d9                	li	a5,22
80007a68:	00f10f23          	sb	a5,30(sp)
80007a6c:	a809                	j	80007a7e <.L18>

80007a6e <.L23>:
    }
    else if (SMAddress > MAX_MBX_WRITE_ADDRESS)
80007a6e:	01a15703          	lhu	a4,26(sp)
80007a72:	678d                	lui	a5,0x3
80007a74:	00f76563          	bltu	a4,a5,80007a7e <.L18>
    {
        /* receive mailbox address is too great */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007a78:	47d9                	li	a5,22
80007a7a:	00f10f23          	sb	a5,30(sp)

80007a7e <.L18>:
    }


    if ( result == 0 )
80007a7e:	01e14783          	lbu	a5,30(sp)
80007a82:	10079e63          	bnez	a5,80007b9e <.L24>
    {
        /* check the Sync Manager Parameter for the Send Mailbox (Sync Manager Channel 1) */
        pSyncMan = GetSyncMan(MAILBOX_READ);
80007a86:	4505                	li	a0,1
80007a88:	33bd                	jal	800077f6 <GetSyncMan>
80007a8a:	ca2a                	sw	a0,20(sp)

    SMLength = (UINT16)((pSyncMan->AddressLength & SM_LENGTH_MASK) >> SM_LENGTH_SHIFT);
80007a8c:	47d2                	lw	a5,20(sp)
80007a8e:	0007c703          	lbu	a4,0(a5) # 3000 <__BOOT_HEADER_segment_size__+0x1000>
80007a92:	0017c683          	lbu	a3,1(a5)
80007a96:	06a2                	sll	a3,a3,0x8
80007a98:	8f55                	or	a4,a4,a3
80007a9a:	0027c683          	lbu	a3,2(a5)
80007a9e:	06c2                	sll	a3,a3,0x10
80007aa0:	8f55                	or	a4,a4,a3
80007aa2:	0037c783          	lbu	a5,3(a5)
80007aa6:	07e2                	sll	a5,a5,0x18
80007aa8:	8fd9                	or	a5,a5,a4
80007aaa:	83c1                	srl	a5,a5,0x10
80007aac:	00f11e23          	sh	a5,28(sp)
    SMAddress = (UINT16)(pSyncMan->AddressLength & SM_ADDRESS_MASK);
80007ab0:	47d2                	lw	a5,20(sp)
80007ab2:	0007c703          	lbu	a4,0(a5)
80007ab6:	0017c683          	lbu	a3,1(a5)
80007aba:	06a2                	sll	a3,a3,0x8
80007abc:	8f55                	or	a4,a4,a3
80007abe:	0027c683          	lbu	a3,2(a5)
80007ac2:	06c2                	sll	a3,a3,0x10
80007ac4:	8f55                	or	a4,a4,a3
80007ac6:	0037c783          	lbu	a5,3(a5)
80007aca:	07e2                	sll	a5,a5,0x18
80007acc:	8fd9                	or	a5,a5,a4
80007ace:	00f11d23          	sh	a5,26(sp)


    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
80007ad2:	47d2                	lw	a5,20(sp)
80007ad4:	0047c703          	lbu	a4,4(a5)
80007ad8:	0057c683          	lbu	a3,5(a5)
80007adc:	06a2                	sll	a3,a3,0x8
80007ade:	8f55                	or	a4,a4,a3
80007ae0:	0067c683          	lbu	a3,6(a5)
80007ae4:	06c2                	sll	a3,a3,0x10
80007ae6:	8f55                	or	a4,a4,a3
80007ae8:	0077c783          	lbu	a5,7(a5)
80007aec:	07e2                	sll	a5,a5,0x18
80007aee:	8fd9                	or	a5,a5,a4
80007af0:	873e                	mv	a4,a5
80007af2:	67c1                	lui	a5,0x10
80007af4:	8ff9                	and	a5,a5,a4
80007af6:	e789                	bnez	a5,80007b00 <.L25>
    {
        /* send mailbox is not enabled */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007af8:	47d9                	li	a5,22
80007afa:	00f10f23          	sb	a5,30(sp)
80007afe:	a045                	j	80007b9e <.L24>

80007b00 <.L25>:
    }
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
80007b00:	47d2                	lw	a5,20(sp)
80007b02:	0047c703          	lbu	a4,4(a5) # 10004 <__AXI_SRAM_segment_used_size__+0x6aa8>
80007b06:	0057c683          	lbu	a3,5(a5)
80007b0a:	06a2                	sll	a3,a3,0x8
80007b0c:	8f55                	or	a4,a4,a3
80007b0e:	0067c683          	lbu	a3,6(a5)
80007b12:	06c2                	sll	a3,a3,0x10
80007b14:	8f55                	or	a4,a4,a3
80007b16:	0077c783          	lbu	a5,7(a5)
80007b1a:	07e2                	sll	a5,a5,0x18
80007b1c:	8fd9                	or	a5,a5,a4
80007b1e:	8bb1                	and	a5,a5,12
80007b20:	c789                	beqz	a5,80007b2a <.L26>
    {
        /* receive mailbox is not readable by the master*/
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007b22:	47d9                	li	a5,22
80007b24:	00f10f23          	sb	a5,30(sp)
80007b28:	a89d                	j	80007b9e <.L24>

80007b2a <.L26>:
    }
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
80007b2a:	47d2                	lw	a5,20(sp)
80007b2c:	0047c703          	lbu	a4,4(a5)
80007b30:	0057c683          	lbu	a3,5(a5)
80007b34:	06a2                	sll	a3,a3,0x8
80007b36:	8f55                	or	a4,a4,a3
80007b38:	0067c683          	lbu	a3,6(a5)
80007b3c:	06c2                	sll	a3,a3,0x10
80007b3e:	8f55                	or	a4,a4,a3
80007b40:	0077c783          	lbu	a5,7(a5)
80007b44:	07e2                	sll	a5,a5,0x18
80007b46:	8fd9                	or	a5,a5,a4
80007b48:	8b89                	and	a5,a5,2
80007b4a:	e789                	bnez	a5,80007b54 <.L27>
    {
        /* receive mailbox is not in one buffer mode */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007b4c:	47d9                	li	a5,22
80007b4e:	00f10f23          	sb	a5,30(sp)
80007b52:	a0b1                	j	80007b9e <.L24>

80007b54 <.L27>:
    }
    else if (SMLength < MIN_MBX_SIZE)
80007b54:	01c15703          	lhu	a4,28(sp)
80007b58:	02300793          	li	a5,35
80007b5c:	00e7e663          	bltu	a5,a4,80007b68 <.L28>
    {
        /* send mailbox size is too small */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007b60:	47d9                	li	a5,22
80007b62:	00f10f23          	sb	a5,30(sp)
80007b66:	a825                	j	80007b9e <.L24>

80007b68 <.L28>:
    }
    else if (SMLength > MAX_MBX_SIZE)
80007b68:	01c15703          	lhu	a4,28(sp)
80007b6c:	08000793          	li	a5,128
80007b70:	00e7f663          	bgeu	a5,a4,80007b7c <.L29>
    {
        /* send mailbox size is too great */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007b74:	47d9                	li	a5,22
80007b76:	00f10f23          	sb	a5,30(sp)
80007b7a:	a015                	j	80007b9e <.L24>

80007b7c <.L29>:
    }
    else if (SMAddress < MIN_MBX_READ_ADDRESS)
80007b7c:	01a15703          	lhu	a4,26(sp)
80007b80:	6785                	lui	a5,0x1
80007b82:	00f77663          	bgeu	a4,a5,80007b8e <.L30>
    {
        /* send mailbox address is too small */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007b86:	47d9                	li	a5,22
80007b88:	00f10f23          	sb	a5,30(sp)
80007b8c:	a809                	j	80007b9e <.L24>

80007b8e <.L30>:
    }
    else if (SMAddress > MAX_MBX_READ_ADDRESS)
80007b8e:	01a15703          	lhu	a4,26(sp)
80007b92:	678d                	lui	a5,0x3
80007b94:	00f76563          	bltu	a4,a5,80007b9e <.L24>
    {
        /* send mailbox address is too great */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
80007b98:	47d9                	li	a5,22
80007b9a:	00f10f23          	sb	a5,30(sp)

80007b9e <.L24>:
    }
    }

    if ( result == 0 && maxChannel > PROCESS_DATA_IN )
80007b9e:	01e14783          	lbu	a5,30(sp)
80007ba2:	18079663          	bnez	a5,80007d2e <.L31>
80007ba6:	00f14703          	lbu	a4,15(sp)
80007baa:	478d                	li	a5,3
80007bac:	18e7f163          	bgeu	a5,a4,80007d2e <.L31>
    {
        /* b3BufferMode is only set, if inputs and outputs are running in 3-Buffer-Mode when leaving this function */
        b3BufferMode = TRUE;
80007bb0:	4705                	li	a4,1
80007bb2:	1ae182a3          	sb	a4,421(gp) # 120951d <b3BufferMode>
        /* check the Sync Manager Parameter for the Inputs (Sync Manager Channel 2 (0 in case if no mailbox is supported)) */
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
80007bb6:	450d                	li	a0,3
80007bb8:	393d                	jal	800077f6 <GetSyncMan>
80007bba:	ca2a                	sw	a0,20(sp)

    SMLength = (UINT16)((pSyncMan->AddressLength & SM_LENGTH_MASK) >> SM_LENGTH_SHIFT);
80007bbc:	47d2                	lw	a5,20(sp)
80007bbe:	0007c703          	lbu	a4,0(a5) # 3000 <__BOOT_HEADER_segment_size__+0x1000>
80007bc2:	0017c683          	lbu	a3,1(a5)
80007bc6:	06a2                	sll	a3,a3,0x8
80007bc8:	8f55                	or	a4,a4,a3
80007bca:	0027c683          	lbu	a3,2(a5)
80007bce:	06c2                	sll	a3,a3,0x10
80007bd0:	8f55                	or	a4,a4,a3
80007bd2:	0037c783          	lbu	a5,3(a5)
80007bd6:	07e2                	sll	a5,a5,0x18
80007bd8:	8fd9                	or	a5,a5,a4
80007bda:	83c1                	srl	a5,a5,0x10
80007bdc:	00f11e23          	sh	a5,28(sp)
    SMAddress = (UINT16)(pSyncMan->AddressLength & SM_ADDRESS_MASK);
80007be0:	47d2                	lw	a5,20(sp)
80007be2:	0007c703          	lbu	a4,0(a5)
80007be6:	0017c683          	lbu	a3,1(a5)
80007bea:	06a2                	sll	a3,a3,0x8
80007bec:	8f55                	or	a4,a4,a3
80007bee:	0027c683          	lbu	a3,2(a5)
80007bf2:	06c2                	sll	a3,a3,0x10
80007bf4:	8f55                	or	a4,a4,a3
80007bf6:	0037c783          	lbu	a5,3(a5)
80007bfa:	07e2                	sll	a5,a5,0x18
80007bfc:	8fd9                	or	a5,a5,a4
80007bfe:	00f11d23          	sh	a5,26(sp)


    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
80007c02:	47d2                	lw	a5,20(sp)
80007c04:	0047c703          	lbu	a4,4(a5)
80007c08:	0057c683          	lbu	a3,5(a5)
80007c0c:	06a2                	sll	a3,a3,0x8
80007c0e:	8f55                	or	a4,a4,a3
80007c10:	0067c683          	lbu	a3,6(a5)
80007c14:	06c2                	sll	a3,a3,0x10
80007c16:	8f55                	or	a4,a4,a3
80007c18:	0077c783          	lbu	a5,7(a5)
80007c1c:	07e2                	sll	a5,a5,0x18
80007c1e:	8fd9                	or	a5,a5,a4
80007c20:	873e                	mv	a4,a5
80007c22:	67c1                	lui	a5,0x10
80007c24:	8ff9                	and	a5,a5,a4
80007c26:	cb81                	beqz	a5,80007c36 <.L32>
80007c28:	01c15783          	lhu	a5,28(sp)
80007c2c:	e789                	bnez	a5,80007c36 <.L32>
    {
        /* the SM3 size is 0 and the SM3 is active */
        result = SYNCMANCHSETTINGS + 1;
80007c2e:	478d                	li	a5,3
80007c30:	00f10f23          	sb	a5,30(sp)
80007c34:	a0fd                	j	80007d22 <.L33>

80007c36 <.L32>:
    }
        else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
80007c36:	47d2                	lw	a5,20(sp)
80007c38:	0047c703          	lbu	a4,4(a5) # 10004 <__AXI_SRAM_segment_used_size__+0x6aa8>
80007c3c:	0057c683          	lbu	a3,5(a5)
80007c40:	06a2                	sll	a3,a3,0x8
80007c42:	8f55                	or	a4,a4,a3
80007c44:	0067c683          	lbu	a3,6(a5)
80007c48:	06c2                	sll	a3,a3,0x10
80007c4a:	8f55                	or	a4,a4,a3
80007c4c:	0077c783          	lbu	a5,7(a5)
80007c50:	07e2                	sll	a5,a5,0x18
80007c52:	8fd9                	or	a5,a5,a4
80007c54:	873e                	mv	a4,a5
80007c56:	67c1                	lui	a5,0x10
80007c58:	8ff9                	and	a5,a5,a4
80007c5a:	cbdd                	beqz	a5,80007d10 <.L34>
        {
            /* Sync Manager Channel 3 is active, input size has to greater 0 */
                if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
80007c5c:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80007c60:	01c15703          	lhu	a4,28(sp)
80007c64:	00f71b63          	bne	a4,a5,80007c7a <.L35>
80007c68:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80007c6c:	c799                	beqz	a5,80007c7a <.L35>
80007c6e:	01c15703          	lhu	a4,28(sp)
80007c72:	04000793          	li	a5,64
80007c76:	00e7f663          	bgeu	a5,a4,80007c82 <.L36>

80007c7a <.L35>:
                {
                    /* sizes don't match */
                    result = SYNCMANCHSIZE + 1;
80007c7a:	4785                	li	a5,1
80007c7c:	00f10f23          	sb	a5,30(sp)
80007c80:	a04d                	j	80007d22 <.L33>

80007c82 <.L36>:
                }
                else
                {
                    /* sizes matches */
                    if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE)
80007c82:	47d2                	lw	a5,20(sp)
80007c84:	0047c703          	lbu	a4,4(a5) # 10004 <__AXI_SRAM_segment_used_size__+0x6aa8>
80007c88:	0057c683          	lbu	a3,5(a5)
80007c8c:	06a2                	sll	a3,a3,0x8
80007c8e:	8f55                	or	a4,a4,a3
80007c90:	0067c683          	lbu	a3,6(a5)
80007c94:	06c2                	sll	a3,a3,0x10
80007c96:	8f55                	or	a4,a4,a3
80007c98:	0077c783          	lbu	a5,7(a5)
80007c9c:	07e2                	sll	a5,a5,0x18
80007c9e:	8fd9                	or	a5,a5,a4
80007ca0:	8bb1                	and	a5,a5,12
80007ca2:	e3bd                	bnez	a5,80007d08 <.L38>
                    {
                        /* settings match */
                        if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (SMAddress <= MAX_PD_READ_ADDRESS))
80007ca4:	18b1c703          	lbu	a4,395(gp) # 1209503 <nAlStatus>
80007ca8:	4789                	li	a5,2
80007caa:	00f71c63          	bne	a4,a5,80007cc2 <.L39>
80007cae:	01a15703          	lhu	a4,26(sp)
80007cb2:	6785                	lui	a5,0x1
80007cb4:	00f76763          	bltu	a4,a5,80007cc2 <.L39>
80007cb8:	01a15703          	lhu	a4,26(sp)
80007cbc:	678d                	lui	a5,0x3
80007cbe:	00f76d63          	bltu	a4,a5,80007cd8 <.L40>

80007cc2 <.L39>:
                            || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
80007cc2:	18b1c703          	lbu	a4,395(gp) # 1209503 <nAlStatus>
80007cc6:	4789                	li	a5,2
80007cc8:	02f70c63          	beq	a4,a5,80007d00 <.L41>
80007ccc:	16a1d783          	lhu	a5,362(gp) # 12094e2 <nEscAddrInputData>
80007cd0:	01a15703          	lhu	a4,26(sp)
80007cd4:	02f71663          	bne	a4,a5,80007d00 <.L41>

80007cd8 <.L40>:
                            )
                        {
                            /* addresses match */

                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
80007cd8:	47d2                	lw	a5,20(sp)
80007cda:	0047c703          	lbu	a4,4(a5) # 3004 <__BOOT_HEADER_segment_size__+0x1004>
80007cde:	0057c683          	lbu	a3,5(a5)
80007ce2:	06a2                	sll	a3,a3,0x8
80007ce4:	8f55                	or	a4,a4,a3
80007ce6:	0067c683          	lbu	a3,6(a5)
80007cea:	06c2                	sll	a3,a3,0x10
80007cec:	8f55                	or	a4,a4,a3
80007cee:	0077c783          	lbu	a5,7(a5)
80007cf2:	07e2                	sll	a5,a5,0x18
80007cf4:	8fd9                	or	a5,a5,a4
80007cf6:	8b89                	and	a5,a5,2
80007cf8:	c78d                	beqz	a5,80007d22 <.L33>
                                {
                                    /* inputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
                                    b3BufferMode = FALSE;
80007cfa:	1a0182a3          	sb	zero,421(gp) # 120951d <b3BufferMode>
                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
80007cfe:	a015                	j	80007d22 <.L33>

80007d00 <.L41>:
                                }
                        }
                        else
                        {
                            /* input address is out of the allowed area or has changed in SAFEOP or OP */
                            result = SYNCMANCHADDRESS + 1;
80007d00:	4789                	li	a5,2
80007d02:	00f10f23          	sb	a5,30(sp)
80007d06:	a831                	j	80007d22 <.L33>

80007d08 <.L38>:
                        }
                    }
                    else
                    {
                        /* input settings do not match */
                        result = SYNCMANCHSETTINGS + 1;
80007d08:	478d                	li	a5,3
80007d0a:	00f10f23          	sb	a5,30(sp)
80007d0e:	a811                	j	80007d22 <.L33>

80007d10 <.L34>:
                    }
                }
        }
        else if (SMLength != 0 || nPdInputSize != 0)
80007d10:	01c15783          	lhu	a5,28(sp)
80007d14:	e781                	bnez	a5,80007d1c <.L44>
80007d16:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80007d1a:	c781                	beqz	a5,80007d22 <.L33>

80007d1c <.L44>:
        {
            /* input size is not zero although the SM3 channel is not enabled */
            result = SYNCMANCHSIZE + 1;
80007d1c:	4785                	li	a5,1
80007d1e:	00f10f23          	sb	a5,30(sp)

80007d22 <.L33>:
        }



        if ( result != 0 )
80007d22:	01e14783          	lbu	a5,30(sp)
80007d26:	c781                	beqz	a5,80007d2e <.L31>
        {
            result = ALSTATUSCODE_INVALIDSMINCFG;
80007d28:	47f9                	li	a5,30
80007d2a:	00f10f23          	sb	a5,30(sp)

80007d2e <.L31>:
        }
    }


//    else
    if (result == 0 && maxChannel > PROCESS_DATA_OUT)
80007d2e:	01e14783          	lbu	a5,30(sp)
80007d32:	1c079063          	bnez	a5,80007ef2 <.L45>
80007d36:	00f14703          	lbu	a4,15(sp)
80007d3a:	4789                	li	a5,2
80007d3c:	1ae7fb63          	bgeu	a5,a4,80007ef2 <.L45>
    {
        /* check the Sync Manager Parameter for the Outputs (Sync Manager Channel 2) */
        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
80007d40:	4509                	li	a0,2
80007d42:	3c55                	jal	800077f6 <GetSyncMan>
80007d44:	ca2a                	sw	a0,20(sp)

        SMLength = (UINT16)((pSyncMan->AddressLength & SM_LENGTH_MASK) >> SM_LENGTH_SHIFT);
80007d46:	47d2                	lw	a5,20(sp)
80007d48:	0007c703          	lbu	a4,0(a5)
80007d4c:	0017c683          	lbu	a3,1(a5)
80007d50:	06a2                	sll	a3,a3,0x8
80007d52:	8f55                	or	a4,a4,a3
80007d54:	0027c683          	lbu	a3,2(a5)
80007d58:	06c2                	sll	a3,a3,0x10
80007d5a:	8f55                	or	a4,a4,a3
80007d5c:	0037c783          	lbu	a5,3(a5)
80007d60:	07e2                	sll	a5,a5,0x18
80007d62:	8fd9                	or	a5,a5,a4
80007d64:	83c1                	srl	a5,a5,0x10
80007d66:	00f11e23          	sh	a5,28(sp)
        SMAddress = (UINT16)(pSyncMan->AddressLength & SM_ADDRESS_MASK);
80007d6a:	47d2                	lw	a5,20(sp)
80007d6c:	0007c703          	lbu	a4,0(a5)
80007d70:	0017c683          	lbu	a3,1(a5)
80007d74:	06a2                	sll	a3,a3,0x8
80007d76:	8f55                	or	a4,a4,a3
80007d78:	0027c683          	lbu	a3,2(a5)
80007d7c:	06c2                	sll	a3,a3,0x10
80007d7e:	8f55                	or	a4,a4,a3
80007d80:	0037c783          	lbu	a5,3(a5)
80007d84:	07e2                	sll	a5,a5,0x18
80007d86:	8fd9                	or	a5,a5,a4
80007d88:	00f11d23          	sh	a5,26(sp)


    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
80007d8c:	47d2                	lw	a5,20(sp)
80007d8e:	0047c703          	lbu	a4,4(a5)
80007d92:	0057c683          	lbu	a3,5(a5)
80007d96:	06a2                	sll	a3,a3,0x8
80007d98:	8f55                	or	a4,a4,a3
80007d9a:	0067c683          	lbu	a3,6(a5)
80007d9e:	06c2                	sll	a3,a3,0x10
80007da0:	8f55                	or	a4,a4,a3
80007da2:	0077c783          	lbu	a5,7(a5)
80007da6:	07e2                	sll	a5,a5,0x18
80007da8:	8fd9                	or	a5,a5,a4
80007daa:	873e                	mv	a4,a5
80007dac:	67c1                	lui	a5,0x10
80007dae:	8ff9                	and	a5,a5,a4
80007db0:	cb81                	beqz	a5,80007dc0 <.L46>
80007db2:	01c15783          	lhu	a5,28(sp)
80007db6:	e789                	bnez	a5,80007dc0 <.L46>
    {
        /* the SM2 size is 0 and the SM2 is active */
        result = SYNCMANCHSETTINGS + 1;
80007db8:	478d                	li	a5,3
80007dba:	00f10f23          	sb	a5,30(sp)
80007dbe:	a225                	j	80007ee6 <.L47>

80007dc0 <.L46>:
    }
        else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
80007dc0:	47d2                	lw	a5,20(sp)
80007dc2:	0047c703          	lbu	a4,4(a5) # 10004 <__AXI_SRAM_segment_used_size__+0x6aa8>
80007dc6:	0057c683          	lbu	a3,5(a5)
80007dca:	06a2                	sll	a3,a3,0x8
80007dcc:	8f55                	or	a4,a4,a3
80007dce:	0067c683          	lbu	a3,6(a5)
80007dd2:	06c2                	sll	a3,a3,0x10
80007dd4:	8f55                	or	a4,a4,a3
80007dd6:	0077c783          	lbu	a5,7(a5)
80007dda:	07e2                	sll	a5,a5,0x18
80007ddc:	8fd9                	or	a5,a5,a4
80007dde:	873e                	mv	a4,a5
80007de0:	67c1                	lui	a5,0x10
80007de2:	8ff9                	and	a5,a5,a4
80007de4:	0e078863          	beqz	a5,80007ed4 <.L48>
        {
            /* Sync Manager Channel 2 is active, output size has to greater 0 */
            if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
80007de8:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80007dec:	01c15703          	lhu	a4,28(sp)
80007df0:	0cf71e63          	bne	a4,a5,80007ecc <.L49>
80007df4:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80007df8:	cbf1                	beqz	a5,80007ecc <.L49>
80007dfa:	01c15703          	lhu	a4,28(sp)
80007dfe:	04000793          	li	a5,64
80007e02:	0ce7e563          	bltu	a5,a4,80007ecc <.L49>
            {
                /* sizes match */
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
80007e06:	47d2                	lw	a5,20(sp)
80007e08:	0047c703          	lbu	a4,4(a5) # 10004 <__AXI_SRAM_segment_used_size__+0x6aa8>
80007e0c:	0057c683          	lbu	a3,5(a5)
80007e10:	06a2                	sll	a3,a3,0x8
80007e12:	8f55                	or	a4,a4,a3
80007e14:	0067c683          	lbu	a3,6(a5)
80007e18:	06c2                	sll	a3,a3,0x10
80007e1a:	8f55                	or	a4,a4,a3
80007e1c:	0077c783          	lbu	a5,7(a5)
80007e20:	07e2                	sll	a5,a5,0x18
80007e22:	8fd9                	or	a5,a5,a4
80007e24:	00c7f713          	and	a4,a5,12
80007e28:	4791                	li	a5,4
80007e2a:	08f71c63          	bne	a4,a5,80007ec2 <.L50>
                {
                    /* settings match */
                    if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
80007e2e:	18b1c703          	lbu	a4,395(gp) # 1209503 <nAlStatus>
80007e32:	4789                	li	a5,2
80007e34:	00f71c63          	bne	a4,a5,80007e4c <.L51>
80007e38:	01a15703          	lhu	a4,26(sp)
80007e3c:	6785                	lui	a5,0x1
80007e3e:	00f76763          	bltu	a4,a5,80007e4c <.L51>
80007e42:	01a15703          	lhu	a4,26(sp)
80007e46:	678d                	lui	a5,0x3
80007e48:	00f76d63          	bltu	a4,a5,80007e62 <.L52>

80007e4c <.L51>:
                       ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
80007e4c:	18b1c703          	lbu	a4,395(gp) # 1209503 <nAlStatus>
80007e50:	4789                	li	a5,2
80007e52:	06f70463          	beq	a4,a5,80007eba <.L53>
80007e56:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
80007e5a:	01a15703          	lhu	a4,26(sp)
80007e5e:	04f71e63          	bne	a4,a5,80007eba <.L53>

80007e62 <.L52>:
                        )
                    {
                        /* addresses match */
                        {
                            /* check, if watchdog trigger is enabled */
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
80007e62:	47d2                	lw	a5,20(sp)
80007e64:	0047c703          	lbu	a4,4(a5) # 3004 <__BOOT_HEADER_segment_size__+0x1004>
80007e68:	0057c683          	lbu	a3,5(a5)
80007e6c:	06a2                	sll	a3,a3,0x8
80007e6e:	8f55                	or	a4,a4,a3
80007e70:	0067c683          	lbu	a3,6(a5)
80007e74:	06c2                	sll	a3,a3,0x10
80007e76:	8f55                	or	a4,a4,a3
80007e78:	0077c783          	lbu	a5,7(a5)
80007e7c:	07e2                	sll	a5,a5,0x18
80007e7e:	8fd9                	or	a5,a5,a4
80007e80:	0407f793          	and	a5,a5,64
80007e84:	c789                	beqz	a5,80007e8e <.L54>
                            {
                                bWdTrigger = TRUE;
80007e86:	4705                	li	a4,1
80007e88:	18e18623          	sb	a4,396(gp) # 1209504 <bWdTrigger>
80007e8c:	a019                	j	80007e92 <.L55>

80007e8e <.L54>:
                            }
                            else
                            {
                                bWdTrigger = FALSE;
80007e8e:	18018623          	sb	zero,396(gp) # 1209504 <bWdTrigger>

80007e92 <.L55>:
                            }

                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
80007e92:	47d2                	lw	a5,20(sp)
80007e94:	0047c703          	lbu	a4,4(a5)
80007e98:	0057c683          	lbu	a3,5(a5)
80007e9c:	06a2                	sll	a3,a3,0x8
80007e9e:	8f55                	or	a4,a4,a3
80007ea0:	0067c683          	lbu	a3,6(a5)
80007ea4:	06c2                	sll	a3,a3,0x10
80007ea6:	8f55                	or	a4,a4,a3
80007ea8:	0077c783          	lbu	a5,7(a5)
80007eac:	07e2                	sll	a5,a5,0x18
80007eae:	8fd9                	or	a5,a5,a4
80007eb0:	8b89                	and	a5,a5,2
80007eb2:	cf81                	beqz	a5,80007eca <.L58>
                            {
                                /* outputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
                                b3BufferMode = FALSE;
80007eb4:	1a0182a3          	sb	zero,421(gp) # 120951d <b3BufferMode>
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
80007eb8:	a809                	j	80007eca <.L58>

80007eba <.L53>:
                        }
                    }
                    else
                    {
                        /* output address is out of the allowed area or has changed in SAFEOP or OP */
                        result = SYNCMANCHADDRESS + 1;
80007eba:	4789                	li	a5,2
80007ebc:	00f10f23          	sb	a5,30(sp)
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
80007ec0:	a01d                	j	80007ee6 <.L47>

80007ec2 <.L50>:
                    }
                }
                else
                {
                    /* output settings do not match */
                    result = SYNCMANCHSETTINGS + 1;
80007ec2:	478d                	li	a5,3
80007ec4:	00f10f23          	sb	a5,30(sp)
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
80007ec8:	a839                	j	80007ee6 <.L47>

80007eca <.L58>:
80007eca:	a831                	j	80007ee6 <.L47>

80007ecc <.L49>:
                }
            }
            else
            {
                /* output sizes don't match */
                result = SYNCMANCHSIZE + 1;
80007ecc:	4785                	li	a5,1
80007ece:	00f10f23          	sb	a5,30(sp)
80007ed2:	a811                	j	80007ee6 <.L47>

80007ed4 <.L48>:
            }
        }
        else if (SMLength != 0 || nPdOutputSize != 0)
80007ed4:	01c15783          	lhu	a5,28(sp)
80007ed8:	e781                	bnez	a5,80007ee0 <.L60>
80007eda:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80007ede:	c781                	beqz	a5,80007ee6 <.L47>

80007ee0 <.L60>:
        {
            /* output size is not zero although the SM2 channel is not enabled */
            result = SYNCMANCHSIZE + 1;
80007ee0:	4785                	li	a5,1
80007ee2:	00f10f23          	sb	a5,30(sp)

80007ee6 <.L47>:
        }

        if ( result != 0 )
80007ee6:	01e14783          	lbu	a5,30(sp)
80007eea:	c781                	beqz	a5,80007ef2 <.L45>
        {
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
80007eec:	47f5                	li	a5,29
80007eee:	00f10f23          	sb	a5,30(sp)

80007ef2 <.L45>:
        }
    }


    if ( result == 0 )
80007ef2:	01e14783          	lbu	a5,30(sp)
80007ef6:	eba1                	bnez	a5,80007f46 <.L61>
    {
        /* the Enable-Byte of the rest of the SM channels has to be read to acknowledge the SM-Change-Interrupt */
        for (i = maxChannel; i < nMaxSyncMan; i++)
80007ef8:	00f14783          	lbu	a5,15(sp)
80007efc:	00f10fa3          	sb	a5,31(sp)
80007f00:	a82d                	j	80007f3a <.L62>

80007f02 <.L63>:
        {
            pSyncMan = GetSyncMan(i);
80007f02:	01f14783          	lbu	a5,31(sp)
80007f06:	853e                	mv	a0,a5
80007f08:	30fd                	jal	800077f6 <GetSyncMan>
80007f0a:	ca2a                	sw	a0,20(sp)
            SMActivate = pSyncMan->Settings[0];
80007f0c:	47d2                	lw	a5,20(sp)
80007f0e:	0047c703          	lbu	a4,4(a5)
80007f12:	0057c683          	lbu	a3,5(a5)
80007f16:	06a2                	sll	a3,a3,0x8
80007f18:	8f55                	or	a4,a4,a3
80007f1a:	0067c683          	lbu	a3,6(a5)
80007f1e:	06c2                	sll	a3,a3,0x10
80007f20:	8f55                	or	a4,a4,a3
80007f22:	0077c783          	lbu	a5,7(a5)
80007f26:	07e2                	sll	a5,a5,0x18
80007f28:	8fd9                	or	a5,a5,a4
80007f2a:	873e                	mv	a4,a5
80007f2c:	12e1a623          	sw	a4,300(gp) # 12094a4 <SMActivate>
        for (i = maxChannel; i < nMaxSyncMan; i++)
80007f30:	01f14783          	lbu	a5,31(sp)
80007f34:	0785                	add	a5,a5,1
80007f36:	00f10fa3          	sb	a5,31(sp)

80007f3a <.L62>:
80007f3a:	18a1c783          	lbu	a5,394(gp) # 1209502 <nMaxSyncMan>
80007f3e:	01f14703          	lbu	a4,31(sp)
80007f42:	fcf760e3          	bltu	a4,a5,80007f02 <.L63>

80007f46 <.L61>:
        }
    }
    return result;
80007f46:	01e14783          	lbu	a5,30(sp)

80007f4a <.L16>:
}
80007f4a:	853e                	mv	a0,a5
80007f4c:	50b2                	lw	ra,44(sp)
80007f4e:	6145                	add	sp,sp,48
80007f50:	8082                	ret

Disassembly of section .text.StartInputHandler:

80008248 <StartInputHandler>:
 \brief  and the AL Event Mask register will be set

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartInputHandler(void)
{
80008248:	711d                	add	sp,sp,-96
8000824a:	ce86                	sw	ra,92(sp)
    TSYNCMAN ESCMEM * pSyncMan;

     UINT32        dcControl;

    UINT16     wdiv = 0;
8000824c:	04011223          	sh	zero,68(sp)
    UINT16     wd = 0;
80008250:	04011123          	sh	zero,66(sp)
    UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
80008254:	de02                	sw	zero,60(sp)
    UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
80008256:	dc02                	sw	zero,56(sp)
    BOOL bSubordinatedCycles = FALSE;
80008258:	040107a3          	sb	zero,79(sp)

    UINT16    nPdInputBuffer = 3;
8000825c:	478d                	li	a5,3
8000825e:	04f11623          	sh	a5,76(sp)

    UINT16    nPdOutputBuffer = 3;
80008262:	478d                	li	a5,3
80008264:	04f11523          	sh	a5,74(sp)

    UINT16 SyncType0x1C32 = 0; /* Helper variable for sync type for SM2 (required if no CoE is supported or no output process data available)*/
80008268:	04011423          	sh	zero,72(sp)
    UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/
8000826c:	04011323          	sh	zero,70(sp)

    UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */
80008270:	57fd                	li	a5,-1
80008272:	02f11b23          	sh	a5,54(sp)

    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
80008276:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000827a:	00c7c703          	lbu	a4,12(a5)
8000827e:	00d7c783          	lbu	a5,13(a5)
80008282:	07a2                	sll	a5,a5,0x8
80008284:	8fd9                	or	a5,a5,a4
80008286:	0807c7b3          	zext.h	a5,a5
8000828a:	03615703          	lhu	a4,54(sp)
8000828e:	8ff9                	and	a5,a5,a4
80008290:	02f11b23          	sh	a5,54(sp)
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
80008294:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80008298:	00c7c703          	lbu	a4,12(a5)
8000829c:	00d7c783          	lbu	a5,13(a5)
800082a0:	07a2                	sll	a5,a5,0x8
800082a2:	8fd9                	or	a5,a5,a4
800082a4:	0807c7b3          	zext.h	a5,a5
800082a8:	03615703          	lhu	a4,54(sp)
800082ac:	8ff9                	and	a5,a5,a4
800082ae:	02f11b23          	sh	a5,54(sp)

    u16ALEventMask = 0;
800082b2:	14019d23          	sh	zero,346(gp) # 12094d2 <u16ALEventMask>


    /* 
        --- Check if SyncManager areas overlapping --- 
    */
    bEcatFirstOutputsReceived = FALSE;
800082b6:	1a0180a3          	sb	zero,417(gp) # 1209519 <bEcatFirstOutputsReceived>

    /* get a pointer to the Sync Manager Channel 2 (Outputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
800082ba:	4509                	li	a0,2
800082bc:	d3aff0ef          	jal	800077f6 <GetSyncMan>
800082c0:	d82a                	sw	a0,48(sp)
    /* store the address of the Sync Manager Channel 2 (Outputs) */
    nEscAddrOutputData = (UINT16) (pSyncMan->AddressLength & SM_ADDRESS_MASK);
800082c2:	57c2                	lw	a5,48(sp)
800082c4:	0007c703          	lbu	a4,0(a5)
800082c8:	0017c683          	lbu	a3,1(a5)
800082cc:	06a2                	sll	a3,a3,0x8
800082ce:	8f55                	or	a4,a4,a3
800082d0:	0027c683          	lbu	a3,2(a5)
800082d4:	06c2                	sll	a3,a3,0x10
800082d6:	8f55                	or	a4,a4,a3
800082d8:	0037c783          	lbu	a5,3(a5)
800082dc:	07e2                	sll	a5,a5,0x18
800082de:	8fd9                	or	a5,a5,a4
800082e0:	0807c733          	zext.h	a4,a5
800082e4:	16e19423          	sh	a4,360(gp) # 12094e0 <nEscAddrOutputData>
    /* get the number of output buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
800082e8:	57c2                	lw	a5,48(sp)
800082ea:	0047c703          	lbu	a4,4(a5)
800082ee:	0057c683          	lbu	a3,5(a5)
800082f2:	06a2                	sll	a3,a3,0x8
800082f4:	8f55                	or	a4,a4,a3
800082f6:	0067c683          	lbu	a3,6(a5)
800082fa:	06c2                	sll	a3,a3,0x10
800082fc:	8f55                	or	a4,a4,a3
800082fe:	0077c783          	lbu	a5,7(a5)
80008302:	07e2                	sll	a5,a5,0x18
80008304:	8fd9                	or	a5,a5,a4
80008306:	8b89                	and	a5,a5,2
80008308:	c781                	beqz	a5,80008310 <.L65>
    {
       nPdOutputBuffer = 1;
8000830a:	4785                	li	a5,1
8000830c:	04f11523          	sh	a5,74(sp)

80008310 <.L65>:
    }


    /* get a pointer to the Sync Manager Channel 3 (Inputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_IN);
80008310:	450d                	li	a0,3
80008312:	ce4ff0ef          	jal	800077f6 <GetSyncMan>
80008316:	d82a                	sw	a0,48(sp)
    /* store the address of the Sync Manager Channel 3 (Inputs)*/
    nEscAddrInputData = (UINT16) (pSyncMan->AddressLength & SM_ADDRESS_MASK);
80008318:	57c2                	lw	a5,48(sp)
8000831a:	0007c703          	lbu	a4,0(a5)
8000831e:	0017c683          	lbu	a3,1(a5)
80008322:	06a2                	sll	a3,a3,0x8
80008324:	8f55                	or	a4,a4,a3
80008326:	0027c683          	lbu	a3,2(a5)
8000832a:	06c2                	sll	a3,a3,0x10
8000832c:	8f55                	or	a4,a4,a3
8000832e:	0037c783          	lbu	a5,3(a5)
80008332:	07e2                	sll	a5,a5,0x18
80008334:	8fd9                	or	a5,a5,a4
80008336:	0807c733          	zext.h	a4,a5
8000833a:	16e19523          	sh	a4,362(gp) # 12094e2 <nEscAddrInputData>


    /* get the number of input buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
8000833e:	57c2                	lw	a5,48(sp)
80008340:	0047c703          	lbu	a4,4(a5)
80008344:	0057c683          	lbu	a3,5(a5)
80008348:	06a2                	sll	a3,a3,0x8
8000834a:	8f55                	or	a4,a4,a3
8000834c:	0067c683          	lbu	a3,6(a5)
80008350:	06c2                	sll	a3,a3,0x10
80008352:	8f55                	or	a4,a4,a3
80008354:	0077c783          	lbu	a5,7(a5)
80008358:	07e2                	sll	a5,a5,0x18
8000835a:	8fd9                	or	a5,a5,a4
8000835c:	8b89                	and	a5,a5,2
8000835e:	c781                	beqz	a5,80008366 <.L66>
    {
        nPdInputBuffer = 1;
80008360:	4785                	li	a5,1
80008362:	04f11623          	sh	a5,76(sp)

80008366 <.L66>:
    }
    /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
       the Sync Manager memory areas for the Mailbox */

    if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
80008366:	16a1d783          	lhu	a5,362(gp) # 12094e2 <nEscAddrInputData>
8000836a:	873e                	mv	a4,a5
8000836c:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80008370:	86be                	mv	a3,a5
80008372:	04c15783          	lhu	a5,76(sp)
80008376:	02f687b3          	mul	a5,a3,a5
8000837a:	97ba                	add	a5,a5,a4
8000837c:	1501d703          	lhu	a4,336(gp) # 12094c8 <u16EscAddrSendMbx>
80008380:	00f75d63          	bge	a4,a5,8000839a <.L67>
80008384:	16a1d783          	lhu	a5,362(gp) # 12094e2 <nEscAddrInputData>
80008388:	873e                	mv	a4,a5
8000838a:	1501d783          	lhu	a5,336(gp) # 12094c8 <u16EscAddrSendMbx>
8000838e:	86be                	mv	a3,a5
80008390:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80008394:	97b6                	add	a5,a5,a3
80008396:	02f74c63          	blt	a4,a5,800083ce <.L68>

8000839a <.L67>:
       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
8000839a:	16a1d783          	lhu	a5,362(gp) # 12094e2 <nEscAddrInputData>
8000839e:	873e                	mv	a4,a5
800083a0:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
800083a4:	86be                	mv	a3,a5
800083a6:	04c15783          	lhu	a5,76(sp)
800083aa:	02f687b3          	mul	a5,a3,a5
800083ae:	97ba                	add	a5,a5,a4
800083b0:	1521d703          	lhu	a4,338(gp) # 12094ca <u16EscAddrReceiveMbx>
800083b4:	02f75063          	bge	a4,a5,800083d4 <.L69>
800083b8:	16a1d783          	lhu	a5,362(gp) # 12094e2 <nEscAddrInputData>
800083bc:	873e                	mv	a4,a5
800083be:	1521d783          	lhu	a5,338(gp) # 12094ca <u16EscAddrReceiveMbx>
800083c2:	86be                	mv	a3,a5
800083c4:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
800083c8:	97b6                	add	a5,a5,a3
800083ca:	00f75563          	bge	a4,a5,800083d4 <.L69>

800083ce <.L68>:
        )
    {
        return ALSTATUSCODE_INVALIDSMINCFG;
800083ce:	47f9                	li	a5,30
800083d0:	1770006f          	j	80008d46 <.L70>

800083d4 <.L69>:
    }

    if (
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
800083d4:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
800083d8:	873e                	mv	a4,a5
800083da:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
800083de:	86be                	mv	a3,a5
800083e0:	04a15783          	lhu	a5,74(sp)
800083e4:	02f687b3          	mul	a5,a3,a5
800083e8:	97ba                	add	a5,a5,a4
800083ea:	1501d703          	lhu	a4,336(gp) # 12094c8 <u16EscAddrSendMbx>
    if (
800083ee:	00f75d63          	bge	a4,a5,80008408 <.L71>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
800083f2:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
800083f6:	873e                	mv	a4,a5
800083f8:	1501d783          	lhu	a5,336(gp) # 12094c8 <u16EscAddrSendMbx>
800083fc:	86be                	mv	a3,a5
800083fe:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80008402:	97b6                	add	a5,a5,a3
80008404:	06f74663          	blt	a4,a5,80008470 <.L72>

80008408 <.L71>:
        ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
80008408:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
8000840c:	873e                	mv	a4,a5
8000840e:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80008412:	86be                	mv	a3,a5
80008414:	04a15783          	lhu	a5,74(sp)
80008418:	02f687b3          	mul	a5,a3,a5
8000841c:	97ba                	add	a5,a5,a4
8000841e:	1521d703          	lhu	a4,338(gp) # 12094ca <u16EscAddrReceiveMbx>
80008422:	00f75d63          	bge	a4,a5,8000843c <.L73>
80008426:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
8000842a:	873e                	mv	a4,a5
8000842c:	1521d783          	lhu	a5,338(gp) # 12094ca <u16EscAddrReceiveMbx>
80008430:	86be                	mv	a3,a5
80008432:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
80008436:	97b6                	add	a5,a5,a3
80008438:	02f74c63          	blt	a4,a5,80008470 <.L72>

8000843c <.L73>:
        ||
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
8000843c:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
80008440:	873e                	mv	a4,a5
80008442:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80008446:	86be                	mv	a3,a5
80008448:	04a15783          	lhu	a5,74(sp)
8000844c:	02f687b3          	mul	a5,a3,a5
80008450:	97ba                	add	a5,a5,a4
80008452:	16a1d703          	lhu	a4,362(gp) # 12094e2 <nEscAddrInputData>
        ||
80008456:	02f75063          	bge	a4,a5,80008476 <.L74>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
8000845a:	1681d783          	lhu	a5,360(gp) # 12094e0 <nEscAddrOutputData>
8000845e:	873e                	mv	a4,a5
80008460:	16a1d783          	lhu	a5,362(gp) # 12094e2 <nEscAddrInputData>
80008464:	86be                	mv	a3,a5
80008466:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
8000846a:	97b6                	add	a5,a5,a3
8000846c:	00f75563          	bge	a4,a5,80008476 <.L74>

80008470 <.L72>:
        )
    {

        /* Sync Manager Channel 2 memory area (Outputs) overlaps the Sync Manager memory areas for the Mailbox
           or the Sync Manager Channel 3 memory area (Inputs) */
        return ALSTATUSCODE_INVALIDSMOUTCFG;
80008470:	47f5                	li	a5,29
80008472:	0d50006f          	j	80008d46 <.L70>

80008476 <.L74>:
        --- Check configured synchronization ---
    */

    /* Get the DC Control/Activation register value*/
     /*Read registers 0x980:0x983 (corresponding masks are adapted)*/
    HW_EscReadDWord(dcControl, ESC_DC_UNIT_CONTROL_OFFSET);
80008476:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000847a:	6785                	lui	a5,0x1
8000847c:	98078793          	add	a5,a5,-1664 # 980 <.L24>
80008480:	97ba                	add	a5,a5,a4
80008482:	439c                	lw	a5,0(a5)
80008484:	d63e                	sw	a5,44(sp)
    dcControl = SWAPDWORD(dcControl);
    dcControl &=ESC_DC_SYNC_ACTIVATION_MASK;
80008486:	5732                	lw	a4,44(sp)
80008488:	67c1                	lui	a5,0x10
8000848a:	17fd                	add	a5,a5,-1 # ffff <__AXI_SRAM_segment_used_size__+0x6aa3>
8000848c:	8ff9                	and	a5,a5,a4
8000848e:	d63e                	sw	a5,44(sp)

    // Cycle time for Sync0
        HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
80008490:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80008494:	6785                	lui	a5,0x1
80008496:	9a078793          	add	a5,a5,-1632 # 9a0 <.L23+0x6>
8000849a:	97ba                	add	a5,a5,a4
8000849c:	439c                	lw	a5,0(a5)
8000849e:	de3e                	sw	a5,60(sp)
        cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);

    // Cycle time for Sync1
        HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
800084a0:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
800084a4:	6785                	lui	a5,0x1
800084a6:	9a478793          	add	a5,a5,-1628 # 9a4 <e2p_write_private+0x2>
800084aa:	97ba                	add	a5,a5,a4
800084ac:	439c                	lw	a5,0(a5)
800084ae:	dc3e                	sw	a5,56(sp)
        shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);


    SyncType0x1C32 = sSyncManOutPar.u16SyncType;
800084b0:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800084b4:	0027c703          	lbu	a4,2(a5)
800084b8:	0037c783          	lbu	a5,3(a5)
800084bc:	07a2                	sll	a5,a5,0x8
800084be:	8fd9                	or	a5,a5,a4
800084c0:	04f11423          	sh	a5,72(sp)
    SyncType0x1C33 = sSyncManInPar.u16SyncType;
800084c4:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
800084c8:	0027c703          	lbu	a4,2(a5)
800084cc:	0037c783          	lbu	a5,3(a5)
800084d0:	07a2                	sll	a5,a5,0x8
800084d2:	8fd9                	or	a5,a5,a4
800084d4:	04f11323          	sh	a5,70(sp)
    /* check general DC register plausibility and if configuration is supported
       - 0x981 DC Active
       - 0x9A0:0x9A3 Sync0 Cycle
       - 0x9A4:0x9A7 Sync1 Cycle
    */
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
800084d8:	5732                	lw	a4,44(sp)
800084da:	6785                	lui	a5,0x1
800084dc:	90078793          	add	a5,a5,-1792 # 900 <e2p_config_info+0x5e>
800084e0:	8ff9                	and	a5,a5,a4
800084e2:	cfe1                	beqz	a5,800085ba <.L75>
    {
        /* DC unit is active at least one Sync signal shall be generated */
        if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
800084e4:	57b2                	lw	a5,44(sp)
800084e6:	6007f793          	and	a5,a5,1536
800084ea:	e789                	bnez	a5,800084f4 <.L76>
        {
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
800084ec:	03000793          	li	a5,48
800084f0:	0570006f          	j	80008d46 <.L70>

800084f4 <.L76>:
        }

        /* If Sync1 shall only be active if also Sync0 will be generated*/
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
800084f4:	57b2                	lw	a5,44(sp)
800084f6:	2007f793          	and	a5,a5,512
800084fa:	eb89                	bnez	a5,8000850c <.L77>
            && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
800084fc:	57b2                	lw	a5,44(sp)
800084fe:	4007f793          	and	a5,a5,1024
80008502:	c789                	beqz	a5,8000850c <.L77>
        {
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
80008504:	03000793          	li	a5,48
80008508:	03f0006f          	j	80008d46 <.L70>

8000850c <.L77>:
        }

        if(u16MinSuppSyncType != 0)
8000850c:	03615783          	lhu	a5,54(sp)
80008510:	c78d                	beqz	a5,8000853a <.L78>
        {
            if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
80008512:	03615783          	lhu	a5,54(sp)
80008516:	8b91                	and	a5,a5,4
80008518:	e789                	bnez	a5,80008522 <.L79>
8000851a:	57b2                	lw	a5,44(sp)
8000851c:	2007f793          	and	a5,a5,512
80008520:	eb89                	bnez	a5,80008532 <.L80>

80008522 <.L79>:
                ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
80008522:	03615783          	lhu	a5,54(sp)
80008526:	8ba1                	and	a5,a5,8
80008528:	eb89                	bnez	a5,8000853a <.L78>
8000852a:	57b2                	lw	a5,44(sp)
8000852c:	4007f793          	and	a5,a5,1024
80008530:	c789                	beqz	a5,8000853a <.L78>

80008532 <.L80>:
            {
                /* Sync0 is not supported but will be generated*/
                return ALSTATUSCODE_DCINVALIDSYNCCFG;                   
80008532:	03000793          	li	a5,48
80008536:	0110006f          	j	80008d46 <.L70>

8000853a <.L78>:
    }
        }

        {
            UINT32 curMinCycleTime = MIN_PD_CYCLE_TIME;
8000853a:	67a1                	lui	a5,0x8
8000853c:	9e078793          	add	a5,a5,-1568 # 79e0 <__HEAPSIZE__+0x39e0>
80008540:	d43e                	sw	a5,40(sp)
            curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
80008542:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80008546:	00e7c703          	lbu	a4,14(a5)
8000854a:	00f7c683          	lbu	a3,15(a5)
8000854e:	06a2                	sll	a3,a3,0x8
80008550:	8f55                	or	a4,a4,a3
80008552:	0107c683          	lbu	a3,16(a5)
80008556:	06c2                	sll	a3,a3,0x10
80008558:	8f55                	or	a4,a4,a3
8000855a:	0117c783          	lbu	a5,17(a5)
8000855e:	07e2                	sll	a5,a5,0x18
80008560:	8fd9                	or	a5,a5,a4
80008562:	d43e                	sw	a5,40(sp)

            /*Check if Sync0 cycle time is supported*/
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
80008564:	57f2                	lw	a5,60(sp)
80008566:	cf91                	beqz	a5,80008582 <.L81>
80008568:	5772                	lw	a4,60(sp)
8000856a:	57a2                	lw	a5,40(sp)
8000856c:	00f76763          	bltu	a4,a5,8000857a <.L82>
80008570:	5772                	lw	a4,60(sp)
80008572:	c35007b7          	lui	a5,0xc3500
80008576:	00e7f663          	bgeu	a5,a4,80008582 <.L81>

8000857a <.L82>:
            {
                    return ALSTATUSCODE_DCSYNC0CYCLETIME;
8000857a:	03600793          	li	a5,54
8000857e:	7c80006f          	j	80008d46 <.L70>

80008582 <.L81>:
            }
        }


        /* Check if Subordinated cycles are configured */
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
80008582:	57b2                	lw	a5,44(sp)
80008584:	2007f793          	and	a5,a5,512
80008588:	cf91                	beqz	a5,800085a4 <.L83>
8000858a:	57b2                	lw	a5,44(sp)
8000858c:	4007f793          	and	a5,a5,1024
80008590:	cb91                	beqz	a5,800085a4 <.L83>
        {
            /* For Subordinated cycles both Sync signals shall be active and Sync0 is not configured in single shot (cycle time == 0)*/
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
80008592:	57e2                	lw	a5,56(sp)
80008594:	cb81                	beqz	a5,800085a4 <.L83>
80008596:	5762                	lw	a4,56(sp)
80008598:	57f2                	lw	a5,60(sp)
8000859a:	00f76563          	bltu	a4,a5,800085a4 <.L83>
            {
                bSubordinatedCycles = TRUE;
8000859e:	4785                	li	a5,1
800085a0:	04f107a3          	sb	a5,79(sp)

800085a4 <.L83>:
            }
        }

        /* Dump an error if subordinated cycles are configured but not supported */
        if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
800085a4:	04f14783          	lbu	a5,79(sp)
800085a8:	cb89                	beqz	a5,800085ba <.L75>
800085aa:	03615783          	lhu	a5,54(sp)
800085ae:	8bc1                	and	a5,a5,16
800085b0:	e789                	bnez	a5,800085ba <.L75>
        {
             return ALSTATUSCODE_DCINVALIDSYNCCFG;
800085b2:	03000793          	li	a5,48
800085b6:	7900006f          	j	80008d46 <.L70>

800085ba <.L75>:


    /*
        Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
    */
    if(bSyncSetByUser)
800085ba:	18d1c783          	lbu	a5,397(gp) # 1209505 <bSyncSetByUser>
800085be:	c3d9                	beqz	a5,80008644 <.L84>
    {
        if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
800085c0:	5732                	lw	a4,44(sp)
800085c2:	6785                	lui	a5,0x1
800085c4:	90078793          	add	a5,a5,-1792 # 900 <e2p_config_info+0x5e>
800085c8:	8ff9                	and	a5,a5,a4
800085ca:	eb8d                	bnez	a5,800085fc <.L85>
        {
            /* DC out unit not enabled => no DC mode shall be set */
            if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
800085cc:	04815703          	lhu	a4,72(sp)
800085d0:	4789                	li	a5,2
800085d2:	02f70163          	beq	a4,a5,800085f4 <.L86>
800085d6:	04815703          	lhu	a4,72(sp)
800085da:	478d                	li	a5,3
800085dc:	00f70c63          	beq	a4,a5,800085f4 <.L86>
                ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
800085e0:	04615703          	lhu	a4,70(sp)
800085e4:	4789                	li	a5,2
800085e6:	00f70763          	beq	a4,a5,800085f4 <.L86>
800085ea:	04615703          	lhu	a4,70(sp)
800085ee:	478d                	li	a5,3
800085f0:	0ef71063          	bne	a4,a5,800086d0 <.L87>

800085f4 <.L86>:
            {
                return ALSTATUSCODE_DCINVALIDSYNCCFG;
800085f4:	03000793          	li	a5,48
800085f8:	74e0006f          	j	80008d46 <.L70>

800085fc <.L85>:
            }
        } //if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
    else
    {
            if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
800085fc:	57b2                	lw	a5,44(sp)
800085fe:	4007f793          	and	a5,a5,1024
80008602:	ef99                	bnez	a5,80008620 <.L88>
            {
                /* No Sync 1 is generated => No Sync1 Sync Type shall configured*/
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
80008604:	04815703          	lhu	a4,72(sp)
80008608:	478d                	li	a5,3
8000860a:	00f70763          	beq	a4,a5,80008618 <.L89>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
8000860e:	04615703          	lhu	a4,70(sp)
80008612:	478d                	li	a5,3
80008614:	00f71663          	bne	a4,a5,80008620 <.L88>

80008618 <.L89>:
                {
                    return ALSTATUSCODE_DCINVALIDSYNCCFG;
80008618:	03000793          	li	a5,48
8000861c:	72a0006f          	j	80008d46 <.L70>

80008620 <.L88>:
                }
            } //if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)

            if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
80008620:	57b2                	lw	a5,44(sp)
80008622:	2007f793          	and	a5,a5,512
80008626:	e7cd                	bnez	a5,800086d0 <.L87>
            {
                /* No Sync 0 is generated => No Sync0 Sync Type shall configured*/
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC0)
80008628:	04815703          	lhu	a4,72(sp)
8000862c:	4789                	li	a5,2
8000862e:	00f70763          	beq	a4,a5,8000863c <.L90>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC0))
80008632:	04615703          	lhu	a4,70(sp)
80008636:	4789                	li	a5,2
80008638:	08f71c63          	bne	a4,a5,800086d0 <.L87>

8000863c <.L90>:
                {
                    return ALSTATUSCODE_DCINVALIDSYNCCFG;
8000863c:	03000793          	li	a5,48
80008640:	7060006f          	j	80008d46 <.L70>

80008644 <.L84>:
        }
    } //if(bSyncSetByUser)
    else
    {
        /* No Sync Type selected by user => Configure Sync Type based on DC register values*/
        if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
80008644:	5732                	lw	a4,44(sp)
80008646:	6785                	lui	a5,0x1
80008648:	90078793          	add	a5,a5,-1792 # 900 <e2p_config_info+0x5e>
8000864c:	8ff9                	and	a5,a5,a4
8000864e:	e3a1                	bnez	a5,8000868e <.L91>
        {
            /* Activation or auto activation of the Sync Out Unit is disabled => Free Run or SM Sync is configured*/

            /* AL Event enabled => Configure SM Sync*/
            if (nPdOutputSize > 0)
80008650:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80008654:	cf99                	beqz	a5,80008672 <.L92>
            {
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
80008656:	4785                	li	a5,1
80008658:	04f11423          	sh	a5,72(sp)
                
                if (nPdInputSize > 0)
8000865c:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80008660:	c791                	beqz	a5,8000866c <.L93>
                {
                    SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
80008662:	02200793          	li	a5,34
80008666:	04f11323          	sh	a5,70(sp)
8000866a:	a09d                	j	800086d0 <.L87>

8000866c <.L93>:
                }
                else
                {
                    SyncType0x1C33 = SYNCTYPE_FREERUN;
8000866c:	04011323          	sh	zero,70(sp)
80008670:	a085                	j	800086d0 <.L87>

80008672 <.L92>:
                }
            }
            else if (nPdInputSize > 0)
80008672:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80008676:	c799                	beqz	a5,80008684 <.L94>
            {
                SyncType0x1C32 = SYNCTYPE_FREERUN;
80008678:	04011423          	sh	zero,72(sp)
                SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
8000867c:	4785                	li	a5,1
8000867e:	04f11323          	sh	a5,70(sp)
80008682:	a0b9                	j	800086d0 <.L87>

80008684 <.L94>:
            }
            else
            {
                SyncType0x1C32 = SYNCTYPE_FREERUN;
80008684:	04011423          	sh	zero,72(sp)
                SyncType0x1C33 = SYNCTYPE_FREERUN;
80008688:	04011323          	sh	zero,70(sp)
8000868c:	a091                	j	800086d0 <.L87>

8000868e <.L91>:
            }

        }
        else
        {
            if (nPdOutputSize > 0)
8000868e:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80008692:	cf81                	beqz	a5,800086aa <.L95>
            {
                /* Sync Signal generation is active*/
                if (bSubordinatedCycles)
80008694:	04f14783          	lbu	a5,79(sp)
80008698:	c789                	beqz	a5,800086a2 <.L96>
                {
                    SyncType0x1C32 = SYNCTYPE_DCSYNC1;
8000869a:	478d                	li	a5,3
8000869c:	04f11423          	sh	a5,72(sp)
800086a0:	a039                	j	800086ae <.L97>

800086a2 <.L96>:
                }
                else
                {
                    SyncType0x1C32 = SYNCTYPE_DCSYNC0;
800086a2:	4789                	li	a5,2
800086a4:	04f11423          	sh	a5,72(sp)
800086a8:	a019                	j	800086ae <.L97>

800086aa <.L95>:
                }
            }
            else
            {
                SyncType0x1C32 = SYNCTYPE_FREERUN;
800086aa:	04011423          	sh	zero,72(sp)

800086ae <.L97>:
            }


            if (nPdInputSize > 0)
800086ae:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
800086b2:	cf89                	beqz	a5,800086cc <.L98>
            {
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
800086b4:	57b2                	lw	a5,44(sp)
800086b6:	4007f793          	and	a5,a5,1024
800086ba:	c789                	beqz	a5,800086c4 <.L99>
                {
                    /* If Sync1 is available the inputs will always be mapped with Sync1 */
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
800086bc:	478d                	li	a5,3
800086be:	04f11323          	sh	a5,70(sp)
800086c2:	a039                	j	800086d0 <.L87>

800086c4 <.L99>:
                }
                else
                {
                    /* Map Inputs based on Sync0*/
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
800086c4:	4789                	li	a5,2
800086c6:	04f11323          	sh	a5,70(sp)
800086ca:	a019                	j	800086d0 <.L87>

800086cc <.L98>:
                }
            }
            else
            {
                SyncType0x1C33 = SYNCTYPE_FREERUN;
800086cc:	04011323          	sh	zero,70(sp)

800086d0 <.L87>:
            }
        }
    }

    /* Update Cycle time entries if DC Sync Mode enabled */
    if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
800086d0:	04815703          	lhu	a4,72(sp)
800086d4:	478d                	li	a5,3
800086d6:	12f71f63          	bne	a4,a5,80008814 <.L100>
    {
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
800086da:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800086de:	5772                	lw	a4,60(sp)
800086e0:	0ff77713          	zext.b	a4,a4
800086e4:	0207c683          	lbu	a3,32(a5)
800086e8:	8a81                	and	a3,a3,0
800086ea:	8f55                	or	a4,a4,a3
800086ec:	02e78023          	sb	a4,32(a5)
800086f0:	5772                	lw	a4,60(sp)
800086f2:	8321                	srl	a4,a4,0x8
800086f4:	0ff77713          	zext.b	a4,a4
800086f8:	0217c683          	lbu	a3,33(a5)
800086fc:	8a81                	and	a3,a3,0
800086fe:	8f55                	or	a4,a4,a3
80008700:	02e780a3          	sb	a4,33(a5)
80008704:	5772                	lw	a4,60(sp)
80008706:	8341                	srl	a4,a4,0x10
80008708:	0ff77713          	zext.b	a4,a4
8000870c:	0227c683          	lbu	a3,34(a5)
80008710:	8a81                	and	a3,a3,0
80008712:	8f55                	or	a4,a4,a3
80008714:	02e78123          	sb	a4,34(a5)
80008718:	5772                	lw	a4,60(sp)
8000871a:	8361                	srl	a4,a4,0x18
8000871c:	0237c683          	lbu	a3,35(a5)
80008720:	8a81                	and	a3,a3,0
80008722:	8f55                	or	a4,a4,a3
80008724:	02e781a3          	sb	a4,35(a5)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
80008728:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000872c:	5772                	lw	a4,60(sp)
8000872e:	0ff77713          	zext.b	a4,a4
80008732:	0047c683          	lbu	a3,4(a5)
80008736:	8a81                	and	a3,a3,0
80008738:	8f55                	or	a4,a4,a3
8000873a:	00e78223          	sb	a4,4(a5)
8000873e:	5772                	lw	a4,60(sp)
80008740:	8321                	srl	a4,a4,0x8
80008742:	0ff77713          	zext.b	a4,a4
80008746:	0057c683          	lbu	a3,5(a5)
8000874a:	8a81                	and	a3,a3,0
8000874c:	8f55                	or	a4,a4,a3
8000874e:	00e782a3          	sb	a4,5(a5)
80008752:	5772                	lw	a4,60(sp)
80008754:	8341                	srl	a4,a4,0x10
80008756:	0ff77713          	zext.b	a4,a4
8000875a:	0067c683          	lbu	a3,6(a5)
8000875e:	8a81                	and	a3,a3,0
80008760:	8f55                	or	a4,a4,a3
80008762:	00e78323          	sb	a4,6(a5)
80008766:	5772                	lw	a4,60(sp)
80008768:	8361                	srl	a4,a4,0x18
8000876a:	0077c683          	lbu	a3,7(a5)
8000876e:	8a81                	and	a3,a3,0
80008770:	8f55                	or	a4,a4,a3
80008772:	00e783a3          	sb	a4,7(a5)

        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
80008776:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000877a:	5772                	lw	a4,60(sp)
8000877c:	0ff77713          	zext.b	a4,a4
80008780:	0207c683          	lbu	a3,32(a5)
80008784:	8a81                	and	a3,a3,0
80008786:	8f55                	or	a4,a4,a3
80008788:	02e78023          	sb	a4,32(a5)
8000878c:	5772                	lw	a4,60(sp)
8000878e:	8321                	srl	a4,a4,0x8
80008790:	0ff77713          	zext.b	a4,a4
80008794:	0217c683          	lbu	a3,33(a5)
80008798:	8a81                	and	a3,a3,0
8000879a:	8f55                	or	a4,a4,a3
8000879c:	02e780a3          	sb	a4,33(a5)
800087a0:	5772                	lw	a4,60(sp)
800087a2:	8341                	srl	a4,a4,0x10
800087a4:	0ff77713          	zext.b	a4,a4
800087a8:	0227c683          	lbu	a3,34(a5)
800087ac:	8a81                	and	a3,a3,0
800087ae:	8f55                	or	a4,a4,a3
800087b0:	02e78123          	sb	a4,34(a5)
800087b4:	5772                	lw	a4,60(sp)
800087b6:	8361                	srl	a4,a4,0x18
800087b8:	0237c683          	lbu	a3,35(a5)
800087bc:	8a81                	and	a3,a3,0
800087be:	8f55                	or	a4,a4,a3
800087c0:	02e781a3          	sb	a4,35(a5)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
800087c4:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
800087c8:	5772                	lw	a4,60(sp)
800087ca:	0ff77713          	zext.b	a4,a4
800087ce:	0047c683          	lbu	a3,4(a5)
800087d2:	8a81                	and	a3,a3,0
800087d4:	8f55                	or	a4,a4,a3
800087d6:	00e78223          	sb	a4,4(a5)
800087da:	5772                	lw	a4,60(sp)
800087dc:	8321                	srl	a4,a4,0x8
800087de:	0ff77713          	zext.b	a4,a4
800087e2:	0057c683          	lbu	a3,5(a5)
800087e6:	8a81                	and	a3,a3,0
800087e8:	8f55                	or	a4,a4,a3
800087ea:	00e782a3          	sb	a4,5(a5)
800087ee:	5772                	lw	a4,60(sp)
800087f0:	8341                	srl	a4,a4,0x10
800087f2:	0ff77713          	zext.b	a4,a4
800087f6:	0067c683          	lbu	a3,6(a5)
800087fa:	8a81                	and	a3,a3,0
800087fc:	8f55                	or	a4,a4,a3
800087fe:	00e78323          	sb	a4,6(a5)
80008802:	5772                	lw	a4,60(sp)
80008804:	8361                	srl	a4,a4,0x18
80008806:	0077c683          	lbu	a3,7(a5)
8000880a:	8a81                	and	a3,a3,0
8000880c:	8f55                	or	a4,a4,a3
8000880e:	00e783a3          	sb	a4,7(a5)
80008812:	a291                	j	80008956 <.L101>

80008814 <.L100>:
    }
    else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
80008814:	04815703          	lhu	a4,72(sp)
80008818:	4789                	li	a5,2
8000881a:	12f71e63          	bne	a4,a5,80008956 <.L101>
    {
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
8000881e:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80008822:	5772                	lw	a4,60(sp)
80008824:	0ff77713          	zext.b	a4,a4
80008828:	0207c683          	lbu	a3,32(a5)
8000882c:	8a81                	and	a3,a3,0
8000882e:	8f55                	or	a4,a4,a3
80008830:	02e78023          	sb	a4,32(a5)
80008834:	5772                	lw	a4,60(sp)
80008836:	8321                	srl	a4,a4,0x8
80008838:	0ff77713          	zext.b	a4,a4
8000883c:	0217c683          	lbu	a3,33(a5)
80008840:	8a81                	and	a3,a3,0
80008842:	8f55                	or	a4,a4,a3
80008844:	02e780a3          	sb	a4,33(a5)
80008848:	5772                	lw	a4,60(sp)
8000884a:	8341                	srl	a4,a4,0x10
8000884c:	0ff77713          	zext.b	a4,a4
80008850:	0227c683          	lbu	a3,34(a5)
80008854:	8a81                	and	a3,a3,0
80008856:	8f55                	or	a4,a4,a3
80008858:	02e78123          	sb	a4,34(a5)
8000885c:	5772                	lw	a4,60(sp)
8000885e:	8361                	srl	a4,a4,0x18
80008860:	0237c683          	lbu	a3,35(a5)
80008864:	8a81                	and	a3,a3,0
80008866:	8f55                	or	a4,a4,a3
80008868:	02e781a3          	sb	a4,35(a5)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
8000886c:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80008870:	5772                	lw	a4,60(sp)
80008872:	0ff77713          	zext.b	a4,a4
80008876:	0047c683          	lbu	a3,4(a5)
8000887a:	8a81                	and	a3,a3,0
8000887c:	8f55                	or	a4,a4,a3
8000887e:	00e78223          	sb	a4,4(a5)
80008882:	5772                	lw	a4,60(sp)
80008884:	8321                	srl	a4,a4,0x8
80008886:	0ff77713          	zext.b	a4,a4
8000888a:	0057c683          	lbu	a3,5(a5)
8000888e:	8a81                	and	a3,a3,0
80008890:	8f55                	or	a4,a4,a3
80008892:	00e782a3          	sb	a4,5(a5)
80008896:	5772                	lw	a4,60(sp)
80008898:	8341                	srl	a4,a4,0x10
8000889a:	0ff77713          	zext.b	a4,a4
8000889e:	0067c683          	lbu	a3,6(a5)
800088a2:	8a81                	and	a3,a3,0
800088a4:	8f55                	or	a4,a4,a3
800088a6:	00e78323          	sb	a4,6(a5)
800088aa:	5772                	lw	a4,60(sp)
800088ac:	8361                	srl	a4,a4,0x18
800088ae:	0077c683          	lbu	a3,7(a5)
800088b2:	8a81                	and	a3,a3,0
800088b4:	8f55                	or	a4,a4,a3
800088b6:	00e783a3          	sb	a4,7(a5)

        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
800088ba:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
800088be:	5772                	lw	a4,60(sp)
800088c0:	0ff77713          	zext.b	a4,a4
800088c4:	0207c683          	lbu	a3,32(a5)
800088c8:	8a81                	and	a3,a3,0
800088ca:	8f55                	or	a4,a4,a3
800088cc:	02e78023          	sb	a4,32(a5)
800088d0:	5772                	lw	a4,60(sp)
800088d2:	8321                	srl	a4,a4,0x8
800088d4:	0ff77713          	zext.b	a4,a4
800088d8:	0217c683          	lbu	a3,33(a5)
800088dc:	8a81                	and	a3,a3,0
800088de:	8f55                	or	a4,a4,a3
800088e0:	02e780a3          	sb	a4,33(a5)
800088e4:	5772                	lw	a4,60(sp)
800088e6:	8341                	srl	a4,a4,0x10
800088e8:	0ff77713          	zext.b	a4,a4
800088ec:	0227c683          	lbu	a3,34(a5)
800088f0:	8a81                	and	a3,a3,0
800088f2:	8f55                	or	a4,a4,a3
800088f4:	02e78123          	sb	a4,34(a5)
800088f8:	5772                	lw	a4,60(sp)
800088fa:	8361                	srl	a4,a4,0x18
800088fc:	0237c683          	lbu	a3,35(a5)
80008900:	8a81                	and	a3,a3,0
80008902:	8f55                	or	a4,a4,a3
80008904:	02e781a3          	sb	a4,35(a5)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
80008908:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000890c:	5772                	lw	a4,60(sp)
8000890e:	0ff77713          	zext.b	a4,a4
80008912:	0047c683          	lbu	a3,4(a5)
80008916:	8a81                	and	a3,a3,0
80008918:	8f55                	or	a4,a4,a3
8000891a:	00e78223          	sb	a4,4(a5)
8000891e:	5772                	lw	a4,60(sp)
80008920:	8321                	srl	a4,a4,0x8
80008922:	0ff77713          	zext.b	a4,a4
80008926:	0057c683          	lbu	a3,5(a5)
8000892a:	8a81                	and	a3,a3,0
8000892c:	8f55                	or	a4,a4,a3
8000892e:	00e782a3          	sb	a4,5(a5)
80008932:	5772                	lw	a4,60(sp)
80008934:	8341                	srl	a4,a4,0x10
80008936:	0ff77713          	zext.b	a4,a4
8000893a:	0067c683          	lbu	a3,6(a5)
8000893e:	8a81                	and	a3,a3,0
80008940:	8f55                	or	a4,a4,a3
80008942:	00e78323          	sb	a4,6(a5)
80008946:	5772                	lw	a4,60(sp)
80008948:	8361                	srl	a4,a4,0x18
8000894a:	0077c683          	lbu	a3,7(a5)
8000894e:	8a81                	and	a3,a3,0
80008950:	8f55                	or	a4,a4,a3
80008952:	00e783a3          	sb	a4,7(a5)

80008956 <.L101>:
    }

    /* Set global flags based on Sync Type */
    if ( !b3BufferMode )
80008956:	1a51c783          	lbu	a5,421(gp) # 120951d <b3BufferMode>
8000895a:	eb91                	bnez	a5,8000896e <.L102>
    {
        /* 1-Buffer-Mode configured => For free run it shall be 3Buffer mode*/
        if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
8000895c:	04815783          	lhu	a5,72(sp)
80008960:	c781                	beqz	a5,80008968 <.L103>
80008962:	04615783          	lhu	a5,70(sp)
80008966:	e781                	bnez	a5,8000896e <.L102>

80008968 <.L103>:
        {
                return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
80008968:	02900793          	li	a5,41
8000896c:	aee9                	j	80008d46 <.L70>

8000896e <.L102>:
        }
    }

    /* If no free run is supported the EscInt is always enabled*/
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
8000896e:	04815783          	lhu	a5,72(sp)
80008972:	e781                	bnez	a5,8000897a <.L104>
80008974:	04615783          	lhu	a5,70(sp)
80008978:	c781                	beqz	a5,80008980 <.L105>

8000897a <.L104>:
        {
        /* ECAT Synchron Mode, the ESC interrupt is enabled */
        bEscIntEnabled = TRUE;
8000897a:	4705                	li	a4,1
8000897c:	18e18ea3          	sb	a4,413(gp) # 1209515 <bEscIntEnabled>

80008980 <.L105>:
    }

        /* Update value for AL Event Mask register (0x204) */
        if(bEscIntEnabled)
80008980:	19d1c783          	lbu	a5,413(gp) # 1209515 <bEscIntEnabled>
80008984:	c385                	beqz	a5,800089a4 <.L106>
        {
            if(nPdOutputSize > 0)
80008986:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000898a:	c791                	beqz	a5,80008996 <.L107>
            {
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
8000898c:	40000713          	li	a4,1024
80008990:	14e19d23          	sh	a4,346(gp) # 12094d2 <u16ALEventMask>
80008994:	a801                	j	800089a4 <.L106>

80008996 <.L107>:
            }
            else if(nPdInputSize > 0)
80008996:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
8000899a:	c789                	beqz	a5,800089a4 <.L106>
            {
                u16ALEventMask = PROCESS_INPUT_EVENT;
8000899c:	28b01713          	bset	a4,zero,0xb
800089a0:	14e19d23          	sh	a4,346(gp) # 12094d2 <u16ALEventMask>

800089a4 <.L106>:
            }

        }

        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
800089a4:	04815703          	lhu	a4,72(sp)
800089a8:	4789                	li	a5,2
800089aa:	02f70163          	beq	a4,a5,800089cc <.L108>
800089ae:	04815703          	lhu	a4,72(sp)
800089b2:	478d                	li	a5,3
800089b4:	00f70c63          	beq	a4,a5,800089cc <.L108>
            || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
800089b8:	04615703          	lhu	a4,70(sp)
800089bc:	4789                	li	a5,2
800089be:	00f70763          	beq	a4,a5,800089cc <.L108>
800089c2:	04615703          	lhu	a4,70(sp)
800089c6:	478d                	li	a5,3
800089c8:	00f71a63          	bne	a4,a5,800089dc <.L109>

800089cc <.L108>:
        {
            /* slave is running in DC-mode */
            bDcSyncActive = TRUE;
800089cc:	4705                	li	a4,1
800089ce:	1ae18123          	sb	a4,418(gp) # 120951a <bDcSyncActive>

            /*In case of an Input only application with DC no PDI Isr handling is required*/
            if (nPdOutputSize == 0)
800089d2:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
800089d6:	e399                	bnez	a5,800089dc <.L109>
            {
               u16ALEventMask = 0;
800089d8:	14019d23          	sh	zero,346(gp) # 12094d2 <u16ALEventMask>

800089dc <.L109>:
            }
        }



    sSyncManOutPar.u16SyncType = SyncType0x1C32;
800089dc:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800089e0:	4726                	lw	a4,72(sp)
800089e2:	0ff77713          	zext.b	a4,a4
800089e6:	0027c683          	lbu	a3,2(a5)
800089ea:	8a81                	and	a3,a3,0
800089ec:	8f55                	or	a4,a4,a3
800089ee:	00e78123          	sb	a4,2(a5)
800089f2:	4726                	lw	a4,72(sp)
800089f4:	8321                	srl	a4,a4,0x8
800089f6:	0ff77713          	zext.b	a4,a4
800089fa:	0037c683          	lbu	a3,3(a5)
800089fe:	8a81                	and	a3,a3,0
80008a00:	8f55                	or	a4,a4,a3
80008a02:	00e781a3          	sb	a4,3(a5)
    sSyncManInPar.u16SyncType = SyncType0x1C33;
80008a06:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80008a0a:	04615703          	lhu	a4,70(sp)
80008a0e:	0ff77713          	zext.b	a4,a4
80008a12:	0027c683          	lbu	a3,2(a5)
80008a16:	8a81                	and	a3,a3,0
80008a18:	8f55                	or	a4,a4,a3
80008a1a:	00e78123          	sb	a4,2(a5)
80008a1e:	04615703          	lhu	a4,70(sp)
80008a22:	8321                	srl	a4,a4,0x8
80008a24:	08074733          	zext.h	a4,a4
80008a28:	0037c683          	lbu	a3,3(a5)
80008a2c:	8a81                	and	a3,a3,0
80008a2e:	8f55                	or	a4,a4,a3
80008a30:	00e781a3          	sb	a4,3(a5)

    /* Calculate number of Sync0 events within one SM cycle and the Sync0 events on which the inputs has to be latched*/
    LatchInputSync0Value = 0;
80008a34:	16019d23          	sh	zero,378(gp) # 12094f2 <LatchInputSync0Value>
    LatchInputSync0Counter = 0;
80008a38:	16019e23          	sh	zero,380(gp) # 12094f4 <LatchInputSync0Counter>
    u16SmSync0Value = 0;
80008a3c:	34021b23          	sh	zero,854(tp) # 356 <default_isr_62+0x60>
    u16SmSync0Counter = 0;
80008a40:	fa019f23          	sh	zero,-66(gp) # 1209336 <u16SmSync0Counter>


    if(bSubordinatedCycles == TRUE)
80008a44:	04f14703          	lbu	a4,79(sp)
80008a48:	4785                	li	a5,1
80008a4a:	06f71763          	bne	a4,a5,80008ab8 <.L110>

80008a4e <.LBB3>:
    {
        
        UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
80008a4e:	5762                	lw	a4,56(sp)
80008a50:	57f2                	lw	a5,60(sp)
80008a52:	97ba                	add	a5,a5,a4
80008a54:	d23e                	sw	a5,36(sp)


        /* get the number of Sync0 event within on SM cycle */
        if(shiftTimeSync1 >= cycleTimeSync0)
80008a56:	5762                	lw	a4,56(sp)
80008a58:	57f2                	lw	a5,60(sp)
80008a5a:	02f76763          	bltu	a4,a5,80008a88 <.L111>
        {

            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
80008a5e:	5712                	lw	a4,36(sp)
80008a60:	57f2                	lw	a5,60(sp)
80008a62:	02f757b3          	divu	a5,a4,a5
80008a66:	0807c733          	zext.h	a4,a5
80008a6a:	34e21b23          	sh	a4,854(tp) # 356 <default_isr_62+0x60>
            
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
80008a6e:	5712                	lw	a4,36(sp)
80008a70:	57f2                	lw	a5,60(sp)
80008a72:	02f777b3          	remu	a5,a4,a5
80008a76:	ef81                	bnez	a5,80008a8e <.L112>
            {
                /* if the Sync1cycletime/Sync0cycletime ratio is even one additional tick */
                u16SmSync0Value ++;
80008a78:	35625783          	lhu	a5,854(tp) # 356 <default_isr_62+0x60>
80008a7c:	0785                	add	a5,a5,1
80008a7e:	0807c733          	zext.h	a4,a5
80008a82:	34e21b23          	sh	a4,854(tp) # 356 <default_isr_62+0x60>
80008a86:	a021                	j	80008a8e <.L112>

80008a88 <.L111>:
            }
        }
        else
        {
            u16SmSync0Value = 1;
80008a88:	4705                	li	a4,1
80008a8a:	34e21b23          	sh	a4,854(tp) # 356 <default_isr_62+0x60>

80008a8e <.L112>:
        }

        /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
        LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);
80008a8e:	5712                	lw	a4,36(sp)
80008a90:	57f2                	lw	a5,60(sp)
80008a92:	02f757b3          	divu	a5,a4,a5
80008a96:	0807c733          	zext.h	a4,a5
80008a9a:	16e19d23          	sh	a4,378(gp) # 12094f2 <LatchInputSync0Value>

        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
80008a9e:	5712                	lw	a4,36(sp)
80008aa0:	57f2                	lw	a5,60(sp)
80008aa2:	02f777b3          	remu	a5,a4,a5
80008aa6:	cb8d                	beqz	a5,80008ad8 <.L113>
        {
            LatchInputSync0Value++;
80008aa8:	17a1d783          	lhu	a5,378(gp) # 12094f2 <LatchInputSync0Value>
80008aac:	0785                	add	a5,a5,1
80008aae:	0807c733          	zext.h	a4,a5
80008ab2:	16e19d23          	sh	a4,378(gp) # 12094f2 <LatchInputSync0Value>
80008ab6:	a00d                	j	80008ad8 <.L113>

80008ab8 <.L110>:
        }

    }
    else 
    {
        if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
80008ab8:	04815703          	lhu	a4,72(sp)
80008abc:	4789                	li	a5,2
80008abe:	00f71563          	bne	a4,a5,80008ac8 <.L114>
        {
            /* if SyncType of 0x1C32 is 2 the Sync0 event is trigger once during a SM cycle */
            u16SmSync0Value = 1;
80008ac2:	4705                	li	a4,1
80008ac4:	34e21b23          	sh	a4,854(tp) # 356 <default_isr_62+0x60>

80008ac8 <.L114>:
        }   

        if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
80008ac8:	04615703          	lhu	a4,70(sp)
80008acc:	478d                	li	a5,3
80008ace:	00f70563          	beq	a4,a5,80008ad8 <.L113>
        {
            LatchInputSync0Value = 1;
80008ad2:	4705                	li	a4,1
80008ad4:	16e19d23          	sh	a4,378(gp) # 12094f2 <LatchInputSync0Value>

80008ad8 <.L113>:
    }



    /* reset the error counter indicating synchronization problems */
    sCycleDiag.syncFailedCounter = 0;
80008ad8:	1481c703          	lbu	a4,328(gp) # 12094c0 <sCycleDiag>
80008adc:	8b01                	and	a4,a4,0
80008ade:	14e18423          	sb	a4,328(gp) # 12094c0 <sCycleDiag>
80008ae2:	1491c703          	lbu	a4,329(gp) # 12094c1 <sCycleDiag+0x1>
80008ae6:	8b01                	and	a4,a4,0
80008ae8:	14e184a3          	sb	a4,329(gp) # 12094c1 <sCycleDiag+0x1>

80008aec <.LBB4>:
        --- Check watchdog settings ---
    */

    /*get the watchdog time (register 0x420). if value is > 0 watchdog is active*/
    {
    UINT32 tmpValue = 0;
80008aec:	d002                	sw	zero,32(sp)
    HW_EscReadDWord(tmpValue, ESC_PD_WD_TIME);
80008aee:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80008af2:	42078793          	add	a5,a5,1056
80008af6:	439c                	lw	a5,0(a5)
80008af8:	d03e                	sw	a5,32(sp)

    wd = (UINT16)(SWAPDWORD(tmpValue) & 0x0000FFFF);
80008afa:	5782                	lw	a5,32(sp)
80008afc:	04f11123          	sh	a5,66(sp)

80008b00 <.LBE4>:
    }

    if (nPdOutputSize > 0 &&  wd != 0 )
80008b00:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80008b04:	c3bd                	beqz	a5,80008b6a <.L115>
80008b06:	04215783          	lhu	a5,66(sp)
80008b0a:	c3a5                	beqz	a5,80008b6a <.L115>

80008b0c <.LBB5>:
    {
    /*get watchdog divider (register 0x400)*/
    {
    UINT32 tmpValue = 0;
80008b0c:	ce02                	sw	zero,28(sp)
    HW_EscReadDWord(tmpValue, ESC_WD_DIVIDER_OFFSET);
80008b0e:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80008b12:	40078793          	add	a5,a5,1024
80008b16:	439c                	lw	a5,0(a5)
80008b18:	ce3e                	sw	a5,28(sp)
    tmpValue = SWAPDWORD(tmpValue);

    wdiv = (UINT16)(tmpValue & 0x0000FFFF);
80008b1a:	47f2                	lw	a5,28(sp)
80008b1c:	04f11223          	sh	a5,68(sp)

80008b20 <.LBE5>:
    }
        if ( wdiv != 0 )
80008b20:	04415783          	lhu	a5,68(sp)
80008b24:	cf95                	beqz	a5,80008b60 <.L116>

80008b26 <.LBB6>:
        {
            /* the ESC subtracts 2 in register 0x400 so it has to be added here */
            UINT32 d = wdiv+2;
80008b26:	04415783          	lhu	a5,68(sp)
80008b2a:	0789                	add	a5,a5,2
80008b2c:	cc3e                	sw	a5,24(sp)


            d *= wd;
80008b2e:	04215783          	lhu	a5,66(sp)
80008b32:	4762                	lw	a4,24(sp)
80008b34:	02f707b3          	mul	a5,a4,a5
80008b38:	cc3e                	sw	a5,24(sp)
            /* store watchdog in ms in variable EcatWdValue */
            /* watchdog value has to be rounded up */
            d = (INT32)(d + 24999);
80008b3a:	4762                	lw	a4,24(sp)
80008b3c:	6799                	lui	a5,0x6
80008b3e:	1a778793          	add	a5,a5,423 # 61a7 <__HEAPSIZE__+0x21a7>
80008b42:	97ba                	add	a5,a5,a4
80008b44:	cc3e                	sw	a5,24(sp)
            d /= 25000;
80008b46:	4762                	lw	a4,24(sp)
80008b48:	6799                	lui	a5,0x6
80008b4a:	1a878793          	add	a5,a5,424 # 61a8 <__HEAPSIZE__+0x21a8>
80008b4e:	02f757b3          	divu	a5,a4,a5
80008b52:	cc3e                	sw	a5,24(sp)
            EcatWdValue = (UINT16) d;
80008b54:	47e2                	lw	a5,24(sp)
80008b56:	0807c733          	zext.h	a4,a5
80008b5a:	18e19123          	sh	a4,386(gp) # 12094fa <EcatWdValue>

80008b5e <.LBE6>:
        if ( wdiv != 0 )
80008b5e:	a811                	j	80008b72 <.L118>

80008b60 <.L116>:
        }
        else
        {
            wd = 0;
80008b60:	04011123          	sh	zero,66(sp)
            /* wd value has to be set to zero, if the wd is 0 */
            EcatWdValue = 0;
80008b64:	18019123          	sh	zero,386(gp) # 12094fa <EcatWdValue>
        if ( wdiv != 0 )
80008b68:	a029                	j	80008b72 <.L118>

80008b6a <.L115>:
        }
    }
    else
    {
        /* the watchdog is deactivated or slave has no output process data*/
        wdiv = 0;
80008b6a:	04011223          	sh	zero,68(sp)
        EcatWdValue = 0;
80008b6e:	18019123          	sh	zero,386(gp) # 12094fa <EcatWdValue>

80008b72 <.L118>:
    }

    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
80008b72:	1821d783          	lhu	a5,386(gp) # 12094fa <EcatWdValue>
80008b76:	e781                	bnez	a5,80008b7e <.L119>
80008b78:	18c1c783          	lbu	a5,396(gp) # 1209504 <bWdTrigger>
80008b7c:	e799                	bnez	a5,80008b8a <.L120>

80008b7e <.L119>:
80008b7e:	1821d783          	lhu	a5,386(gp) # 12094fa <EcatWdValue>
80008b82:	c791                	beqz	a5,80008b8e <.L121>
80008b84:	18c1c783          	lbu	a5,396(gp) # 1209504 <bWdTrigger>
80008b88:	e399                	bnez	a5,80008b8e <.L121>

80008b8a <.L120>:
    {
        /* if the WD-Trigger in the Sync Manager Channel 2 Control-Byte is set (Bit 6 of Register 0x814)
            an error has to be returned */
        return ALSTATUSCODE_INVALIDWDCFG;
80008b8a:	47fd                	li	a5,31
80008b8c:	aa6d                	j	80008d46 <.L70>

80008b8e <.L121>:
    }

    if ( bEscIntEnabled && nPdOutputSize != 0 )
80008b8e:	19d1c783          	lbu	a5,413(gp) # 1209515 <bEscIntEnabled>
80008b92:	cf81                	beqz	a5,80008baa <.L122>
80008b94:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80008b98:	cb89                	beqz	a5,80008baa <.L122>
    {
        /* ECAT synchron Mode is active, the Sync Manager Channel 2 event
           has to activated in the AL-Event mask register */
        u16ALEventMask |= PROCESS_OUTPUT_EVENT;
80008b9a:	15a1d783          	lhu	a5,346(gp) # 12094d2 <u16ALEventMask>
80008b9e:	4007e793          	or	a5,a5,1024
80008ba2:	0807c733          	zext.h	a4,a5
80008ba6:	14e19d23          	sh	a4,346(gp) # 12094d2 <u16ALEventMask>

80008baa <.L122>:
    }
/*The application ESM function is separated from this function to handle pending transitions*/

    Sync0WdValue = 0;
80008baa:	16019b23          	sh	zero,374(gp) # 12094ee <Sync0WdValue>
    Sync0WdCounter = 0;
80008bae:	16019c23          	sh	zero,376(gp) # 12094f0 <Sync0WdCounter>
    Sync1WdCounter = 0;
80008bb2:	16019a23          	sh	zero,372(gp) # 12094ec <Sync1WdCounter>
    Sync1WdValue = 0;
80008bb6:	16019923          	sh	zero,370(gp) # 12094ea <Sync1WdValue>
    bDcRunning = FALSE;
80008bba:	1a0181a3          	sb	zero,419(gp) # 120951b <bDcRunning>
    bSmSyncSequenceValid = FALSE;
80008bbe:	180187a3          	sb	zero,399(gp) # 1209507 <bSmSyncSequenceValid>
    i16WaitForPllRunningTimeout = 0;
80008bc2:	16019723          	sh	zero,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>

80008bc6 <.LBB7>:

/*ECATCHANGE_START(V5.13) ECAT1*/
    /*Get Sync mapped to AL Event indication*/
    {
        UINT32 u32TmpVar = 0;
80008bc6:	ca02                	sw	zero,20(sp)
        HW_EscReadDWord(u32TmpVar, ESC_PDI_CONFIGURATION);
80008bc8:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80008bcc:	15078793          	add	a5,a5,336
80008bd0:	439c                	lw	a5,0(a5)
80008bd2:	ca3e                	sw	a5,20(sp)
        if ((u32TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
80008bd4:	4752                	lw	a4,20(sp)
80008bd6:	28b01793          	bset	a5,zero,0xb
80008bda:	8ff9                	and	a5,a5,a4
80008bdc:	cb89                	beqz	a5,80008bee <.L123>
        {
            u16ALEventMask |= SYNC0_EVENT;
80008bde:	15a1d783          	lhu	a5,346(gp) # 12094d2 <u16ALEventMask>
80008be2:	0047e793          	or	a5,a5,4
80008be6:	0807c733          	zext.h	a4,a5
80008bea:	14e19d23          	sh	a4,346(gp) # 12094d2 <u16ALEventMask>

80008bee <.L123>:
        }

        if ((u32TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
80008bee:	4752                	lw	a4,20(sp)
80008bf0:	67a1                	lui	a5,0x8
80008bf2:	8ff9                	and	a5,a5,a4
80008bf4:	cb89                	beqz	a5,80008c06 <.L124>
        {
            u16ALEventMask |= SYNC1_EVENT;
80008bf6:	15a1d783          	lhu	a5,346(gp) # 12094d2 <u16ALEventMask>
80008bfa:	0087e793          	or	a5,a5,8
80008bfe:	0807c733          	zext.h	a4,a5
80008c02:	14e19d23          	sh	a4,346(gp) # 12094d2 <u16ALEventMask>

80008c06 <.L124>:
        }
    }
/*ECATCHANGE_END(V5.13) ECAT1*/
    sSyncManInPar.u16SmEventMissedCounter = 0;
80008c06:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80008c0a:	0247c703          	lbu	a4,36(a5) # 8024 <__AHB_SRAM_segment_size__+0x24>
80008c0e:	8b01                	and	a4,a4,0
80008c10:	02e78223          	sb	a4,36(a5)
80008c14:	0257c703          	lbu	a4,37(a5)
80008c18:	8b01                	and	a4,a4,0
80008c1a:	02e782a3          	sb	a4,37(a5)
    sSyncManInPar.u16CycleExceededCounter = 0;
80008c1e:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80008c22:	0267c703          	lbu	a4,38(a5)
80008c26:	8b01                	and	a4,a4,0
80008c28:	02e78323          	sb	a4,38(a5)
80008c2c:	0277c703          	lbu	a4,39(a5)
80008c30:	8b01                	and	a4,a4,0
80008c32:	02e783a3          	sb	a4,39(a5)
    sSyncManInPar.u8SyncError = 0;
80008c36:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80008c3a:	02078e23          	sb	zero,60(a5)


    sSyncManOutPar.u16SmEventMissedCounter = 0;
80008c3e:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80008c42:	0247c703          	lbu	a4,36(a5)
80008c46:	8b01                	and	a4,a4,0
80008c48:	02e78223          	sb	a4,36(a5)
80008c4c:	0257c703          	lbu	a4,37(a5)
80008c50:	8b01                	and	a4,a4,0
80008c52:	02e782a3          	sb	a4,37(a5)
    sSyncManOutPar.u16CycleExceededCounter = 0;
80008c56:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80008c5a:	0267c703          	lbu	a4,38(a5)
80008c5e:	8b01                	and	a4,a4,0
80008c60:	02e78323          	sb	a4,38(a5)
80008c64:	0277c703          	lbu	a4,39(a5)
80008c68:	8b01                	and	a4,a4,0
80008c6a:	02e783a3          	sb	a4,39(a5)
    sSyncManOutPar.u8SyncError = 0;
80008c6e:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
80008c72:	02078e23          	sb	zero,60(a5)

    /* calculate the Sync0/Sync1 watchdog timeouts */
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
80008c76:	57b2                	lw	a5,44(sp)
80008c78:	2007f793          	and	a5,a5,512
80008c7c:	c7d5                	beqz	a5,80008d28 <.L125>
    {
        /*calculate the Sync0 Watchdog counter value the minimum value is 1 ms
            if the sync0 cycle is greater 500us the Sync0 Wd value is 2*Sycn0 cycle */
        if(cycleTimeSync0 == 0)
80008c7e:	57f2                	lw	a5,60(sp)
80008c80:	e781                	bnez	a5,80008c88 <.L126>
        {
            Sync0WdValue = 0;
80008c82:	16019b23          	sh	zero,374(gp) # 12094ee <Sync0WdValue>
80008c86:	a82d                	j	80008cc0 <.L127>

80008c88 <.L126>:
        }
        else
        {
            UINT32 Sync0Cycle = cycleTimeSync0/100000;
80008c88:	5772                	lw	a4,60(sp)
80008c8a:	67e1                	lui	a5,0x18
80008c8c:	6a078793          	add	a5,a5,1696 # 186a0 <__FLASH_segment_used_size__+0x4a10>
80008c90:	02f757b3          	divu	a5,a4,a5
80008c94:	c83e                	sw	a5,16(sp)

            if(Sync0Cycle < 5)
80008c96:	4742                	lw	a4,16(sp)
80008c98:	4791                	li	a5,4
80008c9a:	00e7e663          	bltu	a5,a4,80008ca6 <.L128>
            {
                /*Sync0 cycle less than 500us*/
                Sync0WdValue = 1;
80008c9e:	4705                	li	a4,1
80008ca0:	16e19b23          	sh	a4,374(gp) # 12094ee <Sync0WdValue>
80008ca4:	a831                	j	80008cc0 <.L127>

80008ca6 <.L128>:
            }
            else
            {
                Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
80008ca6:	47c2                	lw	a5,16(sp)
80008ca8:	0807c7b3          	zext.h	a5,a5
80008cac:	0786                	sll	a5,a5,0x1
80008cae:	0807c733          	zext.h	a4,a5
80008cb2:	47a9                	li	a5,10
80008cb4:	02f757b3          	divu	a5,a4,a5
80008cb8:	0807c733          	zext.h	a4,a5
80008cbc:	16e19b23          	sh	a4,374(gp) # 12094ee <Sync0WdValue>

80008cc0 <.L127>:
            }
        }

        /* Calculate also the watchdog time for Sync1*/
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
80008cc0:	57b2                	lw	a5,44(sp)
80008cc2:	4007f793          	and	a5,a5,1024
80008cc6:	c3ad                	beqz	a5,80008d28 <.L125>
        {
            if(shiftTimeSync1 < cycleTimeSync0)
80008cc8:	5762                	lw	a4,56(sp)
80008cca:	57f2                	lw	a5,60(sp)
80008ccc:	00f77763          	bgeu	a4,a5,80008cda <.L129>
        {
                /* Sync 1 has the same cycle time than Sync0 (maybe with a shift (shiftTimeSync1 > 0))*/
                Sync1WdValue = Sync0WdValue;
80008cd0:	1761d703          	lhu	a4,374(gp) # 12094ee <Sync0WdValue>
80008cd4:	16e19923          	sh	a4,370(gp) # 12094ea <Sync1WdValue>
80008cd8:	a881                	j	80008d28 <.L125>

80008cda <.L129>:
        }
        else
        {
                /* Sync1 cycle is larger than Sync0 (e.g. subordinated Sync0 cycles) */
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
80008cda:	5762                	lw	a4,56(sp)
80008cdc:	57f2                	lw	a5,60(sp)
80008cde:	973e                	add	a4,a4,a5
80008ce0:	67e1                	lui	a5,0x18
80008ce2:	6a078793          	add	a5,a5,1696 # 186a0 <__FLASH_segment_used_size__+0x4a10>
80008ce6:	02f757b3          	divu	a5,a4,a5
80008cea:	c63e                	sw	a5,12(sp)
                if(Sync1Cycle < 5)
80008cec:	4732                	lw	a4,12(sp)
80008cee:	4791                	li	a5,4
80008cf0:	00e7e663          	bltu	a5,a4,80008cfc <.L130>
                {
                    /*Sync0 cycle less than 500us*/
                    Sync1WdValue = 1;
80008cf4:	4705                	li	a4,1
80008cf6:	16e19923          	sh	a4,370(gp) # 12094ea <Sync1WdValue>
80008cfa:	a819                	j	80008d10 <.L131>

80008cfc <.L130>:
                }
                else
                {
                    Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
80008cfc:	47b2                	lw	a5,12(sp)
80008cfe:	00179713          	sll	a4,a5,0x1
80008d02:	47a9                	li	a5,10
80008d04:	02f757b3          	divu	a5,a4,a5
80008d08:	0807c733          	zext.h	a4,a5
80008d0c:	16e19923          	sh	a4,370(gp) # 12094ea <Sync1WdValue>

80008d10 <.L131>:
                }

                /* add one Sync0 cycle because the Sync1 cycle starts on the next Sync0 after the Sync1 signal */
                Sync1WdValue += Sync0WdValue/2;
80008d10:	1761d783          	lhu	a5,374(gp) # 12094ee <Sync0WdValue>
80008d14:	8385                	srl	a5,a5,0x1
80008d16:	0807c733          	zext.h	a4,a5
80008d1a:	1721d783          	lhu	a5,370(gp) # 12094ea <Sync1WdValue>
80008d1e:	97ba                	add	a5,a5,a4
80008d20:	0807c733          	zext.h	a4,a5
80008d24:	16e19923          	sh	a4,370(gp) # 12094ea <Sync1WdValue>

80008d28 <.L125>:
            }
    }
    }

    if(nPdOutputSize > 0)
80008d28:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80008d2c:	c781                	beqz	a5,80008d34 <.L132>
    {
        EnableSyncManChannel(PROCESS_DATA_OUT);
80008d2e:	4509                	li	a0,2
80008d30:	b7bfe0ef          	jal	800078aa <EnableSyncManChannel>

80008d34 <.L132>:
    }

    if(nPdInputSize > 0)
80008d34:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80008d38:	c781                	beqz	a5,80008d40 <.L133>
    {
        EnableSyncManChannel(PROCESS_DATA_IN);
80008d3a:	450d                	li	a0,3
80008d3c:	b6ffe0ef          	jal	800078aa <EnableSyncManChannel>

80008d40 <.L133>:
    }

    /*write initial input data*/
    PDO_InputMapping();
80008d40:	b7ffd0ef          	jal	800068be <PDO_InputMapping>

    return ALSTATUSCODE_NOERROR;
80008d44:	4781                	li	a5,0

80008d46 <.L70>:
}
80008d46:	853e                	mv	a0,a5
80008d48:	40f6                	lw	ra,92(sp)
80008d4a:	6125                	add	sp,sp,96
80008d4c:	8082                	ret

Disassembly of section .text.SetALStatus:

80008d4e <SetALStatus>:
 \param alStatusCode    New AL Status Code (written to register 0x134)

  \brief  The function changes the state of the EtherCAT ASIC to the requested.
*////////////////////////////////////////////////////////////////////////////////////////
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
80008d4e:	1101                	add	sp,sp,-32
80008d50:	87aa                	mv	a5,a0
80008d52:	872e                	mv	a4,a1
80008d54:	00f107a3          	sb	a5,15(sp)
80008d58:	87ba                	mv	a5,a4
80008d5a:	00f11623          	sh	a5,12(sp)
    UINT16 Value = alStatusCode;
80008d5e:	00c15783          	lhu	a5,12(sp)
80008d62:	00f11f23          	sh	a5,30(sp)
    UINT32 tmpValue = 0;
80008d66:	cc02                	sw	zero,24(sp)

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
80008d68:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008d6c:	00f14703          	lbu	a4,15(sp)
80008d70:	00f70663          	beq	a4,a5,80008d7c <.L145>
    {
        nAlStatus = alStatus;
80008d74:	00f14703          	lbu	a4,15(sp)
80008d78:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>

80008d7c <.L145>:
    }

    /*Handle Explicit Device ID is requested*/
    if(bExplicitDevIdRequested && !(nAlStatus & STATE_CHANGE) && alStatusCode == 0 && ((nAlStatus & STATE_MASK) != STATE_BOOT))
80008d7c:	19c1c783          	lbu	a5,412(gp) # 1209514 <bExplicitDevIdRequested>
80008d80:	cf85                	beqz	a5,80008db8 <.L146>
80008d82:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008d86:	8bc1                	and	a5,a5,16
80008d88:	eb85                	bnez	a5,80008db8 <.L146>
80008d8a:	00c15783          	lhu	a5,12(sp)
80008d8e:	e78d                	bnez	a5,80008db8 <.L146>
80008d90:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008d94:	00f7f713          	and	a4,a5,15
80008d98:	478d                	li	a5,3
80008d9a:	00f70f63          	beq	a4,a5,80008db8 <.L146>
    {
/*ECATCHANGE_START(V5.13) ECAT2*/
        Value = u16IdValue;
80008d9e:	14e1d783          	lhu	a5,334(gp) # 12094c6 <u16IdValue>
80008da2:	00f11f23          	sh	a5,30(sp)
/*ECATCHANGE_END(V5.13) ECAT2*/
        nAlStatus |= STATE_DEVID;
80008da6:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008daa:	0207e793          	or	a5,a5,32
80008dae:	0ff7f713          	zext.b	a4,a5
80008db2:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>
80008db6:	a809                	j	80008dc8 <.L147>

80008db8 <.L146>:
    }
    else
    {
        nAlStatus &= ~STATE_DEVID;
80008db8:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008dbc:	fdf7f793          	and	a5,a5,-33
80008dc0:	0ff7f713          	zext.b	a4,a5
80008dc4:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>

80008dc8 <.L147>:
    }

    if (alStatusCode != 0xFFFF)
80008dc8:	00c15703          	lhu	a4,12(sp)
80008dcc:	67c1                	lui	a5,0x10
80008dce:	17fd                	add	a5,a5,-1 # ffff <__AXI_SRAM_segment_used_size__+0x6aa3>
80008dd0:	00f70b63          	beq	a4,a5,80008de6 <.L148>
    {
        tmpValue = SWAPDWORD((UINT32) Value);
80008dd4:	01e15783          	lhu	a5,30(sp)
80008dd8:	cc3e                	sw	a5,24(sp)

        HW_EscWriteDWord(tmpValue,ESC_AL_STATUS_CODE_OFFSET);
80008dda:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80008dde:	13478793          	add	a5,a5,308
80008de2:	4762                	lw	a4,24(sp)
80008de4:	c398                	sw	a4,0(a5)

80008de6 <.L148>:
    }

    tmpValue = (UINT32) nAlStatus;
80008de6:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008dea:	cc3e                	sw	a5,24(sp)
    tmpValue = SWAPDWORD(tmpValue);

    HW_EscWriteDWord(tmpValue,ESC_AL_STATUS_OFFSET);
80008dec:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80008df0:	13078793          	add	a5,a5,304
80008df4:	4762                	lw	a4,24(sp)
80008df6:	c398                	sw	a4,0(a5)

    /*The Run LED state is set in Set LED Indication, only the Error LED blink code is set here*/

    /*set Error blink code*/
    if(alStatusCode == 0x00 || !(alStatus & STATE_CHANGE))
80008df8:	00c15783          	lhu	a5,12(sp)
80008dfc:	c789                	beqz	a5,80008e06 <.L149>
80008dfe:	00f14783          	lbu	a5,15(sp)
80008e02:	8bc1                	and	a5,a5,16
80008e04:	e781                	bnez	a5,80008e0c <.L150>

80008e06 <.L149>:
    {
        u8EcatErrorLed = LED_OFF;
80008e06:	180183a3          	sb	zero,391(gp) # 12094ff <u8EcatErrorLed>
80008e0a:	a0a9                	j	80008e54 <.L151>

80008e0c <.L150>:
    }
    else if((alStatusCode == ALSTATUSCODE_NOSYNCERROR) ||
80008e0c:	00c15703          	lhu	a4,12(sp)
80008e10:	02d00793          	li	a5,45
80008e14:	02f70063          	beq	a4,a5,80008e34 <.L152>
80008e18:	00c15703          	lhu	a4,12(sp)
80008e1c:	47e9                	li	a5,26
80008e1e:	00f70b63          	beq	a4,a5,80008e34 <.L152>
        (alStatusCode == ALSTATUSCODE_SYNCERROR) ||
80008e22:	00c15703          	lhu	a4,12(sp)
80008e26:	03200793          	li	a5,50
80008e2a:	00f70563          	beq	a4,a5,80008e34 <.L152>
        (alStatusCode == ALSTATUSCODE_DCPLLSYNCERROR)
/*ECATCHANGE_START(V5.13) ESM1*/
        || (u8LocalErrorState > 0))
80008e2e:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
80008e32:	c789                	beqz	a5,80008e3c <.L153>

80008e34 <.L152>:
/*ECATCHANGE_END(V5.13) ESM1*/
    {
        u8EcatErrorLed = LED_SINGLEFLASH;
80008e34:	4705                	li	a4,1
80008e36:	18e183a3          	sb	a4,391(gp) # 12094ff <u8EcatErrorLed>
80008e3a:	a829                	j	80008e54 <.L151>

80008e3c <.L153>:
    }
    else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
80008e3c:	00c15703          	lhu	a4,12(sp)
80008e40:	47ed                	li	a5,27
80008e42:	00f71663          	bne	a4,a5,80008e4e <.L154>
    {
        u8EcatErrorLed = LED_DOUBLEFLASH;
80008e46:	4709                	li	a4,2
80008e48:	18e183a3          	sb	a4,391(gp) # 12094ff <u8EcatErrorLed>
80008e4c:	a021                	j	80008e54 <.L151>

80008e4e <.L154>:
    }
    else
    {
        u8EcatErrorLed = LED_BLINKING;
80008e4e:	4735                	li	a4,13
80008e50:	18e183a3          	sb	a4,391(gp) # 12094ff <u8EcatErrorLed>

80008e54 <.L151>:
    }
    u8EcatErrorLed |= LED_OVERRIDE;
80008e54:	1871c783          	lbu	a5,391(gp) # 12094ff <u8EcatErrorLed>
80008e58:	0107e793          	or	a5,a5,16
80008e5c:	0ff7f713          	zext.b	a4,a5
80008e60:	18e183a3          	sb	a4,391(gp) # 12094ff <u8EcatErrorLed>

    /*The Run LED registers are also written in 16 or 32 Bit access => calculate value*/
    switch((alStatus & STATE_MASK))
80008e64:	00f14783          	lbu	a5,15(sp)
80008e68:	8bbd                	and	a5,a5,15
80008e6a:	4721                	li	a4,8
80008e6c:	02f76e63          	bltu	a4,a5,80008ea8 <.L155>
80008e70:	00279713          	sll	a4,a5,0x2
80008e74:	800057b7          	lui	a5,0x80005
80008e78:	ca078793          	add	a5,a5,-864 # 80004ca0 <.L157>
80008e7c:	97ba                	add	a5,a5,a4
80008e7e:	439c                	lw	a5,0(a5)
80008e80:	8782                	jr	a5

80008e82 <.L161>:
    {
    case STATE_INIT:
        u8EcatRunLed = LED_OFF;
80008e82:	18018323          	sb	zero,390(gp) # 12094fe <u8EcatRunLed>
        break;
80008e86:	a00d                	j	80008ea8 <.L155>

80008e88 <.L160>:
    case STATE_PREOP:
        u8EcatRunLed = LED_BLINKING;
80008e88:	4735                	li	a4,13
80008e8a:	18e18323          	sb	a4,390(gp) # 12094fe <u8EcatRunLed>
        break;
80008e8e:	a829                	j	80008ea8 <.L155>

80008e90 <.L158>:
    case STATE_SAFEOP:
        u8EcatRunLed = LED_SINGLEFLASH;
80008e90:	4705                	li	a4,1
80008e92:	18e18323          	sb	a4,390(gp) # 12094fe <u8EcatRunLed>
        break;
80008e96:	a809                	j	80008ea8 <.L155>

80008e98 <.L156>:
    case STATE_OP:
        u8EcatRunLed = LED_ON;
80008e98:	473d                	li	a4,15
80008e9a:	18e18323          	sb	a4,390(gp) # 12094fe <u8EcatRunLed>
        break;
80008e9e:	a029                	j	80008ea8 <.L155>

80008ea0 <.L159>:
    case STATE_BOOT:
        u8EcatRunLed = LED_FLICKERING;
80008ea0:	4739                	li	a4,14
80008ea2:	18e18323          	sb	a4,390(gp) # 12094fe <u8EcatRunLed>
        break;
80008ea6:	0001                	nop

80008ea8 <.L155>:
    }

    u8EcatRunLed |= LED_OVERRIDE;
80008ea8:	1861c783          	lbu	a5,390(gp) # 12094fe <u8EcatRunLed>
80008eac:	0107e793          	or	a5,a5,16
80008eb0:	0ff7f713          	zext.b	a4,a5
80008eb4:	18e18323          	sb	a4,390(gp) # 12094fe <u8EcatRunLed>

80008eb8 <.LBB11>:

    {
    UINT32 TmpVar = 0;
80008eb8:	ca02                	sw	zero,20(sp)
    TmpVar = SWAPDWORD((((UINT32)u8EcatRunLed) | (((UINT32)u8EcatErrorLed)<<8)));
80008eba:	1861c783          	lbu	a5,390(gp) # 12094fe <u8EcatRunLed>
80008ebe:	873e                	mv	a4,a5
80008ec0:	1871c783          	lbu	a5,391(gp) # 12094ff <u8EcatErrorLed>
80008ec4:	07a2                	sll	a5,a5,0x8
80008ec6:	8fd9                	or	a5,a5,a4
80008ec8:	ca3e                	sw	a5,20(sp)

    HW_EscWriteDWord(TmpVar,ESC_RUN_LED_OVERRIDE);
80008eca:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80008ece:	13878793          	add	a5,a5,312
80008ed2:	4752                	lw	a4,20(sp)
80008ed4:	c398                	sw	a4,0(a5)

80008ed6 <.LBE11>:
    }
}
80008ed6:	0001                	nop
80008ed8:	6105                	add	sp,sp,32
80008eda:	8082                	ret

Disassembly of section .text.AL_ControlInd:

80008edc <AL_ControlInd>:
              alControl contains the requested new state (INIT, PRE_OP or SAFE_OP)

*////////////////////////////////////////////////////////////////////////////////////////

void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
{
80008edc:	7179                	add	sp,sp,-48
80008ede:	d606                	sw	ra,44(sp)
80008ee0:	87aa                	mv	a5,a0
80008ee2:	872e                	mv	a4,a1
80008ee4:	00f107a3          	sb	a5,15(sp)
80008ee8:	87ba                	mv	a5,a4
80008eea:	00f11623          	sh	a5,12(sp)
    UINT16        result = 0;
80008eee:	00011f23          	sh	zero,30(sp)
    UINT8            bErrAck = 0;
80008ef2:	00010ea3          	sb	zero,29(sp)
    UINT8         stateTrans;
    /*deactivate ESM timeout counter*/
    EsmTimeoutCounter = -1;
80008ef6:	577d                	li	a4,-1
80008ef8:	16e19f23          	sh	a4,382(gp) # 12094f6 <EsmTimeoutCounter>
    bApplEsmPending = TRUE;
80008efc:	4705                	li	a4,1
80008efe:	1ae18223          	sb	a4,420(gp) # 120951c <bApplEsmPending>

    /* reset the Error Flag in case of acknowledge by the Master */
    if ( alControl & STATE_CHANGE )
80008f02:	00f14783          	lbu	a5,15(sp)
80008f06:	8bc1                	and	a5,a5,16
80008f08:	cf81                	beqz	a5,80008f20 <.L163>
    {
        bErrAck = 1;
80008f0a:	4785                	li	a5,1
80008f0c:	00f10ea3          	sb	a5,29(sp)
        nAlStatus &= ~STATE_CHANGE;
80008f10:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008f14:	9bbd                	and	a5,a5,-17
80008f16:	0ff7f713          	zext.b	a4,a5
80008f1a:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>
80008f1e:	a01d                	j	80008f44 <.L164>

80008f20 <.L163>:
        /*enable SM2 is moved to state transition block. First check SM Settings.*/
    }
    else if ((nAlStatus & STATE_CHANGE)
80008f20:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008f24:	8bc1                	and	a5,a5,16
80008f26:	cb81                	beqz	a5,80008f36 <.L165>
        // HBu 17.04.08: the error has to be acknowledged before when sending the same (or a higher) state
        //               (the error was acknowledged with the same state before independent of the acknowledge flag)
        /*Error Acknowledge with 0xX1 is allowed*/
        && (alControl & STATE_MASK) != STATE_INIT)
80008f28:	00f14783          	lbu	a5,15(sp)
80008f2c:	00f7f713          	and	a4,a5,15
80008f30:	4785                	li	a5,1
80008f32:	50f71663          	bne	a4,a5,8000943e <.L228>

80008f36 <.L165>:
           and the new state request will be ignored */
        return;
    }
    else
    {
        nAlStatus &= STATE_MASK;
80008f36:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008f3a:	8bbd                	and	a5,a5,15
80008f3c:	0ff7f713          	zext.b	a4,a5
80008f40:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>

80008f44 <.L164>:

    

    /* generate a variable for the state transition
      (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
    alControl &= STATE_MASK;
80008f44:	00f14783          	lbu	a5,15(sp)
80008f48:	8bbd                	and	a5,a5,15
80008f4a:	00f107a3          	sb	a5,15(sp)
    stateTrans = nAlStatus;
80008f4e:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80008f52:	00f10e23          	sb	a5,28(sp)
    stateTrans <<= 4;
80008f56:	01c14783          	lbu	a5,28(sp)
80008f5a:	0792                	sll	a5,a5,0x4
80008f5c:	00f10e23          	sb	a5,28(sp)
    stateTrans += alControl;
80008f60:	01c14783          	lbu	a5,28(sp)
80008f64:	873e                	mv	a4,a5
80008f66:	00f14783          	lbu	a5,15(sp)
80008f6a:	97ba                	add	a5,a5,a4
80008f6c:	00f10e23          	sb	a5,28(sp)

    /* check the SYNCM settings depending on the state transition */
    switch ( stateTrans )
80008f70:	01c14783          	lbu	a5,28(sp)
80008f74:	08800713          	li	a4,136
80008f78:	08e78663          	beq	a5,a4,80009004 <.L167>
80008f7c:	08800713          	li	a4,136
80008f80:	08f74c63          	blt	a4,a5,80009018 <.L168>
80008f84:	08400713          	li	a4,132
80008f88:	06e78e63          	beq	a5,a4,80009004 <.L167>
80008f8c:	08400713          	li	a4,132
80008f90:	08f74463          	blt	a4,a5,80009018 <.L168>
80008f94:	08200713          	li	a4,130
80008f98:	04e78363          	beq	a5,a4,80008fde <.L169>
80008f9c:	08200713          	li	a4,130
80008fa0:	06f74c63          	blt	a4,a5,80009018 <.L168>
80008fa4:	4749                	li	a4,18
80008fa6:	02e78c63          	beq	a5,a4,80008fde <.L169>
80008faa:	4749                	li	a4,18
80008fac:	06e7c663          	blt	a5,a4,80009018 <.L168>
80008fb0:	04800713          	li	a4,72
80008fb4:	06f74263          	blt	a4,a5,80009018 <.L168>
80008fb8:	02200713          	li	a4,34
80008fbc:	04e7ce63          	blt	a5,a4,80009018 <.L168>
80008fc0:	fde78793          	add	a5,a5,-34
80008fc4:	02600713          	li	a4,38
80008fc8:	04f76863          	bltu	a4,a5,80009018 <.L168>
80008fcc:	00279713          	sll	a4,a5,0x2
80008fd0:	800057b7          	lui	a5,0x80005
80008fd4:	cc478793          	add	a5,a5,-828 # 80004cc4 <.L170>
80008fd8:	97ba                	add	a5,a5,a4
80008fda:	439c                	lw	a5,0(a5)
80008fdc:	8782                	jr	a5

80008fde <.L169>:
    case SAFEOP_2_PREOP:
    case PREOP_2_PREOP:
        /* in PREOP only the SYNCM settings for SYNCM0 and SYNCM1 (mailbox)
           are checked, if result is unequal 0, the slave will stay in or
           switch to INIT and set the ErrorInd Bit (bit 4) of the AL-Status */
        result = CheckSmSettings(MAILBOX_READ+1);
80008fde:	4509                	li	a0,2
80008fe0:	937fe0ef          	jal	80007916 <CheckSmSettings>
80008fe4:	87aa                	mv	a5,a0
80008fe6:	00f11f23          	sh	a5,30(sp)
        break;
80008fea:	a03d                	j	80009018 <.L168>

80008fec <.L171>:
        /* before checking the SYNCM settings for SYNCM2 and SYNCM3 (process data)
           the expected length of input data (nPdInputSize) and output data (nPdOutputSize)
            could be adapted (changed by PDO-Assign and/or PDO-Mapping)
            if result is unequal 0, the slave will stay in PREOP and set
            the ErrorInd Bit (bit 4) of the AL-Status */
        result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
80008fec:	16218593          	add	a1,gp,354 # 12094da <nPdOutputSize>
80008ff0:	16418513          	add	a0,gp,356 # 12094dc <nPdInputSize>
80008ff4:	352020ef          	jal	8000b346 <APPL_GenerateMapping>
80008ff8:	87aa                	mv	a5,a0
80008ffa:	00f11f23          	sh	a5,30(sp)

            if (result != 0)
80008ffe:	01e15783          	lhu	a5,30(sp)
80009002:	eb91                	bnez	a5,80009016 <.L229>

80009004 <.L167>:
    case SAFEOP_2_SAFEOP:
    case OP_2_OP:
        /* in SAFEOP or OP the SYNCM settings for all SYNCM are checked
           if result is unequal 0, the slave will stay in or
           switch to PREOP and set the ErrorInd Bit (bit 4) of the AL-Status */
        result = CheckSmSettings(nMaxSyncMan);
80009004:	18a1c783          	lbu	a5,394(gp) # 1209502 <nMaxSyncMan>
80009008:	853e                	mv	a0,a5
8000900a:	90dfe0ef          	jal	80007916 <CheckSmSettings>
8000900e:	87aa                	mv	a5,a0
80009010:	00f11f23          	sh	a5,30(sp)
        break;
80009014:	a011                	j	80009018 <.L168>

80009016 <.L229>:
                break;
80009016:	0001                	nop

80009018 <.L168>:

    }

    if ( result == 0 )
80009018:	01e15783          	lhu	a5,30(sp)
8000901c:	24079c63          	bnez	a5,80009274 <.L172>
    {
        /* execute the corresponding local management service(s) depending on the state transition */
        nEcatStateTrans = 0;
80009020:	16019623          	sh	zero,364(gp) # 12094e4 <nEcatStateTrans>
        switch ( stateTrans )
80009024:	01c14783          	lbu	a5,28(sp)
80009028:	17bd                	add	a5,a5,-17
8000902a:	07700713          	li	a4,119
8000902e:	22f76f63          	bltu	a4,a5,8000926c <.L173>
80009032:	00279713          	sll	a4,a5,0x2
80009036:	800057b7          	lui	a5,0x80005
8000903a:	d6078793          	add	a5,a5,-672 # 80004d60 <.L175>
8000903e:	97ba                	add	a5,a5,a4
80009040:	439c                	lw	a5,0(a5)
80009042:	8782                	jr	a5

80009044 <.L186>:
        {
        case INIT_2_BOOT    :
            result = ALSTATUSCODE_BOOTNOTSUPP;
80009044:	47cd                	li	a5,19
80009046:	00f11f23          	sh	a5,30(sp)



            break;
8000904a:	ac71                	j	800092e6 <.L208>

8000904c <.L183>:

        case BOOT_2_INIT    :
            result = ALSTATUSCODE_BOOTNOTSUPP;
8000904c:	47cd                	li	a5,19
8000904e:	00f11f23          	sh	a5,30(sp)

            BackToInitTransition();
80009052:	65b050ef          	jal	8000eeac <BackToInitTransition>



            break;
80009056:	ac41                	j	800092e6 <.L208>

80009058 <.L187>:
        case INIT_2_PREOP :

           UpdateEEPROMLoadedState();
80009058:	461050ef          	jal	8000ecb8 <UpdateEEPROMLoadedState>

            if (EepromLoaded == FALSE)
8000905c:	1a71c783          	lbu	a5,423(gp) # 120951f <EepromLoaded>
80009060:	e789                	bnez	a5,8000906a <.L190>
            {
                //return an error if the EEPROM was not loaded correct  (device restart is required after the new EEPORM update)
                result = ALSTATUSCODE_EE_ERROR;
80009062:	05100793          	li	a5,81
80009066:	00f11f23          	sh	a5,30(sp)

8000906a <.L190>:
            }
            if (result == 0)
8000906a:	01e15783          	lhu	a5,30(sp)
8000906e:	26079163          	bnez	a5,800092d0 <.L230>
            {
            /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
               sync managers SYNCM0 and SYNCM1 overlap each other
              if result is unequal 0, the slave will stay in INIT
              and sets the ErrorInd Bit (bit 4) of the AL-Status */
            result = MBX_StartMailboxHandler();
80009072:	4d2060ef          	jal	8000f544 <MBX_StartMailboxHandler>
80009076:	87aa                	mv	a5,a0
80009078:	00f11f23          	sh	a5,30(sp)
            if (result == 0)
8000907c:	01e15783          	lhu	a5,30(sp)
80009080:	ef91                	bnez	a5,8000909c <.L192>
            {
                bApplEsmPending = FALSE;
80009082:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
                /* additionally there could be an application specific check (in ecatappl.c)
                   if the state transition from INIT to PREOP should be done
                 if result is unequal 0, the slave will stay in INIT
                 and sets the ErrorInd Bit (bit 4) of the AL-Status */
                result = APPL_StartMailboxHandler();
80009086:	2a2020ef          	jal	8000b328 <APPL_StartMailboxHandler>
8000908a:	87aa                	mv	a5,a0
8000908c:	00f11f23          	sh	a5,30(sp)
                if ( result == 0 )
80009090:	01e15783          	lhu	a5,30(sp)
80009094:	e781                	bnez	a5,8000909c <.L192>
                {
                    bMbxRunning = TRUE;
80009096:	4705                	li	a4,1
80009098:	18e18ca3          	sb	a4,409(gp) # 1209511 <bMbxRunning>

8000909c <.L192>:
                }
            }

            if(result != 0 && result != NOERROR_INWORK)
8000909c:	01e15783          	lhu	a5,30(sp)
800090a0:	22078863          	beqz	a5,800092d0 <.L230>
800090a4:	01e15703          	lhu	a4,30(sp)
800090a8:	0ff00793          	li	a5,255
800090ac:	22f70263          	beq	a4,a5,800092d0 <.L230>
            {
                /*Stop APPL Mbx handler if APPL Start Mbx handler was called before*/
                    if (!bApplEsmPending)
800090b0:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
800090b4:	e399                	bnez	a5,800090ba <.L193>
                    {
                        APPL_StopMailboxHandler();
800090b6:	278020ef          	jal	8000b32e <APPL_StopMailboxHandler>

800090ba <.L193>:
                    }

                 MBX_StopMailboxHandler();
800090ba:	5da060ef          	jal	8000f694 <MBX_StopMailboxHandler>
            }

            }
            break;
800090be:	ac09                	j	800092d0 <.L230>

800090c0 <.L184>:

        case PREOP_2_SAFEOP:
            /* start the input handler (function is defined above) */
            result = StartInputHandler();
800090c0:	988ff0ef          	jal	80008248 <StartInputHandler>
800090c4:	87aa                	mv	a5,a0
800090c6:	00f11f23          	sh	a5,30(sp)
            if ( result == 0 )
800090ca:	01e15783          	lhu	a5,30(sp)
800090ce:	e78d                	bnez	a5,800090f8 <.L194>
            {
                bApplEsmPending = FALSE;
800090d0:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
                result = APPL_StartInputHandler(&u16ALEventMask);
800090d4:	15a18513          	add	a0,gp,346 # 12094d2 <u16ALEventMask>
800090d8:	4aa080ef          	jal	80011582 <APPL_StartInputHandler>
800090dc:	87aa                	mv	a5,a0
800090de:	00f11f23          	sh	a5,30(sp)

                if(result == 0)
800090e2:	01e15783          	lhu	a5,30(sp)
800090e6:	eb89                	bnez	a5,800090f8 <.L194>
                {
/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
                    /* initialize the AL Event Mask register (0x204) */
                    SetALEventMask( u16ALEventMask );
800090e8:	15a1d783          	lhu	a5,346(gp) # 12094d2 <u16ALEventMask>
800090ec:	853e                	mv	a0,a5
800090ee:	eacfe0ef          	jal	8000779a <SetALEventMask>

                    bEcatInputUpdateRunning = TRUE;
800090f2:	4705                	li	a4,1
800090f4:	1ae18023          	sb	a4,416(gp) # 1209518 <bEcatInputUpdateRunning>

800090f8 <.L194>:
                }
            }

            /*if one start input handler returned an error stop the input handler*/
            if(result != 0 && result != NOERROR_INWORK)
800090f8:	01e15783          	lhu	a5,30(sp)
800090fc:	1c078c63          	beqz	a5,800092d4 <.L231>
80009100:	01e15703          	lhu	a4,30(sp)
80009104:	0ff00793          	li	a5,255
80009108:	1cf70663          	beq	a4,a5,800092d4 <.L231>
            {
                if(!bApplEsmPending)
8000910c:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
80009110:	e399                	bnez	a5,80009116 <.L196>
                {
                    /*Call only the APPL stop handler if the APPL start handler was called before*/
                    /*The application can react to the state transition in the function APPL_StopInputHandler */
                    APPL_StopInputHandler();
80009112:	222020ef          	jal	8000b334 <APPL_StopInputHandler>

80009116 <.L196>:
                }

                StopInputHandler();
80009116:	48b050ef          	jal	8000eda0 <StopInputHandler>
            }
            break;
8000911a:	aa6d                	j	800092d4 <.L231>

8000911c <.L180>:

        case SAFEOP_2_OP:
/*ECATCHANGE_START(V5.13) ESM2*/
            /*enable SM if error was acknowledged*/
            if (bErrAck)
8000911c:	01d14783          	lbu	a5,29(sp)
80009120:	cf91                	beqz	a5,8000913c <.L197>
            {
                if (nPdOutputSize > 0)
80009122:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80009126:	c789                	beqz	a5,80009130 <.L198>
                {
                    EnableSyncManChannel(PROCESS_DATA_OUT);
80009128:	4509                	li	a0,2
8000912a:	f80fe0ef          	jal	800078aa <EnableSyncManChannel>
8000912e:	a039                	j	8000913c <.L197>

80009130 <.L198>:
                }
                else
                    if (nPdInputSize > 0)
80009130:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80009134:	c781                	beqz	a5,8000913c <.L197>
                    {
                        EnableSyncManChannel(PROCESS_DATA_IN);
80009136:	450d                	li	a0,3
80009138:	f72fe0ef          	jal	800078aa <EnableSyncManChannel>

8000913c <.L197>:
                    }
            }
            /*ECATCHANGE_END(V5.13) ESM2*/

            /* start the output handler (function is defined above) */
            result = StartOutputHandler();
8000913c:	3b5050ef          	jal	8000ecf0 <StartOutputHandler>
80009140:	87aa                	mv	a5,a0
80009142:	00f11f23          	sh	a5,30(sp)
            if(result == 0)
80009146:	01e15783          	lhu	a5,30(sp)
8000914a:	ef91                	bnez	a5,80009166 <.L199>
            {
                bApplEsmPending = FALSE;
8000914c:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
                result = APPL_StartOutputHandler();
80009150:	1ea020ef          	jal	8000b33a <APPL_StartOutputHandler>
80009154:	87aa                	mv	a5,a0
80009156:	00f11f23          	sh	a5,30(sp)

                if(result == 0)
8000915a:	01e15783          	lhu	a5,30(sp)
8000915e:	e781                	bnez	a5,80009166 <.L199>
                {
                    /*Device is in OPERATINAL*/
                    bEcatOutputUpdateRunning = TRUE;
80009160:	4705                	li	a4,1
80009162:	18e18fa3          	sb	a4,415(gp) # 1209517 <bEcatOutputUpdateRunning>

80009166 <.L199>:
                }

            }

            if ( result != 0 && result != NOERROR_INWORK)
80009166:	01e15783          	lhu	a5,30(sp)
8000916a:	16078763          	beqz	a5,800092d8 <.L232>
8000916e:	01e15703          	lhu	a4,30(sp)
80009172:	0ff00793          	li	a5,255
80009176:	16f70163          	beq	a4,a5,800092d8 <.L232>
            {
                    if (!bApplEsmPending)
8000917a:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
8000917e:	e399                	bnez	a5,80009184 <.L201>
                    {
                        APPL_StopOutputHandler();
80009180:	1c0020ef          	jal	8000b340 <APPL_StopOutputHandler>

80009184 <.L201>:
                    }

                StopOutputHandler();
80009184:	411050ef          	jal	8000ed94 <StopOutputHandler>
            }

            break;
80009188:	aa81                	j	800092d8 <.L232>

8000918a <.L176>:

        case OP_2_SAFEOP:
            /* stop the output handler (function is defined above) */
            APPL_StopOutputHandler();
8000918a:	1b6020ef          	jal	8000b340 <APPL_StopOutputHandler>

            StopOutputHandler();
8000918e:	407050ef          	jal	8000ed94 <StopOutputHandler>

            bApplEsmPending = FALSE;
80009192:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>

            break;
80009196:	aa81                	j	800092e6 <.L208>

80009198 <.L178>:

        case OP_2_PREOP:
            /* stop the output handler (function is defined above) */
            result = APPL_StopOutputHandler();
80009198:	1a8020ef          	jal	8000b340 <APPL_StopOutputHandler>
8000919c:	87aa                	mv	a5,a0
8000919e:	00f11f23          	sh	a5,30(sp)

            StopOutputHandler();
800091a2:	3f3050ef          	jal	8000ed94 <StopOutputHandler>

            bApplEsmPending = FALSE;
800091a6:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>

            if (result != 0)
800091aa:	01e15783          	lhu	a5,30(sp)
800091ae:	12079763          	bnez	a5,800092dc <.L233>
            {
                break;
            }

            stateTrans = SAFEOP_2_PREOP;
800091b2:	04200793          	li	a5,66
800091b6:	00f10e23          	sb	a5,28(sp)

800091ba <.L181>:

        case SAFEOP_2_PREOP:
            /* stop the input handler (function is defined above) */
            APPL_StopInputHandler();
800091ba:	17a020ef          	jal	8000b334 <APPL_StopInputHandler>
           
            StopInputHandler();
800091be:	3e3050ef          	jal	8000eda0 <StopInputHandler>

            bApplEsmPending = FALSE;
800091c2:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>

            break;
800091c6:	a205                	j	800092e6 <.L208>

800091c8 <.L179>:

        case OP_2_INIT:
            /* stop the output handler (function is defined above) */
            result = APPL_StopOutputHandler();
800091c8:	178020ef          	jal	8000b340 <APPL_StopOutputHandler>
800091cc:	87aa                	mv	a5,a0
800091ce:	00f11f23          	sh	a5,30(sp)

            StopOutputHandler();
800091d2:	3c3050ef          	jal	8000ed94 <StopOutputHandler>

            bApplEsmPending = FALSE;
800091d6:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>

            if (result != 0)
800091da:	01e15783          	lhu	a5,30(sp)
800091de:	10079163          	bnez	a5,800092e0 <.L234>
            {
                break;
            }
            
            stateTrans = SAFEOP_2_INIT;
800091e2:	04100793          	li	a5,65
800091e6:	00f10e23          	sb	a5,28(sp)

800091ea <.L182>:

        case SAFEOP_2_INIT:
            /* stop the input handler (function is defined above) */
            result = APPL_StopInputHandler();
800091ea:	14a020ef          	jal	8000b334 <APPL_StopInputHandler>
800091ee:	87aa                	mv	a5,a0
800091f0:	00f11f23          	sh	a5,30(sp)
            
            StopInputHandler();
800091f4:	3ad050ef          	jal	8000eda0 <StopInputHandler>

            bApplEsmPending = FALSE;
800091f8:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>

            if (result != 0)
800091fc:	01e15783          	lhu	a5,30(sp)
80009200:	0e079263          	bnez	a5,800092e4 <.L235>
            {
                break;
            }
            stateTrans = PREOP_2_INIT;
80009204:	02100793          	li	a5,33
80009208:	00f10e23          	sb	a5,28(sp)

8000920c <.L185>:

        case PREOP_2_INIT:
            MBX_StopMailboxHandler();
8000920c:	488060ef          	jal	8000f694 <MBX_StopMailboxHandler>
            result = APPL_StopMailboxHandler();
80009210:	11e020ef          	jal	8000b32e <APPL_StopMailboxHandler>
80009214:	87aa                	mv	a5,a0
80009216:	00f11f23          	sh	a5,30(sp)

            BackToInitTransition();
8000921a:	493050ef          	jal	8000eeac <BackToInitTransition>
            break;
8000921e:	a0e1                	j	800092e6 <.L208>

80009220 <.L188>:
        case INIT_2_INIT:
            BackToInitTransition();
80009220:	48d050ef          	jal	8000eeac <BackToInitTransition>

80009224 <.L174>:
        case PREOP_2_PREOP:
        case SAFEOP_2_SAFEOP:
        case OP_2_OP:
            if(bErrAck)
80009224:	01d14783          	lbu	a5,29(sp)
80009228:	cb81                	beqz	a5,80009238 <.L205>
            {
                APPL_AckErrorInd(stateTrans);
8000922a:	01c14783          	lbu	a5,28(sp)
8000922e:	0807c7b3          	zext.h	a5,a5
80009232:	853e                	mv	a0,a5
80009234:	0e6020ef          	jal	8000b31a <APPL_AckErrorInd>

80009238 <.L205>:
            }


                /*no local error flag is currently active, enable SM*/
                if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
80009238:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000923c:	8bb1                	and	a5,a5,12
8000923e:	cf91                	beqz	a5,8000925a <.L206>
                {
                    if(nPdOutputSize > 0)
80009240:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80009244:	c789                	beqz	a5,8000924e <.L207>
                    {
                        EnableSyncManChannel(PROCESS_DATA_OUT);
80009246:	4509                	li	a0,2
80009248:	e62fe0ef          	jal	800078aa <EnableSyncManChannel>
8000924c:	a039                	j	8000925a <.L206>

8000924e <.L207>:
                    }
                    else 
                    if(nPdInputSize > 0)
8000924e:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80009252:	c781                	beqz	a5,8000925a <.L206>
                    {
                        EnableSyncManChannel(PROCESS_DATA_IN);
80009254:	450d                	li	a0,3
80009256:	e54fe0ef          	jal	800078aa <EnableSyncManChannel>

8000925a <.L206>:
                    }
                }
            
            result = NOERROR_NOSTATECHANGE;
8000925a:	0fe00793          	li	a5,254
8000925e:	00f11f23          	sh	a5,30(sp)
            break;
80009262:	a051                	j	800092e6 <.L208>

80009264 <.L177>:
        case SAFEOP_2_BOOT:
        case OP_2_BOOT:
        case BOOT_2_PREOP:
        case BOOT_2_SAFEOP:
        case BOOT_2_OP:
            result = ALSTATUSCODE_INVALIDALCONTROL;
80009264:	47c5                	li	a5,17
80009266:	00f11f23          	sh	a5,30(sp)
            break;
8000926a:	a8b5                	j	800092e6 <.L208>

8000926c <.L173>:

        default:
            result = ALSTATUSCODE_UNKNOWNALCONTROL;
8000926c:	47c9                	li	a5,18
8000926e:	00f11f23          	sh	a5,30(sp)
            break;
80009272:	a895                	j	800092e6 <.L208>

80009274 <.L172>:
    }
    else
    {
        /* the checking of the sync manager settings was not successful
            switch back the state to PREOP or INIT */
        switch (nAlStatus)
80009274:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80009278:	4721                	li	a4,8
8000927a:	00e78c63          	beq	a5,a4,80009292 <.L209>
8000927e:	4721                	li	a4,8
80009280:	06f74363          	blt	a4,a5,800092e6 <.L208>
80009284:	4709                	li	a4,2
80009286:	00e78e63          	beq	a5,a4,800092a2 <.L210>
8000928a:	4711                	li	a4,4
8000928c:	00e78763          	beq	a5,a4,8000929a <.L211>
80009290:	a899                	j	800092e6 <.L208>

80009292 <.L209>:
        {
        case STATE_OP:
            /* stop the output handler (function is defined above) */
            APPL_StopOutputHandler();
80009292:	0ae020ef          	jal	8000b340 <APPL_StopOutputHandler>
            StopOutputHandler();
80009296:	2ff050ef          	jal	8000ed94 <StopOutputHandler>

8000929a <.L211>:
        case STATE_SAFEOP:
            /* stop the input handler (function is defined above) */
            APPL_StopInputHandler();
8000929a:	09a020ef          	jal	8000b334 <APPL_StopInputHandler>

            StopInputHandler();
8000929e:	303050ef          	jal	8000eda0 <StopInputHandler>

800092a2 <.L210>:
        case STATE_PREOP:
            if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
800092a2:	01e15703          	lhu	a4,30(sp)
800092a6:	47d9                	li	a5,22
800092a8:	02f71063          	bne	a4,a5,800092c8 <.L212>
            {
                /* the mailbox sync manager settings were wrong, switch back to INIT */
                MBX_StopMailboxHandler();
800092ac:	3e8060ef          	jal	8000f694 <MBX_StopMailboxHandler>
                APPL_StopMailboxHandler();
800092b0:	07e020ef          	jal	8000b32e <APPL_StopMailboxHandler>

                /*Disable SM0 (MBX Out)*/
                DisableSyncManChannel(MAILBOX_WRITE);
800092b4:	4501                	li	a0,0
800092b6:	d84fe0ef          	jal	8000783a <DisableSyncManChannel>

                /*Disable SM1 (MBX In)*/
                DisableSyncManChannel(MAILBOX_READ);
800092ba:	4505                	li	a0,1
800092bc:	d7efe0ef          	jal	8000783a <DisableSyncManChannel>

                nAlStatus = STATE_INIT;
800092c0:	4705                	li	a4,1
800092c2:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>
800092c6:	a005                	j	800092e6 <.L208>

800092c8 <.L212>:
            }
            else
            {
                nAlStatus = STATE_PREOP;
800092c8:	4709                	li	a4,2
800092ca:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>
800092ce:	a821                	j	800092e6 <.L208>

800092d0 <.L230>:
            break;
800092d0:	0001                	nop
800092d2:	a811                	j	800092e6 <.L208>

800092d4 <.L231>:
            break;
800092d4:	0001                	nop
800092d6:	a801                	j	800092e6 <.L208>

800092d8 <.L232>:
            break;
800092d8:	0001                	nop
800092da:	a031                	j	800092e6 <.L208>

800092dc <.L233>:
                break;
800092dc:	0001                	nop
800092de:	a021                	j	800092e6 <.L208>

800092e0 <.L234>:
                break;
800092e0:	0001                	nop
800092e2:	a011                	j	800092e6 <.L208>

800092e4 <.L235>:
                break;
800092e4:	0001                	nop

800092e6 <.L208>:
            }
        }
    }

    if ( result == NOERROR_INWORK )
800092e6:	01e15703          	lhu	a4,30(sp)
800092ea:	0ff00793          	li	a5,255
800092ee:	08f71763          	bne	a4,a5,8000937c <.L213>
    {
        /* state transition is still in work
            ECAT_StateChange must be called from the application */
        bEcatWaitForAlControlRes = TRUE;
800092f2:	4705                	li	a4,1
800092f4:	18e18f23          	sb	a4,414(gp) # 1209516 <bEcatWaitForAlControlRes>
        /* state transition has to be stored */
        nEcatStateTrans = stateTrans;
800092f8:	01c14783          	lbu	a5,28(sp)
800092fc:	0807c733          	zext.h	a4,a5
80009300:	16e19623          	sh	a4,364(gp) # 12094e4 <nEcatStateTrans>

        /*Init ESM timeout counter (will be decremented with the local 1ms timer)*/
        switch(nEcatStateTrans)
80009304:	16c1d783          	lhu	a5,364(gp) # 12094e4 <nEcatStateTrans>
80009308:	04800713          	li	a4,72
8000930c:	02e78763          	beq	a5,a4,8000933a <.L214>
80009310:	04800713          	li	a4,72
80009314:	02f74963          	blt	a4,a5,80009346 <.L215>
80009318:	474d                	li	a4,19
8000931a:	00f74663          	blt	a4,a5,80009326 <.L216>
8000931e:	4749                	li	a4,18
80009320:	00e7d863          	bge	a5,a4,80009330 <.L217>
80009324:	a00d                	j	80009346 <.L215>

80009326 <.L216>:
80009326:	02400713          	li	a4,36
8000932a:	00e78863          	beq	a5,a4,8000933a <.L214>
8000932e:	a821                	j	80009346 <.L215>

80009330 <.L217>:
        {
            case INIT_2_PREOP:
            case INIT_2_BOOT:
                EsmTimeoutCounter = PREOPTIMEOUT;
80009330:	7d000713          	li	a4,2000
80009334:	16e19f23          	sh	a4,382(gp) # 12094f6 <EsmTimeoutCounter>
            break;
80009338:	a821                	j	80009350 <.L218>

8000933a <.L214>:
            case PREOP_2_SAFEOP:
            case SAFEOP_2_OP:
                EsmTimeoutCounter = SAFEOP2OPTIMEOUT;
8000933a:	6709                	lui	a4,0x2
8000933c:	32870713          	add	a4,a4,808 # 2328 <__BOOT_HEADER_segment_size__+0x328>
80009340:	16e19f23          	sh	a4,382(gp) # 12094f6 <EsmTimeoutCounter>
                break;
80009344:	a031                	j	80009350 <.L218>

80009346 <.L215>:
           default:
                EsmTimeoutCounter = 200; //Set default timeout value to 200ms
80009346:	0c800713          	li	a4,200
8000934a:	16e19f23          	sh	a4,382(gp) # 12094f6 <EsmTimeoutCounter>
                break;
8000934e:	0001                	nop

80009350 <.L218>:
        }
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.
80009350:	17e19783          	lh	a5,382(gp) # 12094f6 <EsmTimeoutCounter>
80009354:	0807c733          	zext.h	a4,a5
80009358:	17e19683          	lh	a3,382(gp) # 12094f6 <EsmTimeoutCounter>
8000935c:	47a9                	li	a5,10
8000935e:	02f6c7b3          	div	a5,a3,a5
80009362:	60579793          	sext.h	a5,a5
80009366:	0807c7b3          	zext.h	a5,a5
8000936a:	40f707b3          	sub	a5,a4,a5
8000936e:	0807c7b3          	zext.h	a5,a5
80009372:	60579713          	sext.h	a4,a5
80009376:	16e19f23          	sh	a4,382(gp) # 12094f6 <EsmTimeoutCounter>
8000937a:	a0d9                	j	80009440 <.L162>

8000937c <.L213>:

    }
    else if ( alControl != (nAlStatus & STATE_MASK) )
8000937c:	00f14703          	lbu	a4,15(sp)
80009380:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80009384:	8bbd                	and	a5,a5,15
80009386:	0af70463          	beq	a4,a5,8000942e <.L219>
    {
        /* The slave state has changed */

        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
8000938a:	01e15783          	lhu	a5,30(sp)
8000938e:	e781                	bnez	a5,80009396 <.L220>
80009390:	00c15783          	lhu	a5,12(sp)
80009394:	cf95                	beqz	a5,800093d0 <.L221>

80009396 <.L220>:
80009396:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000939a:	00f14703          	lbu	a4,15(sp)
8000939e:	8fd9                	or	a5,a5,a4
800093a0:	0ff7f793          	zext.b	a5,a5
800093a4:	8ba1                	and	a5,a5,8
800093a6:	c78d                	beqz	a5,800093d0 <.L221>
        {
            /* the local application requested to leave the state OP so we have to disable the SM2
               and make the state change from OP to SAFEOP by calling StopOutputHandler */

            //only execute StopOutputHandler() if Output update is still running
            if(bEcatOutputUpdateRunning)
800093a8:	19f1c783          	lbu	a5,415(gp) # 1209517 <bEcatOutputUpdateRunning>
800093ac:	c789                	beqz	a5,800093b6 <.L222>
            {
                APPL_StopOutputHandler();
800093ae:	793010ef          	jal	8000b340 <APPL_StopOutputHandler>

                StopOutputHandler();
800093b2:	1e3050ef          	jal	8000ed94 <StopOutputHandler>

800093b6 <.L222>:
            }

            if(nPdOutputSize > 0)
800093b6:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
800093ba:	c789                	beqz	a5,800093c4 <.L223>
            {
                /* disable the Sync Manager Channel 2 (outputs) */
                DisableSyncManChannel(PROCESS_DATA_OUT);
800093bc:	4509                	li	a0,2
800093be:	c7cfe0ef          	jal	8000783a <DisableSyncManChannel>
800093c2:	a039                	j	800093d0 <.L221>

800093c4 <.L223>:
            }
            else
                if(nPdInputSize > 0)
800093c4:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
800093c8:	c781                	beqz	a5,800093d0 <.L221>
            {
                /*disable Sync Manager 3 (inputs) if no outputs available*/
                DisableSyncManChannel(PROCESS_DATA_IN);
800093ca:	450d                	li	a0,3
800093cc:	c6efe0ef          	jal	8000783a <DisableSyncManChannel>

800093d0 <.L221>:
            }

        }
        if ( result != 0 )
800093d0:	01e15783          	lhu	a5,30(sp)
800093d4:	c395                	beqz	a5,800093f8 <.L224>
        {
                if (nAlStatus == STATE_OP)
800093d6:	18b1c703          	lbu	a4,395(gp) # 1209503 <nAlStatus>
800093da:	47a1                	li	a5,8
800093dc:	00f71563          	bne	a4,a5,800093e6 <.L225>
                {
                    nAlStatus = STATE_SAFEOP;
800093e0:	4711                	li	a4,4
800093e2:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>

800093e6 <.L225>:
                }
            /* save the failed status to be able to decide, if the AL Status Code shall be
               reset in case of a coming successful state transition */
            nAlStatus |= STATE_CHANGE;
800093e6:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
800093ea:	0107e793          	or	a5,a5,16
800093ee:	0ff7f713          	zext.b	a4,a5
800093f2:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>
800093f6:	a015                	j	8000941a <.L226>

800093f8 <.L224>:
        }
        else
        {
            /* state transition was successful */
            if ( alStatusCode != 0 )
800093f8:	00c15783          	lhu	a5,12(sp)
800093fc:	cb99                	beqz	a5,80009412 <.L227>
            {
                /* state change request from the user */
                result = alStatusCode;
800093fe:	00c15783          	lhu	a5,12(sp)
80009402:	00f11f23          	sh	a5,30(sp)
                alControl |= STATE_CHANGE;
80009406:	00f14783          	lbu	a5,15(sp)
8000940a:	0107e793          	or	a5,a5,16
8000940e:	00f107a3          	sb	a5,15(sp)

80009412 <.L227>:
            }
            /* acknowledge the new state */
            nAlStatus = alControl;
80009412:	00f14703          	lbu	a4,15(sp)
80009416:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>

8000941a <.L226>:
        }

        bEcatWaitForAlControlRes = FALSE;
8000941a:	18018f23          	sb	zero,414(gp) # 1209516 <bEcatWaitForAlControlRes>

        /* write the AL Status register */
        SetALStatus(nAlStatus, result);
8000941e:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80009422:	01e15703          	lhu	a4,30(sp)
80009426:	85ba                	mv	a1,a4
80009428:	853e                	mv	a0,a5
8000942a:	3215                	jal	80008d4e <SetALStatus>
8000942c:	a811                	j	80009440 <.L162>

8000942e <.L219>:
    }
    else
    {
        /* Error acknowledgement without a state transition */

         bEcatWaitForAlControlRes = FALSE;
8000942e:	18018f23          	sb	zero,414(gp) # 1209516 <bEcatWaitForAlControlRes>

        /* AL-Status has to be updated and AL-Status-Code has to be reset
           if the the error bit was acknowledged */
        SetALStatus(nAlStatus, 0);
80009432:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80009436:	4581                	li	a1,0
80009438:	853e                	mv	a0,a5
8000943a:	3a11                	jal	80008d4e <SetALStatus>
8000943c:	a011                	j	80009440 <.L162>

8000943e <.L228>:
        return;
8000943e:	0001                	nop

80009440 <.L162>:
    }
    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 state machine from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/

}
80009440:	50b2                	lw	ra,44(sp)
80009442:	6145                	add	sp,sp,48
80009444:	8082                	ret

Disassembly of section .text.ECAT_Init:

80009446 <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
80009446:	1101                	add	sp,sp,-32
80009448:	ce06                	sw	ra,28(sp)

8000944a <.LBB14>:
    UINT8 i;
    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    {
    UINT32 TmpVar = 0;
8000944a:	c402                	sw	zero,8(sp)

    HW_EscReadDWord(TmpVar, ESC_COMM_INFO_OFFSET);
8000944c:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
80009450:	0791                	add	a5,a5,4
80009452:	439c                	lw	a5,0(a5)
80009454:	c43e                	sw	a5,8(sp)

    TmpVar = SWAPDWORD(TmpVar);
    nMaxSyncMan = (UINT8)((TmpVar & ESC_SM_CHANNELS_MASK) >> ESC_SM_CHANNELS_SHIFT);
80009456:	47a2                	lw	a5,8(sp)
80009458:	83a1                	srl	a5,a5,0x8
8000945a:	0ff7f713          	zext.b	a4,a5
8000945e:	18e18523          	sb	a4,394(gp) # 1209502 <nMaxSyncMan>

    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    nMaxEscAddress = (UINT16)(((TmpVar & ESC_DPRAM_SIZE_MASK) >> ESC_DPRAM_SIZE_SHIFT) << 10) + 0xFFF;
80009462:	47a2                	lw	a5,8(sp)
80009464:	83c1                	srl	a5,a5,0x10
80009466:	0807c7b3          	zext.h	a5,a5
8000946a:	07aa                	sll	a5,a5,0xa
8000946c:	0807c733          	zext.h	a4,a5
80009470:	6785                	lui	a5,0x1
80009472:	17fd                	add	a5,a5,-1 # fff <.L76+0x39>
80009474:	97ba                	add	a5,a5,a4
80009476:	0807c733          	zext.h	a4,a5
8000947a:	16e19323          	sh	a4,358(gp) # 12094de <nMaxEscAddress>

8000947e <.LBE14>:
    }

/*ECATCHANGE_START(V5.13) ECAT2*/
    u16IdValue = 0;
8000947e:	14019723          	sh	zero,334(gp) # 12094c6 <u16IdValue>
/*ECATCHANGE_END(V5.13) ECAT2*/

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();
80009482:	037050ef          	jal	8000ecb8 <UpdateEEPROMLoadedState>

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
80009486:	000107a3          	sb	zero,15(sp)
8000948a:	a819                	j	800094a0 <.L324>

8000948c <.L325>:
    {
        DisableSyncManChannel(i);
8000948c:	00f14783          	lbu	a5,15(sp)
80009490:	853e                	mv	a0,a5
80009492:	ba8fe0ef          	jal	8000783a <DisableSyncManChannel>
    for (i = 0; i < nMaxSyncMan; i++)
80009496:	00f14783          	lbu	a5,15(sp)
8000949a:	0785                	add	a5,a5,1
8000949c:	00f107a3          	sb	a5,15(sp)

800094a0 <.L324>:
800094a0:	18a1c783          	lbu	a5,394(gp) # 1209502 <nMaxSyncMan>
800094a4:	00f14703          	lbu	a4,15(sp)
800094a8:	fef762e3          	bltu	a4,a5,8000948c <.L325>
    }

    /* initialize the mailbox handler */
    MBX_Init();
800094ac:	28e9                	jal	80009586 <MBX_Init>

    /* initialize variables */
    bApplEsmPending = FALSE;
800094ae:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
    bEcatWaitForAlControlRes = FALSE;
800094b2:	18018f23          	sb	zero,414(gp) # 1209516 <bEcatWaitForAlControlRes>
    bEcatFirstOutputsReceived = FALSE;
800094b6:	1a0180a3          	sb	zero,417(gp) # 1209519 <bEcatFirstOutputsReceived>
     bEcatOutputUpdateRunning = FALSE;
800094ba:	18018fa3          	sb	zero,415(gp) # 1209517 <bEcatOutputUpdateRunning>
     bEcatInputUpdateRunning = FALSE;
800094be:	1a018023          	sb	zero,416(gp) # 1209518 <bEcatInputUpdateRunning>
     bExplicitDevIdRequested = FALSE;
800094c2:	18018e23          	sb	zero,412(gp) # 1209514 <bExplicitDevIdRequested>
    bWdTrigger = FALSE;
800094c6:	18018623          	sb	zero,396(gp) # 1209504 <bWdTrigger>
    EcatWdValue = 0;
800094ca:	18019123          	sh	zero,386(gp) # 12094fa <EcatWdValue>
    Sync0WdCounter = 0;
800094ce:	16019c23          	sh	zero,376(gp) # 12094f0 <Sync0WdCounter>
    Sync0WdValue = 0;
800094d2:	16019b23          	sh	zero,374(gp) # 12094ee <Sync0WdValue>
    Sync1WdCounter = 0;
800094d6:	16019a23          	sh	zero,372(gp) # 12094ec <Sync1WdCounter>
    Sync1WdValue = 0;
800094da:	16019923          	sh	zero,370(gp) # 12094ea <Sync1WdValue>
    bDcSyncActive = FALSE;
800094de:	1a018123          	sb	zero,418(gp) # 120951a <bDcSyncActive>

    /*ECATCHANGE_START(V5.13) ESM1*/
    u8LocalErrorState = 0;
800094e2:	180182a3          	sb	zero,389(gp) # 12094fd <u8LocalErrorState>
    /*ECATCHANGE_END(V5.13) ESM1*/
    u16LocalErrorCode = 0x00;
800094e6:	14019623          	sh	zero,332(gp) # 12094c4 <u16LocalErrorCode>

    u16ALEventMask = 0;
800094ea:	14019d23          	sh	zero,346(gp) # 12094d2 <u16ALEventMask>
    nPdOutputSize = 0;
800094ee:	16019123          	sh	zero,354(gp) # 12094da <nPdOutputSize>
    nPdInputSize = 0;
800094f2:	16019223          	sh	zero,356(gp) # 12094dc <nPdInputSize>

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
800094f6:	4705                	li	a4,1
800094f8:	18e185a3          	sb	a4,395(gp) # 1209503 <nAlStatus>
    SetALStatus(nAlStatus, 0);
800094fc:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80009500:	4581                	li	a1,0
80009502:	853e                	mv	a0,a5
80009504:	30a9                	jal	80008d4e <SetALStatus>
    nEcatStateTrans = 0;
80009506:	16019623          	sh	zero,364(gp) # 12094e4 <nEcatStateTrans>
    u8EcatErrorLed = LED_OFF;
8000950a:	180183a3          	sb	zero,391(gp) # 12094ff <u8EcatErrorLed>

    bEscIntEnabled = FALSE;
8000950e:	18018ea3          	sb	zero,413(gp) # 1209515 <bEscIntEnabled>

    /* initialize the COE part */
    COE_Init();
80009512:	74a050ef          	jal	8000ec5c <COE_Init>

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
    /*reset AL event mask*/
    ResetALEventMask(0);
80009516:	4501                	li	a0,0
80009518:	a12fe0ef          	jal	8000772a <ResetALEventMask>
}
8000951c:	0001                	nop
8000951e:	40f2                	lw	ra,28(sp)
80009520:	6105                	add	sp,sp,32
80009522:	8082                	ret

Disassembly of section .text.GetOutOfMbxQueue:

80009524 <GetOutOfMbxQueue>:
//
//    GetOutOfMbxQueue
//

TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
{
80009524:	1101                	add	sp,sp,-32
80009526:	c62a                	sw	a0,12(sp)
    TMBX MBXMEM * pMbx;
    ENTER_MBX_CRITICAL;

    if (pQueue->firstInQueue != pQueue->lastInQueue)
80009528:	47b2                	lw	a5,12(sp)
8000952a:	0007d703          	lhu	a4,0(a5)
8000952e:	47b2                	lw	a5,12(sp)
80009530:	0027d783          	lhu	a5,2(a5)
80009534:	04f70463          	beq	a4,a5,8000957c <.L6>

80009538 <.LBB2>:
    {
        // Queue ist nicht leer
        UINT16 firstInQueue = pQueue->firstInQueue;
80009538:	47b2                	lw	a5,12(sp)
8000953a:	0007d783          	lhu	a5,0(a5)
8000953e:	00f11d23          	sh	a5,26(sp)
        pMbx = pQueue->queue[firstInQueue];
80009542:	01a15783          	lhu	a5,26(sp)
80009546:	4732                	lw	a4,12(sp)
80009548:	078a                	sll	a5,a5,0x2
8000954a:	97ba                	add	a5,a5,a4
8000954c:	479c                	lw	a5,8(a5)
8000954e:	ce3e                	sw	a5,28(sp)
        firstInQueue++;
80009550:	01a15783          	lhu	a5,26(sp)
80009554:	0785                	add	a5,a5,1
80009556:	00f11d23          	sh	a5,26(sp)
        pQueue->firstInQueue = firstInQueue;
8000955a:	47b2                	lw	a5,12(sp)
8000955c:	01a15703          	lhu	a4,26(sp)
80009560:	00e79023          	sh	a4,0(a5)
        
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
80009564:	47b2                	lw	a5,12(sp)
80009566:	0007d703          	lhu	a4,0(a5)
8000956a:	47b2                	lw	a5,12(sp)
8000956c:	0047d783          	lhu	a5,4(a5)
80009570:	00f71763          	bne	a4,a5,8000957e <.L7>
        {
            // Umbruch der Queue
            pQueue->firstInQueue = 0;
80009574:	47b2                	lw	a5,12(sp)
80009576:	00079023          	sh	zero,0(a5)
8000957a:	a011                	j	8000957e <.L7>

8000957c <.L6>:
        }
    }
    else
    {
        pMbx = 0;
8000957c:	ce02                	sw	zero,28(sp)

8000957e <.L7>:
    }


    LEAVE_MBX_CRITICAL;

    return pMbx;
8000957e:	47f2                	lw	a5,28(sp)
}
80009580:	853e                	mv	a0,a5
80009582:	6105                	add	sp,sp,32
80009584:	8082                	ret

Disassembly of section .text.MBX_Init:

80009586 <MBX_Init>:
/**
 \brief    This function intialize the Mailbox Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
80009586:	1141                	add	sp,sp,-16
    
    u16ReceiveMbxSize = MIN_MBX_SIZE;
80009588:	02400713          	li	a4,36
8000958c:	14e19523          	sh	a4,330(gp) # 12094c2 <u16ReceiveMbxSize>
    u16SendMbxSize = MAX_MBX_SIZE;
80009590:	08000713          	li	a4,128
80009594:	fee19f23          	sh	a4,-2(gp) # 1209376 <u16SendMbxSize>
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
80009598:	6705                	lui	a4,0x1
8000959a:	14e19923          	sh	a4,338(gp) # 12094ca <u16EscAddrReceiveMbx>
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
8000959e:	6705                	lui	a4,0x1
800095a0:	14e19823          	sh	a4,336(gp) # 12094c8 <u16EscAddrSendMbx>

    sMbxReceiveQueue.firstInQueue    = 0;
800095a4:	03418793          	add	a5,gp,52 # 12093ac <sMbxReceiveQueue>
800095a8:	00079023          	sh	zero,0(a5)
    sMbxReceiveQueue.lastInQueue     = 0;
800095ac:	03418793          	add	a5,gp,52 # 12093ac <sMbxReceiveQueue>
800095b0:	00079123          	sh	zero,2(a5)
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
800095b4:	03418793          	add	a5,gp,52 # 12093ac <sMbxReceiveQueue>
800095b8:	4729                	li	a4,10
800095ba:	00e79223          	sh	a4,4(a5)
    sMbxSendQueue.firstInQueue        = 0;
800095be:	00018793          	mv	a5,gp
800095c2:	00079023          	sh	zero,0(a5)
    sMbxSendQueue.lastInQueue         = 0;
800095c6:	00018793          	mv	a5,gp
800095ca:	00079123          	sh	zero,2(a5)
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
800095ce:	00018793          	mv	a5,gp
800095d2:	4729                	li	a4,10
800095d4:	00e79223          	sh	a4,4(a5)
    psWriteMbx  = NULL;
800095d8:	0a01ae23          	sw	zero,188(gp) # 1209434 <psWriteMbx>


    psRepeatMbx = NULL;
800095dc:	0c01a223          	sw	zero,196(gp) # 120943c <psRepeatMbx>
    psReadMbx    = NULL;
800095e0:	0c01a423          	sw	zero,200(gp) # 1209440 <psReadMbx>
    psStoreMbx    = NULL;
800095e4:	0c01a023          	sw	zero,192(gp) # 1209438 <psStoreMbx>

    bMbxRepeatToggle    = FALSE;
800095e8:	18018d23          	sb	zero,410(gp) # 1209512 <bMbxRepeatToggle>

800095ec <.LBB3>:
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
     {
        UINT32 sm1Activate = 0;
800095ec:	c602                	sw	zero,12(sp)
        HW_EscReadDWord(sm1Activate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
800095ee:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
800095f2:	6785                	lui	a5,0x1
800095f4:	80c78793          	add	a5,a5,-2036 # 80c <.L13+0x32>
800095f8:	97ba                	add	a5,a5,a4
800095fa:	439c                	lw	a5,0(a5)
800095fc:	c63e                	sw	a5,12(sp)
        sm1Activate &= SWAPDWORD(~0x02000000);
800095fe:	4732                	lw	a4,12(sp)
80009600:	fe0007b7          	lui	a5,0xfe000
80009604:	17fd                	add	a5,a5,-1 # fdffffff <__AHB_SRAM_segment_end__+0xddf7fff>
80009606:	8ff9                	and	a5,a5,a4
80009608:	c63e                	sw	a5,12(sp)
        HW_EscWriteDWord(sm1Activate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
8000960a:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000960e:	6785                	lui	a5,0x1
80009610:	80c78793          	add	a5,a5,-2036 # 80c <.L13+0x32>
80009614:	97ba                	add	a5,a5,a4
80009616:	4732                	lw	a4,12(sp)
80009618:	c398                	sw	a4,0(a5)

8000961a <.LBE3>:
    }
    bMbxRunning = FALSE;
8000961a:	18018ca3          	sb	zero,409(gp) # 1209511 <bMbxRunning>
    bSendMbxIsFull = FALSE;
8000961e:	18018823          	sb	zero,400(gp) # 1209508 <bSendMbxIsFull>
    bReceiveMbxIsLocked = FALSE;
80009622:	18018b23          	sb	zero,406(gp) # 120950e <bReceiveMbxIsLocked>
    u8MailboxSendReqStored    = 0;
80009626:	18018223          	sb	zero,388(gp) # 12094fc <u8MailboxSendReqStored>
    u8MbxWriteCounter = 0;
8000962a:	fa018ea3          	sb	zero,-67(gp) # 1209335 <u8MbxWriteCounter>
    u8MbxReadCounter    = 0;
8000962e:	fe018ea3          	sb	zero,-3(gp) # 1209375 <u8MbxReadCounter>
}
80009632:	0001                	nop
80009634:	0141                	add	sp,sp,16
80009636:	8082                	ret

Disassembly of section .text.MBX_MailboxReadInd:

80009638 <MBX_MailboxReadInd>:
/**
 \brief This function is called when the Master has read the Send-Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_MailboxReadInd(void)
{
80009638:	1101                	add	sp,sp,-32
8000963a:	ce06                	sw	ra,28(sp)
    bSendMbxIsFull = FALSE;
8000963c:	18018823          	sb	zero,400(gp) # 1209508 <bSendMbxIsFull>

    // HBu 02.05.06: the pointer psRepeatMbx is only free if there is no stored
    //               mailbox service from the last repeat
    if (psRepeatMbx && psStoreMbx == NULL)
80009640:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
80009644:	c38d                	beqz	a5,80009666 <.L36>
80009646:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
8000964a:	ef91                	bnez	a5,80009666 <.L36>
    {
        /* the last sent service is not stored for repeat any longer */
/*ECATCHANGE_START(V5.13) MBX3*/
        if (psReadMbx != psRepeatMbx)
8000964c:	0c81a703          	lw	a4,200(gp) # 1209440 <psReadMbx>
80009650:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
80009654:	00f70963          	beq	a4,a5,80009666 <.L36>
        {
            APPL_FreeMailboxBuffer(psRepeatMbx);
80009658:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000965c:	853e                	mv	a0,a5
8000965e:	2080b0ef          	jal	80014866 <free>
            psRepeatMbx = NULL;
80009662:	0c01a223          	sw	zero,196(gp) # 120943c <psRepeatMbx>

80009666 <.L36>:
/*ECATCHANGE_END(V5.13) MBX3*/

    }

    /* the actual sent service has to be stored for repeat */
    psRepeatMbx = psReadMbx;
80009666:	0c81a703          	lw	a4,200(gp) # 1209440 <psReadMbx>
8000966a:	0ce1a223          	sw	a4,196(gp) # 120943c <psRepeatMbx>

      if ( psStoreMbx )
8000966e:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
80009672:	cb81                	beqz	a5,80009682 <.L37>
      {
        /* there was a buffer stored */
        MBX_CopyToSendMailbox(psStoreMbx);
80009674:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
80009678:	853e                	mv	a0,a5
8000967a:	2a89                	jal	800097cc <MBX_CopyToSendMailbox>
        /* no more buffer to be stored any more */
        psStoreMbx = NULL;
8000967c:	0c01a023          	sw	zero,192(gp) # 1209438 <psStoreMbx>
80009680:	a809                	j	80009692 <.L38>

80009682 <.L37>:
      }
      else
    {
        TMBX MBXMEM* pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
80009682:	00018513          	mv	a0,gp
80009686:	3d79                	jal	80009524 <GetOutOfMbxQueue>
80009688:	c62a                	sw	a0,12(sp)

        
        if (pMbx)
8000968a:	47b2                	lw	a5,12(sp)
8000968c:	c399                	beqz	a5,80009692 <.L38>
        {
            MBX_CopyToSendMailbox(pMbx);
8000968e:	4532                	lw	a0,12(sp)
80009690:	2a35                	jal	800097cc <MBX_CopyToSendMailbox>

80009692 <.L38>:
        }
    }

      if ( u8MailboxSendReqStored )
80009692:	1841c783          	lbu	a5,388(gp) # 12094fc <u8MailboxSendReqStored>
80009696:	c3a9                	beqz	a5,800096d8 <.L40>
    {
        /* there are mailbox services stored to be sent */
        if ( u8MailboxSendReqStored & COE_SERVICE )
80009698:	1841c783          	lbu	a5,388(gp) # 12094fc <u8MailboxSendReqStored>
8000969c:	8b89                	and	a5,a5,2
8000969e:	cf8d                	beqz	a5,800096d8 <.L40>

800096a0 <.LBB6>:
        {
           UINT8 result = 0;
800096a0:	000105a3          	sb	zero,11(sp)
            /* reset the flag indicating that CoE service to be sent was stored */
            u8MailboxSendReqStored &= ~COE_SERVICE;
800096a4:	1841c783          	lbu	a5,388(gp) # 12094fc <u8MailboxSendReqStored>
800096a8:	9bf5                	and	a5,a5,-3
800096aa:	0ff7f713          	zext.b	a4,a5
800096ae:	18e18223          	sb	a4,388(gp) # 12094fc <u8MailboxSendReqStored>

            /* call CoE function that will send the stored CoE service */
            result = COE_ContinueInd(psWriteMbx);
800096b2:	0bc1a783          	lw	a5,188(gp) # 1209434 <psWriteMbx>
800096b6:	853e                	mv	a0,a5
800096b8:	5b0050ef          	jal	8000ec68 <COE_ContinueInd>
800096bc:	87aa                	mv	a5,a0
800096be:	00f105a3          	sb	a5,11(sp)

            if (result != 0)
800096c2:	00b14783          	lbu	a5,11(sp)
800096c6:	cb89                	beqz	a5,800096d8 <.L40>
            {
                /*Set the pending CoE indication is an error occurred during the continue indication*/
                u8MailboxSendReqStored |= COE_SERVICE;
800096c8:	1841c783          	lbu	a5,388(gp) # 12094fc <u8MailboxSendReqStored>
800096cc:	0027e793          	or	a5,a5,2
800096d0:	0ff7f713          	zext.b	a4,a5
800096d4:	18e18223          	sb	a4,388(gp) # 12094fc <u8MailboxSendReqStored>

800096d8 <.L40>:
/*ECATCHANGE_END(V5.13) EOE1*/

        {
        }
    }
}
800096d8:	0001                	nop
800096da:	40f2                	lw	ra,28(sp)
800096dc:	6105                	add	sp,sp,32
800096de:	8082                	ret

Disassembly of section .text.MBX_MailboxSendReq:

800096e0 <MBX_MailboxSendReq>:

 \brief        This function puts a new Mailbox service in the Send Mailbox
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_MailboxSendReq( TMBX MBXMEM * pMbx, UINT8 flags )
{
800096e0:	7179                	add	sp,sp,-48
800096e2:	d606                	sw	ra,44(sp)
800096e4:	c62a                	sw	a0,12(sp)
800096e6:	87ae                	mv	a5,a1
800096e8:	00f105a3          	sb	a5,11(sp)
    UINT8 result = 0;
800096ec:	00010fa3          	sb	zero,31(sp)

    /* HBu 06.02.06: in INIT-state a mailbox send request shall be refused */
    if ( (nAlStatus & STATE_MASK) == STATE_INIT )
800096f0:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
800096f4:	00f7f713          	and	a4,a5,15
800096f8:	4785                	li	a5,1
800096fa:	00f71563          	bne	a4,a5,80009704 <.L45>
    {
        return ERROR_INVALIDSTATE;
800096fe:	0f000793          	li	a5,240
80009702:	a0c9                	j	800097c4 <.L46>

80009704 <.L45>:

    ENTER_MBX_CRITICAL;

    /* the counter in the mailbox header has to be incremented with every new mailbox service to be sent
       if the mailbox data link layer is supported (software switch MAILBOX_REPEAT_SUPPORTED set)*/
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
80009704:	47b2                	lw	a5,12(sp)
80009706:	0057c783          	lbu	a5,5(a5)
8000970a:	8bbd                	and	a5,a5,15
8000970c:	0ff7f713          	zext.b	a4,a5
80009710:	47b2                	lw	a5,12(sp)
80009712:	00e782a3          	sb	a4,5(a5)
    /* HBu 13.02.06: Repeat-Counter was incremented too much if the mailbox service could not be sent */
    /* u8MbxCounter holds the actual counter for the mailbox header, only the values
       1-7 are allowed if the mailbox data link layer is supported  */
    if ( (u8MbxReadCounter & 0x07) == 0 )
80009716:	ffd1c783          	lbu	a5,-3(gp) # 1209375 <u8MbxReadCounter>
8000971a:	8b9d                	and	a5,a5,7
8000971c:	e781                	bnez	a5,80009724 <.L47>
    {
        u8MbxReadCounter = 1;
8000971e:	4705                	li	a4,1
80009720:	fee18ea3          	sb	a4,-3(gp) # 1209375 <u8MbxReadCounter>

80009724 <.L47>:
    }

    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
80009724:	47b2                	lw	a5,12(sp)
80009726:	0057c783          	lbu	a5,5(a5)
8000972a:	60479713          	sext.b	a4,a5
8000972e:	ffd1c783          	lbu	a5,-3(gp) # 1209375 <u8MbxReadCounter>
80009732:	60479793          	sext.b	a5,a5
80009736:	0792                	sll	a5,a5,0x4
80009738:	60479793          	sext.b	a5,a5
8000973c:	8fd9                	or	a5,a5,a4
8000973e:	60479793          	sext.b	a5,a5
80009742:	0ff7f713          	zext.b	a4,a5
80009746:	47b2                	lw	a5,12(sp)
80009748:	00e782a3          	sb	a4,5(a5)

    /* try to copy the mailbox command in the ESC */
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
8000974c:	4532                	lw	a0,12(sp)
8000974e:	28bd                	jal	800097cc <.LFE237>
80009750:	87aa                	mv	a5,a0
80009752:	cb9d                	beqz	a5,80009788 <.L48>
    {
        /* no success, send mailbox was full, set flag  */
        result = PutInMbxQueue(pMbx, &sMbxSendQueue);
80009754:	00018593          	mv	a1,gp
80009758:	4532                	lw	a0,12(sp)
8000975a:	593050ef          	jal	8000f4ec <PutInMbxQueue>
8000975e:	87aa                	mv	a5,a0
80009760:	00f10fa3          	sb	a5,31(sp)
        if (result != 0)
80009764:	01f14783          	lbu	a5,31(sp)
80009768:	cb81                	beqz	a5,80009778 <.L49>
        {
            flags |= FRAGMENTS_FOLLOW;
8000976a:	00b14783          	lbu	a5,11(sp)
8000976e:	f807e793          	or	a5,a5,-128
80009772:	00f105a3          	sb	a5,11(sp)
80009776:	a005                	j	80009796 <.L50>

80009778 <.L49>:
        }
        else
        {
            u8MbxReadCounter++;
80009778:	ffd1c783          	lbu	a5,-3(gp) # 1209375 <u8MbxReadCounter>
8000977c:	0785                	add	a5,a5,1
8000977e:	0ff7f713          	zext.b	a4,a5
80009782:	fee18ea3          	sb	a4,-3(gp) # 1209375 <u8MbxReadCounter>
80009786:	a801                	j	80009796 <.L50>

80009788 <.L48>:
        }
    }
    /* HBu 13.02.06: Repeat-Counter was incremented too much if the mailbox service could not be sent */
    else
    {
        u8MbxReadCounter++;
80009788:	ffd1c783          	lbu	a5,-3(gp) # 1209375 <u8MbxReadCounter>
8000978c:	0785                	add	a5,a5,1
8000978e:	0ff7f713          	zext.b	a4,a5
80009792:	fee18ea3          	sb	a4,-3(gp) # 1209375 <u8MbxReadCounter>

80009796 <.L50>:
    }

    if ( flags & FRAGMENTS_FOLLOW )
80009796:	00b10783          	lb	a5,11(sp)
8000979a:	0207d363          	bgez	a5,800097c0 <.L51>
    {
        /* store the mailbox service that the corresponding XXX_ContinueInd function will
           be called when the send mailbox will have been read by the master because there
           are mailbox commands to be sent for this service */
        u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
8000979e:	00b10783          	lb	a5,11(sp)
800097a2:	07f7f793          	and	a5,a5,127
800097a6:	60479713          	sext.b	a4,a5
800097aa:	1841c783          	lbu	a5,388(gp) # 12094fc <u8MailboxSendReqStored>
800097ae:	60479793          	sext.b	a5,a5
800097b2:	8fd9                	or	a5,a5,a4
800097b4:	60479793          	sext.b	a5,a5
800097b8:	0ff7f713          	zext.b	a4,a5
800097bc:	18e18223          	sb	a4,388(gp) # 12094fc <u8MailboxSendReqStored>

800097c0 <.L51>:
    }

    LEAVE_MBX_CRITICAL;

    return result;
800097c0:	01f14783          	lbu	a5,31(sp)

800097c4 <.L46>:
}
800097c4:	853e                	mv	a0,a5
800097c6:	50b2                	lw	ra,44(sp)
800097c8:	6145                	add	sp,sp,48
800097ca:	8082                	ret

Disassembly of section .text.MBX_CopyToSendMailbox:

800097cc <MBX_CopyToSendMailbox>:

 \brief    This function copies data to the Send Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
{
800097cc:	7179                	add	sp,sp,-48
800097ce:	d606                	sw	ra,44(sp)
800097d0:	c62a                	sw	a0,12(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
800097d2:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
800097d6:	00f7f713          	and	a4,a5,15
800097da:	4785                	li	a5,1
800097dc:	00f71563          	bne	a4,a5,800097e6 <.L61>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
800097e0:	0f000793          	li	a5,240
800097e4:	a2ad                	j	8000994e <.L62>

800097e6 <.L61>:
    }


    if ( !bMbxRunning )
800097e6:	1991c783          	lbu	a5,409(gp) # 1209511 <bMbxRunning>
800097ea:	e781                	bnez	a5,800097f2 <.L63>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
800097ec:	0f000793          	li	a5,240
800097f0:	aab9                	j	8000994e <.L62>

800097f2 <.L63>:
    }

    if ( bSendMbxIsFull )
800097f2:	1901c783          	lbu	a5,400(gp) # 1209508 <bSendMbxIsFull>
800097f6:	c399                	beqz	a5,800097fc <.L64>
    {
        /* mailbox service cannot be sent because the send mailbox is still full */
        return MBXERR_NOMOREMEMORY;
800097f8:	479d                	li	a5,7
800097fa:	aa91                	j	8000994e <.L62>

800097fc <.L64>:
    }
    else
    {
        /* the variable mbxSize contains the size of the mailbox data to be sent */
        UINT16 mbxSize = pMbx->MbxHeader.Length;
800097fc:	47b2                	lw	a5,12(sp)
800097fe:	0007c703          	lbu	a4,0(a5)
80009802:	0017c783          	lbu	a5,1(a5)
80009806:	07a2                	sll	a5,a5,0x8
80009808:	8fd9                	or	a5,a5,a4
8000980a:	00f11e23          	sh	a5,28(sp)

8000980e <.LBB11>:
/*ECATCHANGE_START(V5.13) MBX2*/
        /*Reset the not used mailbox memory*/
        {
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
8000980e:	1501d783          	lhu	a5,336(gp) # 12094c8 <u16EscAddrSendMbx>
80009812:	01c15703          	lhu	a4,28(sp)
80009816:	97ba                	add	a5,a5,a4
80009818:	0807c7b3          	zext.h	a5,a5
8000981c:	0799                	add	a5,a5,6
8000981e:	00f11f23          	sh	a5,30(sp)
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
80009822:	1501d703          	lhu	a4,336(gp) # 12094c8 <u16EscAddrSendMbx>
80009826:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
8000982a:	97ba                	add	a5,a5,a4
8000982c:	00f11d23          	sh	a5,26(sp)
            /*round down to last even 32bit address*/
            LastUsedAddr = LastUsedAddr & 0xFFFC;
80009830:	01e15783          	lhu	a5,30(sp)
80009834:	9bf9                	and	a5,a5,-2
80009836:	9bf5                	and	a5,a5,-3
80009838:	00f11f23          	sh	a5,30(sp)
            LastAddrToReset = (LastAddrToReset - 4) & 0xFFFC;
8000983c:	01a15783          	lhu	a5,26(sp)
80009840:	17f1                	add	a5,a5,-4
80009842:	0807c7b3          	zext.h	a5,a5
80009846:	9bf9                	and	a5,a5,-2
80009848:	9bf5                	and	a5,a5,-3
8000984a:	00f11d23          	sh	a5,26(sp)
            u32dummy = 0;
8000984e:	0801ac23          	sw	zero,152(gp) # 1209410 <u32dummy>

            /*clear all unused bytes*/
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
80009852:	a015                	j	80009876 <.L65>

80009854 <.L66>:
            {
                HW_EscWriteDWord(u32dummy, LastUsedAddr);
80009854:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80009858:	01e15783          	lhu	a5,30(sp)
8000985c:	8389                	srl	a5,a5,0x2
8000985e:	0807c7b3          	zext.h	a5,a5
80009862:	078a                	sll	a5,a5,0x2
80009864:	97ba                	add	a5,a5,a4
80009866:	0981a703          	lw	a4,152(gp) # 1209410 <u32dummy>
8000986a:	c398                	sw	a4,0(a5)
                LastUsedAddr = LastUsedAddr + 4;
8000986c:	01e15783          	lhu	a5,30(sp)
80009870:	0791                	add	a5,a5,4
80009872:	00f11f23          	sh	a5,30(sp)

80009876 <.L65>:
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
80009876:	01e15703          	lhu	a4,30(sp)
8000987a:	01a15783          	lhu	a5,26(sp)
8000987e:	fcf76be3          	bltu	a4,a5,80009854 <.L66>

80009882 <.LBE11>:
            }

        }
/*ECATCHANGE_END(V5.13) MBX2*/

        HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
80009882:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
80009886:	1501d783          	lhu	a5,336(gp) # 12094c8 <u16EscAddrSendMbx>
8000988a:	8389                	srl	a5,a5,0x2
8000988c:	0807c7b3          	zext.h	a5,a5
80009890:	078a                	sll	a5,a5,0x2
80009892:	973e                	add	a4,a4,a5
80009894:	01c15783          	lhu	a5,28(sp)
80009898:	0799                	add	a5,a5,6
8000989a:	863e                	mv	a2,a5
8000989c:	45b2                	lw	a1,12(sp)
8000989e:	853a                	mv	a0,a4
800098a0:	3bc040ef          	jal	8000dc5c <memcpy>

800098a4 <.LBB12>:


        {
        /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
        VARVOLATILE UINT32 smstate = 0x00;
800098a4:	c802                	sw	zero,16(sp)
        HW_EscReadDWord(smstate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
800098a6:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
800098aa:	6785                	lui	a5,0x1
800098ac:	80c78793          	add	a5,a5,-2036 # 80c <.L13+0x32>
800098b0:	97ba                	add	a5,a5,a4
800098b2:	439c                	lw	a5,0(a5)
800098b4:	c83e                	sw	a5,16(sp)
        smstate = SWAPDWORD(smstate);
800098b6:	47c2                	lw	a5,16(sp)
800098b8:	c83e                	sw	a5,16(sp)

        if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
800098ba:	4742                	lw	a4,16(sp)
800098bc:	28b01793          	bset	a5,zero,0xb
800098c0:	8ff9                	and	a5,a5,a4
800098c2:	ebb5                	bnez	a5,80009936 <.L67>

800098c4 <.LBB13>:
        {
            
            UINT16 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
800098c4:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
800098c8:	01c15703          	lhu	a4,28(sp)
800098cc:	8f99                	sub	a5,a5,a4
800098ce:	0807c7b3          	zext.h	a5,a5
800098d2:	17e9                	add	a5,a5,-6
800098d4:	00f11c23          	sh	a5,24(sp)

            /*Write last Byte to trigger mailbox full flag*/
            /*Read last 4 Bytes and write them again (required if low 3 Bytes of the DWORD were written before)*/
            u32dummy = 0;
800098d8:	0801ac23          	sw	zero,152(gp) # 1209410 <u32dummy>
            if(BytesLeft < 4)
800098dc:	01815703          	lhu	a4,24(sp)
800098e0:	478d                	li	a5,3
800098e2:	02e7eb63          	bltu	a5,a4,80009918 <.L68>

800098e6 <.LBB14>:
            {
                /*The last 4Bytes are overlapping the already written buffer*/

                /*Get the valid 32Bit address*/
                UINT32 LastDataAddress = ((mbxSize + MBX_HEADER_SIZE)/4);
800098e6:	01c15783          	lhu	a5,28(sp)
800098ea:	0799                	add	a5,a5,6
800098ec:	41f7d713          	sra	a4,a5,0x1f
800098f0:	8b0d                	and	a4,a4,3
800098f2:	97ba                	add	a5,a5,a4
800098f4:	8789                	sra	a5,a5,0x2
800098f6:	ca3e                	sw	a5,20(sp)


                /*Copy the buffer to overwrite*/
                MEMCPY((UINT32 *)&u32dummy,(((UINT32 *)pMbx) + LastDataAddress),(4 - BytesLeft));
800098f8:	47d2                	lw	a5,20(sp)
800098fa:	078a                	sll	a5,a5,0x2
800098fc:	4732                	lw	a4,12(sp)
800098fe:	00f706b3          	add	a3,a4,a5
80009902:	01815783          	lhu	a5,24(sp)
80009906:	4711                	li	a4,4
80009908:	40f707b3          	sub	a5,a4,a5
8000990c:	863e                	mv	a2,a5
8000990e:	85b6                	mv	a1,a3
80009910:	09818513          	add	a0,gp,152 # 1209410 <u32dummy>
80009914:	348040ef          	jal	8000dc5c <memcpy>

80009918 <.L68>:
            }

            HW_EscWriteDWord(u32dummy, (u16EscAddrSendMbx + u16SendMbxSize - 4));
80009918:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000991c:	1501d783          	lhu	a5,336(gp) # 12094c8 <u16EscAddrSendMbx>
80009920:	86be                	mv	a3,a5
80009922:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80009926:	97b6                	add	a5,a5,a3
80009928:	17f1                	add	a5,a5,-4
8000992a:	8789                	sra	a5,a5,0x2
8000992c:	078a                	sll	a5,a5,0x2
8000992e:	97ba                	add	a5,a5,a4
80009930:	0981a703          	lw	a4,152(gp) # 1209410 <u32dummy>
80009934:	c398                	sw	a4,0(a5)

80009936 <.L67>:
            the other one the actual service to be sent (psReadMbx),
            there is no buffer available for a mailbox receive service
            until the last sent buffer was read from the master
            the exception is after the INIT2PREOP transition, in that
            case there is no last sent service (psReadMbx = 0) */
        if ( psReadMbx )
80009936:	0c81a783          	lw	a5,200(gp) # 1209440 <psReadMbx>
8000993a:	c399                	beqz	a5,80009940 <.L69>
        {
            psWriteMbx = NULL;
8000993c:	0a01ae23          	sw	zero,188(gp) # 1209434 <psWriteMbx>

80009940 <.L69>:
        }
        psReadMbx = pMbx;
80009940:	4732                	lw	a4,12(sp)
80009942:	0ce1a423          	sw	a4,200(gp) # 1209440 <psReadMbx>

        /* set flag that send mailbox is full now */
        bSendMbxIsFull = TRUE;
80009946:	4705                	li	a4,1
80009948:	18e18823          	sb	a4,400(gp) # 1209508 <bSendMbxIsFull>


        return 0;
8000994c:	4781                	li	a5,0

8000994e <.L62>:
    }
}
8000994e:	853e                	mv	a0,a5
80009950:	50b2                	lw	ra,44(sp)
80009952:	6145                	add	sp,sp,48
80009954:	8082                	ret

Disassembly of section .text.MBX_Main:

80009956 <MBX_Main>:
 \brief    This function is called cyclically to check if a received Mailbox service was
             stored.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Main(void)
{
80009956:	1101                	add	sp,sp,-32
80009958:	ce06                	sw	ra,28(sp)
    TMBX MBXMEM *pMbx = NULL;
8000995a:	c402                	sw	zero,8(sp)

8000995c <.L73>:

    do
    {
        UINT8 result = 0;
8000995c:	000107a3          	sb	zero,15(sp)

        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
80009960:	03418513          	add	a0,gp,52 # 12093ac <sMbxReceiveQueue>
80009964:	36c1                	jal	80009524 <GetOutOfMbxQueue>
80009966:	c42a                	sw	a0,8(sp)
        if ( pMbx )
80009968:	47a2                	lw	a5,8(sp)
8000996a:	c799                	beqz	a5,80009978 <.L71>
        {
            result = MailboxServiceInd(pMbx);
8000996c:	4522                	lw	a0,8(sp)
8000996e:	623050ef          	jal	8000f790 <MailboxServiceInd>
80009972:	87aa                	mv	a5,a0
80009974:	00f107a3          	sb	a5,15(sp)

80009978 <.L71>:
        }

        if ( result != 0 )
80009978:	00f14783          	lbu	a5,15(sp)
8000997c:	cfad                	beqz	a5,800099f6 <.L72>
        {
            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
8000997e:	47a2                	lw	a5,8(sp)
80009980:	0007c703          	lbu	a4,0(a5)
80009984:	8b01                	and	a4,a4,0
80009986:	00476713          	or	a4,a4,4
8000998a:	00e78023          	sb	a4,0(a5)
8000998e:	0017c703          	lbu	a4,1(a5)
80009992:	8b01                	and	a4,a4,0
80009994:	00e780a3          	sb	a4,1(a5)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
80009998:	47a2                	lw	a5,8(sp)
8000999a:	0057c783          	lbu	a5,5(a5)
8000999e:	9bc1                	and	a5,a5,-16
800099a0:	0ff7f713          	zext.b	a4,a5
800099a4:	47a2                	lw	a5,8(sp)
800099a6:	00e782a3          	sb	a4,5(a5)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
800099aa:	47a2                	lw	a5,8(sp)
800099ac:	0067c703          	lbu	a4,6(a5)
800099b0:	8b01                	and	a4,a4,0
800099b2:	00176713          	or	a4,a4,1
800099b6:	00e78323          	sb	a4,6(a5)
800099ba:	0077c703          	lbu	a4,7(a5)
800099be:	8b01                	and	a4,a4,0
800099c0:	00e783a3          	sb	a4,7(a5)
            pMbx->Data[1]                        = SWAPWORD(result);
800099c4:	00f14783          	lbu	a5,15(sp)
800099c8:	0807c733          	zext.h	a4,a5
800099cc:	47a2                	lw	a5,8(sp)
800099ce:	0ff77693          	zext.b	a3,a4
800099d2:	0087c603          	lbu	a2,8(a5)
800099d6:	8a01                	and	a2,a2,0
800099d8:	8ed1                	or	a3,a3,a2
800099da:	00d78423          	sb	a3,8(a5)
800099de:	8321                	srl	a4,a4,0x8
800099e0:	08074733          	zext.h	a4,a4
800099e4:	0097c683          	lbu	a3,9(a5)
800099e8:	8a81                	and	a3,a3,0
800099ea:	8f55                	or	a4,a4,a3
800099ec:	00e784a3          	sb	a4,9(a5)
            MBX_MailboxSendReq(pMbx, 0);
800099f0:	4581                	li	a1,0
800099f2:	4522                	lw	a0,8(sp)
800099f4:	31f5                	jal	800096e0 <MBX_MailboxSendReq>

800099f6 <.L72>:
        }
    }
    while ( pMbx != NULL );
800099f6:	47a2                	lw	a5,8(sp)
800099f8:	f3b5                	bnez	a5,8000995c <.L73>


    if (bReceiveMbxIsLocked)
800099fa:	1961c783          	lbu	a5,406(gp) # 120950e <bReceiveMbxIsLocked>
800099fe:	c399                	beqz	a5,80009a04 <.L75>
    {
        /* the work on the receive mailbox is locked, check if it can be unlocked (if all
           mailbox commands has been sent */
        MBX_CheckAndCopyMailbox();
80009a00:	77b050ef          	jal	8000f97a <MBX_CheckAndCopyMailbox>

80009a04 <.L75>:
    if (u8MailboxSendReqStored)
    {
        /* there are mailbox services stored to be sent */
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
80009a04:	0001                	nop
80009a06:	40f2                	lw	ra,28(sp)
80009a08:	6105                	add	sp,sp,32
80009a0a:	8082                	ret

Disassembly of section .text.OBJ_GetObjectLength:

80009a0c <OBJ_GetObjectLength>:

 \brief     This function returns the size of the requested entry. If bCompleteaccess is set the size of the complete object is returned (the returned size is byte packed, gaps based on the used platform/compiler are not taken into account)

*////////////////////////////////////////////////////////////////////////////////////////
UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
{
80009a0c:	1101                	add	sp,sp,-32
80009a0e:	87aa                	mv	a5,a0
80009a10:	c432                	sw	a2,8(sp)
80009a12:	8736                	mv	a4,a3
80009a14:	00f11723          	sh	a5,14(sp)
80009a18:	87ae                	mv	a5,a1
80009a1a:	00f106a3          	sb	a5,13(sp)
80009a1e:	87ba                	mv	a5,a4
80009a20:	00f10623          	sb	a5,12(sp)
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
80009a24:	47a2                	lw	a5,8(sp)
80009a26:	00c7d783          	lhu	a5,12(a5)
80009a2a:	87a1                	sra	a5,a5,0x8
80009a2c:	0ff7f793          	zext.b	a5,a5
80009a30:	8bbd                	and	a5,a5,15
80009a32:	00f10ca3          	sb	a5,25(sp)
    
    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
80009a36:	47a2                	lw	a5,8(sp)
80009a38:	00c7d783          	lhu	a5,12(a5)
80009a3c:	00f10c23          	sb	a5,24(sp)
    UINT32 size = 0;
80009a40:	ce02                	sw	zero,28(sp)

    if ( bCompleteAccess )
80009a42:	00c14783          	lbu	a5,12(sp)
80009a46:	c3f1                	beqz	a5,80009b0a <.L7>
    {
        if ( objCode == OBJCODE_VAR )
80009a48:	01914703          	lbu	a4,25(sp)
80009a4c:	479d                	li	a5,7
80009a4e:	00f71463          	bne	a4,a5,80009a56 <.L8>
        {
            return 0;
80009a52:	4781                	li	a5,0
80009a54:	a281                	j	80009b94 <.L9>

80009a56 <.L8>:
        }
        else if ((objCode == OBJCODE_ARR)
80009a56:	01914703          	lbu	a4,25(sp)
80009a5a:	47a1                	li	a5,8
80009a5c:	04f71563          	bne	a4,a5,80009aa6 <.L10>
            )
        {

            /* we have to get the maxSubindex from the actual value of subindex 0,
                which is stored as UINT16 at the beginning of the object's variable */
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
80009a60:	47a2                	lw	a5,8(sp)
80009a62:	4f9c                	lw	a5,24(a5)
80009a64:	0007d783          	lhu	a5,0(a5)
80009a68:	00f10c23          	sb	a5,24(sp)


            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
80009a6c:	47a2                	lw	a5,8(sp)
80009a6e:	4b9c                	lw	a5,16(a5)
80009a70:	0799                	add	a5,a5,6
80009a72:	0027c703          	lbu	a4,2(a5)
80009a76:	0037c783          	lbu	a5,3(a5)
80009a7a:	07a2                	sll	a5,a5,0x8
80009a7c:	8fd9                	or	a5,a5,a4
80009a7e:	0807c7b3          	zext.h	a5,a5
80009a82:	873e                	mv	a4,a5
80009a84:	01814783          	lbu	a5,24(sp)
80009a88:	02f707b3          	mul	a5,a4,a5
80009a8c:	ce3e                	sw	a5,28(sp)

/* no padding required: Bit entries within an array object may overlap byte borders*/

            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
80009a8e:	47f2                	lw	a5,28(sp)
80009a90:	079d                	add	a5,a5,7
80009a92:	838d                	srl	a5,a5,0x3
80009a94:	ce3e                	sw	a5,28(sp)

            if ( subindex == 0 )
80009a96:	00d14783          	lbu	a5,13(sp)
80009a9a:	e781                	bnez	a5,80009aa2 <.L11>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
80009a9c:	47f2                	lw	a5,28(sp)
80009a9e:	0789                	add	a5,a5,2
80009aa0:	ce3e                	sw	a5,28(sp)

80009aa2 <.L11>:
            }
            return size;
80009aa2:	47f2                	lw	a5,28(sp)
80009aa4:	a8c5                	j	80009b94 <.L9>

80009aa6 <.L10>:
/*ECATCHANGE_START(V5.13) COE1*/
            UINT16 i;
/*ECATCHANGE_END(V5.13) COE1*/

            /* add the sizes of all entries */
            for (i = 1; i <= maxSubindex; i++)
80009aa6:	4785                	li	a5,1
80009aa8:	00f11d23          	sh	a5,26(sp)
80009aac:	a81d                	j	80009ae2 <.L12>

80009aae <.L13>:
            {
                size += pObjEntry->pEntryDesc[i].BitLength;
80009aae:	47a2                	lw	a5,8(sp)
80009ab0:	4b94                	lw	a3,16(a5)
80009ab2:	01a15703          	lhu	a4,26(sp)
80009ab6:	87ba                	mv	a5,a4
80009ab8:	0786                	sll	a5,a5,0x1
80009aba:	97ba                	add	a5,a5,a4
80009abc:	0786                	sll	a5,a5,0x1
80009abe:	97b6                	add	a5,a5,a3
80009ac0:	0027c703          	lbu	a4,2(a5)
80009ac4:	0037c783          	lbu	a5,3(a5)
80009ac8:	07a2                	sll	a5,a5,0x8
80009aca:	8fd9                	or	a5,a5,a4
80009acc:	0807c7b3          	zext.h	a5,a5
80009ad0:	873e                	mv	a4,a5
80009ad2:	47f2                	lw	a5,28(sp)
80009ad4:	97ba                	add	a5,a5,a4
80009ad6:	ce3e                	sw	a5,28(sp)
            for (i = 1; i <= maxSubindex; i++)
80009ad8:	01a15783          	lhu	a5,26(sp)
80009adc:	0785                	add	a5,a5,1
80009ade:	00f11d23          	sh	a5,26(sp)

80009ae2 <.L12>:
80009ae2:	01814783          	lbu	a5,24(sp)
80009ae6:	0807c7b3          	zext.h	a5,a5
80009aea:	01a15703          	lhu	a4,26(sp)
80009aee:	fce7f0e3          	bgeu	a5,a4,80009aae <.L13>
            }
            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
80009af2:	47f2                	lw	a5,28(sp)
80009af4:	079d                	add	a5,a5,7
80009af6:	838d                	srl	a5,a5,0x3
80009af8:	ce3e                	sw	a5,28(sp)

            if ( subindex == 0 )
80009afa:	00d14783          	lbu	a5,13(sp)
80009afe:	e781                	bnez	a5,80009b06 <.L14>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
80009b00:	47f2                	lw	a5,28(sp)
80009b02:	0789                	add	a5,a5,2
80009b04:	ce3e                	sw	a5,28(sp)

80009b06 <.L14>:
            }
            return size;
80009b06:	47f2                	lw	a5,28(sp)
80009b08:	a071                	j	80009b94 <.L9>

80009b0a <.L7>:
        }
    }
    else
    {
        if ( objCode == OBJCODE_VAR )
80009b0a:	01914703          	lbu	a4,25(sp)
80009b0e:	479d                	li	a5,7
80009b10:	00f71f63          	bne	a4,a5,80009b2e <.L15>
        {

            return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
80009b14:	47a2                	lw	a5,8(sp)
80009b16:	4b9c                	lw	a5,16(a5)
80009b18:	0027c703          	lbu	a4,2(a5)
80009b1c:	0037c783          	lbu	a5,3(a5)
80009b20:	07a2                	sll	a5,a5,0x8
80009b22:	8fd9                	or	a5,a5,a4
80009b24:	0807c7b3          	zext.h	a5,a5
80009b28:	079d                	add	a5,a5,7
80009b2a:	878d                	sra	a5,a5,0x3
80009b2c:	a0a5                	j	80009b94 <.L9>

80009b2e <.L15>:

        }
        else if ( subindex == 0 )
80009b2e:	00d14783          	lbu	a5,13(sp)
80009b32:	e399                	bnez	a5,80009b38 <.L16>
        {
            /* for single access subindex 0 is transmitted as UINT8 */
            return 1;
80009b34:	4785                	li	a5,1
80009b36:	a8b9                	j	80009b94 <.L9>

80009b38 <.L16>:
        }
        else if((objCode == OBJCODE_ARR)
80009b38:	01914703          	lbu	a4,25(sp)
80009b3c:	47a1                	li	a5,8
80009b3e:	02f71063          	bne	a4,a5,80009b5e <.L17>
            )
        {
            return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
80009b42:	47a2                	lw	a5,8(sp)
80009b44:	4b9c                	lw	a5,16(a5)
80009b46:	0799                	add	a5,a5,6
80009b48:	0027c703          	lbu	a4,2(a5)
80009b4c:	0037c783          	lbu	a5,3(a5)
80009b50:	07a2                	sll	a5,a5,0x8
80009b52:	8fd9                	or	a5,a5,a4
80009b54:	0807c7b3          	zext.h	a5,a5
80009b58:	079d                	add	a5,a5,7
80009b5a:	878d                	sra	a5,a5,0x3
80009b5c:	a825                	j	80009b94 <.L9>

80009b5e <.L17>:
        }
        else
        {
            {
                if (maxSubindex < subindex)
80009b5e:	01814703          	lbu	a4,24(sp)
80009b62:	00d14783          	lbu	a5,13(sp)
80009b66:	00f77463          	bgeu	a4,a5,80009b6e <.L18>
                {
                    return 0;
80009b6a:	4781                	li	a5,0
80009b6c:	a025                	j	80009b94 <.L9>

80009b6e <.L18>:

                }
                else
                {
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
80009b6e:	47a2                	lw	a5,8(sp)
80009b70:	4b94                	lw	a3,16(a5)
80009b72:	00d14703          	lbu	a4,13(sp)
80009b76:	87ba                	mv	a5,a4
80009b78:	0786                	sll	a5,a5,0x1
80009b7a:	97ba                	add	a5,a5,a4
80009b7c:	0786                	sll	a5,a5,0x1
80009b7e:	97b6                	add	a5,a5,a3
80009b80:	0027c703          	lbu	a4,2(a5)
80009b84:	0037c783          	lbu	a5,3(a5)
80009b88:	07a2                	sll	a5,a5,0x8
80009b8a:	8fd9                	or	a5,a5,a4
80009b8c:	0807c7b3          	zext.h	a5,a5
80009b90:	079d                	add	a5,a5,7
80009b92:	878d                	sra	a5,a5,0x3

80009b94 <.L9>:
                }
            }
        }
    }
}
80009b94:	853e                	mv	a0,a5
80009b96:	6105                	add	sp,sp,32
80009b98:	8082                	ret

Disassembly of section .text.OBJ_CopyNumberToString:

80009b9a <OBJ_CopyNumberToString>:
         which shall be initialized with 000

*////////////////////////////////////////////////////////////////////////////////////////

void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
{
80009b9a:	1101                	add	sp,sp,-32
80009b9c:	c62a                	sw	a0,12(sp)
80009b9e:	87ae                	mv	a5,a1
80009ba0:	00f105a3          	sb	a5,11(sp)
    UINT8 Modulo;

    pStr[2] = '0';
80009ba4:	47b2                	lw	a5,12(sp)
80009ba6:	0789                	add	a5,a5,2
80009ba8:	03000713          	li	a4,48
80009bac:	00e78023          	sb	a4,0(a5)
    pStr[0] += (Number / 100);
80009bb0:	47b2                	lw	a5,12(sp)
80009bb2:	0007c703          	lbu	a4,0(a5)
80009bb6:	00b14683          	lbu	a3,11(sp)
80009bba:	06400793          	li	a5,100
80009bbe:	02f6d7b3          	divu	a5,a3,a5
80009bc2:	0ff7f793          	zext.b	a5,a5
80009bc6:	97ba                	add	a5,a5,a4
80009bc8:	0ff7f713          	zext.b	a4,a5
80009bcc:	47b2                	lw	a5,12(sp)
80009bce:	00e78023          	sb	a4,0(a5)
    Modulo = Number % 100;
80009bd2:	00b14703          	lbu	a4,11(sp)
80009bd6:	06400793          	li	a5,100
80009bda:	02f777b3          	remu	a5,a4,a5
80009bde:	00f10fa3          	sb	a5,31(sp)
    pStr[1] += (Modulo / 10);
80009be2:	47b2                	lw	a5,12(sp)
80009be4:	0785                	add	a5,a5,1
80009be6:	0007c683          	lbu	a3,0(a5)
80009bea:	01f14703          	lbu	a4,31(sp)
80009bee:	47a9                	li	a5,10
80009bf0:	02f757b3          	divu	a5,a4,a5
80009bf4:	0ff7f713          	zext.b	a4,a5
80009bf8:	47b2                	lw	a5,12(sp)
80009bfa:	0785                	add	a5,a5,1
80009bfc:	9736                	add	a4,a4,a3
80009bfe:	0ff77713          	zext.b	a4,a4
80009c02:	00e78023          	sb	a4,0(a5)
    pStr[2] += (Modulo % 10);
80009c06:	47b2                	lw	a5,12(sp)
80009c08:	0789                	add	a5,a5,2
80009c0a:	0007c683          	lbu	a3,0(a5)
80009c0e:	01f14703          	lbu	a4,31(sp)
80009c12:	47a9                	li	a5,10
80009c14:	02f777b3          	remu	a5,a4,a5
80009c18:	0ff7f713          	zext.b	a4,a5
80009c1c:	47b2                	lw	a5,12(sp)
80009c1e:	0789                	add	a5,a5,2
80009c20:	9736                	add	a4,a4,a3
80009c22:	0ff77713          	zext.b	a4,a4
80009c26:	00e78023          	sb	a4,0(a5)
}
80009c2a:	0001                	nop
80009c2c:	6105                	add	sp,sp,32
80009c2e:	8082                	ret

Disassembly of section .text.OBJ_GetEntryDesc:

80009c30 <OBJ_GetEntryDesc>:
         to define the object dictionary independent of the sdoserv-files

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
{
80009c30:	1101                	add	sp,sp,-32
80009c32:	c62a                	sw	a0,12(sp)
80009c34:	87ae                	mv	a5,a1
80009c36:	00f105a3          	sb	a5,11(sp)
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
80009c3a:	47b2                	lw	a5,12(sp)
80009c3c:	00c7d783          	lhu	a5,12(a5)
80009c40:	87a1                	sra	a5,a5,0x8
80009c42:	0ff7f793          	zext.b	a5,a5
80009c46:	8bbd                	and	a5,a5,15
80009c48:	00f10da3          	sb	a5,27(sp)

    if ((objCode == OBJCODE_ARR)
80009c4c:	01b14703          	lbu	a4,27(sp)
80009c50:	47a1                	li	a5,8
80009c52:	00f71e63          	bne	a4,a5,80009c6e <.L56>
        )
    {
        /* object is an array */
        if ( Subindex == 0 )
80009c56:	00b14783          	lbu	a5,11(sp)
80009c5a:	e789                	bnez	a5,80009c64 <.L57>
        {
            /* subindex 0 has a description */
            pEntry = &pObjEntry->pEntryDesc[0];
80009c5c:	47b2                	lw	a5,12(sp)
80009c5e:	4b9c                	lw	a5,16(a5)
80009c60:	ce3e                	sw	a5,28(sp)
80009c62:	a005                	j	80009c82 <.L58>

80009c64 <.L57>:
        }
        else
        {
            /* and all other elements have the same description */
            pEntry = &pObjEntry->pEntryDesc[1];
80009c64:	47b2                	lw	a5,12(sp)
80009c66:	4b9c                	lw	a5,16(a5)
80009c68:	0799                	add	a5,a5,6
80009c6a:	ce3e                	sw	a5,28(sp)
80009c6c:	a819                	j	80009c82 <.L58>

80009c6e <.L56>:
    }
    else
    {
        {
            /* object is a variable or a record return the corresponding entry */
            pEntry = &pObjEntry->pEntryDesc[Subindex];
80009c6e:	47b2                	lw	a5,12(sp)
80009c70:	4b94                	lw	a3,16(a5)
80009c72:	00b14703          	lbu	a4,11(sp)
80009c76:	87ba                	mv	a5,a4
80009c78:	0786                	sll	a5,a5,0x1
80009c7a:	97ba                	add	a5,a5,a4
80009c7c:	0786                	sll	a5,a5,0x1
80009c7e:	97b6                	add	a5,a5,a3
80009c80:	ce3e                	sw	a5,28(sp)

80009c82 <.L58>:
        }
    }

    return pEntry;
80009c82:	47f2                	lw	a5,28(sp)
}
80009c84:	853e                	mv	a0,a5
80009c86:	6105                	add	sp,sp,32
80009c88:	8082                	ret

Disassembly of section .text.OBJ_GetObjDesc:

80009c8a <OBJ_GetObjDesc>:
         to define the object dictionary independent of the sdoserv-files

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
{
80009c8a:	1141                	add	sp,sp,-16
80009c8c:	c62a                	sw	a0,12(sp)
    return &pObjEntry->ObjDesc;
80009c8e:	47b2                	lw	a5,12(sp)
80009c90:	07a9                	add	a5,a5,10
}
80009c92:	853e                	mv	a0,a5
80009c94:	0141                	add	sp,sp,16
80009c96:	8082                	ret

Disassembly of section .text.OBJ_Read:

80009c98 <OBJ_Read>:

 \brief    This function reads the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
80009c98:	715d                	add	sp,sp,-80
80009c9a:	c686                	sw	ra,76(sp)
80009c9c:	c432                	sw	a2,8(sp)
80009c9e:	c236                	sw	a3,4(sp)
80009ca0:	c03a                	sw	a4,0(sp)
80009ca2:	873e                	mv	a4,a5
80009ca4:	87aa                	mv	a5,a0
80009ca6:	00f11723          	sh	a5,14(sp)
80009caa:	87ae                	mv	a5,a1
80009cac:	00f106a3          	sb	a5,13(sp)
80009cb0:	87ba                	mv	a5,a4
80009cb2:	00f10623          	sb	a5,12(sp)
    UINT16 i = subindex;
80009cb6:	00d14783          	lbu	a5,13(sp)
80009cba:	02f11f23          	sh	a5,62(sp)
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
80009cbe:	4792                	lw	a5,4(sp)
80009cc0:	00c7d783          	lhu	a5,12(a5)
80009cc4:	87a1                	sra	a5,a5,0x8
80009cc6:	0ff7f793          	zext.b	a5,a5
80009cca:	8bbd                	and	a5,a5,15
80009ccc:	02f10923          	sb	a5,50(sp)
    UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
80009cd0:	4792                	lw	a5,4(sp)
80009cd2:	00c7d783          	lhu	a5,12(a5)
80009cd6:	0ff7f793          	zext.b	a5,a5
80009cda:	02f11e23          	sh	a5,60(sp)
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    /* lastSubindex is used for complete access to make loop over the requested entries
    to be read, we initialize this variable with the requested subindex that only
    one loop will be done for a single access */
    UINT16 lastSubindex = subindex;
80009cde:	00d14783          	lbu	a5,13(sp)
80009ce2:	02f11d23          	sh	a5,58(sp)

    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
80009ce6:	03214703          	lbu	a4,50(sp)
80009cea:	479d                	li	a5,7
80009cec:	00f70f63          	beq	a4,a5,80009d0a <.L111>
80009cf0:	00e15703          	lhu	a4,14(sp)
80009cf4:	6785                	lui	a5,0x1
80009cf6:	00f76a63          	bltu	a4,a5,80009d0a <.L111>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
        actual value of subindex 0, which is stored as UINT16 at the beginning of the
        object's variable */
        maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
80009cfa:	4792                	lw	a5,4(sp)
80009cfc:	4f9c                	lw	a5,24(a5)
80009cfe:	0007d783          	lhu	a5,0(a5) # 1000 <.L76+0x3a>
80009d02:	0ff7f793          	zext.b	a5,a5
80009d06:	02f11e23          	sh	a5,60(sp)

80009d0a <.L111>:

    }

    if ( bCompleteAccess )
80009d0a:	00c14783          	lbu	a5,12(sp)
80009d0e:	c395                	beqz	a5,80009d32 <.L112>
    {
        if ( objCode == OBJCODE_VAR || index < 0x1000 )
80009d10:	03214703          	lbu	a4,50(sp)
80009d14:	479d                	li	a5,7
80009d16:	00f70763          	beq	a4,a5,80009d24 <.L113>
80009d1a:	00e15703          	lhu	a4,14(sp)
80009d1e:	6785                	lui	a5,0x1
80009d20:	00f77463          	bgeu	a4,a5,80009d28 <.L114>

80009d24 <.L113>:
        {
            /* complete access is not supported with simple objects or ENUM descriptions */
            return ABORTIDX_UNSUPPORTED_ACCESS;
80009d24:	4795                	li	a5,5
80009d26:	afbd                	j	8000a4a4 <.L115>

80009d28 <.L114>:
        }


        /* we read until the maximum subindex */
        lastSubindex = maxSubindex;
80009d28:	03c15783          	lhu	a5,60(sp)
80009d2c:	02f11d23          	sh	a5,58(sp)
80009d30:	a059                	j	80009db6 <.L116>

80009d32 <.L112>:
    }
    else
        if ( subindex > maxSubindex )
80009d32:	00d14783          	lbu	a5,13(sp)
80009d36:	0807c7b3          	zext.h	a5,a5
80009d3a:	03c15703          	lhu	a4,60(sp)
80009d3e:	00f77463          	bgeu	a4,a5,80009d46 <.L117>
        {
            /* the maximum subindex is reached */
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
80009d42:	47c5                	li	a5,17
80009d44:	a785                	j	8000a4a4 <.L115>

80009d46 <.L117>:
        }
        else
        {
            /* get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
80009d46:	03e15783          	lhu	a5,62(sp)
80009d4a:	0ff7f793          	zext.b	a5,a5
80009d4e:	85be                	mv	a1,a5
80009d50:	4512                	lw	a0,4(sp)
80009d52:	3df9                	jal	80009c30 <OBJ_GetEntryDesc>
80009d54:	d62a                	sw	a0,44(sp)

            /*Check access only for non-align entries*/
            if(pEntry->ObjAccess != 0x0)
80009d56:	57b2                	lw	a5,44(sp)
80009d58:	0047c703          	lbu	a4,4(a5) # 1004 <.L76+0x3e>
80009d5c:	0057c783          	lbu	a5,5(a5)
80009d60:	07a2                	sll	a5,a5,0x8
80009d62:	8fd9                	or	a5,a5,a4
80009d64:	0807c7b3          	zext.h	a5,a5
80009d68:	c7a9                	beqz	a5,80009db2 <.L118>
            {
                /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
                if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)))
80009d6a:	57b2                	lw	a5,44(sp)
80009d6c:	0047c703          	lbu	a4,4(a5)
80009d70:	0057c783          	lbu	a5,5(a5)
80009d74:	07a2                	sll	a5,a5,0x8
80009d76:	8fd9                	or	a5,a5,a4
80009d78:	0807c7b3          	zext.h	a5,a5
80009d7c:	0ff7f793          	zext.b	a5,a5
80009d80:	0786                	sll	a5,a5,0x1
80009d82:	0ff7f793          	zext.b	a5,a5
80009d86:	00e7f713          	and	a4,a5,14
80009d8a:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80009d8e:	8bbd                	and	a5,a5,15
80009d90:	8ff9                	and	a5,a5,a4
80009d92:	e395                	bnez	a5,80009db6 <.L116>
                {
                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
80009d94:	57b2                	lw	a5,44(sp)
80009d96:	0047c703          	lbu	a4,4(a5)
80009d9a:	0057c783          	lbu	a5,5(a5)
80009d9e:	07a2                	sll	a5,a5,0x8
80009da0:	8fd9                	or	a5,a5,a4
80009da2:	0807c7b3          	zext.h	a5,a5
80009da6:	8b9d                	and	a5,a5,7
80009da8:	e399                	bnez	a5,80009dae <.L119>
                    {
                        /* it is a write only entry */
                        return ABORTIDX_WRITE_ONLY_ENTRY;
80009daa:	4799                	li	a5,6
80009dac:	ade5                	j	8000a4a4 <.L115>

80009dae <.L119>:
                    }
                    else
                    {
                        /* we don't have read access in this state */
                        return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
80009dae:	47e9                	li	a5,26
80009db0:	add5                	j	8000a4a4 <.L115>

80009db2 <.L118>:
                    }
                }
            }
            else
            {
                return ABORTIDX_UNSUPPORTED_ACCESS;
80009db2:	4795                	li	a5,5
80009db4:	adc5                	j	8000a4a4 <.L115>

80009db6 <.L116>:
            }

        }

    /* ECATCHANGE_START(V5.13) COE4*/
        if (pAPPL_CoeReadInd != NULL)
80009db6:	1081a783          	lw	a5,264(gp) # 1209480 <pAPPL_CoeReadInd>
80009dba:	cf81                	beqz	a5,80009dd2 <.L120>
        {
            pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
80009dbc:	1081a783          	lw	a5,264(gp) # 1209480 <pAPPL_CoeReadInd>
80009dc0:	00c14603          	lbu	a2,12(sp)
80009dc4:	00d14683          	lbu	a3,13(sp)
80009dc8:	00e15703          	lhu	a4,14(sp)
80009dcc:	85b6                	mv	a1,a3
80009dce:	853a                	mv	a0,a4
80009dd0:	9782                	jalr	a5

80009dd2 <.L120>:
        }
        /* ECATCHANGE_END(V5.13) COE4*/

        if ( pObjEntry->Read != NULL )
80009dd2:	4792                	lw	a5,4(sp)
80009dd4:	4fdc                	lw	a5,28(a5)
80009dd6:	cf91                	beqz	a5,80009df2 <.L121>
        {
            /* Read function is defined, we call the object specific read function */
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
80009dd8:	4792                	lw	a5,4(sp)
80009dda:	4fdc                	lw	a5,28(a5)
80009ddc:	00c14703          	lbu	a4,12(sp)
80009de0:	00d14583          	lbu	a1,13(sp)
80009de4:	00e15503          	lhu	a0,14(sp)
80009de8:	4682                	lw	a3,0(sp)
80009dea:	4622                	lw	a2,8(sp)
80009dec:	9782                	jalr	a5
80009dee:	87aa                	mv	a5,a0
80009df0:	ad55                	j	8000a4a4 <.L115>

80009df2 <.L121>:
        }
        else if ( index < 0x1000 && subindex != 0 )
80009df2:	00e15703          	lhu	a4,14(sp)
80009df6:	6785                	lui	a5,0x1
80009df8:	08f77463          	bgeu	a4,a5,80009e80 <.L122>
80009dfc:	00d14783          	lbu	a5,13(sp)
80009e00:	c3c1                	beqz	a5,80009e80 <.L122>

80009e02 <.LBB10>:
        {
            /* an ENUM description is read */
            UINT16 size;
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
80009e02:	4792                	lw	a5,4(sp)
80009e04:	4f9c                	lw	a5,24(a5)
80009e06:	d43e                	sw	a5,40(sp)
            CHAR **p;

            /* we get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
80009e08:	00d14783          	lbu	a5,13(sp)
80009e0c:	85be                	mv	a1,a5
80009e0e:	4512                	lw	a0,4(sp)
80009e10:	3505                	jal	80009c30 <OBJ_GetEntryDesc>
80009e12:	d62a                	sw	a0,44(sp)
            size = BIT2BYTE(pEntry->BitLength);
80009e14:	57b2                	lw	a5,44(sp)
80009e16:	0027c703          	lbu	a4,2(a5) # 1002 <.L76+0x3c>
80009e1a:	0037c783          	lbu	a5,3(a5)
80009e1e:	07a2                	sll	a5,a5,0x8
80009e20:	8fd9                	or	a5,a5,a4
80009e22:	0807c7b3          	zext.h	a5,a5
80009e26:	079d                	add	a5,a5,7
80009e28:	878d                	sra	a5,a5,0x3
80009e2a:	02f11323          	sh	a5,38(sp)

            p = (CHAR **) pVarPtr;
80009e2e:	57a2                	lw	a5,40(sp)
80009e30:	d03e                	sw	a5,32(sp)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
80009e32:	00d14703          	lbu	a4,13(sp)
80009e36:	400007b7          	lui	a5,0x40000
80009e3a:	17fd                	add	a5,a5,-1 # 3fffffff <__AXI_SRAM_segment_end__+0x3edbffff>
80009e3c:	97ba                	add	a5,a5,a4
80009e3e:	078a                	sll	a5,a5,0x2
80009e40:	5702                	lw	a4,32(sp)
80009e42:	97ba                	add	a5,a5,a4
80009e44:	439c                	lw	a5,0(a5)
80009e46:	d43e                	sw	a5,40(sp)
            /*ECATCHANGE_START(V5.13) */
            {
            // Get enum value (first 32Bit)
/*ECATCHANGE_START(V5.13) */

            pData[0] = pVarPtr[0];
80009e48:	57a2                	lw	a5,40(sp)
80009e4a:	0007d703          	lhu	a4,0(a5)
80009e4e:	4782                	lw	a5,0(sp)
80009e50:	00e79023          	sh	a4,0(a5)
            pData[1] = pVarPtr[1];
80009e54:	4782                	lw	a5,0(sp)
80009e56:	0789                	add	a5,a5,2
80009e58:	5722                	lw	a4,40(sp)
80009e5a:	00275703          	lhu	a4,2(a4) # 1002 <.L76+0x3c>
80009e5e:	00e79023          	sh	a4,0(a5)
            pData += 2;
80009e62:	4782                	lw	a5,0(sp)
80009e64:	0791                	add	a5,a5,4
80009e66:	c03e                	sw	a5,0(sp)
            pVarPtr += 2;
80009e68:	57a2                	lw	a5,40(sp)
80009e6a:	0791                	add	a5,a5,4
80009e6c:	d43e                	sw	a5,40(sp)
/*ECATCHANGE_END(V5.13) */

            // Get enum description
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
80009e6e:	02615783          	lhu	a5,38(sp)
80009e72:	17f1                	add	a5,a5,-4
80009e74:	863e                	mv	a2,a5
80009e76:	55a2                	lw	a1,40(sp)
80009e78:	4502                	lw	a0,0(sp)
80009e7a:	5e3030ef          	jal	8000dc5c <memcpy>

80009e7e <.LBE10>:
        {
80009e7e:	a515                	j	8000a4a2 <.L123>

80009e80 <.L122>:
            }
        }
        else
        {
            UINT8 bRead = 0x0;
80009e80:	02010ca3          	sb	zero,57(sp)
            UINT8 result = 0;
80009e84:	02010c23          	sb	zero,56(sp)


            /* a variable object is read */
            for (i = subindex; i <= lastSubindex; i++)
80009e88:	00d14783          	lbu	a5,13(sp)
80009e8c:	02f11f23          	sh	a5,62(sp)
80009e90:	abed                	j	8000a48a <.L124>

80009e92 <.L166>:
            {
                /* if only a single entry is requested, this loop will only be done once */
                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
80009e92:	4792                	lw	a5,4(sp)
80009e94:	4f9c                	lw	a5,24(a5)
80009e96:	ce3e                	sw	a5,28(sp)
                UINT16 bitOffset = 0;
80009e98:	02011b23          	sh	zero,54(sp)

                
                if (i == 0)
80009e9c:	03e15783          	lhu	a5,62(sp)
80009ea0:	c38d                	beqz	a5,80009ec2 <.L125>
                {
                    /* subindex 0 is requested, the entry's data is at the beginning of the object's variable */
                }
                else if ( index >= 0x1000 )
80009ea2:	00e15703          	lhu	a4,14(sp)
80009ea6:	6785                	lui	a5,0x1
80009ea8:	00f76d63          	bltu	a4,a5,80009ec2 <.L125>
                {
                    /* subindex 1-n of an variable object is requested, we get the offset of the variable here */
                    bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
80009eac:	03e15783          	lhu	a5,62(sp)
80009eb0:	0ff7f793          	zext.b	a5,a5
80009eb4:	4592                	lw	a1,4(sp)
80009eb6:	853e                	mv	a0,a5
80009eb8:	7c5050ef          	jal	8000fe7c <OBJ_GetEntryOffset>
80009ebc:	87aa                	mv	a5,a0
80009ebe:	02f11b23          	sh	a5,54(sp)

80009ec2 <.L125>:
                }

                /* we increment the variable pointer to the corresponding word address */
                pVarPtr += (bitOffset >> 4);
80009ec2:	03615783          	lhu	a5,54(sp)
80009ec6:	8391                	srl	a5,a5,0x4
80009ec8:	0807c7b3          	zext.h	a5,a5
80009ecc:	0786                	sll	a5,a5,0x1
80009ece:	4772                	lw	a4,28(sp)
80009ed0:	97ba                	add	a5,a5,a4
80009ed2:	ce3e                	sw	a5,28(sp)

                /* get the corresponding entry description */
                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
80009ed4:	03e15783          	lhu	a5,62(sp)
80009ed8:	0ff7f793          	zext.b	a5,a5
80009edc:	85be                	mv	a1,a5
80009ede:	4512                	lw	a0,4(sp)
80009ee0:	3b81                	jal	80009c30 <OBJ_GetEntryDesc>
80009ee2:	d62a                	sw	a0,44(sp)
                if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)) )
80009ee4:	57b2                	lw	a5,44(sp)
80009ee6:	0047c703          	lbu	a4,4(a5) # 1004 <.L76+0x3e>
80009eea:	0057c783          	lbu	a5,5(a5)
80009eee:	07a2                	sll	a5,a5,0x8
80009ef0:	8fd9                	or	a5,a5,a4
80009ef2:	0807c7b3          	zext.h	a5,a5
80009ef6:	0ff7f793          	zext.b	a5,a5
80009efa:	0786                	sll	a5,a5,0x1
80009efc:	0ff7f793          	zext.b	a5,a5
80009f00:	00e7f713          	and	a4,a5,14
80009f04:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
80009f08:	8bbd                	and	a5,a5,15
80009f0a:	8ff9                	and	a5,a5,a4
80009f0c:	4c078063          	beqz	a5,8000a3cc <.L126>
                {
                    if ( i == subindex                                     /* requested entry */
80009f10:	00d14783          	lbu	a5,13(sp)
80009f14:	0807c7b3          	zext.h	a5,a5
80009f18:	03e15703          	lhu	a4,62(sp)
80009f1c:	00f70e63          	beq	a4,a5,80009f38 <.L127>
                        || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
80009f20:	00c14783          	lbu	a5,12(sp)
80009f24:	54078e63          	beqz	a5,8000a480 <.L160>
80009f28:	00d14783          	lbu	a5,13(sp)
80009f2c:	0807c7b3          	zext.h	a5,a5
80009f30:	03e15703          	lhu	a4,62(sp)
80009f34:	54f76663          	bltu	a4,a5,8000a480 <.L160>

80009f38 <.L127>:
                    {
                        UINT16 bitMask;

                        /* we have to copy the entry */
                        if ( i == 0 && objCode != OBJCODE_VAR )
80009f38:	03e15783          	lhu	a5,62(sp)
80009f3c:	ef99                	bnez	a5,80009f5a <.L129>
80009f3e:	03214703          	lbu	a4,50(sp)
80009f42:	479d                	li	a5,7
80009f44:	00f70b63          	beq	a4,a5,80009f5a <.L129>
                        {
                            /* we read subindex 0 of an array or record */
                            {
                                pData[0] = SWAPWORD((UINT16)maxSubindex);
80009f48:	4782                	lw	a5,0(sp)
80009f4a:	03c15703          	lhu	a4,60(sp)
80009f4e:	00e79023          	sh	a4,0(a5)
                            }

                            /* we increment the destination pointer by 2 because the subindex 0 will be
                            transmitted as UINT16 for a complete access */
                            pData++;
80009f52:	4782                	lw	a5,0(sp)
80009f54:	0789                	add	a5,a5,2
80009f56:	c03e                	sw	a5,0(sp)
80009f58:	a325                	j	8000a480 <.L160>

80009f5a <.L129>:
                        }
                        else
                        {
                            UINT16 dataType = pEntry->DataType;
80009f5a:	57b2                	lw	a5,44(sp)
80009f5c:	0007c703          	lbu	a4,0(a5)
80009f60:	0017c783          	lbu	a5,1(a5)
80009f64:	07a2                	sll	a5,a5,0x8
80009f66:	8fd9                	or	a5,a5,a4
80009f68:	02f11a23          	sh	a5,52(sp)
                            
                            if (pEntry->DataType >= 0x700)
80009f6c:	57b2                	lw	a5,44(sp)
80009f6e:	0007c703          	lbu	a4,0(a5)
80009f72:	0017c783          	lbu	a5,1(a5)
80009f76:	07a2                	sll	a5,a5,0x8
80009f78:	8fd9                	or	a5,a5,a4
80009f7a:	0807c733          	zext.h	a4,a5
80009f7e:	6ff00793          	li	a5,1791
80009f82:	06e7fc63          	bgeu	a5,a4,80009ffa <.L130>
                            {
                                /* the ENUM data types are defined from index 0x700 in this example
                                convert in standard data type for the read access */
                                if ( pEntry->BitLength <= 8 )
80009f86:	57b2                	lw	a5,44(sp)
80009f88:	0027c703          	lbu	a4,2(a5)
80009f8c:	0037c783          	lbu	a5,3(a5)
80009f90:	07a2                	sll	a5,a5,0x8
80009f92:	8fd9                	or	a5,a5,a4
80009f94:	0807c733          	zext.h	a4,a5
80009f98:	47a1                	li	a5,8
80009f9a:	02e7e063          	bltu	a5,a4,80009fba <.L131>
                                {
                                    dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
80009f9e:	57b2                	lw	a5,44(sp)
80009fa0:	0027c703          	lbu	a4,2(a5)
80009fa4:	0037c783          	lbu	a5,3(a5)
80009fa8:	07a2                	sll	a5,a5,0x8
80009faa:	8fd9                	or	a5,a5,a4
80009fac:	0807c7b3          	zext.h	a5,a5
80009fb0:	02f78793          	add	a5,a5,47
80009fb4:	02f11a23          	sh	a5,52(sp)
80009fb8:	a089                	j	80009ffa <.L130>

80009fba <.L131>:
                                }
                                else if ( pEntry->BitLength == 16 )
80009fba:	57b2                	lw	a5,44(sp)
80009fbc:	0027c703          	lbu	a4,2(a5)
80009fc0:	0037c783          	lbu	a5,3(a5)
80009fc4:	07a2                	sll	a5,a5,0x8
80009fc6:	8fd9                	or	a5,a5,a4
80009fc8:	0807c733          	zext.h	a4,a5
80009fcc:	47c1                	li	a5,16
80009fce:	00f71663          	bne	a4,a5,80009fda <.L132>
                                {
                                    dataType = DEFTYPE_UNSIGNED16;
80009fd2:	4799                	li	a5,6
80009fd4:	02f11a23          	sh	a5,52(sp)
80009fd8:	a00d                	j	80009ffa <.L130>

80009fda <.L132>:
                                }
                                else if ( pEntry->BitLength == 32 )
80009fda:	57b2                	lw	a5,44(sp)
80009fdc:	0027c703          	lbu	a4,2(a5)
80009fe0:	0037c783          	lbu	a5,3(a5)
80009fe4:	07a2                	sll	a5,a5,0x8
80009fe6:	8fd9                	or	a5,a5,a4
80009fe8:	0807c733          	zext.h	a4,a5
80009fec:	02000793          	li	a5,32
80009ff0:	00f71563          	bne	a4,a5,80009ffa <.L130>
                                {
                                    dataType = DEFTYPE_UNSIGNED32;
80009ff4:	479d                	li	a5,7
80009ff6:	02f11a23          	sh	a5,52(sp)

80009ffa <.L130>:
                                }
                            }

                            switch (dataType)
80009ffa:	03415783          	lhu	a5,52(sp)
80009ffe:	26300713          	li	a4,611
8000a002:	3af74a63          	blt	a4,a5,8000a3b6 <.L133>
8000a006:	26000713          	li	a4,608
8000a00a:	2ae7de63          	bge	a5,a4,8000a2c6 <.L134>
8000a00e:	03700713          	li	a4,55
8000a012:	3af74263          	blt	a4,a5,8000a3b6 <.L133>
8000a016:	4779                	li	a4,30
8000a018:	02e7d163          	bge	a5,a4,8000a03a <.L135>
8000a01c:	476d                	li	a4,27
8000a01e:	38f74c63          	blt	a4,a5,8000a3b6 <.L133>
8000a022:	4725                	li	a4,9
8000a024:	04e7dc63          	bge	a5,a4,8000a07c <.L136>
8000a028:	c3dd                	beqz	a5,8000a0ce <.L137>
8000a02a:	3807c663          	bltz	a5,8000a3b6 <.L133>
8000a02e:	4721                	li	a4,8
8000a030:	38f74363          	blt	a4,a5,8000a3b6 <.L133>
8000a034:	06f04163          	bgtz	a5,8000a096 <.L138>
8000a038:	aebd                	j	8000a3b6 <.L133>

8000a03a <.L135>:
8000a03a:	1789                	add	a5,a5,-30
8000a03c:	4705                	li	a4,1
8000a03e:	00f717b3          	sll	a5,a4,a5
8000a042:	03fc8737          	lui	a4,0x3fc8
8000a046:	0705                	add	a4,a4,1 # 3fc8001 <__AXI_SRAM_segment_end__+0x2d88001>
8000a048:	8f7d                	and	a4,a4,a5
8000a04a:	00e03733          	snez	a4,a4
8000a04e:	0ff77713          	zext.b	a4,a4
8000a052:	e375                	bnez	a4,8000a136 <.L139>
8000a054:	00020737          	lui	a4,0x20
8000a058:	0711                	add	a4,a4,4 # 20004 <__DLM_segment_size__+0x4>
8000a05a:	8f7d                	and	a4,a4,a5
8000a05c:	00e03733          	snez	a4,a4
8000a060:	0ff77713          	zext.b	a4,a4
8000a064:	1e071563          	bnez	a4,8000a24e <.L140>
8000a068:	6741                	lui	a4,0x10
8000a06a:	0709                	add	a4,a4,2 # 10002 <__AXI_SRAM_segment_used_size__+0x6aa6>
8000a06c:	8ff9                	and	a5,a5,a4
8000a06e:	00f037b3          	snez	a5,a5
8000a072:	0ff7f793          	zext.b	a5,a5
8000a076:	1a079c63          	bnez	a5,8000a22e <.L141>
8000a07a:	ae35                	j	8000a3b6 <.L133>

8000a07c <.L136>:
8000a07c:	17dd                	add	a5,a5,-9
8000a07e:	4749                	li	a4,18
8000a080:	32f76b63          	bltu	a4,a5,8000a3b6 <.L133>
8000a084:	00279713          	sll	a4,a5,0x2
8000a088:	800057b7          	lui	a5,0x80005
8000a08c:	fec78793          	add	a5,a5,-20 # 80004fec <.L143>
8000a090:	97ba                	add	a5,a5,a4
8000a092:	439c                	lw	a5,0(a5)
8000a094:	8782                	jr	a5

8000a096 <.L138>:
8000a096:	873e                	mv	a4,a5
8000a098:	4785                	li	a5,1
8000a09a:	00e797b3          	sll	a5,a5,a4
8000a09e:	1907f713          	and	a4,a5,400
8000a0a2:	00e03733          	snez	a4,a4
8000a0a6:	0ff77713          	zext.b	a4,a4
8000a0aa:	1a071263          	bnez	a4,8000a24e <.L140>
8000a0ae:	0267f713          	and	a4,a5,38
8000a0b2:	00e03733          	snez	a4,a4
8000a0b6:	0ff77713          	zext.b	a4,a4
8000a0ba:	ef35                	bnez	a4,8000a136 <.L139>
8000a0bc:	0487f793          	and	a5,a5,72
8000a0c0:	00f037b3          	snez	a5,a5
8000a0c4:	0ff7f793          	zext.b	a5,a5
8000a0c8:	16079363          	bnez	a5,8000a22e <.L141>
8000a0cc:	a4ed                	j	8000a3b6 <.L133>

8000a0ce <.L137>:
                            {
                            case DEFTYPE_NULL:
                                if(bCompleteAccess)
8000a0ce:	00c14783          	lbu	a5,12(sp)
8000a0d2:	c3a5                	beqz	a5,8000a132 <.L145>
                                {
                                    /*Handle alignment entry*/
                                    if (((pEntry->BitLength & 0xF) > 0)
8000a0d4:	57b2                	lw	a5,44(sp)
8000a0d6:	0027c703          	lbu	a4,2(a5)
8000a0da:	0037c783          	lbu	a5,3(a5)
8000a0de:	07a2                	sll	a5,a5,0x8
8000a0e0:	8fd9                	or	a5,a5,a4
8000a0e2:	0807c7b3          	zext.h	a5,a5
8000a0e6:	8bbd                	and	a5,a5,15
8000a0e8:	02f05563          	blez	a5,8000a112 <.L146>
                                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
8000a0ec:	57b2                	lw	a5,44(sp)
8000a0ee:	0027c703          	lbu	a4,2(a5)
8000a0f2:	0037c783          	lbu	a5,3(a5)
8000a0f6:	07a2                	sll	a5,a5,0x8
8000a0f8:	8fd9                	or	a5,a5,a4
8000a0fa:	0807c7b3          	zext.h	a5,a5
8000a0fe:	03615703          	lhu	a4,54(sp)
8000a102:	97ba                	add	a5,a5,a4
8000a104:	0807c7b3          	zext.h	a5,a5
8000a108:	8bbd                	and	a5,a5,15
8000a10a:	e781                	bnez	a5,8000a112 <.L146>
                                    {
                                        /* we have reached the UINT16 border */
                                        pData++;
8000a10c:	4782                	lw	a5,0(sp)
8000a10e:	0789                	add	a5,a5,2
8000a110:	c03e                	sw	a5,0(sp)

8000a112 <.L146>:
                                    }

                                    /*increment WORD offset*/
                                    pData += ((pEntry->BitLength & 0xF0) >> 4);
8000a112:	57b2                	lw	a5,44(sp)
8000a114:	0027c703          	lbu	a4,2(a5)
8000a118:	0037c783          	lbu	a5,3(a5)
8000a11c:	07a2                	sll	a5,a5,0x8
8000a11e:	8fd9                	or	a5,a5,a4
8000a120:	0807c7b3          	zext.h	a5,a5
8000a124:	8791                	sra	a5,a5,0x4
8000a126:	8bbd                	and	a5,a5,15
8000a128:	0786                	sll	a5,a5,0x1
8000a12a:	4702                	lw	a4,0(sp)
8000a12c:	97ba                	add	a5,a5,a4
8000a12e:	c03e                	sw	a5,0(sp)
                                }
                                else
                                {
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
                                }
                                break;
8000a130:	ac51                	j	8000a3c4 <.L148>

8000a132 <.L145>:
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
8000a132:	47e1                	li	a5,24
8000a134:	ae85                	j	8000a4a4 <.L115>

8000a136 <.L139>:
                            case    DEFTYPE_INTEGER8:
                            case    DEFTYPE_UNSIGNED8:
                            case    DEFTYPE_BYTE :
                                {
                                    /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
                                    UINT16 TmpValue = 0x0000;
8000a136:	00011d23          	sh	zero,26(sp)

                                    
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
8000a13a:	57b2                	lw	a5,44(sp)
8000a13c:	0027c703          	lbu	a4,2(a5)
8000a140:	0037c783          	lbu	a5,3(a5)
8000a144:	07a2                	sll	a5,a5,0x8
8000a146:	8fd9                	or	a5,a5,a4
8000a148:	0807c7b3          	zext.h	a5,a5
8000a14c:	86be                	mv	a3,a5
8000a14e:	800057b7          	lui	a5,0x80005
8000a152:	f4078713          	add	a4,a5,-192 # 80004f40 <cBitMask>
8000a156:	00169793          	sll	a5,a3,0x1
8000a15a:	97ba                	add	a5,a5,a4
8000a15c:	0007d783          	lhu	a5,0(a5)
8000a160:	873e                	mv	a4,a5
8000a162:	03615783          	lhu	a5,54(sp)
8000a166:	8bbd                	and	a5,a5,15
8000a168:	00f717b3          	sll	a5,a4,a5
8000a16c:	00f11c23          	sh	a5,24(sp)

                                    /*Swap object data (if required); all masks and offsets are defined for little endian format*/
                                    TmpValue = SWAPWORD(pVarPtr[0]);
8000a170:	47f2                	lw	a5,28(sp)
8000a172:	0007d783          	lhu	a5,0(a5)
8000a176:	00f11d23          	sh	a5,26(sp)

                                    /*Clear pData if the first bits within the WORD memory will be copied*/
                                    if ((bitOffset & 0x0F) == 0) 
8000a17a:	03615783          	lhu	a5,54(sp)
8000a17e:	8bbd                	and	a5,a5,15
8000a180:	e781                	bnez	a5,8000a188 <.L149>
                                    {
                                        pData[0] = 0;
8000a182:	4782                	lw	a5,0(sp)
8000a184:	00079023          	sh	zero,0(a5)

8000a188 <.L149>:
                                    }

                                    pData[0] = SWAPWORD(pData[0]);
8000a188:	4782                	lw	a5,0(sp)
8000a18a:	0007d703          	lhu	a4,0(a5)
8000a18e:	4782                	lw	a5,0(sp)
8000a190:	00e79023          	sh	a4,0(a5)

                                    if (bCompleteAccess) 
8000a194:	00c14783          	lbu	a5,12(sp)
8000a198:	c39d                	beqz	a5,8000a1be <.L150>
                                    {
                                        /*shifting is not required for Complete access because the bits are set to the correct offset by the master*/
                                        pData[0] |= TmpValue & bitMask;
8000a19a:	4782                	lw	a5,0(sp)
8000a19c:	0007d703          	lhu	a4,0(a5)
8000a1a0:	01a15783          	lhu	a5,26(sp)
8000a1a4:	86be                	mv	a3,a5
8000a1a6:	01815783          	lhu	a5,24(sp)
8000a1aa:	8ff5                	and	a5,a5,a3
8000a1ac:	0807c7b3          	zext.h	a5,a5
8000a1b0:	8fd9                	or	a5,a5,a4
8000a1b2:	0807c733          	zext.h	a4,a5
8000a1b6:	4782                	lw	a5,0(sp)
8000a1b8:	00e79023          	sh	a4,0(a5)
8000a1bc:	a835                	j	8000a1f8 <.L151>

8000a1be <.L150>:
                                    }
                                    else
                                    {
                                        /*Shift Bits to the beginning of the mailbox memory*/
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
8000a1be:	4782                	lw	a5,0(sp)
8000a1c0:	0007d783          	lhu	a5,0(a5)
8000a1c4:	60579713          	sext.h	a4,a5
8000a1c8:	01a15783          	lhu	a5,26(sp)
8000a1cc:	86be                	mv	a3,a5
8000a1ce:	01815783          	lhu	a5,24(sp)
8000a1d2:	8ff5                	and	a5,a5,a3
8000a1d4:	0807c7b3          	zext.h	a5,a5
8000a1d8:	86be                	mv	a3,a5
8000a1da:	03615783          	lhu	a5,54(sp)
8000a1de:	8bbd                	and	a5,a5,15
8000a1e0:	40f6d7b3          	sra	a5,a3,a5
8000a1e4:	60579793          	sext.h	a5,a5
8000a1e8:	8fd9                	or	a5,a5,a4
8000a1ea:	60579793          	sext.h	a5,a5
8000a1ee:	0807c733          	zext.h	a4,a5
8000a1f2:	4782                	lw	a5,0(sp)
8000a1f4:	00e79023          	sh	a4,0(a5)

8000a1f8 <.L151>:
                                    }

                                    pData[0] = SWAPWORD(pData[0]);
8000a1f8:	4782                	lw	a5,0(sp)
8000a1fa:	0007d703          	lhu	a4,0(a5)
8000a1fe:	4782                	lw	a5,0(sp)
8000a200:	00e79023          	sh	a4,0(a5)
                                    if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
8000a204:	57b2                	lw	a5,44(sp)
8000a206:	0027c703          	lbu	a4,2(a5)
8000a20a:	0037c783          	lbu	a5,3(a5)
8000a20e:	07a2                	sll	a5,a5,0x8
8000a210:	8fd9                	or	a5,a5,a4
8000a212:	0807c7b3          	zext.h	a5,a5
8000a216:	03615703          	lhu	a4,54(sp)
8000a21a:	97ba                	add	a5,a5,a4
8000a21c:	0807c7b3          	zext.h	a5,a5
8000a220:	8bbd                	and	a5,a5,15
8000a222:	18079c63          	bnez	a5,8000a3ba <.L167>
                                    {
                                        /* we have reached the UINT16 border */
                                        pData++;
8000a226:	4782                	lw	a5,0(sp)
8000a228:	0789                	add	a5,a5,2
8000a22a:	c03e                	sw	a5,0(sp)

8000a22c <.LBE15>:
                                    }

                                }
                                break;
8000a22c:	a279                	j	8000a3ba <.L167>

8000a22e <.L141>:
                            case    DEFTYPE_INTEGER16:
                            case    DEFTYPE_UNSIGNED16:
                            case    DEFTYPE_BITARR16:
                            case    DEFTYPE_WORD:

                                if(bitOffset & 0xF)
8000a22e:	03615783          	lhu	a5,54(sp)
8000a232:	8bbd                	and	a5,a5,15
8000a234:	c399                	beqz	a5,8000a23a <.L153>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
8000a236:	4795                	li	a5,5
8000a238:	a4b5                	j	8000a4a4 <.L115>

8000a23a <.L153>:
                                }
                                /* in this example the objects are defined in that way,
                                that the 16 bit type are always starting at an exact WORD offset */
                                pData[0] = SWAPWORD(pVarPtr[0]);
8000a23a:	47f2                	lw	a5,28(sp)
8000a23c:	0007d703          	lhu	a4,0(a5)
8000a240:	4782                	lw	a5,0(sp)
8000a242:	00e79023          	sh	a4,0(a5)
                                pData++;
8000a246:	4782                	lw	a5,0(sp)
8000a248:	0789                	add	a5,a5,2
8000a24a:	c03e                	sw	a5,0(sp)
                                break;
8000a24c:	aaa5                	j	8000a3c4 <.L148>

8000a24e <.L140>:
                            case    DEFTYPE_UNSIGNED32:
                            case    DEFTYPE_INTEGER32:
                            case    DEFTYPE_REAL32:
                            case    DEFTYPE_BITARR32:
                            case    DEFTYPE_DWORD:
                                if(bitOffset & 0xF)
8000a24e:	03615783          	lhu	a5,54(sp)
8000a252:	8bbd                	and	a5,a5,15
8000a254:	c399                	beqz	a5,8000a25a <.L154>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
8000a256:	4795                	li	a5,5
8000a258:	a4b1                	j	8000a4a4 <.L115>

8000a25a <.L154>:
                                }

                                /* in this example the objects are defined in that way,
                                that the 32 bit type are always starting at an exact WORD offset */
                                pData[0] = pVarPtr[0];
8000a25a:	47f2                	lw	a5,28(sp)
8000a25c:	0007d703          	lhu	a4,0(a5)
8000a260:	4782                	lw	a5,0(sp)
8000a262:	00e79023          	sh	a4,0(a5)
                                pData[1] = pVarPtr[1];
8000a266:	4782                	lw	a5,0(sp)
8000a268:	0789                	add	a5,a5,2
8000a26a:	4772                	lw	a4,28(sp)
8000a26c:	00275703          	lhu	a4,2(a4)
8000a270:	00e79023          	sh	a4,0(a5)
                                pData += 2;
8000a274:	4782                	lw	a5,0(sp)
8000a276:	0791                	add	a5,a5,4
8000a278:	c03e                	sw	a5,0(sp)
                                break;
8000a27a:	a2a9                	j	8000a3c4 <.L148>

8000a27c <.L142>:
                            case    DEFTYPE_REAL64:
                            case 	DEFTYPE_INTEGER64:
                            case    DEFTYPE_UNSIGNED64:
                                if(bitOffset & 0xF)
8000a27c:	03615783          	lhu	a5,54(sp)
8000a280:	8bbd                	and	a5,a5,15
8000a282:	c399                	beqz	a5,8000a288 <.L155>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
8000a284:	4795                	li	a5,5
8000a286:	ac39                	j	8000a4a4 <.L115>

8000a288 <.L155>:
                                }

                                /* in this example the objects are defined in that way,
                                that the 64 bit type are always starting at an exact WORD offset */
                                pData[0] = pVarPtr[0];
8000a288:	47f2                	lw	a5,28(sp)
8000a28a:	0007d703          	lhu	a4,0(a5)
8000a28e:	4782                	lw	a5,0(sp)
8000a290:	00e79023          	sh	a4,0(a5)
                                pData[1] = pVarPtr[1];
8000a294:	4782                	lw	a5,0(sp)
8000a296:	0789                	add	a5,a5,2
8000a298:	4772                	lw	a4,28(sp)
8000a29a:	00275703          	lhu	a4,2(a4)
8000a29e:	00e79023          	sh	a4,0(a5)
                                pData[2] = pVarPtr[2];
8000a2a2:	4782                	lw	a5,0(sp)
8000a2a4:	0791                	add	a5,a5,4
8000a2a6:	4772                	lw	a4,28(sp)
8000a2a8:	00475703          	lhu	a4,4(a4)
8000a2ac:	00e79023          	sh	a4,0(a5)
                                pData[3] = pVarPtr[3];
8000a2b0:	4782                	lw	a5,0(sp)
8000a2b2:	0799                	add	a5,a5,6
8000a2b4:	4772                	lw	a4,28(sp)
8000a2b6:	00675703          	lhu	a4,6(a4)
8000a2ba:	00e79023          	sh	a4,0(a5)
                                pData += 4;
8000a2be:	4782                	lw	a5,0(sp)
8000a2c0:	07a1                	add	a5,a5,8
8000a2c2:	c03e                	sw	a5,0(sp)
                                break;
8000a2c4:	a201                	j	8000a3c4 <.L148>

8000a2c6 <.L134>:
                            case DEFTYPE_ARRAY_OF_INT :
                            case DEFTYPE_ARRAY_OF_SINT :
                            case DEFTYPE_ARRAY_OF_DINT :
                            case DEFTYPE_ARRAY_OF_UDINT:

                                if(bitOffset & 0xF)
8000a2c6:	03615783          	lhu	a5,54(sp)
8000a2ca:	8bbd                	and	a5,a5,15
8000a2cc:	c399                	beqz	a5,8000a2d2 <.L156>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
8000a2ce:	4795                	li	a5,5
8000a2d0:	aad1                	j	8000a4a4 <.L115>

8000a2d2 <.L156>:
                                }

                                OBJTOMBXMEMCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
8000a2d2:	57b2                	lw	a5,44(sp)
8000a2d4:	0027c703          	lbu	a4,2(a5)
8000a2d8:	0037c783          	lbu	a5,3(a5)
8000a2dc:	07a2                	sll	a5,a5,0x8
8000a2de:	8fd9                	or	a5,a5,a4
8000a2e0:	0807c7b3          	zext.h	a5,a5
8000a2e4:	079d                	add	a5,a5,7
8000a2e6:	878d                	sra	a5,a5,0x3
8000a2e8:	863e                	mv	a2,a5
8000a2ea:	45f2                	lw	a1,28(sp)
8000a2ec:	4502                	lw	a0,0(sp)
8000a2ee:	16f030ef          	jal	8000dc5c <memcpy>

                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
8000a2f2:	57b2                	lw	a5,44(sp)
8000a2f4:	0027c703          	lbu	a4,2(a5)
8000a2f8:	0037c783          	lbu	a5,3(a5)
8000a2fc:	07a2                	sll	a5,a5,0x8
8000a2fe:	8fd9                	or	a5,a5,a4
8000a300:	0807c7b3          	zext.h	a5,a5
8000a304:	9bc1                	and	a5,a5,-16
8000a306:	07bd                	add	a5,a5,15
8000a308:	8791                	sra	a5,a5,0x4
8000a30a:	0786                	sll	a5,a5,0x1
8000a30c:	4702                	lw	a4,0(sp)
8000a30e:	97ba                	add	a5,a5,a4
8000a310:	c03e                	sw	a5,0(sp)
                                
                                if((pEntry->BitLength & 0xF) != 0)
8000a312:	57b2                	lw	a5,44(sp)
8000a314:	0027c703          	lbu	a4,2(a5)
8000a318:	0037c783          	lbu	a5,3(a5)
8000a31c:	07a2                	sll	a5,a5,0x8
8000a31e:	8fd9                	or	a5,a5,a4
8000a320:	0807c7b3          	zext.h	a5,a5
8000a324:	8bbd                	and	a5,a5,15
8000a326:	cfc1                	beqz	a5,8000a3be <.L168>
                                {
                                    /*current entry has an odd word length => clear last byte of next word*/
                                    *pData &= 0xFF;
8000a328:	4782                	lw	a5,0(sp)
8000a32a:	0007d783          	lhu	a5,0(a5)
8000a32e:	0ff7f793          	zext.b	a5,a5
8000a332:	0807c733          	zext.h	a4,a5
8000a336:	4782                	lw	a5,0(sp)
8000a338:	00e79023          	sh	a4,0(a5)
                                }

                                break;
8000a33c:	a049                	j	8000a3be <.L168>

8000a33e <.L144>:
                            case    DEFTYPE_VISIBLESTRING:
                                if(bitOffset & 0xF)
8000a33e:	03615783          	lhu	a5,54(sp)
8000a342:	8bbd                	and	a5,a5,15
8000a344:	c399                	beqz	a5,8000a34a <.L158>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
8000a346:	4795                	li	a5,5
8000a348:	aab1                	j	8000a4a4 <.L115>

8000a34a <.L158>:
                                }

                                /* in this example the objects are defined in that way,
                                that these types are always starting at an even WORD offset */
                                OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
8000a34a:	57b2                	lw	a5,44(sp)
8000a34c:	0027c703          	lbu	a4,2(a5)
8000a350:	0037c783          	lbu	a5,3(a5)
8000a354:	07a2                	sll	a5,a5,0x8
8000a356:	8fd9                	or	a5,a5,a4
8000a358:	0807c7b3          	zext.h	a5,a5
8000a35c:	079d                	add	a5,a5,7
8000a35e:	878d                	sra	a5,a5,0x3
8000a360:	863e                	mv	a2,a5
8000a362:	45f2                	lw	a1,28(sp)
8000a364:	4502                	lw	a0,0(sp)
8000a366:	0f7030ef          	jal	8000dc5c <memcpy>
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
8000a36a:	57b2                	lw	a5,44(sp)
8000a36c:	0027c703          	lbu	a4,2(a5)
8000a370:	0037c783          	lbu	a5,3(a5)
8000a374:	07a2                	sll	a5,a5,0x8
8000a376:	8fd9                	or	a5,a5,a4
8000a378:	0807c7b3          	zext.h	a5,a5
8000a37c:	9bc1                	and	a5,a5,-16
8000a37e:	07bd                	add	a5,a5,15
8000a380:	8791                	sra	a5,a5,0x4
8000a382:	0786                	sll	a5,a5,0x1
8000a384:	4702                	lw	a4,0(sp)
8000a386:	97ba                	add	a5,a5,a4
8000a388:	c03e                	sw	a5,0(sp)

                                if((pEntry->BitLength & 0xF) != 0)
8000a38a:	57b2                	lw	a5,44(sp)
8000a38c:	0027c703          	lbu	a4,2(a5)
8000a390:	0037c783          	lbu	a5,3(a5)
8000a394:	07a2                	sll	a5,a5,0x8
8000a396:	8fd9                	or	a5,a5,a4
8000a398:	0807c7b3          	zext.h	a5,a5
8000a39c:	8bbd                	and	a5,a5,15
8000a39e:	c395                	beqz	a5,8000a3c2 <.L169>
                                {
                                    /*current entry has an odd word length => clear last byte of next word*/
                                    *pData &= 0xFF;
8000a3a0:	4782                	lw	a5,0(sp)
8000a3a2:	0007d783          	lhu	a5,0(a5)
8000a3a6:	0ff7f793          	zext.b	a5,a5
8000a3aa:	0807c733          	zext.h	a4,a5
8000a3ae:	4782                	lw	a5,0(sp)
8000a3b0:	00e79023          	sh	a4,0(a5)
                                }
                                
                                break;
8000a3b4:	a039                	j	8000a3c2 <.L169>

8000a3b6 <.L133>:
                            default:
                                /* other data types are not supported from this example */
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
8000a3b6:	47e1                	li	a5,24
8000a3b8:	a0f5                	j	8000a4a4 <.L115>

8000a3ba <.L167>:
                                break;
8000a3ba:	0001                	nop
8000a3bc:	a021                	j	8000a3c4 <.L148>

8000a3be <.L168>:
                                break;
8000a3be:	0001                	nop
8000a3c0:	a011                	j	8000a3c4 <.L148>

8000a3c2 <.L169>:
                                break;
8000a3c2:	0001                	nop

8000a3c4 <.L148>:
                            } //switch (deftype)

                            bRead = 1;
8000a3c4:	4785                	li	a5,1
8000a3c6:	02f10ca3          	sb	a5,57(sp)
8000a3ca:	a85d                	j	8000a480 <.L160>

8000a3cc <.L126>:
                    }
                }
                else
                {
                    /*No access to current object entry => shift pData if required*/
                    UINT8 cnt = 0;
8000a3cc:	020109a3          	sb	zero,51(sp)

                    /*If this entry is the first in the 16Bit block clear the memory*/
                    if ((bitOffset & 0x0F) == 0) 
8000a3d0:	03615783          	lhu	a5,54(sp)
8000a3d4:	8bbd                	and	a5,a5,15
8000a3d6:	e781                	bnez	a5,8000a3de <.L161>
                    {
                        *pData = 0;
8000a3d8:	4782                	lw	a5,0(sp)
8000a3da:	00079023          	sh	zero,0(a5)

8000a3de <.L161>:
                    }

                    /*Handle Bit/Byte Offset*/
                    if (((pEntry->BitLength & 0xF) > 0)
8000a3de:	57b2                	lw	a5,44(sp)
8000a3e0:	0027c703          	lbu	a4,2(a5)
8000a3e4:	0037c783          	lbu	a5,3(a5)
8000a3e8:	07a2                	sll	a5,a5,0x8
8000a3ea:	8fd9                	or	a5,a5,a4
8000a3ec:	0807c7b3          	zext.h	a5,a5
8000a3f0:	8bbd                	and	a5,a5,15
8000a3f2:	02f05863          	blez	a5,8000a422 <.L162>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
8000a3f6:	57b2                	lw	a5,44(sp)
8000a3f8:	0027c703          	lbu	a4,2(a5)
8000a3fc:	0037c783          	lbu	a5,3(a5)
8000a400:	07a2                	sll	a5,a5,0x8
8000a402:	8fd9                	or	a5,a5,a4
8000a404:	0807c7b3          	zext.h	a5,a5
8000a408:	03615703          	lhu	a4,54(sp)
8000a40c:	97ba                	add	a5,a5,a4
8000a40e:	0807c7b3          	zext.h	a5,a5
8000a412:	8bbd                	and	a5,a5,15
8000a414:	e799                	bnez	a5,8000a422 <.L162>
                    {
                        /* we have reached the UINT16 border */
                        pData++;
8000a416:	4782                	lw	a5,0(sp)
8000a418:	0789                	add	a5,a5,2
8000a41a:	c03e                	sw	a5,0(sp)
                        
                        /*Clear new buffer*/
                        *pData = 0;
8000a41c:	4782                	lw	a5,0(sp)
8000a41e:	00079023          	sh	zero,0(a5)

8000a422 <.L162>:
                    }

                    /*increment WORD offset*/
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
8000a422:	020109a3          	sb	zero,51(sp)
8000a426:	a821                	j	8000a43e <.L163>

8000a428 <.L164>:
                    {
                        
                        /*current 16Bit are skipped => clear current buffer */
                        pData++;
8000a428:	4782                	lw	a5,0(sp)
8000a42a:	0789                	add	a5,a5,2
8000a42c:	c03e                	sw	a5,0(sp)

                        /*Clear new buffer*/
                        *pData = 0;
8000a42e:	4782                	lw	a5,0(sp)
8000a430:	00079023          	sh	zero,0(a5)
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
8000a434:	03314783          	lbu	a5,51(sp)
8000a438:	0785                	add	a5,a5,1
8000a43a:	02f109a3          	sb	a5,51(sp)

8000a43e <.L163>:
8000a43e:	03314703          	lbu	a4,51(sp)
8000a442:	57b2                	lw	a5,44(sp)
8000a444:	0027c683          	lbu	a3,2(a5)
8000a448:	0037c783          	lbu	a5,3(a5)
8000a44c:	07a2                	sll	a5,a5,0x8
8000a44e:	8fd5                	or	a5,a5,a3
8000a450:	0807c7b3          	zext.h	a5,a5
8000a454:	8791                	sra	a5,a5,0x4
8000a456:	8bbd                	and	a5,a5,15
8000a458:	fcf748e3          	blt	a4,a5,8000a428 <.L164>


                    

                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
8000a45c:	57b2                	lw	a5,44(sp)
8000a45e:	0047c703          	lbu	a4,4(a5)
8000a462:	0057c783          	lbu	a5,5(a5)
8000a466:	07a2                	sll	a5,a5,0x8
8000a468:	8fd9                	or	a5,a5,a4
8000a46a:	0807c7b3          	zext.h	a5,a5
8000a46e:	8b9d                	and	a5,a5,7
8000a470:	e789                	bnez	a5,8000a47a <.L165>
                    {
                        /* it is a write only entry */
                        result = ABORTIDX_WRITE_ONLY_ENTRY;
8000a472:	4799                	li	a5,6
8000a474:	02f10c23          	sb	a5,56(sp)
8000a478:	a021                	j	8000a480 <.L160>

8000a47a <.L165>:
                    }
                    else
                    {
                        /* we don't have read access in this state */
                        result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
8000a47a:	47e9                	li	a5,26
8000a47c:	02f10c23          	sb	a5,56(sp)

8000a480 <.L160>:
            for (i = subindex; i <= lastSubindex; i++)
8000a480:	03e15783          	lhu	a5,62(sp)
8000a484:	0785                	add	a5,a5,1
8000a486:	02f11f23          	sh	a5,62(sp)

8000a48a <.L124>:
8000a48a:	03e15703          	lhu	a4,62(sp)
8000a48e:	03a15783          	lhu	a5,58(sp)
8000a492:	a0e7f0e3          	bgeu	a5,a4,80009e92 <.L166>
                    }
                }
            }

            if(bRead == 0)
8000a496:	03914783          	lbu	a5,57(sp)
8000a49a:	e781                	bnez	a5,8000a4a2 <.L123>
            {
                return result;
8000a49c:	03814783          	lbu	a5,56(sp)
8000a4a0:	a011                	j	8000a4a4 <.L115>

8000a4a2 <.L123>:
            }
        }

    return 0;
8000a4a2:	4781                	li	a5,0

8000a4a4 <.L115>:
}
8000a4a4:	853e                	mv	a0,a5
8000a4a6:	40b6                	lw	ra,76(sp)
8000a4a8:	6161                	add	sp,sp,80
8000a4aa:	8082                	ret

Disassembly of section .text.OBJ_Write:

8000a4ac <OBJ_Write>:

 \brief    This function writes the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
8000a4ac:	715d                	add	sp,sp,-80
8000a4ae:	c686                	sw	ra,76(sp)
8000a4b0:	c432                	sw	a2,8(sp)
8000a4b2:	c236                	sw	a3,4(sp)
8000a4b4:	c03a                	sw	a4,0(sp)
8000a4b6:	873e                	mv	a4,a5
8000a4b8:	87aa                	mv	a5,a0
8000a4ba:	00f11723          	sh	a5,14(sp)
8000a4be:	87ae                	mv	a5,a1
8000a4c0:	00f106a3          	sb	a5,13(sp)
8000a4c4:	87ba                	mv	a5,a4
8000a4c6:	00f10623          	sb	a5,12(sp)
    UINT16 i = subindex;
8000a4ca:	00d14783          	lbu	a5,13(sp)
8000a4ce:	02f11f23          	sh	a5,62(sp)
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
8000a4d2:	4792                	lw	a5,4(sp)
8000a4d4:	00c7d783          	lhu	a5,12(a5)
8000a4d8:	87a1                	sra	a5,a5,0x8
8000a4da:	0ff7f793          	zext.b	a5,a5
8000a4de:	8bbd                	and	a5,a5,15
8000a4e0:	02f105a3          	sb	a5,43(sp)
    UINT16 maxSubindex = 0;
8000a4e4:	02011e23          	sh	zero,60(sp)
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
8000a4e8:	4792                	lw	a5,4(sp)
8000a4ea:	00c7d783          	lhu	a5,12(a5)
8000a4ee:	0ff7f793          	zext.b	a5,a5
8000a4f2:	02f11423          	sh	a5,40(sp)
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    BOOL bClearSubindex0Required = FALSE;
8000a4f6:	02010da3          	sb	zero,59(sp)
    /* lastSubindex is used for complete access to make loop over the requested entries
       to be read, we initialize this variable with the requested subindex that only
       one loop will be done for a single access */
    UINT16 lastSubindex = subindex;
8000a4fa:	00d14783          	lbu	a5,13(sp)
8000a4fe:	02f11c23          	sh	a5,56(sp)

    /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
        because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
    if ( objCode != OBJCODE_VAR )
8000a502:	02b14703          	lbu	a4,43(sp)
8000a506:	479d                	li	a5,7
8000a508:	08f70263          	beq	a4,a5,8000a58c <.L171>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
           actual value of subindex 0, which is stored as UINT16 at the beginning of the
            object's variable */
        maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
8000a50c:	4792                	lw	a5,4(sp)
8000a50e:	4f9c                	lw	a5,24(a5)
8000a510:	0007d783          	lhu	a5,0(a5)
8000a514:	0ff7f793          	zext.b	a5,a5
8000a518:	02f11e23          	sh	a5,60(sp)

        /*If the subindex0 of a PDO assign or PDO mapping object is 0 the maximum subindex is specified by the object description*/
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
8000a51c:	03c15783          	lhu	a5,60(sp)
8000a520:	e7b5                	bnez	a5,8000a58c <.L171>
8000a522:	00e15703          	lhu	a4,14(sp)
8000a526:	6789                	lui	a5,0x2
8000a528:	c0f78793          	add	a5,a5,-1009 # 1c0f <__ILM_segment_used_end__+0x69>
8000a52c:	00e7f963          	bgeu	a5,a4,8000a53e <.L172>
8000a530:	00e15703          	lhu	a4,14(sp)
8000a534:	6789                	lui	a5,0x2
8000a536:	c2f78793          	add	a5,a5,-977 # 1c2f <__ILM_segment_used_end__+0x89>
8000a53a:	04e7f563          	bgeu	a5,a4,8000a584 <.L173>

8000a53e <.L172>:
8000a53e:	00e15703          	lhu	a4,14(sp)
8000a542:	6785                	lui	a5,0x1
8000a544:	5ff78793          	add	a5,a5,1535 # 15ff <.L81+0x7>
8000a548:	00e7f963          	bgeu	a5,a4,8000a55a <.L174>
8000a54c:	00e15703          	lhu	a4,14(sp)
8000a550:	6785                	lui	a5,0x1
8000a552:	7ff78793          	add	a5,a5,2047 # 17ff <.L102+0x19>
8000a556:	02e7f763          	bgeu	a5,a4,8000a584 <.L173>

8000a55a <.L174>:
8000a55a:	00e15703          	lhu	a4,14(sp)
8000a55e:	6789                	lui	a5,0x2
8000a560:	9ff78793          	add	a5,a5,-1537 # 19ff <rom_xpi_nor_program+0x3d>
8000a564:	00e7f963          	bgeu	a5,a4,8000a576 <.L175>
8000a568:	00e15703          	lhu	a4,14(sp)
8000a56c:	6789                	lui	a5,0x2
8000a56e:	bff78793          	add	a5,a5,-1025 # 1bff <__ILM_segment_used_end__+0x59>
8000a572:	00e7f963          	bgeu	a5,a4,8000a584 <.L173>

8000a576 <.L175>:
8000a576:	00e15703          	lhu	a4,14(sp)
8000a57a:	67bd                	lui	a5,0xf
8000a57c:	03078793          	add	a5,a5,48 # f030 <__AXI_SRAM_segment_used_size__+0x5ad4>
8000a580:	00f71663          	bne	a4,a5,8000a58c <.L171>

8000a584 <.L173>:
        {
            maxSubindex = maxConfiguredSubindex;
8000a584:	02815783          	lhu	a5,40(sp)
8000a588:	02f11e23          	sh	a5,60(sp)

8000a58c <.L171>:
        }
    }


    if ( bCompleteAccess )
8000a58c:	00c14783          	lbu	a5,12(sp)
8000a590:	cb95                	beqz	a5,8000a5c4 <.L176>
    {
        if ( objCode == OBJCODE_VAR )
8000a592:	02b14703          	lbu	a4,43(sp)
8000a596:	479d                	li	a5,7
8000a598:	00f71563          	bne	a4,a5,8000a5a2 <.L177>
        {
            /* complete access is not supported with simple objects */
            return ABORTIDX_UNSUPPORTED_ACCESS;
8000a59c:	4795                	li	a5,5
8000a59e:	1590006f          	j	8000aef6 <.L178>

8000a5a2 <.L177>:
        }

        if ((subindex == 0) && (dataSize > 0))
8000a5a2:	00d14783          	lbu	a5,13(sp)
8000a5a6:	eb91                	bnez	a5,8000a5ba <.L179>
8000a5a8:	47a2                	lw	a5,8(sp)
8000a5aa:	cb81                	beqz	a5,8000a5ba <.L179>
        {
            /* we change the subindex 0 */
            maxSubindex = (UINT8) SWAPWORD(pData[0]);
8000a5ac:	4782                	lw	a5,0(sp)
8000a5ae:	0007d783          	lhu	a5,0(a5)
8000a5b2:	0ff7f793          	zext.b	a5,a5
8000a5b6:	02f11e23          	sh	a5,60(sp)

8000a5ba <.L179>:
        }


        /* we write until the maximum subindex */
        lastSubindex = maxSubindex;
8000a5ba:	03c15783          	lhu	a5,60(sp)
8000a5be:	02f11c23          	sh	a5,56(sp)
8000a5c2:	a069                	j	8000a64c <.L180>

8000a5c4 <.L176>:
    }
    else
    if (subindex > maxSubindex)
8000a5c4:	00d14783          	lbu	a5,13(sp)
8000a5c8:	0807c7b3          	zext.h	a5,a5
8000a5cc:	03c15703          	lhu	a4,60(sp)
8000a5d0:	00f77563          	bgeu	a4,a5,8000a5da <.L181>
    {
        /* the maximum subindex is reached */
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
8000a5d4:	47c5                	li	a5,17
8000a5d6:	1210006f          	j	8000aef6 <.L178>

8000a5da <.L181>:
    {
        /* we check the write access for single accesses here, a complete write access
           is allowed if at least one entry is writable (in this case the values for the
            read only entries shall be ignored) */
        /* we get the corresponding entry description */
        pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
8000a5da:	00d14783          	lbu	a5,13(sp)
8000a5de:	85be                	mv	a1,a5
8000a5e0:	4512                	lw	a0,4(sp)
8000a5e2:	e4eff0ef          	jal	80009c30 <OBJ_GetEntryDesc>
8000a5e6:	d22a                	sw	a0,36(sp)

        /* check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
           by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
        if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
8000a5e8:	5792                	lw	a5,36(sp)
8000a5ea:	0047c703          	lbu	a4,4(a5)
8000a5ee:	0057c783          	lbu	a5,5(a5)
8000a5f2:	07a2                	sll	a5,a5,0x8
8000a5f4:	8fd9                	or	a5,a5,a4
8000a5f6:	0807c7b3          	zext.h	a5,a5
8000a5fa:	8789                	sra	a5,a5,0x2
8000a5fc:	0ff7f793          	zext.b	a5,a5
8000a600:	00e7f713          	and	a4,a5,14
8000a604:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000a608:	8bbd                	and	a5,a5,15
8000a60a:	8ff9                	and	a5,a5,a4
8000a60c:	e3a1                	bnez	a5,8000a64c <.L180>
        {
            /* we don't have write access */
            if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
8000a60e:	5792                	lw	a5,36(sp)
8000a610:	0047c703          	lbu	a4,4(a5)
8000a614:	0057c783          	lbu	a5,5(a5)
8000a618:	07a2                	sll	a5,a5,0x8
8000a61a:	8fd9                	or	a5,a5,a4
8000a61c:	0807c7b3          	zext.h	a5,a5
8000a620:	0387f793          	and	a5,a5,56
8000a624:	e38d                	bnez	a5,8000a646 <.L182>
            {
                if (pEntry->ObjAccess == 0)
8000a626:	5792                	lw	a5,36(sp)
8000a628:	0047c703          	lbu	a4,4(a5)
8000a62c:	0057c783          	lbu	a5,5(a5)
8000a630:	07a2                	sll	a5,a5,0x8
8000a632:	8fd9                	or	a5,a5,a4
8000a634:	0807c7b3          	zext.h	a5,a5
8000a638:	e781                	bnez	a5,8000a640 <.L183>
                {
                        return ABORTIDX_UNSUPPORTED_ACCESS;
8000a63a:	4795                	li	a5,5
8000a63c:	0bb0006f          	j	8000aef6 <.L178>

8000a640 <.L183>:
                }
                else
                {
                        /* it is a read only entry */
                        return ABORTIDX_READ_ONLY_ENTRY;
8000a640:	479d                	li	a5,7
8000a642:	0b50006f          	j	8000aef6 <.L178>

8000a646 <.L182>:
                }
            }
            else
            {
                /* we don't have write access in this state */
                return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
8000a646:	47e9                	li	a5,26
8000a648:	0af0006f          	j	8000aef6 <.L178>

8000a64c <.L180>:

    }

    /* Subindex 0 shall be set to zero if a single PDO / PDO assign entry is written
    or a complete access without subindex0 is requested */
    if((subindex > 0) &&
8000a64c:	00d14783          	lbu	a5,13(sp)
8000a650:	c3c1                	beqz	a5,8000a6d0 <.L184>
8000a652:	00e15703          	lhu	a4,14(sp)
8000a656:	6789                	lui	a5,0x2
8000a658:	c0f78793          	add	a5,a5,-1009 # 1c0f <__ILM_segment_used_end__+0x69>
8000a65c:	00e7f963          	bgeu	a5,a4,8000a66e <.L185>
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
8000a660:	00e15703          	lhu	a4,14(sp)
8000a664:	6789                	lui	a5,0x2
8000a666:	c2f78793          	add	a5,a5,-977 # 1c2f <__ILM_segment_used_end__+0x89>
8000a66a:	04e7f563          	bgeu	a5,a4,8000a6b4 <.L186>

8000a66e <.L185>:
8000a66e:	00e15703          	lhu	a4,14(sp)
8000a672:	6785                	lui	a5,0x1
8000a674:	5ff78793          	add	a5,a5,1535 # 15ff <.L81+0x7>
8000a678:	00e7f963          	bgeu	a5,a4,8000a68a <.L187>
8000a67c:	00e15703          	lhu	a4,14(sp)
8000a680:	6785                	lui	a5,0x1
8000a682:	7ff78793          	add	a5,a5,2047 # 17ff <.L102+0x19>
8000a686:	02e7f763          	bgeu	a5,a4,8000a6b4 <.L186>

8000a68a <.L187>:
8000a68a:	00e15703          	lhu	a4,14(sp)
8000a68e:	6789                	lui	a5,0x2
8000a690:	9ff78793          	add	a5,a5,-1537 # 19ff <rom_xpi_nor_program+0x3d>
8000a694:	00e7f963          	bgeu	a5,a4,8000a6a6 <.L188>
8000a698:	00e15703          	lhu	a4,14(sp)
8000a69c:	6789                	lui	a5,0x2
8000a69e:	bff78793          	add	a5,a5,-1025 # 1bff <__ILM_segment_used_end__+0x59>
8000a6a2:	00e7f963          	bgeu	a5,a4,8000a6b4 <.L186>

8000a6a6 <.L188>:
8000a6a6:	00e15703          	lhu	a4,14(sp)
8000a6aa:	67bd                	lui	a5,0xf
8000a6ac:	03078793          	add	a5,a5,48 # f030 <__AXI_SRAM_segment_used_size__+0x5ad4>
8000a6b0:	02f71063          	bne	a4,a5,8000a6d0 <.L184>

8000a6b4 <.L186>:
        )
    {
        /*Check if Subindex0 was cleared before*/
        UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
8000a6b4:	4792                	lw	a5,4(sp)
8000a6b6:	4f9c                	lw	a5,24(a5)
8000a6b8:	0007d783          	lhu	a5,0(a5)
8000a6bc:	0ff7f793          	zext.b	a5,a5
8000a6c0:	02f11123          	sh	a5,34(sp)
        if(Subindex0 != 0x00)
8000a6c4:	02215783          	lhu	a5,34(sp)
8000a6c8:	c781                	beqz	a5,8000a6d0 <.L184>
        {
            bClearSubindex0Required = TRUE;
8000a6ca:	4785                	li	a5,1
8000a6cc:	02f10da3          	sb	a5,59(sp)

8000a6d0 <.L184>:
        }
    }

    if ( pObjEntry->Write != NULL )
8000a6d0:	4792                	lw	a5,4(sp)
8000a6d2:	539c                	lw	a5,32(a5)
8000a6d4:	c7b1                	beqz	a5,8000a720 <.L189>

8000a6d6 <.LBB18>:
    {
        /* Write function is defined, we call the object specific write function */
        /* ECATCHANGE_START(V5.13) COE4*/
        UINT8 result = 0;
8000a6d6:	00010ca3          	sb	zero,25(sp)

        result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
8000a6da:	4792                	lw	a5,4(sp)
8000a6dc:	539c                	lw	a5,32(a5)
8000a6de:	00c14703          	lbu	a4,12(sp)
8000a6e2:	00d14583          	lbu	a1,13(sp)
8000a6e6:	00e15503          	lhu	a0,14(sp)
8000a6ea:	4682                	lw	a3,0(sp)
8000a6ec:	4622                	lw	a2,8(sp)
8000a6ee:	9782                	jalr	a5
8000a6f0:	87aa                	mv	a5,a0
8000a6f2:	00f10ca3          	sb	a5,25(sp)

        if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
8000a6f6:	01914783          	lbu	a5,25(sp)
8000a6fa:	ef99                	bnez	a5,8000a718 <.L190>
8000a6fc:	1041a783          	lw	a5,260(gp) # 120947c <pAPPL_CoeWriteInd>
8000a700:	cf81                	beqz	a5,8000a718 <.L190>
        {
            pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
8000a702:	1041a783          	lw	a5,260(gp) # 120947c <pAPPL_CoeWriteInd>
8000a706:	00c14603          	lbu	a2,12(sp)
8000a70a:	00d14683          	lbu	a3,13(sp)
8000a70e:	00e15703          	lhu	a4,14(sp)
8000a712:	85b6                	mv	a1,a3
8000a714:	853a                	mv	a0,a4
8000a716:	9782                	jalr	a5

8000a718 <.L190>:
        }
        
        return result;
8000a718:	01914783          	lbu	a5,25(sp)
8000a71c:	7da0006f          	j	8000aef6 <.L178>

8000a720 <.L189>:
        /* ECATCHANGE_END(V5.13) COE4*/
    }
    else
    {
        UINT8 bWritten = 0;
8000a720:	02010ba3          	sb	zero,55(sp)
        UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
8000a724:	479d                	li	a5,7
8000a726:	02f10b23          	sb	a5,54(sp)

        if (dataSize == 0)
8000a72a:	47a2                	lw	a5,8(sp)
8000a72c:	e781                	bnez	a5,8000a734 <.L191>
        {
           return 0; //no error
8000a72e:	4781                	li	a5,0
8000a730:	7c60006f          	j	8000aef6 <.L178>

8000a734 <.L191>:
        }

        /* we use the standard write function */
        for (i = subindex; i <= lastSubindex; i++)
8000a734:	00d14783          	lbu	a5,13(sp)
8000a738:	02f11f23          	sh	a5,62(sp)
8000a73c:	a751                	j	8000aec0 <.L192>

8000a73e <.L240>:
        {
            /* if only a single entry is requested, this loop will only be done once */
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
8000a73e:	4792                	lw	a5,4(sp)
8000a740:	4f9c                	lw	a5,24(a5)
8000a742:	d83e                	sw	a5,48(sp)
            UINT16 bitOffset = 0;
8000a744:	02011023          	sh	zero,32(sp)

            /* we get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
8000a748:	03e15783          	lhu	a5,62(sp)
8000a74c:	0ff7f793          	zext.b	a5,a5
8000a750:	85be                	mv	a1,a5
8000a752:	4512                	lw	a0,4(sp)
8000a754:	cdcff0ef          	jal	80009c30 <OBJ_GetEntryDesc>
8000a758:	d22a                	sw	a0,36(sp)

            /*Get the bitOffset before check the access rights to calculate pData offset*/
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
8000a75a:	03e15783          	lhu	a5,62(sp)
8000a75e:	0ff7f793          	zext.b	a5,a5
8000a762:	4592                	lw	a1,4(sp)
8000a764:	853e                	mv	a0,a5
8000a766:	716050ef          	jal	8000fe7c <OBJ_GetEntryOffset>
8000a76a:	87aa                	mv	a5,a0
8000a76c:	02f11023          	sh	a5,32(sp)

            /* we check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
               by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
            if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
8000a770:	5792                	lw	a5,36(sp)
8000a772:	0047c703          	lbu	a4,4(a5)
8000a776:	0057c783          	lbu	a5,5(a5)
8000a77a:	07a2                	sll	a5,a5,0x8
8000a77c:	8fd9                	or	a5,a5,a4
8000a77e:	0807c7b3          	zext.h	a5,a5
8000a782:	8789                	sra	a5,a5,0x2
8000a784:	0ff7f793          	zext.b	a5,a5
8000a788:	00e7f713          	and	a4,a5,14
8000a78c:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000a790:	8bbd                	and	a5,a5,15
8000a792:	8ff9                	and	a5,a5,a4
8000a794:	6a078863          	beqz	a5,8000ae44 <.L193>
            {
                /* we have write access for this entry */
                if (i != 0)
8000a798:	03e15783          	lhu	a5,62(sp)
8000a79c:	cb91                	beqz	a5,8000a7b0 <.L194>
                {
                    /* we increment the variable pointer to the corresponding word address */
                    pVarPtr += (bitOffset >> 4);
8000a79e:	02015783          	lhu	a5,32(sp)
8000a7a2:	8391                	srl	a5,a5,0x4
8000a7a4:	0807c7b3          	zext.h	a5,a5
8000a7a8:	0786                	sll	a5,a5,0x1
8000a7aa:	5742                	lw	a4,48(sp)
8000a7ac:	97ba                	add	a5,a5,a4
8000a7ae:	d83e                	sw	a5,48(sp)

8000a7b0 <.L194>:
                }


                if ( i == subindex                                     /* requested entry */
8000a7b0:	00d14783          	lbu	a5,13(sp)
8000a7b4:	0807c7b3          	zext.h	a5,a5
8000a7b8:	03e15703          	lhu	a4,62(sp)
8000a7bc:	00f70e63          	beq	a4,a5,8000a7d8 <.L195>
                  || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
8000a7c0:	00c14783          	lbu	a5,12(sp)
8000a7c4:	6e078963          	beqz	a5,8000aeb6 <.L196>
8000a7c8:	00d14783          	lbu	a5,13(sp)
8000a7cc:	0807c7b3          	zext.h	a5,a5
8000a7d0:	03e15703          	lhu	a4,62(sp)
8000a7d4:	6ef76163          	bltu	a4,a5,8000aeb6 <.L196>

8000a7d8 <.L195>:
                {
                    UINT16 bitMask;

                    /* we have to copy the entry */
                    if (i == 0 && objCode != OBJCODE_VAR)
8000a7d8:	03e15783          	lhu	a5,62(sp)
8000a7dc:	ef9d                	bnez	a5,8000a81a <.L197>
8000a7de:	02b14703          	lbu	a4,43(sp)
8000a7e2:	479d                	li	a5,7
8000a7e4:	02f70b63          	beq	a4,a5,8000a81a <.L197>

8000a7e8 <.LBB22>:
                    {
                        /*check if the value for subindex0 is valid */
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
8000a7e8:	4782                	lw	a5,0(sp)
8000a7ea:	0007d783          	lhu	a5,0(a5)
8000a7ee:	00f10fa3          	sb	a5,31(sp)
                        
                        if(maxConfiguredSubindex < NewSubindex0)
8000a7f2:	01f14783          	lbu	a5,31(sp)
8000a7f6:	0807c7b3          	zext.h	a5,a5
8000a7fa:	02815703          	lhu	a4,40(sp)
8000a7fe:	00f77463          	bgeu	a4,a5,8000a806 <.L198>
                        {
                            return ABORTIDX_VALUE_TOO_GREAT;
8000a802:	47cd                	li	a5,19
8000a804:	adcd                	j	8000aef6 <.L178>

8000a806 <.L198>:
                        }

                        /* subindex 0 of an array or record shall be written */
                        pVarPtr[0] = SWAPWORD(pData[0]);
8000a806:	4782                	lw	a5,0(sp)
8000a808:	0007d703          	lhu	a4,0(a5)
8000a80c:	57c2                	lw	a5,48(sp)
8000a80e:	00e79023          	sh	a4,0(a5)
                        /* we increment the destination pointer by 2 because the subindex 0 will be
                           transmitted as UINT16 for a complete access */
                        pData++;
8000a812:	4782                	lw	a5,0(sp)
8000a814:	0789                	add	a5,a5,2
8000a816:	c03e                	sw	a5,0(sp)

8000a818 <.LBE22>:
                    {
8000a818:	a515                	j	8000ae3c <.L199>

8000a81a <.L197>:
                    }
                    else
                    {
                        UINT16 dataType = pEntry->DataType;
8000a81a:	5792                	lw	a5,36(sp)
8000a81c:	0007c703          	lbu	a4,0(a5)
8000a820:	0017c783          	lbu	a5,1(a5)
8000a824:	07a2                	sll	a5,a5,0x8
8000a826:	8fd9                	or	a5,a5,a4
8000a828:	02f11723          	sh	a5,46(sp)
                        if (pEntry->DataType >= 0x700)
8000a82c:	5792                	lw	a5,36(sp)
8000a82e:	0007c703          	lbu	a4,0(a5)
8000a832:	0017c783          	lbu	a5,1(a5)
8000a836:	07a2                	sll	a5,a5,0x8
8000a838:	8fd9                	or	a5,a5,a4
8000a83a:	0807c733          	zext.h	a4,a5
8000a83e:	6ff00793          	li	a5,1791
8000a842:	06e7fc63          	bgeu	a5,a4,8000a8ba <.L200>
                        {
                            /* the ENUM data types are defined from index 0x700 in this example
                               convert in standard data type for the write access */
                            if ( pEntry->BitLength <= 8 )
8000a846:	5792                	lw	a5,36(sp)
8000a848:	0027c703          	lbu	a4,2(a5)
8000a84c:	0037c783          	lbu	a5,3(a5)
8000a850:	07a2                	sll	a5,a5,0x8
8000a852:	8fd9                	or	a5,a5,a4
8000a854:	0807c733          	zext.h	a4,a5
8000a858:	47a1                	li	a5,8
8000a85a:	02e7e063          	bltu	a5,a4,8000a87a <.L201>
                            {
                                dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
8000a85e:	5792                	lw	a5,36(sp)
8000a860:	0027c703          	lbu	a4,2(a5)
8000a864:	0037c783          	lbu	a5,3(a5)
8000a868:	07a2                	sll	a5,a5,0x8
8000a86a:	8fd9                	or	a5,a5,a4
8000a86c:	0807c7b3          	zext.h	a5,a5
8000a870:	02f78793          	add	a5,a5,47
8000a874:	02f11723          	sh	a5,46(sp)
8000a878:	a089                	j	8000a8ba <.L200>

8000a87a <.L201>:
                            }
                            else if ( pEntry->BitLength == 16 )
8000a87a:	5792                	lw	a5,36(sp)
8000a87c:	0027c703          	lbu	a4,2(a5)
8000a880:	0037c783          	lbu	a5,3(a5)
8000a884:	07a2                	sll	a5,a5,0x8
8000a886:	8fd9                	or	a5,a5,a4
8000a888:	0807c733          	zext.h	a4,a5
8000a88c:	47c1                	li	a5,16
8000a88e:	00f71663          	bne	a4,a5,8000a89a <.L202>
                            {
                                dataType = DEFTYPE_UNSIGNED16;
8000a892:	4799                	li	a5,6
8000a894:	02f11723          	sh	a5,46(sp)
8000a898:	a00d                	j	8000a8ba <.L200>

8000a89a <.L202>:
                            }
                            else if ( pEntry->BitLength == 32 )
8000a89a:	5792                	lw	a5,36(sp)
8000a89c:	0027c703          	lbu	a4,2(a5)
8000a8a0:	0037c783          	lbu	a5,3(a5)
8000a8a4:	07a2                	sll	a5,a5,0x8
8000a8a6:	8fd9                	or	a5,a5,a4
8000a8a8:	0807c733          	zext.h	a4,a5
8000a8ac:	02000793          	li	a5,32
8000a8b0:	00f71563          	bne	a4,a5,8000a8ba <.L200>
                            {
                                dataType = DEFTYPE_UNSIGNED32;
8000a8b4:	479d                	li	a5,7
8000a8b6:	02f11723          	sh	a5,46(sp)

8000a8ba <.L200>:
                            }
                        }

                        switch (dataType)
8000a8ba:	02e15783          	lhu	a5,46(sp)
8000a8be:	26300713          	li	a4,611
8000a8c2:	56f74a63          	blt	a4,a5,8000ae36 <.L203>
8000a8c6:	26000713          	li	a4,608
8000a8ca:	50e7df63          	bge	a5,a4,8000ade8 <.L204>
8000a8ce:	03700713          	li	a4,55
8000a8d2:	56f74263          	blt	a4,a5,8000ae36 <.L203>
8000a8d6:	4779                	li	a4,30
8000a8d8:	02e7d163          	bge	a5,a4,8000a8fa <.L205>
8000a8dc:	476d                	li	a4,27
8000a8de:	54f74c63          	blt	a4,a5,8000ae36 <.L203>
8000a8e2:	4725                	li	a4,9
8000a8e4:	04e7dc63          	bge	a5,a4,8000a93c <.L206>
8000a8e8:	c3dd                	beqz	a5,8000a98e <.L207>
8000a8ea:	5407c663          	bltz	a5,8000ae36 <.L203>
8000a8ee:	4721                	li	a4,8
8000a8f0:	54f74363          	blt	a4,a5,8000ae36 <.L203>
8000a8f4:	06f04163          	bgtz	a5,8000a956 <.L208>
8000a8f8:	ab3d                	j	8000ae36 <.L203>

8000a8fa <.L205>:
8000a8fa:	1789                	add	a5,a5,-30
8000a8fc:	4705                	li	a4,1
8000a8fe:	00f717b3          	sll	a5,a4,a5
8000a902:	03fc8737          	lui	a4,0x3fc8
8000a906:	0705                	add	a4,a4,1 # 3fc8001 <__AXI_SRAM_segment_end__+0x2d88001>
8000a908:	8f7d                	and	a4,a4,a5
8000a90a:	00e03733          	snez	a4,a4
8000a90e:	0ff77713          	zext.b	a4,a4
8000a912:	e375                	bnez	a4,8000a9f6 <.L209>
8000a914:	00020737          	lui	a4,0x20
8000a918:	0711                	add	a4,a4,4 # 20004 <__DLM_segment_size__+0x4>
8000a91a:	8f7d                	and	a4,a4,a5
8000a91c:	00e03733          	snez	a4,a4
8000a920:	0ff77713          	zext.b	a4,a4
8000a924:	3c071863          	bnez	a4,8000acf4 <.L210>
8000a928:	6741                	lui	a4,0x10
8000a92a:	0709                	add	a4,a4,2 # 10002 <__AXI_SRAM_segment_used_size__+0x6aa6>
8000a92c:	8ff9                	and	a5,a5,a4
8000a92e:	00f037b3          	snez	a5,a5
8000a932:	0ff7f793          	zext.b	a5,a5
8000a936:	1e079f63          	bnez	a5,8000ab34 <.L211>
8000a93a:	a9f5                	j	8000ae36 <.L203>

8000a93c <.L206>:
8000a93c:	17dd                	add	a5,a5,-9
8000a93e:	4749                	li	a4,18
8000a940:	4ef76b63          	bltu	a4,a5,8000ae36 <.L203>
8000a944:	00279713          	sll	a4,a5,0x2
8000a948:	800057b7          	lui	a5,0x80005
8000a94c:	03878793          	add	a5,a5,56 # 80005038 <.L213>
8000a950:	97ba                	add	a5,a5,a4
8000a952:	439c                	lw	a5,0(a5)
8000a954:	8782                	jr	a5

8000a956 <.L208>:
8000a956:	873e                	mv	a4,a5
8000a958:	4785                	li	a5,1
8000a95a:	00e797b3          	sll	a5,a5,a4
8000a95e:	1907f713          	and	a4,a5,400
8000a962:	00e03733          	snez	a4,a4
8000a966:	0ff77713          	zext.b	a4,a4
8000a96a:	38071563          	bnez	a4,8000acf4 <.L210>
8000a96e:	0267f713          	and	a4,a5,38
8000a972:	00e03733          	snez	a4,a4
8000a976:	0ff77713          	zext.b	a4,a4
8000a97a:	ef35                	bnez	a4,8000a9f6 <.L209>
8000a97c:	0487f793          	and	a5,a5,72
8000a980:	00f037b3          	snez	a5,a5
8000a984:	0ff7f793          	zext.b	a5,a5
8000a988:	1a079663          	bnez	a5,8000ab34 <.L211>
8000a98c:	a16d                	j	8000ae36 <.L203>

8000a98e <.L207>:
                        {
                        case DEFTYPE_NULL:
                            if(bCompleteAccess)
8000a98e:	00c14783          	lbu	a5,12(sp)
8000a992:	c3a5                	beqz	a5,8000a9f2 <.L215>
                            {
                                /*Handle alignment entry*/
                                if (((pEntry->BitLength & 0xF) > 0)
8000a994:	5792                	lw	a5,36(sp)
8000a996:	0027c703          	lbu	a4,2(a5)
8000a99a:	0037c783          	lbu	a5,3(a5)
8000a99e:	07a2                	sll	a5,a5,0x8
8000a9a0:	8fd9                	or	a5,a5,a4
8000a9a2:	0807c7b3          	zext.h	a5,a5
8000a9a6:	8bbd                	and	a5,a5,15
8000a9a8:	02f05563          	blez	a5,8000a9d2 <.L216>
                                    && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
8000a9ac:	5792                	lw	a5,36(sp)
8000a9ae:	0027c703          	lbu	a4,2(a5)
8000a9b2:	0037c783          	lbu	a5,3(a5)
8000a9b6:	07a2                	sll	a5,a5,0x8
8000a9b8:	8fd9                	or	a5,a5,a4
8000a9ba:	0807c7b3          	zext.h	a5,a5
8000a9be:	02015703          	lhu	a4,32(sp)
8000a9c2:	97ba                	add	a5,a5,a4
8000a9c4:	0807c7b3          	zext.h	a5,a5
8000a9c8:	8bbd                	and	a5,a5,15
8000a9ca:	e781                	bnez	a5,8000a9d2 <.L216>
                                {
                                    /* we have reached the UINT16 border */
                                    pData++;
8000a9cc:	4782                	lw	a5,0(sp)
8000a9ce:	0789                	add	a5,a5,2
8000a9d0:	c03e                	sw	a5,0(sp)

8000a9d2 <.L216>:
                                }

                                /*increment WORD offset*/
                                pData += ((pEntry->BitLength & 0xF0) >> 4);
8000a9d2:	5792                	lw	a5,36(sp)
8000a9d4:	0027c703          	lbu	a4,2(a5)
8000a9d8:	0037c783          	lbu	a5,3(a5)
8000a9dc:	07a2                	sll	a5,a5,0x8
8000a9de:	8fd9                	or	a5,a5,a4
8000a9e0:	0807c7b3          	zext.h	a5,a5
8000a9e4:	8791                	sra	a5,a5,0x4
8000a9e6:	8bbd                	and	a5,a5,15
8000a9e8:	0786                	sll	a5,a5,0x1
8000a9ea:	4702                	lw	a4,0(sp)
8000a9ec:	97ba                	add	a5,a5,a4
8000a9ee:	c03e                	sw	a5,0(sp)
                            }
                            else
                            {
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
                            }
                            break;
8000a9f0:	a1b1                	j	8000ae3c <.L199>

8000a9f2 <.L215>:
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
8000a9f2:	47e1                	li	a5,24
8000a9f4:	a309                	j	8000aef6 <.L178>

8000a9f6 <.L209>:
                        case    DEFTYPE_INTEGER8:
                        case    DEFTYPE_UNSIGNED8:
                        case    DEFTYPE_BYTE :
                        {
                            /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
                            UINT16 TmpValue = 0x0000;
8000a9f6:	02011623          	sh	zero,44(sp)

                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
8000a9fa:	5792                	lw	a5,36(sp)
8000a9fc:	0027c703          	lbu	a4,2(a5)
8000aa00:	0037c783          	lbu	a5,3(a5)
8000aa04:	07a2                	sll	a5,a5,0x8
8000aa06:	8fd9                	or	a5,a5,a4
8000aa08:	0807c7b3          	zext.h	a5,a5
8000aa0c:	86be                	mv	a3,a5
8000aa0e:	800057b7          	lui	a5,0x80005
8000aa12:	f4078713          	add	a4,a5,-192 # 80004f40 <cBitMask>
8000aa16:	00169793          	sll	a5,a3,0x1
8000aa1a:	97ba                	add	a5,a5,a4
8000aa1c:	0007d783          	lhu	a5,0(a5)
8000aa20:	873e                	mv	a4,a5
8000aa22:	02015783          	lhu	a5,32(sp)
8000aa26:	8bbd                	and	a5,a5,15
8000aa28:	00f717b3          	sll	a5,a4,a5
8000aa2c:	00f11d23          	sh	a5,26(sp)

                            /*Swap object data (if required); all masks and offsets are defined for little endian format*/
                            TmpValue = SWAPWORD(pVarPtr[0]);
8000aa30:	57c2                	lw	a5,48(sp)
8000aa32:	0007d783          	lhu	a5,0(a5)
8000aa36:	02f11623          	sh	a5,44(sp)

                            /*Clear corresponding bits*/
                            TmpValue &= ~bitMask;
8000aa3a:	01a11783          	lh	a5,26(sp)
8000aa3e:	fff7c793          	not	a5,a5
8000aa42:	60579713          	sext.h	a4,a5
8000aa46:	02c11783          	lh	a5,44(sp)
8000aa4a:	8ff9                	and	a5,a5,a4
8000aa4c:	60579793          	sext.h	a5,a5
8000aa50:	02f11623          	sh	a5,44(sp)

                            if (bCompleteAccess) 
8000aa54:	00c14783          	lbu	a5,12(sp)
8000aa58:	cf99                	beqz	a5,8000aa76 <.L218>
                            {
                                /*shifting is not required for Complete access because the bits are set to the correct offset by the master*/
                                TmpValue |= (SWAPWORD(pData[0]) & bitMask);
8000aa5a:	4782                	lw	a5,0(sp)
8000aa5c:	0007d783          	lhu	a5,0(a5)
8000aa60:	01a15703          	lhu	a4,26(sp)
8000aa64:	8ff9                	and	a5,a5,a4
8000aa66:	0807c7b3          	zext.h	a5,a5
8000aa6a:	02c15703          	lhu	a4,44(sp)
8000aa6e:	8fd9                	or	a5,a5,a4
8000aa70:	02f11623          	sh	a5,44(sp)
8000aa74:	a071                	j	8000ab00 <.L219>

8000aa76 <.L218>:
                            }
                            else
                            {
                                if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
8000aa76:	4782                	lw	a5,0(sp)
8000aa78:	0007d783          	lhu	a5,0(a5)
8000aa7c:	86be                	mv	a3,a5
8000aa7e:	5792                	lw	a5,36(sp)
8000aa80:	0027c703          	lbu	a4,2(a5)
8000aa84:	0037c783          	lbu	a5,3(a5)
8000aa88:	07a2                	sll	a5,a5,0x8
8000aa8a:	8fd9                	or	a5,a5,a4
8000aa8c:	0807c7b3          	zext.h	a5,a5
8000aa90:	863e                	mv	a2,a5
8000aa92:	800057b7          	lui	a5,0x80005
8000aa96:	f4078713          	add	a4,a5,-192 # 80004f40 <cBitMask>
8000aa9a:	00161793          	sll	a5,a2,0x1
8000aa9e:	97ba                	add	a5,a5,a4
8000aaa0:	0007d783          	lhu	a5,0(a5)
8000aaa4:	fff7c793          	not	a5,a5
8000aaa8:	8ff5                	and	a5,a5,a3
8000aaaa:	c399                	beqz	a5,8000aab0 <.L220>
                                {
                                    /*written value exceed entry range*/
                                    return ABORTIDX_VALUE_EXCEEDED;
8000aaac:	47c9                	li	a5,18
8000aaae:	a1a1                	j	8000aef6 <.L178>

8000aab0 <.L220>:
                                }
                                else
                                {
                                    /*Shift Bits to corresponding offset within the object memory*/
                                    TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
8000aab0:	4782                	lw	a5,0(sp)
8000aab2:	0007d703          	lhu	a4,0(a5)
8000aab6:	5792                	lw	a5,36(sp)
8000aab8:	0027c683          	lbu	a3,2(a5)
8000aabc:	0037c783          	lbu	a5,3(a5)
8000aac0:	07a2                	sll	a5,a5,0x8
8000aac2:	8fd5                	or	a5,a5,a3
8000aac4:	0807c7b3          	zext.h	a5,a5
8000aac8:	863e                	mv	a2,a5
8000aaca:	800057b7          	lui	a5,0x80005
8000aace:	f4078693          	add	a3,a5,-192 # 80004f40 <cBitMask>
8000aad2:	00161793          	sll	a5,a2,0x1
8000aad6:	97b6                	add	a5,a5,a3
8000aad8:	0007d783          	lhu	a5,0(a5)
8000aadc:	8ff9                	and	a5,a5,a4
8000aade:	0807c7b3          	zext.h	a5,a5
8000aae2:	873e                	mv	a4,a5
8000aae4:	02015783          	lhu	a5,32(sp)
8000aae8:	8bbd                	and	a5,a5,15
8000aaea:	00f717b3          	sll	a5,a4,a5
8000aaee:	60579713          	sext.h	a4,a5
8000aaf2:	02c11783          	lh	a5,44(sp)
8000aaf6:	8fd9                	or	a5,a5,a4
8000aaf8:	60579793          	sext.h	a5,a5
8000aafc:	02f11623          	sh	a5,44(sp)

8000ab00 <.L219>:
                                }
                            }

                            /*Swap written data to big endian format (if required)*/
                            pVarPtr[0] = SWAPWORD(TmpValue);
8000ab00:	57c2                	lw	a5,48(sp)
8000ab02:	02c15703          	lhu	a4,44(sp)
8000ab06:	00e79023          	sh	a4,0(a5)

                            if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
8000ab0a:	5792                	lw	a5,36(sp)
8000ab0c:	0027c703          	lbu	a4,2(a5)
8000ab10:	0037c783          	lbu	a5,3(a5)
8000ab14:	07a2                	sll	a5,a5,0x8
8000ab16:	8fd9                	or	a5,a5,a4
8000ab18:	0807c7b3          	zext.h	a5,a5
8000ab1c:	02015703          	lhu	a4,32(sp)
8000ab20:	97ba                	add	a5,a5,a4
8000ab22:	0807c7b3          	zext.h	a5,a5
8000ab26:	8bbd                	and	a5,a5,15
8000ab28:	30079963          	bnez	a5,8000ae3a <.L243>
                            {
                                /* we have reached the UINT16 border */
                                pData++;
8000ab2c:	4782                	lw	a5,0(sp)
8000ab2e:	0789                	add	a5,a5,2
8000ab30:	c03e                	sw	a5,0(sp)

8000ab32 <.LBE24>:
                            }
                        }
                            break;
8000ab32:	a621                	j	8000ae3a <.L243>

8000ab34 <.L211>:
                        case    DEFTYPE_INTEGER16:
                        case    DEFTYPE_UNSIGNED16:
                        case    DEFTYPE_BITARR16:
                        case    DEFTYPE_WORD:
                            if(bitOffset & 0xF)
8000ab34:	02015783          	lhu	a5,32(sp)
8000ab38:	8bbd                	and	a5,a5,15
8000ab3a:	c399                	beqz	a5,8000ab40 <.L222>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
8000ab3c:	4795                	li	a5,5
8000ab3e:	ae65                	j	8000aef6 <.L178>

8000ab40 <.L222>:
                            }

                            {
                            /* in this example the objects are defined in that way,
                            that the 16 bit type are always starting at an exact WORD offset */
                            UINT16 u16NewData = SWAPWORD(pData[0]);
8000ab40:	4782                	lw	a5,0(sp)
8000ab42:	0007d783          	lhu	a5,0(a5)
8000ab46:	00f11e23          	sh	a5,28(sp)
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
8000ab4a:	03b14783          	lbu	a5,59(sp)
8000ab4e:	cb91                	beqz	a5,8000ab62 <.L223>
8000ab50:	57c2                	lw	a5,48(sp)
8000ab52:	0007d783          	lhu	a5,0(a5)
8000ab56:	01c15703          	lhu	a4,28(sp)
8000ab5a:	00f70463          	beq	a4,a5,8000ab62 <.L223>
                            {
                                /* try to write new data when subindex0 shall be reset*/
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
8000ab5e:	47f1                	li	a5,28
8000ab60:	ae59                	j	8000aef6 <.L178>

8000ab62 <.L223>:
                            }

                            /*check value if a new PDO assign entry should be written*/
                            if(IS_PDO_ASSIGN(index))  //PDO assign
8000ab62:	00e15703          	lhu	a4,14(sp)
8000ab66:	6789                	lui	a5,0x2
8000ab68:	c0f78793          	add	a5,a5,-1009 # 1c0f <__ILM_segment_used_end__+0x69>
8000ab6c:	04e7fa63          	bgeu	a5,a4,8000abc0 <.L224>
8000ab70:	00e15703          	lhu	a4,14(sp)
8000ab74:	6789                	lui	a5,0x2
8000ab76:	c2f78793          	add	a5,a5,-977 # 1c2f <__ILM_segment_used_end__+0x89>
8000ab7a:	04e7e363          	bltu	a5,a4,8000abc0 <.L224>
                            {
                                if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
8000ab7e:	01c15703          	lhu	a4,28(sp)
8000ab82:	6785                	lui	a5,0x1
8000ab84:	5ff78793          	add	a5,a5,1535 # 15ff <.L81+0x7>
8000ab88:	00e7f963          	bgeu	a5,a4,8000ab9a <.L225>
8000ab8c:	01c15703          	lhu	a4,28(sp)
8000ab90:	6785                	lui	a5,0x1
8000ab92:	7ff78793          	add	a5,a5,2047 # 17ff <.L102+0x19>
8000ab96:	02e7f563          	bgeu	a5,a4,8000abc0 <.L224>

8000ab9a <.L225>:
8000ab9a:	01c15703          	lhu	a4,28(sp)
8000ab9e:	6789                	lui	a5,0x2
8000aba0:	9ff78793          	add	a5,a5,-1537 # 19ff <rom_xpi_nor_program+0x3d>
8000aba4:	00e7f963          	bgeu	a5,a4,8000abb6 <.L226>
8000aba8:	01c15703          	lhu	a4,28(sp)
8000abac:	6789                	lui	a5,0x2
8000abae:	bff78793          	add	a5,a5,-1025 # 1bff <__ILM_segment_used_end__+0x59>
8000abb2:	00e7f763          	bgeu	a5,a4,8000abc0 <.L224>

8000abb6 <.L226>:
8000abb6:	01c15783          	lhu	a5,28(sp)
8000abba:	c399                	beqz	a5,8000abc0 <.L224>
                                {
                                    return ABORTIDX_VALUE_EXCEEDED;
8000abbc:	47c9                	li	a5,18
8000abbe:	ae25                	j	8000aef6 <.L178>

8000abc0 <.L224>:
                                }
                            }

                            if(index == 0x1C32 || index == 0x1C33)
8000abc0:	00e15703          	lhu	a4,14(sp)
8000abc4:	6789                	lui	a5,0x2
8000abc6:	c3278793          	add	a5,a5,-974 # 1c32 <__ILM_segment_used_end__+0x8c>
8000abca:	00f70963          	beq	a4,a5,8000abdc <.L227>
8000abce:	00e15703          	lhu	a4,14(sp)
8000abd2:	6789                	lui	a5,0x2
8000abd4:	c3378793          	add	a5,a5,-973 # 1c33 <__ILM_segment_used_end__+0x8d>
8000abd8:	10f71563          	bne	a4,a5,8000ace2 <.L228>

8000abdc <.L227>:
                            {
                               if (i == 1) /* "Synchronisation type" written */
8000abdc:	03e15703          	lhu	a4,62(sp)
8000abe0:	4785                	li	a5,1
8000abe2:	02f71d63          	bne	a4,a5,8000ac1c <.L229>
                               {
                                  /* The Synchronisation type (0x1C3x.1) was written by the user => the Sync type will not be calculated based on the register settings (if they don't match an error will be returned P_2_S)*/
                                  if (pVarPtr[0] != u16NewData)
8000abe6:	57c2                	lw	a5,48(sp)
8000abe8:	0007d783          	lhu	a5,0(a5)
8000abec:	01c15703          	lhu	a4,28(sp)
8000abf0:	02f70363          	beq	a4,a5,8000ac16 <.L230>
                                  {
                                     result = CheckSyncTypeValue(index, u16NewData);
8000abf4:	01c15703          	lhu	a4,28(sp)
8000abf8:	00e15783          	lhu	a5,14(sp)
8000abfc:	85ba                	mv	a1,a4
8000abfe:	853e                	mv	a0,a5
8000ac00:	4f4050ef          	jal	800100f4 <CheckSyncTypeValue>
8000ac04:	87aa                	mv	a5,a0
8000ac06:	02f10b23          	sb	a5,54(sp)

                                     if (result != 0)
8000ac0a:	03614783          	lbu	a5,54(sp)
8000ac0e:	c781                	beqz	a5,8000ac16 <.L230>
                                     {
                                        return result;
8000ac10:	03614783          	lbu	a5,54(sp)
8000ac14:	a4cd                	j	8000aef6 <.L178>

8000ac16 <.L230>:
                                     }
                                  }

                                  /* The user may force to current Sync Mode for that reason the flag has also to be set if the same value was written */
                                  bSyncSetByUser = TRUE;
8000ac16:	4705                	li	a4,1
8000ac18:	18e186a3          	sb	a4,397(gp) # 1209505 <bSyncSetByUser>

8000ac1c <.L229>:
                               }

                               if (i == 8) /* "Get Cycle Time" written*/
8000ac1c:	03e15703          	lhu	a4,62(sp)
8000ac20:	47a1                	li	a5,8
8000ac22:	0cf71063          	bne	a4,a5,8000ace2 <.L228>
                               {

                                   sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
8000ac26:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ac2a:	0127d703          	lhu	a4,18(a5)
8000ac2e:	8b01                	and	a4,a4,0
8000ac30:	00e79923          	sh	a4,18(a5)
8000ac34:	0147d703          	lhu	a4,20(a5)
8000ac38:	8b01                	and	a4,a4,0
8000ac3a:	00e79a23          	sh	a4,20(a5)
                                   sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
8000ac3e:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ac42:	00e7d703          	lhu	a4,14(a5)
8000ac46:	8b01                	and	a4,a4,0
8000ac48:	86ba                	mv	a3,a4
8000ac4a:	6721                	lui	a4,0x8
8000ac4c:	9e070713          	add	a4,a4,-1568 # 79e0 <__HEAPSIZE__+0x39e0>
8000ac50:	8f55                	or	a4,a4,a3
8000ac52:	00e79723          	sh	a4,14(a5)
8000ac56:	0107d703          	lhu	a4,16(a5)
8000ac5a:	8b01                	and	a4,a4,0
8000ac5c:	00e79823          	sh	a4,16(a5)
                                   sSyncManOutPar.u32CycleTime = 0;
8000ac60:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ac64:	0007a223          	sw	zero,4(a5)

                                   sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
8000ac68:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ac6c:	0127d703          	lhu	a4,18(a5)
8000ac70:	8b01                	and	a4,a4,0
8000ac72:	00e79923          	sh	a4,18(a5)
8000ac76:	0147d703          	lhu	a4,20(a5)
8000ac7a:	8b01                	and	a4,a4,0
8000ac7c:	00e79a23          	sh	a4,20(a5)
                                   sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
8000ac80:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ac84:	00e7d703          	lhu	a4,14(a5)
8000ac88:	8b01                	and	a4,a4,0
8000ac8a:	86ba                	mv	a3,a4
8000ac8c:	6721                	lui	a4,0x8
8000ac8e:	9e070713          	add	a4,a4,-1568 # 79e0 <__HEAPSIZE__+0x39e0>
8000ac92:	8f55                	or	a4,a4,a3
8000ac94:	00e79723          	sh	a4,14(a5)
8000ac98:	0107d703          	lhu	a4,16(a5)
8000ac9c:	8b01                	and	a4,a4,0
8000ac9e:	00e79823          	sh	a4,16(a5)
                                   sSyncManInPar.u32CycleTime = 0;
8000aca2:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000aca6:	0007a223          	sw	zero,4(a5)


                                  if ((u16NewData & 0x2) == 0x2)
8000acaa:	01c15783          	lhu	a5,28(sp)
8000acae:	8b89                	and	a5,a5,2
8000acb0:	cb8d                	beqz	a5,8000ace2 <.L228>
                                  {
                                     /* reset the error counters*/
                                     sSyncManOutPar.u16CycleExceededCounter = 0;
8000acb2:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000acb6:	02079323          	sh	zero,38(a5)
                                     sSyncManOutPar.u16SmEventMissedCounter = 0;
8000acba:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000acbe:	02079223          	sh	zero,36(a5)
                                     sSyncManOutPar.u8SyncError = 0;
8000acc2:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000acc6:	02078e23          	sb	zero,60(a5)

                                     sSyncManInPar.u16CycleExceededCounter = 0;
8000acca:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000acce:	02079323          	sh	zero,38(a5)
                                     sSyncManInPar.u16SmEventMissedCounter = 0;
8000acd2:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000acd6:	02079223          	sh	zero,36(a5)
                                     sSyncManInPar.u8SyncError = 0;
8000acda:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000acde:	02078e23          	sb	zero,60(a5)

8000ace2 <.L228>:
                                  }
                               } /* Subindex 8 written*/
                            }

                            pVarPtr[0] = u16NewData;
8000ace2:	57c2                	lw	a5,48(sp)
8000ace4:	01c15703          	lhu	a4,28(sp)
8000ace8:	00e79023          	sh	a4,0(a5)
                            pData++;
8000acec:	4782                	lw	a5,0(sp)
8000acee:	0789                	add	a5,a5,2
8000acf0:	c03e                	sw	a5,0(sp)

8000acf2 <.LBE25>:
                            }
                            break;
8000acf2:	a2a9                	j	8000ae3c <.L199>

8000acf4 <.L210>:
                        case    DEFTYPE_UNSIGNED32:
                        case    DEFTYPE_INTEGER32:
                        case    DEFTYPE_REAL32:
                        case    DEFTYPE_BITARR32:
                        case    DEFTYPE_DWORD:
                            if(bitOffset & 0xF)
8000acf4:	02015783          	lhu	a5,32(sp)
8000acf8:	8bbd                	and	a5,a5,15
8000acfa:	c399                	beqz	a5,8000ad00 <.L231>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
8000acfc:	4795                	li	a5,5
8000acfe:	aae5                	j	8000aef6 <.L178>

8000ad00 <.L231>:
                            }
                            {

                            /* in this example the objects are defined in that way,
                               that the 32 bit type are always starting at an exact WORD offset */
                            if(bClearSubindex0Required && 
8000ad00:	03b14783          	lbu	a5,59(sp)
8000ad04:	c78d                	beqz	a5,8000ad2e <.L232>
                                ((pVarPtr[0] != pData[0])
8000ad06:	57c2                	lw	a5,48(sp)
8000ad08:	0007d703          	lhu	a4,0(a5)
8000ad0c:	4782                	lw	a5,0(sp)
8000ad0e:	0007d783          	lhu	a5,0(a5)
                            if(bClearSubindex0Required && 
8000ad12:	00f71c63          	bne	a4,a5,8000ad2a <.L233>
                                || (pVarPtr[1] != pData[1])))
8000ad16:	57c2                	lw	a5,48(sp)
8000ad18:	0789                	add	a5,a5,2
8000ad1a:	0007d703          	lhu	a4,0(a5)
8000ad1e:	4782                	lw	a5,0(sp)
8000ad20:	0789                	add	a5,a5,2
8000ad22:	0007d783          	lhu	a5,0(a5)
8000ad26:	00f70463          	beq	a4,a5,8000ad2e <.L232>

8000ad2a <.L233>:
                            {
                                /* try to write new data when subindex0 shall be reset*/
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
8000ad2a:	47f1                	li	a5,28
8000ad2c:	a2e9                	j	8000aef6 <.L178>

8000ad2e <.L232>:
                            }

                            pVarPtr[0] = pData[0];
8000ad2e:	4782                	lw	a5,0(sp)
8000ad30:	0007d703          	lhu	a4,0(a5)
8000ad34:	57c2                	lw	a5,48(sp)
8000ad36:	00e79023          	sh	a4,0(a5)
                            pVarPtr[1] = pData[1];
8000ad3a:	57c2                	lw	a5,48(sp)
8000ad3c:	0789                	add	a5,a5,2
8000ad3e:	4702                	lw	a4,0(sp)
8000ad40:	00275703          	lhu	a4,2(a4)
8000ad44:	00e79023          	sh	a4,0(a5)
                            pData += 2;
8000ad48:	4782                	lw	a5,0(sp)
8000ad4a:	0791                	add	a5,a5,4
8000ad4c:	c03e                	sw	a5,0(sp)
                            }
                            break;
8000ad4e:	a0fd                	j	8000ae3c <.L199>

8000ad50 <.L212>:
                        case    DEFTYPE_REAL64:
                        case 	DEFTYPE_INTEGER64:
                        case    DEFTYPE_UNSIGNED64:
                            if(bitOffset & 0xF)
8000ad50:	02015783          	lhu	a5,32(sp)
8000ad54:	8bbd                	and	a5,a5,15
8000ad56:	c399                	beqz	a5,8000ad5c <.L234>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
8000ad58:	4795                	li	a5,5
8000ad5a:	aa71                	j	8000aef6 <.L178>

8000ad5c <.L234>:
                            }
                            /* in this example the objects are defined in that way,
                               that the 64 bit type are always starting at an exact WORD offset */
                            pVarPtr[0] = pData[0];
8000ad5c:	4782                	lw	a5,0(sp)
8000ad5e:	0007d703          	lhu	a4,0(a5)
8000ad62:	57c2                	lw	a5,48(sp)
8000ad64:	00e79023          	sh	a4,0(a5)
                            pVarPtr[1] = pData[1];
8000ad68:	57c2                	lw	a5,48(sp)
8000ad6a:	0789                	add	a5,a5,2
8000ad6c:	4702                	lw	a4,0(sp)
8000ad6e:	00275703          	lhu	a4,2(a4)
8000ad72:	00e79023          	sh	a4,0(a5)
                            pVarPtr[2] = pData[2];
8000ad76:	57c2                	lw	a5,48(sp)
8000ad78:	0791                	add	a5,a5,4
8000ad7a:	4702                	lw	a4,0(sp)
8000ad7c:	00475703          	lhu	a4,4(a4)
8000ad80:	00e79023          	sh	a4,0(a5)
                            pVarPtr[3] = pData[3];
8000ad84:	57c2                	lw	a5,48(sp)
8000ad86:	0799                	add	a5,a5,6
8000ad88:	4702                	lw	a4,0(sp)
8000ad8a:	00675703          	lhu	a4,6(a4)
8000ad8e:	00e79023          	sh	a4,0(a5)
                            pData += 4;
8000ad92:	4782                	lw	a5,0(sp)
8000ad94:	07a1                	add	a5,a5,8
8000ad96:	c03e                	sw	a5,0(sp)
                            break;
8000ad98:	a055                	j	8000ae3c <.L199>

8000ad9a <.L214>:
                        case    DEFTYPE_VISIBLESTRING:
                            if(bitOffset & 0xF)
8000ad9a:	02015783          	lhu	a5,32(sp)
8000ad9e:	8bbd                	and	a5,a5,15
8000ada0:	c399                	beqz	a5,8000ada6 <.L235>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
8000ada2:	4795                	li	a5,5
8000ada4:	aa89                	j	8000aef6 <.L178>

8000ada6 <.L235>:
                            }

                            OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
8000ada6:	5792                	lw	a5,36(sp)
8000ada8:	0027c703          	lbu	a4,2(a5)
8000adac:	0037c783          	lbu	a5,3(a5)
8000adb0:	07a2                	sll	a5,a5,0x8
8000adb2:	8fd9                	or	a5,a5,a4
8000adb4:	0807c7b3          	zext.h	a5,a5
8000adb8:	079d                	add	a5,a5,7
8000adba:	878d                	sra	a5,a5,0x3
8000adbc:	863e                	mv	a2,a5
8000adbe:	4582                	lw	a1,0(sp)
8000adc0:	5542                	lw	a0,48(sp)
8000adc2:	69b020ef          	jal	8000dc5c <memcpy>

                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
8000adc6:	5792                	lw	a5,36(sp)
8000adc8:	0027c703          	lbu	a4,2(a5)
8000adcc:	0037c783          	lbu	a5,3(a5)
8000add0:	07a2                	sll	a5,a5,0x8
8000add2:	8fd9                	or	a5,a5,a4
8000add4:	0807c7b3          	zext.h	a5,a5
8000add8:	9bc1                	and	a5,a5,-16
8000adda:	07bd                	add	a5,a5,15
8000addc:	8791                	sra	a5,a5,0x4
8000adde:	0786                	sll	a5,a5,0x1
8000ade0:	4702                	lw	a4,0(sp)
8000ade2:	97ba                	add	a5,a5,a4
8000ade4:	c03e                	sw	a5,0(sp)
                            break;
8000ade6:	a899                	j	8000ae3c <.L199>

8000ade8 <.L204>:
                        case    DEFTYPE_UNICODE_STRING:
                            case DEFTYPE_ARRAY_OF_INT :
                            case DEFTYPE_ARRAY_OF_SINT :
                            case DEFTYPE_ARRAY_OF_DINT :
                            case DEFTYPE_ARRAY_OF_UDINT:
                            if(bitOffset & 0xF)
8000ade8:	02015783          	lhu	a5,32(sp)
8000adec:	8bbd                	and	a5,a5,15
8000adee:	c399                	beqz	a5,8000adf4 <.L236>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
8000adf0:	4795                	li	a5,5
8000adf2:	a211                	j	8000aef6 <.L178>

8000adf4 <.L236>:
                            }

                            /* in this example the objects are defined in that way,
                               that the other types are always starting at an even byte offset */
                            OBJTOMBXMEMCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
8000adf4:	5792                	lw	a5,36(sp)
8000adf6:	0027c703          	lbu	a4,2(a5)
8000adfa:	0037c783          	lbu	a5,3(a5)
8000adfe:	07a2                	sll	a5,a5,0x8
8000ae00:	8fd9                	or	a5,a5,a4
8000ae02:	0807c7b3          	zext.h	a5,a5
8000ae06:	079d                	add	a5,a5,7
8000ae08:	878d                	sra	a5,a5,0x3
8000ae0a:	863e                	mv	a2,a5
8000ae0c:	4582                	lw	a1,0(sp)
8000ae0e:	5542                	lw	a0,48(sp)
8000ae10:	64d020ef          	jal	8000dc5c <memcpy>
                            pData += BIT2WORD((pEntry->BitLength) & ~0xF);
8000ae14:	5792                	lw	a5,36(sp)
8000ae16:	0027c703          	lbu	a4,2(a5)
8000ae1a:	0037c783          	lbu	a5,3(a5)
8000ae1e:	07a2                	sll	a5,a5,0x8
8000ae20:	8fd9                	or	a5,a5,a4
8000ae22:	0807c7b3          	zext.h	a5,a5
8000ae26:	9bc1                	and	a5,a5,-16
8000ae28:	07bd                	add	a5,a5,15
8000ae2a:	8791                	sra	a5,a5,0x4
8000ae2c:	0786                	sll	a5,a5,0x1
8000ae2e:	4702                	lw	a4,0(sp)
8000ae30:	97ba                	add	a5,a5,a4
8000ae32:	c03e                	sw	a5,0(sp)

                            break;
8000ae34:	a021                	j	8000ae3c <.L199>

8000ae36 <.L203>:
                        default:
                            /* other data types are not supported from this example */
                            return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
8000ae36:	47e1                	li	a5,24
8000ae38:	a87d                	j	8000aef6 <.L178>

8000ae3a <.L243>:
                            break;
8000ae3a:	0001                	nop

8000ae3c <.L199>:
                        }
                    }

                    /* set flag */
                    bWritten = 1;
8000ae3c:	4785                	li	a5,1
8000ae3e:	02f10ba3          	sb	a5,55(sp)
8000ae42:	a895                	j	8000aeb6 <.L196>

8000ae44 <.L193>:

                }
            }
            else
            {
                if(i == 0)
8000ae44:	03e15783          	lhu	a5,62(sp)
8000ae48:	e789                	bnez	a5,8000ae52 <.L237>
                {
                    /* For SubIndex0 16Bit are reserved even if the BitLength is 8 */
                    pData++;
8000ae4a:	4782                	lw	a5,0(sp)
8000ae4c:	0789                	add	a5,a5,2
8000ae4e:	c03e                	sw	a5,0(sp)
8000ae50:	a085                	j	8000aeb0 <.L238>

8000ae52 <.L237>:
                }
                else
                {
                    /*Handle Bit/Byte Offset*/
                    if (((pEntry->BitLength & 0xF) > 0)
8000ae52:	5792                	lw	a5,36(sp)
8000ae54:	0027c703          	lbu	a4,2(a5)
8000ae58:	0037c783          	lbu	a5,3(a5)
8000ae5c:	07a2                	sll	a5,a5,0x8
8000ae5e:	8fd9                	or	a5,a5,a4
8000ae60:	0807c7b3          	zext.h	a5,a5
8000ae64:	8bbd                	and	a5,a5,15
8000ae66:	02f05563          	blez	a5,8000ae90 <.L239>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
8000ae6a:	5792                	lw	a5,36(sp)
8000ae6c:	0027c703          	lbu	a4,2(a5)
8000ae70:	0037c783          	lbu	a5,3(a5)
8000ae74:	07a2                	sll	a5,a5,0x8
8000ae76:	8fd9                	or	a5,a5,a4
8000ae78:	0807c7b3          	zext.h	a5,a5
8000ae7c:	02015703          	lhu	a4,32(sp)
8000ae80:	97ba                	add	a5,a5,a4
8000ae82:	0807c7b3          	zext.h	a5,a5
8000ae86:	8bbd                	and	a5,a5,15
8000ae88:	e781                	bnez	a5,8000ae90 <.L239>
                    {
                        /* we have reached the UINT16 border */
                        pData++;
8000ae8a:	4782                	lw	a5,0(sp)
8000ae8c:	0789                	add	a5,a5,2
8000ae8e:	c03e                	sw	a5,0(sp)

8000ae90 <.L239>:
                    }

                    /*increment WORD offset*/
                    pData += ((pEntry->BitLength & 0xFFF0) >> 4);
8000ae90:	5792                	lw	a5,36(sp)
8000ae92:	0027c703          	lbu	a4,2(a5)
8000ae96:	0037c783          	lbu	a5,3(a5)
8000ae9a:	07a2                	sll	a5,a5,0x8
8000ae9c:	8fd9                	or	a5,a5,a4
8000ae9e:	0807c7b3          	zext.h	a5,a5
8000aea2:	8391                	srl	a5,a5,0x4
8000aea4:	0807c7b3          	zext.h	a5,a5
8000aea8:	0786                	sll	a5,a5,0x1
8000aeaa:	4702                	lw	a4,0(sp)
8000aeac:	97ba                	add	a5,a5,a4
8000aeae:	c03e                	sw	a5,0(sp)

8000aeb0 <.L238>:
                }
                /*If no other entry was written this result will be returned*/
                result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
8000aeb0:	47e1                	li	a5,24
8000aeb2:	02f10b23          	sb	a5,54(sp)

8000aeb6 <.L196>:
        for (i = subindex; i <= lastSubindex; i++)
8000aeb6:	03e15783          	lhu	a5,62(sp)
8000aeba:	0785                	add	a5,a5,1
8000aebc:	02f11f23          	sh	a5,62(sp)

8000aec0 <.L192>:
8000aec0:	03e15703          	lhu	a4,62(sp)
8000aec4:	03815783          	lhu	a5,56(sp)
8000aec8:	86e7fbe3          	bgeu	a5,a4,8000a73e <.L240>
            }
        }

        if (bWritten == 0)
8000aecc:	03714783          	lbu	a5,55(sp)
8000aed0:	e781                	bnez	a5,8000aed8 <.L241>
        {
            /* we didn't write anything, so we have to return the stored error code */
            return result;
8000aed2:	03614783          	lbu	a5,54(sp)
8000aed6:	a005                	j	8000aef6 <.L178>

8000aed8 <.L241>:
        }
    }

    /* ECATCHANGE_START(V5.13) COE4*/
    if (pAPPL_CoeWriteInd != NULL)
8000aed8:	1041a783          	lw	a5,260(gp) # 120947c <pAPPL_CoeWriteInd>
8000aedc:	cf81                	beqz	a5,8000aef4 <.L242>
    {
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
8000aede:	1041a783          	lw	a5,260(gp) # 120947c <pAPPL_CoeWriteInd>
8000aee2:	00c14603          	lbu	a2,12(sp)
8000aee6:	00d14683          	lbu	a3,13(sp)
8000aeea:	00e15703          	lhu	a4,14(sp)
8000aeee:	85b6                	mv	a1,a3
8000aef0:	853a                	mv	a0,a4
8000aef2:	9782                	jalr	a5

8000aef4 <.L242>:
    }
    /* ECATCHANGE_END(V5.13) COE4*/

    return 0;
8000aef4:	4781                	li	a5,0

8000aef6 <.L178>:
}
8000aef6:	853e                	mv	a0,a5
8000aef8:	40b6                	lw	ra,76(sp)
8000aefa:	6161                	add	sp,sp,80
8000aefc:	8082                	ret

Disassembly of section .text.SdoRes:

8000aefe <SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
{
8000aefe:	1101                	add	sp,sp,-32
8000af00:	ce06                	sw	ra,28(sp)
8000af02:	c23a                	sw	a4,4(sp)
8000af04:	c03e                	sw	a5,0(sp)
8000af06:	87aa                	mv	a5,a0
8000af08:	00f107a3          	sb	a5,15(sp)
8000af0c:	87ae                	mv	a5,a1
8000af0e:	00f10723          	sb	a5,14(sp)
8000af12:	87b2                	mv	a5,a2
8000af14:	00f106a3          	sb	a5,13(sp)
8000af18:	87b6                	mv	a5,a3
8000af1a:	00f11523          	sh	a5,10(sp)
	/* for an upload segment response the toggle bit was overwritten */
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
8000af1e:	00e14703          	lbu	a4,14(sp)
8000af22:	06000793          	li	a5,96
8000af26:	00f70863          	beq	a4,a5,8000af36 <.L33>
8000af2a:	00e14783          	lbu	a5,14(sp)
8000af2e:	c781                	beqz	a5,8000af36 <.L33>
	{
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] = 0;
8000af30:	4782                	lw	a5,0(sp)
8000af32:	00078423          	sb	zero,8(a5)

8000af36 <.L33>:
	}
	if (abort == 0)
8000af36:	00f14783          	lbu	a5,15(sp)
8000af3a:	24079163          	bnez	a5,8000b17c <.L34>
	{
		/* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
8000af3e:	4782                	lw	a5,0(sp)
8000af40:	0067c703          	lbu	a4,6(a5)
8000af44:	0077c783          	lbu	a5,7(a5)
8000af48:	07a2                	sll	a5,a5,0x8
8000af4a:	8fd9                	or	a5,a5,a4
8000af4c:	0807c733          	zext.h	a4,a5
8000af50:	6785                	lui	a5,0x1
8000af52:	17fd                	add	a5,a5,-1 # fff <.L76+0x39>
8000af54:	8ff9                	and	a5,a5,a4
8000af56:	0807c733          	zext.h	a4,a5
8000af5a:	4782                	lw	a5,0(sp)
8000af5c:	0ff77693          	zext.b	a3,a4
8000af60:	0067c603          	lbu	a2,6(a5)
8000af64:	8a01                	and	a2,a2,0
8000af66:	8ed1                	or	a3,a3,a2
8000af68:	00d78323          	sb	a3,6(a5)
8000af6c:	8321                	srl	a4,a4,0x8
8000af6e:	08074733          	zext.h	a4,a4
8000af72:	0077c683          	lbu	a3,7(a5)
8000af76:	8a81                	and	a3,a3,0
8000af78:	8f55                	or	a4,a4,a3
8000af7a:	00e783a3          	sb	a4,7(a5)
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
8000af7e:	4782                	lw	a5,0(sp)
8000af80:	0067c703          	lbu	a4,6(a5)
8000af84:	0077c783          	lbu	a5,7(a5)
8000af88:	07a2                	sll	a5,a5,0x8
8000af8a:	8fd9                	or	a5,a5,a4
8000af8c:	0807c733          	zext.h	a4,a5
8000af90:	678d                	lui	a5,0x3
8000af92:	8fd9                	or	a5,a5,a4
8000af94:	0807c733          	zext.h	a4,a5
8000af98:	4782                	lw	a5,0(sp)
8000af9a:	0ff77693          	zext.b	a3,a4
8000af9e:	0067c603          	lbu	a2,6(a5) # 3006 <__BOOT_HEADER_segment_size__+0x1006>
8000afa2:	8a01                	and	a2,a2,0
8000afa4:	8ed1                	or	a3,a3,a2
8000afa6:	00d78323          	sb	a3,6(a5)
8000afaa:	8321                	srl	a4,a4,0x8
8000afac:	08074733          	zext.h	a4,a4
8000afb0:	0077c683          	lbu	a3,7(a5)
8000afb4:	8a81                	and	a3,a3,0
8000afb6:	8f55                	or	a4,a4,a3
8000afb8:	00e783a3          	sb	a4,7(a5)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
8000afbc:	00e14703          	lbu	a4,14(sp)
8000afc0:	04000793          	li	a5,64
8000afc4:	14f71363          	bne	a4,a5,8000b10a <.L35>
		{
			// HBu 06.02.06: Complete Access Bit in the SDO-Upload-Response too */
			if ((objLength <= 4) && (objLength > 0))
8000afc8:	4712                	lw	a4,4(sp)
8000afca:	4791                	li	a5,4
8000afcc:	04e7ef63          	bltu	a5,a4,8000b02a <.L36>
8000afd0:	4792                	lw	a5,4(sp)
8000afd2:	cfa1                	beqz	a5,8000b02a <.L36>
			{
				/* Expedited Upload Response */
				pSdoRes->MbxHeader.Length = EXPEDITED_FRAME_SIZE;
8000afd4:	4782                	lw	a5,0(sp)
8000afd6:	0007c703          	lbu	a4,0(a5)
8000afda:	8b01                	and	a4,a4,0
8000afdc:	00a76713          	or	a4,a4,10
8000afe0:	00e78023          	sb	a4,0(a5)
8000afe4:	0017c703          	lbu	a4,1(a5)
8000afe8:	8b01                	and	a4,a4,0
8000afea:	00e780a3          	sb	a4,1(a5)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOHEADER_SIZEINDICATOR |
8000afee:	4782                	lw	a5,0(sp)
8000aff0:	0087c703          	lbu	a4,8(a5)
					SDOHEADER_TRANSFERTYPE |
					completeAccess |
					((MAX_EXPEDITED_DATA - ((UINT8)objLength)) << SDOHEADERSHIFT_DATASETSIZE) |
8000aff4:	4792                	lw	a5,4(sp)
8000aff6:	0ff7f793          	zext.b	a5,a5
8000affa:	86be                	mv	a3,a5
8000affc:	4791                	li	a5,4
8000affe:	8f95                	sub	a5,a5,a3
					completeAccess |
8000b000:	0ff7f793          	zext.b	a5,a5
8000b004:	078a                	sll	a5,a5,0x2
8000b006:	0ff7f793          	zext.b	a5,a5
8000b00a:	00d14683          	lbu	a3,13(sp)
8000b00e:	8fd5                	or	a5,a5,a3
8000b010:	0ff7f793          	zext.b	a5,a5
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOHEADER_SIZEINDICATOR |
8000b014:	8fd9                	or	a5,a5,a4
8000b016:	0ff7f793          	zext.b	a5,a5
8000b01a:	0437e793          	or	a5,a5,67
8000b01e:	0ff7f713          	zext.b	a4,a5
8000b022:	4782                	lw	a5,0(sp)
8000b024:	00e78423          	sb	a4,8(a5)
8000b028:	aca9                	j	8000b282 <.L40>

8000b02a <.L36>:
					SDOSERVICE_INITIATEUPLOADRES;
			}
			else
			{
				/* Normal or Segmented Upload Response */
				if (dataSize < objLength)
8000b02a:	00a15783          	lhu	a5,10(sp)
8000b02e:	4712                	lw	a4,4(sp)
8000b030:	02e7fa63          	bgeu	a5,a4,8000b064 <.L38>
				{
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
8000b034:	00a15783          	lhu	a5,10(sp)
8000b038:	07a9                	add	a5,a5,10
8000b03a:	0807c733          	zext.h	a4,a5
8000b03e:	4782                	lw	a5,0(sp)
8000b040:	0ff77693          	zext.b	a3,a4
8000b044:	0007c603          	lbu	a2,0(a5)
8000b048:	8a01                	and	a2,a2,0
8000b04a:	8ed1                	or	a3,a3,a2
8000b04c:	00d78023          	sb	a3,0(a5)
8000b050:	8321                	srl	a4,a4,0x8
8000b052:	08074733          	zext.h	a4,a4
8000b056:	0017c683          	lbu	a3,1(a5)
8000b05a:	8a81                	and	a3,a3,0
8000b05c:	8f55                	or	a4,a4,a3
8000b05e:	00e780a3          	sb	a4,1(a5)
8000b062:	a80d                	j	8000b094 <.L39>

8000b064 <.L38>:
				}
				else
				{
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + ((UINT16)objLength);
8000b064:	4792                	lw	a5,4(sp)
8000b066:	0807c7b3          	zext.h	a5,a5
8000b06a:	07a9                	add	a5,a5,10
8000b06c:	0807c733          	zext.h	a4,a5
8000b070:	4782                	lw	a5,0(sp)
8000b072:	0ff77693          	zext.b	a3,a4
8000b076:	0007c603          	lbu	a2,0(a5)
8000b07a:	8a01                	and	a2,a2,0
8000b07c:	8ed1                	or	a3,a3,a2
8000b07e:	00d78023          	sb	a3,0(a5)
8000b082:	8321                	srl	a4,a4,0x8
8000b084:	08074733          	zext.h	a4,a4
8000b088:	0017c683          	lbu	a3,1(a5)
8000b08c:	8a81                	and	a3,a3,0
8000b08e:	8f55                	or	a4,a4,a3
8000b090:	00e780a3          	sb	a4,1(a5)

8000b094 <.L39>:
				}
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
8000b094:	4792                	lw	a5,4(sp)
8000b096:	0807c733          	zext.h	a4,a5
8000b09a:	4782                	lw	a5,0(sp)
8000b09c:	0ff77693          	zext.b	a3,a4
8000b0a0:	00c7c603          	lbu	a2,12(a5)
8000b0a4:	8a01                	and	a2,a2,0
8000b0a6:	8ed1                	or	a3,a3,a2
8000b0a8:	00d78623          	sb	a3,12(a5)
8000b0ac:	8321                	srl	a4,a4,0x8
8000b0ae:	08074733          	zext.h	a4,a4
8000b0b2:	00d7c683          	lbu	a3,13(a5)
8000b0b6:	8a81                	and	a3,a3,0
8000b0b8:	8f55                	or	a4,a4,a3
8000b0ba:	00e786a3          	sb	a4,13(a5)
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
8000b0be:	4792                	lw	a5,4(sp)
8000b0c0:	83c1                	srl	a5,a5,0x10
8000b0c2:	0807c733          	zext.h	a4,a5
8000b0c6:	4782                	lw	a5,0(sp)
8000b0c8:	0ff77693          	zext.b	a3,a4
8000b0cc:	00e7c603          	lbu	a2,14(a5)
8000b0d0:	8a01                	and	a2,a2,0
8000b0d2:	8ed1                	or	a3,a3,a2
8000b0d4:	00d78723          	sb	a3,14(a5)
8000b0d8:	8321                	srl	a4,a4,0x8
8000b0da:	08074733          	zext.h	a4,a4
8000b0de:	00f7c683          	lbu	a3,15(a5)
8000b0e2:	8a81                	and	a3,a3,0
8000b0e4:	8f55                	or	a4,a4,a3
8000b0e6:	00e787a3          	sb	a4,15(a5)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOHEADER_SIZEINDICATOR |
8000b0ea:	4782                	lw	a5,0(sp)
8000b0ec:	0087c783          	lbu	a5,8(a5)
8000b0f0:	00d14703          	lbu	a4,13(sp)
8000b0f4:	8fd9                	or	a5,a5,a4
8000b0f6:	0ff7f793          	zext.b	a5,a5
8000b0fa:	0417e793          	or	a5,a5,65
8000b0fe:	0ff7f713          	zext.b	a4,a5
8000b102:	4782                	lw	a5,0(sp)
8000b104:	00e78423          	sb	a4,8(a5)
8000b108:	aaad                	j	8000b282 <.L40>

8000b10a <.L35>:
					SDOSERVICE_INITIATEUPLOADRES;

			}
		}
		/* for a segmented response the command was wrong in the response */
		else if (command == SDOSERVICE_DOWNLOADSEGMENTREQ)
8000b10a:	00e14783          	lbu	a5,14(sp)
8000b10e:	eb8d                	bnez	a5,8000b140 <.L41>
		{
			/* Download segmented response */
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
8000b110:	4782                	lw	a5,0(sp)
8000b112:	0007c703          	lbu	a4,0(a5)
8000b116:	8b01                	and	a4,a4,0
8000b118:	00a76713          	or	a4,a4,10
8000b11c:	00e78023          	sb	a4,0(a5)
8000b120:	0017c703          	lbu	a4,1(a5)
8000b124:	8b01                	and	a4,a4,0
8000b126:	00e780a3          	sb	a4,1(a5)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOSERVICE_DOWNLOADSEGMENTRES;
8000b12a:	4782                	lw	a5,0(sp)
8000b12c:	0087c783          	lbu	a5,8(a5)
8000b130:	0207e793          	or	a5,a5,32
8000b134:	0ff7f713          	zext.b	a4,a5
8000b138:	4782                	lw	a5,0(sp)
8000b13a:	00e78423          	sb	a4,8(a5)
8000b13e:	a291                	j	8000b282 <.L40>

8000b140 <.L41>:
		}
		else if (command != SDOSERVICE_UPLOADSEGMENTREQ)
8000b140:	00e14703          	lbu	a4,14(sp)
8000b144:	06000793          	li	a5,96
8000b148:	12f70d63          	beq	a4,a5,8000b282 <.L40>
		{
			/* Download response */
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
8000b14c:	4782                	lw	a5,0(sp)
8000b14e:	0007c703          	lbu	a4,0(a5)
8000b152:	8b01                	and	a4,a4,0
8000b154:	00a76713          	or	a4,a4,10
8000b158:	00e78023          	sb	a4,0(a5)
8000b15c:	0017c703          	lbu	a4,1(a5)
8000b160:	8b01                	and	a4,a4,0
8000b162:	00e780a3          	sb	a4,1(a5)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOSERVICE_INITIATEDOWNLOADRES;
8000b166:	4782                	lw	a5,0(sp)
8000b168:	0087c783          	lbu	a5,8(a5)
8000b16c:	0607e793          	or	a5,a5,96
8000b170:	0ff7f713          	zext.b	a4,a5
8000b174:	4782                	lw	a5,0(sp)
8000b176:	00e78423          	sb	a4,8(a5)
8000b17a:	a221                	j	8000b282 <.L40>

8000b17c <.L34>:
		}
	}
	else
	{
		/* generate a SDO-Abort-Request */
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
8000b17c:	4782                	lw	a5,0(sp)
8000b17e:	0007c703          	lbu	a4,0(a5)
8000b182:	8b01                	and	a4,a4,0
8000b184:	00a76713          	or	a4,a4,10
8000b188:	00e78023          	sb	a4,0(a5)
8000b18c:	0017c703          	lbu	a4,1(a5)
8000b190:	8b01                	and	a4,a4,0
8000b192:	00e780a3          	sb	a4,1(a5)
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
8000b196:	4782                	lw	a5,0(sp)
8000b198:	0067c703          	lbu	a4,6(a5)
8000b19c:	0077c783          	lbu	a5,7(a5)
8000b1a0:	07a2                	sll	a5,a5,0x8
8000b1a2:	8fd9                	or	a5,a5,a4
8000b1a4:	0807c733          	zext.h	a4,a5
8000b1a8:	6785                	lui	a5,0x1
8000b1aa:	17fd                	add	a5,a5,-1 # fff <.L76+0x39>
8000b1ac:	8ff9                	and	a5,a5,a4
8000b1ae:	0807c733          	zext.h	a4,a5
8000b1b2:	4782                	lw	a5,0(sp)
8000b1b4:	0ff77693          	zext.b	a3,a4
8000b1b8:	0067c603          	lbu	a2,6(a5)
8000b1bc:	8a01                	and	a2,a2,0
8000b1be:	8ed1                	or	a3,a3,a2
8000b1c0:	00d78323          	sb	a3,6(a5)
8000b1c4:	8321                	srl	a4,a4,0x8
8000b1c6:	08074733          	zext.h	a4,a4
8000b1ca:	0077c683          	lbu	a3,7(a5)
8000b1ce:	8a81                	and	a3,a3,0
8000b1d0:	8f55                	or	a4,a4,a3
8000b1d2:	00e783a3          	sb	a4,7(a5)
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
8000b1d6:	4782                	lw	a5,0(sp)
8000b1d8:	0067c703          	lbu	a4,6(a5)
8000b1dc:	0077c783          	lbu	a5,7(a5)
8000b1e0:	07a2                	sll	a5,a5,0x8
8000b1e2:	8fd9                	or	a5,a5,a4
8000b1e4:	0807c733          	zext.h	a4,a5
8000b1e8:	6789                	lui	a5,0x2
8000b1ea:	8fd9                	or	a5,a5,a4
8000b1ec:	0807c733          	zext.h	a4,a5
8000b1f0:	4782                	lw	a5,0(sp)
8000b1f2:	0ff77693          	zext.b	a3,a4
8000b1f6:	0067c603          	lbu	a2,6(a5) # 2006 <__BOOT_HEADER_segment_size__+0x6>
8000b1fa:	8a01                	and	a2,a2,0
8000b1fc:	8ed1                	or	a3,a3,a2
8000b1fe:	00d78323          	sb	a3,6(a5)
8000b202:	8321                	srl	a4,a4,0x8
8000b204:	08074733          	zext.h	a4,a4
8000b208:	0077c683          	lbu	a3,7(a5)
8000b20c:	8a81                	and	a3,a3,0
8000b20e:	8f55                	or	a4,a4,a3
8000b210:	00e783a3          	sb	a4,7(a5)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SDOSERVICE_ABORTTRANSFER;
8000b214:	4782                	lw	a5,0(sp)
8000b216:	0087c783          	lbu	a5,8(a5)
8000b21a:	f807e793          	or	a5,a5,-128
8000b21e:	0ff7f713          	zext.b	a4,a5
8000b222:	4782                	lw	a5,0(sp)
8000b224:	00e78423          	sb	a4,8(a5)

		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
8000b228:	00f14783          	lbu	a5,15(sp)
8000b22c:	80005737          	lui	a4,0x80005
8000b230:	08470713          	add	a4,a4,132 # 80005084 <cAbortCode>
8000b234:	078a                	sll	a5,a5,0x2
8000b236:	97ba                	add	a5,a5,a4
8000b238:	4398                	lw	a4,0(a5)
8000b23a:	4782                	lw	a5,0(sp)
8000b23c:	0ff77693          	zext.b	a3,a4
8000b240:	00c7c603          	lbu	a2,12(a5)
8000b244:	8a01                	and	a2,a2,0
8000b246:	8ed1                	or	a3,a3,a2
8000b248:	00d78623          	sb	a3,12(a5)
8000b24c:	00875693          	srl	a3,a4,0x8
8000b250:	0ff6f693          	zext.b	a3,a3
8000b254:	00d7c603          	lbu	a2,13(a5)
8000b258:	8a01                	and	a2,a2,0
8000b25a:	8ed1                	or	a3,a3,a2
8000b25c:	00d786a3          	sb	a3,13(a5)
8000b260:	01075693          	srl	a3,a4,0x10
8000b264:	0ff6f693          	zext.b	a3,a3
8000b268:	00e7c603          	lbu	a2,14(a5)
8000b26c:	8a01                	and	a2,a2,0
8000b26e:	8ed1                	or	a3,a3,a2
8000b270:	00d78723          	sb	a3,14(a5)
8000b274:	8361                	srl	a4,a4,0x18
8000b276:	00f7c683          	lbu	a3,15(a5)
8000b27a:	8a81                	and	a3,a3,0
8000b27c:	8f55                	or	a4,a4,a3
8000b27e:	00e787a3          	sb	a4,15(a5)

8000b282 <.L40>:
	}

	// HBu 02.05.06: if the CoE-response could not be sent because the
	//               send mailbox is full it should be stored
	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
8000b282:	4589                	li	a1,2
8000b284:	4502                	lw	a0,0(sp)
8000b286:	c5afe0ef          	jal	800096e0 <MBX_MailboxSendReq>
8000b28a:	87aa                	mv	a5,a0
8000b28c:	c781                	beqz	a5,8000b294 <.L43>
	{
		/* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
		pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
8000b28e:	4702                	lw	a4,0(sp)
8000b290:	0ee1a623          	sw	a4,236(gp) # 1209464 <pCoeSendStored>

8000b294 <.L43>:
	}
}
8000b294:	0001                	nop
8000b296:	40f2                	lw	ra,28(sp)
8000b298:	6105                	add	sp,sp,32
8000b29a:	8082                	ret

Disassembly of section .text.SDOS_ClearPendingResponse:

8000b29c <SDOS_ClearPendingResponse>:
\brief    Clear the variables handling a pending SDO Response
		   This function shall be called before the other mailbox data pointer are set to NULL
*////////////////////////////////////////////////////////////////////////////////////////

void  SDOS_ClearPendingResponse(void)
{
8000b29c:	1141                	add	sp,sp,-16
8000b29e:	c606                	sw	ra,12(sp)
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
8000b2a0:	1941c703          	lbu	a4,404(gp) # 120950c <bSdoInWork>
8000b2a4:	4785                	li	a5,1
8000b2a6:	02f71863          	bne	a4,a5,8000b2d6 <.L92>
8000b2aa:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
8000b2ae:	c785                	beqz	a5,8000b2d6 <.L92>
8000b2b0:	0d81a703          	lw	a4,216(gp) # 1209450 <pSdoResStored>
8000b2b4:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000b2b8:	00f70f63          	beq	a4,a5,8000b2d6 <.L92>
8000b2bc:	0d81a703          	lw	a4,216(gp) # 1209450 <pSdoResStored>
8000b2c0:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
8000b2c4:	00f70963          	beq	a4,a5,8000b2d6 <.L92>
	{
		APPL_FreeMailboxBuffer(pSdoResStored);
8000b2c8:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
8000b2cc:	853e                	mv	a0,a5
8000b2ce:	598090ef          	jal	80014866 <free>
		pSdoResStored = NULL;
8000b2d2:	0c01ac23          	sw	zero,216(gp) # 1209450 <pSdoResStored>

8000b2d6 <.L92>:
	}

	u8PendingSdo = 0;
8000b2d6:	360207a3          	sb	zero,879(tp) # 36f <default_isr_62+0x79>
	bStoreCompleteAccess = FALSE;
8000b2da:	18018723          	sb	zero,398(gp) # 1209506 <bStoreCompleteAccess>
	u16StoreIndex = 0;
8000b2de:	34021323          	sh	zero,838(tp) # 346 <default_isr_62+0x50>
	u8StoreSubindex = 0;
8000b2e2:	34020aa3          	sb	zero,853(tp) # 355 <default_isr_62+0x5f>
	u32StoreDataSize = 0;
8000b2e6:	0a01a023          	sw	zero,160(gp) # 1209418 <u32StoreDataSize>
	pStoreData = NULL;
8000b2ea:	0c01a623          	sw	zero,204(gp) # 1209444 <pStoreData>
	pSdoPendFunc = NULL;
8000b2ee:	0c01ae23          	sw	zero,220(gp) # 1209454 <pSdoPendFunc>
	bSdoInWork = FALSE;
8000b2f2:	18018a23          	sb	zero,404(gp) # 120950c <bSdoInWork>

	if (pSdoSegData != NULL)
8000b2f6:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
8000b2fa:	cb81                	beqz	a5,8000b30a <.L93>
	{
		FREEMEM((UINT16 VARMEM *) pSdoSegData);
8000b2fc:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
8000b300:	853e                	mv	a0,a5
8000b302:	564090ef          	jal	80014866 <free>
		pSdoSegData = NULL;
8000b306:	0c01aa23          	sw	zero,212(gp) # 120944c <pSdoSegData>

8000b30a <.L93>:
	}

	nSdoSegBytesToHandle = 0;
8000b30a:	1001a823          	sw	zero,272(gp) # 1209488 <nSdoSegBytesToHandle>
	nSdoSegService = 0;
8000b30e:	180184a3          	sb	zero,393(gp) # 1209501 <nSdoSegService>

}
8000b312:	0001                	nop
8000b314:	40b2                	lw	ra,12(sp)
8000b316:	0141                	add	sp,sp,16
8000b318:	8082                	ret

Disassembly of section .text.APPL_AckErrorInd:

8000b31a <APPL_AckErrorInd>:
/**
 \brief    The function is called when an error state was acknowledged by the master
*/

void    APPL_AckErrorInd(UINT16 stateTrans)
{
8000b31a:	1141                	add	sp,sp,-16
8000b31c:	87aa                	mv	a5,a0
8000b31e:	00f11723          	sh	a5,14(sp)

}
8000b322:	0001                	nop
8000b324:	0141                	add	sp,sp,16
8000b326:	8082                	ret

Disassembly of section .text.APPL_StartMailboxHandler:

8000b328 <APPL_StartMailboxHandler>:

*/

UINT16 APPL_StartMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
8000b328:	4781                	li	a5,0
}
8000b32a:	853e                	mv	a0,a5
8000b32c:	8082                	ret

Disassembly of section .text.APPL_StopMailboxHandler:

8000b32e <APPL_StopMailboxHandler>:

*/

UINT16 APPL_StopMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
8000b32e:	4781                	li	a5,0
}
8000b330:	853e                	mv	a0,a5
8000b332:	8082                	ret

Disassembly of section .text.APPL_StopInputHandler:

8000b334 <APPL_StopInputHandler>:

*/

UINT16 APPL_StopInputHandler(void)
{
    return ALSTATUSCODE_NOERROR;
8000b334:	4781                	li	a5,0
}
8000b336:	853e                	mv	a0,a5
8000b338:	8082                	ret

Disassembly of section .text.APPL_StartOutputHandler:

8000b33a <APPL_StartOutputHandler>:
           the transition by calling ECAT_StateChange.
*/

UINT16 APPL_StartOutputHandler(void)
{
    return ALSTATUSCODE_NOERROR;
8000b33a:	4781                	li	a5,0
}
8000b33c:	853e                	mv	a0,a5
8000b33e:	8082                	ret

Disassembly of section .text.APPL_StopOutputHandler:

8000b340 <APPL_StopOutputHandler>:

*/

UINT16 APPL_StopOutputHandler(void)
{
    return ALSTATUSCODE_NOERROR;
8000b340:	4781                	li	a5,0
}
8000b342:	853e                	mv	a0,a5
8000b344:	8082                	ret

Disassembly of section .text.APPL_GenerateMapping:

8000b346 <APPL_GenerateMapping>:
\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*/

UINT16 APPL_GenerateMapping(UINT16 *pInputSize, UINT16 *pOutputSize)
{
8000b346:	7139                	add	sp,sp,-64
8000b348:	de06                	sw	ra,60(sp)
8000b34a:	dc22                	sw	s0,56(sp)
8000b34c:	c62a                	sw	a0,12(sp)
8000b34e:	c42e                	sw	a1,8(sp)
    UINT16 result = ALSTATUSCODE_NOERROR;
8000b350:	02011723          	sh	zero,46(sp)
    UINT16 InputSize = 0;
8000b354:	02011623          	sh	zero,44(sp)
    UINT16 OutputSize = 0;
8000b358:	02011523          	sh	zero,42(sp)

#if COE_SUPPORTED
    UINT16 PDOAssignEntryCnt = 0;
8000b35c:	02011423          	sh	zero,40(sp)
    OBJCONST TOBJECT OBJMEM *pPDO = NULL;
8000b360:	d002                	sw	zero,32(sp)
    UINT16 PDOSubindex0 = 0;
8000b362:	00011f23          	sh	zero,30(sp)
    UINT32 *pPDOEntry = NULL;
8000b366:	cc02                	sw	zero,24(sp)
    UINT16 PDOEntryCnt = 0;
8000b368:	02011323          	sh	zero,38(sp)

#if MAX_PD_OUTPUT_SIZE > 0
    /*Scan object 0x1C12 RXPDO assign*/
    for (PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++) {
8000b36c:	02011423          	sh	zero,40(sp)
8000b370:	a04d                	j	8000b412 <.L17>

8000b372 <.L23>:
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
8000b372:	02815783          	lhu	a5,40(sp)
8000b376:	1dc18713          	add	a4,gp,476 # 1209554 <sRxPDOassign>
8000b37a:	0786                	sll	a5,a5,0x1
8000b37c:	97ba                	add	a5,a5,a4
8000b37e:	0027d783          	lhu	a5,2(a5)
8000b382:	853e                	mv	a0,a5
8000b384:	778040ef          	jal	8000fafc <OBJ_GetObjectHandle>
8000b388:	d02a                	sw	a0,32(sp)
        if (pPDO != NULL) {
8000b38a:	5782                	lw	a5,32(sp)
8000b38c:	c7bd                	beqz	a5,8000b3fa <.L18>
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
8000b38e:	5782                	lw	a5,32(sp)
8000b390:	4f9c                	lw	a5,24(a5)
8000b392:	0007d783          	lhu	a5,0(a5)
8000b396:	00f11f23          	sh	a5,30(sp)
            for (PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++) {
8000b39a:	02011323          	sh	zero,38(sp)
8000b39e:	a0b9                	j	8000b3ec <.L19>

8000b3a0 <.L20>:
                pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1), pPDO)>>4));    /* goto PDO entry */
8000b3a0:	5782                	lw	a5,32(sp)
8000b3a2:	4f80                	lw	s0,24(a5)
8000b3a4:	02615783          	lhu	a5,38(sp)
8000b3a8:	0ff7f793          	zext.b	a5,a5
8000b3ac:	0785                	add	a5,a5,1
8000b3ae:	0ff7f793          	zext.b	a5,a5
8000b3b2:	5582                	lw	a1,32(sp)
8000b3b4:	853e                	mv	a0,a5
8000b3b6:	2c7040ef          	jal	8000fe7c <OBJ_GetEntryOffset>
8000b3ba:	87aa                	mv	a5,a0
8000b3bc:	8391                	srl	a5,a5,0x4
8000b3be:	0807c7b3          	zext.h	a5,a5
8000b3c2:	0786                	sll	a5,a5,0x1
8000b3c4:	97a2                	add	a5,a5,s0
8000b3c6:	cc3e                	sw	a5,24(sp)
                /* we increment the expected output size depending on the mapped Entry */
                OutputSize += (UINT16) ((*pPDOEntry) & 0xFF);
8000b3c8:	47e2                	lw	a5,24(sp)
8000b3ca:	439c                	lw	a5,0(a5)
8000b3cc:	0807c7b3          	zext.h	a5,a5
8000b3d0:	0ff7f793          	zext.b	a5,a5
8000b3d4:	0807c7b3          	zext.h	a5,a5
8000b3d8:	02a15703          	lhu	a4,42(sp)
8000b3dc:	97ba                	add	a5,a5,a4
8000b3de:	02f11523          	sh	a5,42(sp)
            for (PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++) {
8000b3e2:	02615783          	lhu	a5,38(sp)
8000b3e6:	0785                	add	a5,a5,1
8000b3e8:	02f11323          	sh	a5,38(sp)

8000b3ec <.L19>:
8000b3ec:	02615703          	lhu	a4,38(sp)
8000b3f0:	01e15783          	lhu	a5,30(sp)
8000b3f4:	faf766e3          	bltu	a4,a5,8000b3a0 <.L20>
8000b3f8:	a801                	j	8000b408 <.L32>

8000b3fa <.L18>:
            }
        } else {
            /*assigned PDO was not found in object dictionary. return invalid mapping*/
            OutputSize = 0;
8000b3fa:	02011523          	sh	zero,42(sp)
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
8000b3fe:	02500793          	li	a5,37
8000b402:	02f11723          	sh	a5,46(sp)
            break;
8000b406:	a821                	j	8000b41e <.L22>

8000b408 <.L32>:
    for (PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++) {
8000b408:	02815783          	lhu	a5,40(sp)
8000b40c:	0785                	add	a5,a5,1
8000b40e:	02f11423          	sh	a5,40(sp)

8000b412 <.L17>:
8000b412:	1dc1d783          	lhu	a5,476(gp) # 1209554 <sRxPDOassign>
8000b416:	02815703          	lhu	a4,40(sp)
8000b41a:	f4f76ce3          	bltu	a4,a5,8000b372 <.L23>

8000b41e <.L22>:
        }
    }

    OutputSize = (OutputSize + 7) >> 3;
8000b41e:	02a15783          	lhu	a5,42(sp)
8000b422:	079d                	add	a5,a5,7
8000b424:	878d                	sra	a5,a5,0x3
8000b426:	02f11523          	sh	a5,42(sp)
#endif

#if MAX_PD_INPUT_SIZE > 0
    if (result == 0) {
8000b42a:	02e15783          	lhu	a5,46(sp)
8000b42e:	ebd5                	bnez	a5,8000b4e2 <.L24>
        /*Scan Object 0x1C13 TXPDO assign*/
        for (PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++) {
8000b430:	02011423          	sh	zero,40(sp)
8000b434:	a04d                	j	8000b4d6 <.L25>

8000b436 <.L30>:
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
8000b436:	02815783          	lhu	a5,40(sp)
8000b43a:	1d818713          	add	a4,gp,472 # 1209550 <sTxPDOassign>
8000b43e:	0786                	sll	a5,a5,0x1
8000b440:	97ba                	add	a5,a5,a4
8000b442:	0027d783          	lhu	a5,2(a5)
8000b446:	853e                	mv	a0,a5
8000b448:	6b4040ef          	jal	8000fafc <OBJ_GetObjectHandle>
8000b44c:	d02a                	sw	a0,32(sp)
            if (pPDO != NULL) {
8000b44e:	5782                	lw	a5,32(sp)
8000b450:	c7bd                	beqz	a5,8000b4be <.L26>
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
8000b452:	5782                	lw	a5,32(sp)
8000b454:	4f9c                	lw	a5,24(a5)
8000b456:	0007d783          	lhu	a5,0(a5)
8000b45a:	00f11f23          	sh	a5,30(sp)
                for (PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++) {
8000b45e:	02011323          	sh	zero,38(sp)
8000b462:	a0b9                	j	8000b4b0 <.L27>

8000b464 <.L28>:
                    pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1), pPDO)>>4));    /* goto PDO entry */
8000b464:	5782                	lw	a5,32(sp)
8000b466:	4f80                	lw	s0,24(a5)
8000b468:	02615783          	lhu	a5,38(sp)
8000b46c:	0ff7f793          	zext.b	a5,a5
8000b470:	0785                	add	a5,a5,1
8000b472:	0ff7f793          	zext.b	a5,a5
8000b476:	5582                	lw	a1,32(sp)
8000b478:	853e                	mv	a0,a5
8000b47a:	203040ef          	jal	8000fe7c <OBJ_GetEntryOffset>
8000b47e:	87aa                	mv	a5,a0
8000b480:	8391                	srl	a5,a5,0x4
8000b482:	0807c7b3          	zext.h	a5,a5
8000b486:	0786                	sll	a5,a5,0x1
8000b488:	97a2                	add	a5,a5,s0
8000b48a:	cc3e                	sw	a5,24(sp)
                    /* we increment the expected output size depending on the mapped Entry */
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
8000b48c:	47e2                	lw	a5,24(sp)
8000b48e:	439c                	lw	a5,0(a5)
8000b490:	0807c7b3          	zext.h	a5,a5
8000b494:	0ff7f793          	zext.b	a5,a5
8000b498:	0807c7b3          	zext.h	a5,a5
8000b49c:	02c15703          	lhu	a4,44(sp)
8000b4a0:	97ba                	add	a5,a5,a4
8000b4a2:	02f11623          	sh	a5,44(sp)
                for (PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++) {
8000b4a6:	02615783          	lhu	a5,38(sp)
8000b4aa:	0785                	add	a5,a5,1
8000b4ac:	02f11323          	sh	a5,38(sp)

8000b4b0 <.L27>:
8000b4b0:	02615703          	lhu	a4,38(sp)
8000b4b4:	01e15783          	lhu	a5,30(sp)
8000b4b8:	faf766e3          	bltu	a4,a5,8000b464 <.L28>
8000b4bc:	a801                	j	8000b4cc <.L33>

8000b4be <.L26>:
                }
            } else {
                /*assigned PDO was not found in object dictionary. return invalid mapping*/
                InputSize = 0;
8000b4be:	02011623          	sh	zero,44(sp)
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
8000b4c2:	02400793          	li	a5,36
8000b4c6:	02f11723          	sh	a5,46(sp)
                break;
8000b4ca:	a821                	j	8000b4e2 <.L24>

8000b4cc <.L33>:
        for (PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++) {
8000b4cc:	02815783          	lhu	a5,40(sp)
8000b4d0:	0785                	add	a5,a5,1
8000b4d2:	02f11423          	sh	a5,40(sp)

8000b4d6 <.L25>:
8000b4d6:	1d81d783          	lhu	a5,472(gp) # 1209550 <sTxPDOassign>
8000b4da:	02815703          	lhu	a4,40(sp)
8000b4de:	f4f76ce3          	bltu	a4,a5,8000b436 <.L30>

8000b4e2 <.L24>:
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;
8000b4e2:	02c15783          	lhu	a5,44(sp)
8000b4e6:	079d                	add	a5,a5,7
8000b4e8:	878d                	sra	a5,a5,0x3
8000b4ea:	02f11623          	sh	a5,44(sp)
#else
    #warning "Define 'InputSize' and 'OutputSize'."
#endif
#endif

    *pInputSize = InputSize;
8000b4ee:	47b2                	lw	a5,12(sp)
8000b4f0:	02c15703          	lhu	a4,44(sp)
8000b4f4:	00e79023          	sh	a4,0(a5)
    *pOutputSize = OutputSize;
8000b4f8:	47a2                	lw	a5,8(sp)
8000b4fa:	02a15703          	lhu	a4,42(sp)
8000b4fe:	00e79023          	sh	a4,0(a5)
    return result;
8000b502:	02e15783          	lhu	a5,46(sp)
}
8000b506:	853e                	mv	a0,a5
8000b508:	50f2                	lw	ra,60(sp)
8000b50a:	5462                	lw	s0,56(sp)
8000b50c:	6121                	add	sp,sp,64
8000b50e:	8082                	ret

Disassembly of section .text.APPL_InputMapping:

8000b510 <APPL_InputMapping>:

\brief      This function will copies the inputs from the local memory to the ESC memory
            to the hardware
*/
void APPL_InputMapping(UINT16 *pData)
{
8000b510:	1101                	add	sp,sp,-32
8000b512:	ce06                	sw	ra,28(sp)
8000b514:	c62a                	sw	a0,12(sp)
    MEMCPY(pData, &InputCounter0x6000, SIZEOF(InputCounter0x6000));
8000b516:	4611                	li	a2,4
8000b518:	13818593          	add	a1,gp,312 # 12094b0 <InputCounter0x6000>
8000b51c:	4532                	lw	a0,12(sp)
8000b51e:	73e020ef          	jal	8000dc5c <memcpy>
}
8000b522:	0001                	nop
8000b524:	40f2                	lw	ra,28(sp)
8000b526:	6105                	add	sp,sp,32
8000b528:	8082                	ret

Disassembly of section .text.APPL_OutputMapping:

8000b52a <APPL_OutputMapping>:

\brief    This function will copies the outputs from the ESC memory to the local memory
            to the hardware
*/
void APPL_OutputMapping(UINT16 *pData)
{
8000b52a:	1101                	add	sp,sp,-32
8000b52c:	ce06                	sw	ra,28(sp)
8000b52e:	c62a                	sw	a0,12(sp)
    MEMCPY(&OutputCounter0x7010, pData, SIZEOF(OutputCounter0x7010));
8000b530:	4611                	li	a2,4
8000b532:	45b2                	lw	a1,12(sp)
8000b534:	13018513          	add	a0,gp,304 # 12094a8 <OutputCounter0x7010>
8000b538:	724020ef          	jal	8000dc5c <memcpy>
}
8000b53c:	0001                	nop
8000b53e:	40f2                	lw	ra,28(sp)
8000b540:	6105                	add	sp,sp,32
8000b542:	8082                	ret

Disassembly of section .text.APPL_GetDeviceID:

8000b544 <APPL_GetDeviceID>:
 \brief     Read the Explicit Device ID (from an external ID switch)
*/
UINT16 APPL_GetDeviceID(void)
{
    /* Explicit Device 5 is expected by Explicit Device ID conformance tests*/
    return 0x5;
8000b544:	4795                	li	a5,5
}
8000b546:	853e                	mv	a0,a5
8000b548:	8082                	ret

Disassembly of section .text.gptmr_channel_is_opmode:

8000b54a <gptmr_channel_is_opmode>:
 * @param [in] ptr GPTMR base address
 * @param [in] ch_index channel index
 * @retval bool true for opmode, false for normal mode
 */
static inline bool gptmr_channel_is_opmode(GPTMR_Type *ptr, uint8_t ch_index)
{
8000b54a:	1141                	add	sp,sp,-16
8000b54c:	c62a                	sw	a0,12(sp)
8000b54e:	87ae                	mv	a5,a1
8000b550:	00f105a3          	sb	a5,11(sp)
    return ((ptr->CHANNEL[ch_index].CR & GPTMR_CHANNEL_CR_OPMODE_MASK) == GPTMR_CHANNEL_CR_OPMODE_MASK) ? true : false;
8000b554:	00b14783          	lbu	a5,11(sp)
8000b558:	4732                	lw	a4,12(sp)
8000b55a:	079a                	sll	a5,a5,0x6
8000b55c:	97ba                	add	a5,a5,a4
8000b55e:	4398                	lw	a4,0(a5)
8000b560:	000207b7          	lui	a5,0x20
8000b564:	8f7d                	and	a4,a4,a5
8000b566:	7781                	lui	a5,0xfffe0
8000b568:	97ba                	add	a5,a5,a4
8000b56a:	0017b793          	seqz	a5,a5
8000b56e:	0ff7f793          	zext.b	a5,a5
}
8000b572:	853e                	mv	a0,a5
8000b574:	0141                	add	sp,sp,16
8000b576:	8082                	ret

Disassembly of section .text.esc_core_enable_clock:

8000b578 <esc_core_enable_clock>:
 *
 * @param[in] ptr ESC base address
 * @param[in] enable Set true to enable or false to disable
 */
static inline void esc_core_enable_clock(ESC_Type *ptr, bool enable)
{
8000b578:	1141                	add	sp,sp,-16
8000b57a:	c62a                	sw	a0,12(sp)
8000b57c:	87ae                	mv	a5,a1
8000b57e:	00f105a3          	sb	a5,11(sp)
    if (enable) {
8000b582:	00b14783          	lbu	a5,11(sp)
8000b586:	cf81                	beqz	a5,8000b59e <.L10>
        ptr->GPR_CFG0 |= ESC_GPR_CFG0_CLK100_EN_MASK;
8000b588:	4732                	lw	a4,12(sp)
8000b58a:	67fd                	lui	a5,0x1f
8000b58c:	97ba                	add	a5,a5,a4
8000b58e:	4398                	lw	a4,0(a5)
8000b590:	6789                	lui	a5,0x2
8000b592:	8f5d                	or	a4,a4,a5
8000b594:	46b2                	lw	a3,12(sp)
8000b596:	67fd                	lui	a5,0x1f
8000b598:	97b6                	add	a5,a5,a3
8000b59a:	c398                	sw	a4,0(a5)
    } else {
        ptr->GPR_CFG0 &= ~ESC_GPR_CFG0_CLK100_EN_MASK;
    }
}
8000b59c:	a821                	j	8000b5b4 <.L12>

8000b59e <.L10>:
        ptr->GPR_CFG0 &= ~ESC_GPR_CFG0_CLK100_EN_MASK;
8000b59e:	4732                	lw	a4,12(sp)
8000b5a0:	67fd                	lui	a5,0x1f
8000b5a2:	97ba                	add	a5,a5,a4
8000b5a4:	4398                	lw	a4,0(a5)
8000b5a6:	77f9                	lui	a5,0xffffe
8000b5a8:	17fd                	add	a5,a5,-1 # ffffdfff <__AHB_SRAM_segment_end__+0xfdf5fff>
8000b5aa:	8f7d                	and	a4,a4,a5
8000b5ac:	46b2                	lw	a3,12(sp)
8000b5ae:	67fd                	lui	a5,0x1f
8000b5b0:	97b6                	add	a5,a5,a3
8000b5b2:	c398                	sw	a4,0(a5)

8000b5b4 <.L12>:
}
8000b5b4:	0001                	nop
8000b5b6:	0141                	add	sp,sp,16
8000b5b8:	8082                	ret

Disassembly of section .text.esc_config_nmii_link_source:

8000b5ba <esc_config_nmii_link_source>:
 * @param[in] link0_from_io true for signal from configured IO; false for signal from register(GPR_CFG2) value
 * @param[in] link1_from_io true for signal from configured IO; false for signal from register(GPR_CFG2) value
 * @param[in] link2_from_io true for signal from configured IO; false for signal from register(GPR_CFG2) value
 */
static inline void esc_config_nmii_link_source(ESC_Type *ptr, bool link0_from_io, bool link1_from_io, bool link2_from_io)
{
8000b5ba:	1141                	add	sp,sp,-16
8000b5bc:	c62a                	sw	a0,12(sp)
8000b5be:	87ae                	mv	a5,a1
8000b5c0:	8736                	mv	a4,a3
8000b5c2:	00f105a3          	sb	a5,11(sp)
8000b5c6:	87b2                	mv	a5,a2
8000b5c8:	00f10523          	sb	a5,10(sp)
8000b5cc:	87ba                	mv	a5,a4
8000b5ce:	00f104a3          	sb	a5,9(sp)
    if (link0_from_io) {
8000b5d2:	00b14783          	lbu	a5,11(sp)
8000b5d6:	cf89                	beqz	a5,8000b5f0 <.L23>
        ptr->GPR_CFG2 |= ESC_GPR_CFG2_NMII_LINK0_FROM_IO_MASK;
8000b5d8:	4732                	lw	a4,12(sp)
8000b5da:	67fd                	lui	a5,0x1f
8000b5dc:	97ba                	add	a5,a5,a4
8000b5de:	4798                	lw	a4,8(a5)
8000b5e0:	002007b7          	lui	a5,0x200
8000b5e4:	8f5d                	or	a4,a4,a5
8000b5e6:	46b2                	lw	a3,12(sp)
8000b5e8:	67fd                	lui	a5,0x1f
8000b5ea:	97b6                	add	a5,a5,a3
8000b5ec:	c798                	sw	a4,8(a5)
8000b5ee:	a805                	j	8000b61e <.L24>

8000b5f0 <.L23>:
    } else {
        ptr->GPR_CFG2 &= ~ESC_GPR_CFG2_NMII_LINK0_FROM_IO_MASK;
8000b5f0:	4732                	lw	a4,12(sp)
8000b5f2:	67fd                	lui	a5,0x1f
8000b5f4:	97ba                	add	a5,a5,a4
8000b5f6:	4798                	lw	a4,8(a5)
8000b5f8:	ffe007b7          	lui	a5,0xffe00
8000b5fc:	17fd                	add	a5,a5,-1 # ffdfffff <__AHB_SRAM_segment_end__+0xfbf7fff>
8000b5fe:	8f7d                	and	a4,a4,a5
8000b600:	46b2                	lw	a3,12(sp)
8000b602:	67fd                	lui	a5,0x1f
8000b604:	97b6                	add	a5,a5,a3
8000b606:	c798                	sw	a4,8(a5)
        ptr->GPR_CFG2 |= ESC_GPR_CFG2_NMII_LINK0_GPR_MASK; /* config GRP to indicate LINK0 is invalid by default */
8000b608:	4732                	lw	a4,12(sp)
8000b60a:	67fd                	lui	a5,0x1f
8000b60c:	97ba                	add	a5,a5,a4
8000b60e:	4798                	lw	a4,8(a5)
8000b610:	001007b7          	lui	a5,0x100
8000b614:	8f5d                	or	a4,a4,a5
8000b616:	46b2                	lw	a3,12(sp)
8000b618:	67fd                	lui	a5,0x1f
8000b61a:	97b6                	add	a5,a5,a3
8000b61c:	c798                	sw	a4,8(a5)

8000b61e <.L24>:
    }

    if (link1_from_io) {
8000b61e:	00a14783          	lbu	a5,10(sp)
8000b622:	cf89                	beqz	a5,8000b63c <.L25>
        ptr->GPR_CFG2 |= ESC_GPR_CFG2_NMII_LINK1_FROM_IO_MASK;
8000b624:	4732                	lw	a4,12(sp)
8000b626:	67fd                	lui	a5,0x1f
8000b628:	97ba                	add	a5,a5,a4
8000b62a:	4798                	lw	a4,8(a5)
8000b62c:	020007b7          	lui	a5,0x2000
8000b630:	8f5d                	or	a4,a4,a5
8000b632:	46b2                	lw	a3,12(sp)
8000b634:	67fd                	lui	a5,0x1f
8000b636:	97b6                	add	a5,a5,a3
8000b638:	c798                	sw	a4,8(a5)
8000b63a:	a805                	j	8000b66a <.L26>

8000b63c <.L25>:
    } else {
        ptr->GPR_CFG2 &= ~ESC_GPR_CFG2_NMII_LINK1_FROM_IO_MASK;
8000b63c:	4732                	lw	a4,12(sp)
8000b63e:	67fd                	lui	a5,0x1f
8000b640:	97ba                	add	a5,a5,a4
8000b642:	4798                	lw	a4,8(a5)
8000b644:	fe0007b7          	lui	a5,0xfe000
8000b648:	17fd                	add	a5,a5,-1 # fdffffff <__AHB_SRAM_segment_end__+0xddf7fff>
8000b64a:	8f7d                	and	a4,a4,a5
8000b64c:	46b2                	lw	a3,12(sp)
8000b64e:	67fd                	lui	a5,0x1f
8000b650:	97b6                	add	a5,a5,a3
8000b652:	c798                	sw	a4,8(a5)
        ptr->GPR_CFG2 |= ESC_GPR_CFG2_NMII_LINK1_GPR_MASK; /* config GRP to indicate LINK1 is invalid by default */
8000b654:	4732                	lw	a4,12(sp)
8000b656:	67fd                	lui	a5,0x1f
8000b658:	97ba                	add	a5,a5,a4
8000b65a:	4798                	lw	a4,8(a5)
8000b65c:	010007b7          	lui	a5,0x1000
8000b660:	8f5d                	or	a4,a4,a5
8000b662:	46b2                	lw	a3,12(sp)
8000b664:	67fd                	lui	a5,0x1f
8000b666:	97b6                	add	a5,a5,a3
8000b668:	c798                	sw	a4,8(a5)

8000b66a <.L26>:
    }

    if (link2_from_io) {
8000b66a:	00914783          	lbu	a5,9(sp)
8000b66e:	cf89                	beqz	a5,8000b688 <.L27>
        ptr->GPR_CFG2 |= ESC_GPR_CFG2_NMII_LINK2_FROM_IO_MASK;
8000b670:	4732                	lw	a4,12(sp)
8000b672:	67fd                	lui	a5,0x1f
8000b674:	97ba                	add	a5,a5,a4
8000b676:	4798                	lw	a4,8(a5)
8000b678:	200007b7          	lui	a5,0x20000
8000b67c:	8f5d                	or	a4,a4,a5
8000b67e:	46b2                	lw	a3,12(sp)
8000b680:	67fd                	lui	a5,0x1f
8000b682:	97b6                	add	a5,a5,a3
8000b684:	c798                	sw	a4,8(a5)
    } else {
        ptr->GPR_CFG2 &= ~ESC_GPR_CFG2_NMII_LINK2_FROM_IO_MASK;
        ptr->GPR_CFG2 |= ESC_GPR_CFG2_NMII_LINK2_GPR_MASK; /* config GRP to indicate LINK2 is invalid by default */
    }
}
8000b686:	a805                	j	8000b6b6 <.L29>

8000b688 <.L27>:
        ptr->GPR_CFG2 &= ~ESC_GPR_CFG2_NMII_LINK2_FROM_IO_MASK;
8000b688:	4732                	lw	a4,12(sp)
8000b68a:	67fd                	lui	a5,0x1f
8000b68c:	97ba                	add	a5,a5,a4
8000b68e:	4798                	lw	a4,8(a5)
8000b690:	e00007b7          	lui	a5,0xe0000
8000b694:	17fd                	add	a5,a5,-1 # dfffffff <__FLASH_segment_end__+0x5fefffff>
8000b696:	8f7d                	and	a4,a4,a5
8000b698:	46b2                	lw	a3,12(sp)
8000b69a:	67fd                	lui	a5,0x1f
8000b69c:	97b6                	add	a5,a5,a3
8000b69e:	c798                	sw	a4,8(a5)
        ptr->GPR_CFG2 |= ESC_GPR_CFG2_NMII_LINK2_GPR_MASK; /* config GRP to indicate LINK2 is invalid by default */
8000b6a0:	4732                	lw	a4,12(sp)
8000b6a2:	67fd                	lui	a5,0x1f
8000b6a4:	97ba                	add	a5,a5,a4
8000b6a6:	4798                	lw	a4,8(a5)
8000b6a8:	100007b7          	lui	a5,0x10000
8000b6ac:	8f5d                	or	a4,a4,a5
8000b6ae:	46b2                	lw	a3,12(sp)
8000b6b0:	67fd                	lui	a5,0x1f
8000b6b2:	97b6                	add	a5,a5,a3
8000b6b4:	c798                	sw	a4,8(a5)

8000b6b6 <.L29>:
}
8000b6b6:	0001                	nop
8000b6b8:	0141                	add	sp,sp,16
8000b6ba:	8082                	ret

Disassembly of section .text.esc_read_eeprom_data:

8000b6bc <esc_read_eeprom_data>:
 *
 * @param[in] ptr ESC base address
 * @return eeprom data
 */
static inline uint64_t esc_read_eeprom_data(ESC_Type *ptr)
{
8000b6bc:	1141                	add	sp,sp,-16
8000b6be:	c62a                	sw	a0,12(sp)
    return ptr->EEPROM_DATA;
8000b6c0:	47b2                	lw	a5,12(sp)
8000b6c2:	5087a703          	lw	a4,1288(a5) # 1f508 <__FLASH_segment_used_size__+0xb878>
8000b6c6:	50c7a783          	lw	a5,1292(a5)
}
8000b6ca:	853a                	mv	a0,a4
8000b6cc:	85be                	mv	a1,a5
8000b6ce:	0141                	add	sp,sp,16
8000b6d0:	8082                	ret

Disassembly of section .text.ppor_sw_reset:

8000b6d2 <ppor_sw_reset>:

/*
 * perform software reset in counter * (1/24Mhz) seconds
 */
static inline void ppor_sw_reset(PPOR_Type *ptr, uint32_t counter)
{
8000b6d2:	1141                	add	sp,sp,-16
8000b6d4:	c62a                	sw	a0,12(sp)
8000b6d6:	c42e                	sw	a1,8(sp)
    ptr->SOFTWARE_RESET = PPOR_SOFTWARE_RESET_COUNTER_SET(counter); }
8000b6d8:	47b2                	lw	a5,12(sp)
8000b6da:	4722                	lw	a4,8(sp)
8000b6dc:	cfd8                	sw	a4,28(a5)
8000b6de:	0001                	nop
8000b6e0:	0141                	add	sp,sp,16
8000b6e2:	8082                	ret

Disassembly of section .text.ecat_timer_ms_enable:

8000b6e4 <ecat_timer_ms_enable>:
}


/* enable gptmr 1ms tick for ecat */
void ecat_timer_ms_enable(void)
{
8000b6e4:	7159                	add	sp,sp,-112
8000b6e6:	d686                	sw	ra,108(sp)
    uint32_t gptmr_freq;
    gptmr_channel_config_t config;

    clock_add_to_group(ECAT_TIMER_GPTMR_CLK, 0);
8000b6e8:	4581                	li	a1,0
8000b6ea:	010607b7          	lui	a5,0x1060
8000b6ee:	00678513          	add	a0,a5,6 # 1060006 <__DLM_segment_end__+0xe40006>
8000b6f2:	485000ef          	jal	8000c376 <clock_add_to_group>
    gptmr_channel_get_default_config(ECAT_TIMER_GPTMR, &config);
8000b6f6:	878a                	mv	a5,sp
8000b6f8:	85be                	mv	a1,a5
8000b6fa:	f0000537          	lui	a0,0xf0000
8000b6fe:	1f0070ef          	jal	800128ee <gptmr_channel_get_default_config>
    gptmr_freq = clock_get_frequency(ECAT_TIMER_GPTMR_CLK);
8000b702:	010607b7          	lui	a5,0x1060
8000b706:	00678513          	add	a0,a5,6 # 1060006 <__DLM_segment_end__+0xe40006>
8000b70a:	1d7000ef          	jal	8000c0e0 <clock_get_frequency>
8000b70e:	ceaa                	sw	a0,92(sp)
    config.reload = gptmr_freq / 1000; /* 1ms */
8000b710:	4776                	lw	a4,92(sp)
8000b712:	3e800793          	li	a5,1000
8000b716:	02f757b3          	divu	a5,a4,a5
8000b71a:	c63e                	sw	a5,12(sp)
    gptmr_channel_config(ECAT_TIMER_GPTMR, ECAT_TIMER_GPTMR_CH, &config, false);
8000b71c:	878a                	mv	a5,sp
8000b71e:	4681                	li	a3,0
8000b720:	863e                	mv	a2,a5
8000b722:	4581                	li	a1,0
8000b724:	f0000537          	lui	a0,0xf0000
8000b728:	258070ef          	jal	80012980 <gptmr_channel_config>
    gptmr_start_counter(ECAT_TIMER_GPTMR, ECAT_TIMER_GPTMR_CH);
8000b72c:	4581                	li	a1,0
8000b72e:	f0000537          	lui	a0,0xf0000
8000b732:	745050ef          	jal	80011676 <gptmr_start_counter>

    gptmr_enable_irq(ECAT_TIMER_GPTMR, GPTMR_CH_RLD_IRQ_MASK(ECAT_TIMER_GPTMR_CH));
8000b736:	4585                	li	a1,1
8000b738:	f0000537          	lui	a0,0xf0000
8000b73c:	6e7050ef          	jal	80011622 <gptmr_enable_irq>
8000b740:	47ad                	li	a5,11
8000b742:	de3e                	sw	a5,60(sp)
8000b744:	4789                	li	a5,2
8000b746:	dc3e                	sw	a5,56(sp)
8000b748:	e40007b7          	lui	a5,0xe4000
8000b74c:	da3e                	sw	a5,52(sp)
8000b74e:	57f2                	lw	a5,60(sp)
8000b750:	d83e                	sw	a5,48(sp)
8000b752:	57e2                	lw	a5,56(sp)
8000b754:	d63e                	sw	a5,44(sp)

8000b756 <.LBB64>:
ATTR_ALWAYS_INLINE static inline void __plic_set_irq_priority(uint32_t base,
                                               uint32_t irq,
                                               uint32_t priority)
{
    volatile uint32_t *priority_ptr = (volatile uint32_t *)(base +
            HPM_PLIC_PRIORITY_OFFSET + ((irq-1) << HPM_PLIC_PRIORITY_SHIFT_PER_SOURCE));
8000b756:	57c2                	lw	a5,48(sp)
8000b758:	17fd                	add	a5,a5,-1 # e3ffffff <__FLASH_segment_end__+0x63efffff>
8000b75a:	00279713          	sll	a4,a5,0x2
8000b75e:	57d2                	lw	a5,52(sp)
8000b760:	97ba                	add	a5,a5,a4
8000b762:	0791                	add	a5,a5,4
    volatile uint32_t *priority_ptr = (volatile uint32_t *)(base +
8000b764:	d43e                	sw	a5,40(sp)
    *priority_ptr = priority;
8000b766:	57a2                	lw	a5,40(sp)
8000b768:	5732                	lw	a4,44(sp)
8000b76a:	c398                	sw	a4,0(a5)
}
8000b76c:	0001                	nop

8000b76e <.LBE66>:
 * @param[in] priority Priority of interrupt
 */
ATTR_ALWAYS_INLINE static inline void intc_set_irq_priority(uint32_t irq, uint32_t priority)
{
    __plic_set_irq_priority(HPM_PLIC_BASE, irq, priority);
}
8000b76e:	0001                	nop
8000b770:	cc82                	sw	zero,88(sp)
8000b772:	47ad                	li	a5,11
8000b774:	cabe                	sw	a5,84(sp)
8000b776:	e40007b7          	lui	a5,0xe4000
8000b77a:	c8be                	sw	a5,80(sp)
8000b77c:	47e6                	lw	a5,88(sp)
8000b77e:	c6be                	sw	a5,76(sp)
8000b780:	47d6                	lw	a5,84(sp)
8000b782:	c4be                	sw	a5,72(sp)

8000b784 <.LBB68>:
                                                        uint32_t target,
                                                        uint32_t irq)
{
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
            HPM_PLIC_ENABLE_OFFSET +
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b784:	47b6                	lw	a5,76(sp)
8000b786:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
8000b78a:	47c6                	lw	a5,80(sp)
8000b78c:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
8000b78e:	47a6                	lw	a5,72(sp)
8000b790:	8395                	srl	a5,a5,0x5
8000b792:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b794:	973e                	add	a4,a4,a5
8000b796:	6789                	lui	a5,0x2
8000b798:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
8000b79a:	c2be                	sw	a5,68(sp)
    uint32_t current = *current_ptr;
8000b79c:	4796                	lw	a5,68(sp)
8000b79e:	439c                	lw	a5,0(a5)
8000b7a0:	c0be                	sw	a5,64(sp)
    current = current | (1 << (irq & 0x1F));
8000b7a2:	47a6                	lw	a5,72(sp)
8000b7a4:	8bfd                	and	a5,a5,31
8000b7a6:	4705                	li	a4,1
8000b7a8:	00f717b3          	sll	a5,a4,a5
8000b7ac:	873e                	mv	a4,a5
8000b7ae:	4786                	lw	a5,64(sp)
8000b7b0:	8fd9                	or	a5,a5,a4
8000b7b2:	c0be                	sw	a5,64(sp)
    *current_ptr = current;
8000b7b4:	4796                	lw	a5,68(sp)
8000b7b6:	4706                	lw	a4,64(sp)
8000b7b8:	c398                	sw	a4,0(a5)
}
8000b7ba:	0001                	nop

8000b7bc <.LBE70>:
}
8000b7bc:	0001                	nop

8000b7be <.LBE68>:
    intc_m_enable_irq_with_priority(ECAT_TIMER_GPTRM_IRQ, 2);
}
8000b7be:	0001                	nop
8000b7c0:	50b6                	lw	ra,108(sp)
8000b7c2:	6165                	add	sp,sp,112
8000b7c4:	8082                	ret

Disassembly of section .text.HW_Init:

8000b7c6 <HW_Init>:
}

UINT16 HW_Init(void)
{
    /* set esc register base address */
    pEsc = (MEM_ADDR ESCMEM *) HPM_ESC_BASE;
8000b7c6:	f1700737          	lui	a4,0xf1700
8000b7ca:	0ee1a223          	sw	a4,228(gp) # 120945c <pEsc>

    return 0;
8000b7ce:	4781                	li	a5,0
}
8000b7d0:	853e                	mv	a0,a5
8000b7d2:	8082                	ret

Disassembly of section .text.ENABLE_ESC_INT:

8000b7d4 <ENABLE_ESC_INT>:
    intc_m_disable_irq(IRQn_ESC_RESET);
}


void ENABLE_ESC_INT(void)
{
8000b7d4:	7155                	add	sp,sp,-208
    HPM_ESC->GPR_CFG1 |= ESC_GPR_CFG1_SYNC0_IRQ_EN_MASK | ESC_GPR_CFG1_SYNC1_IRQ_EN_MASK | ESC_GPR_CFG1_RSTO_IRQ_EN_MASK;
8000b7d6:	f1700737          	lui	a4,0xf1700
8000b7da:	67fd                	lui	a5,0x1f
8000b7dc:	97ba                	add	a5,a5,a4
8000b7de:	43d8                	lw	a4,4(a5)
8000b7e0:	f17006b7          	lui	a3,0xf1700
8000b7e4:	e00007b7          	lui	a5,0xe0000
8000b7e8:	8f5d                	or	a4,a4,a5
8000b7ea:	67fd                	lui	a5,0x1f
8000b7ec:	97b6                	add	a5,a5,a3
8000b7ee:	c3d8                	sw	a4,4(a5)
8000b7f0:	03e00793          	li	a5,62
8000b7f4:	ca3e                	sw	a5,20(sp)
8000b7f6:	478d                	li	a5,3
8000b7f8:	c83e                	sw	a5,16(sp)
8000b7fa:	e40007b7          	lui	a5,0xe4000
8000b7fe:	c63e                	sw	a5,12(sp)
8000b800:	47d2                	lw	a5,20(sp)
8000b802:	c43e                	sw	a5,8(sp)
8000b804:	47c2                	lw	a5,16(sp)
8000b806:	c23e                	sw	a5,4(sp)

8000b808 <.LBB88>:
            HPM_PLIC_PRIORITY_OFFSET + ((irq-1) << HPM_PLIC_PRIORITY_SHIFT_PER_SOURCE));
8000b808:	47a2                	lw	a5,8(sp)
8000b80a:	17fd                	add	a5,a5,-1 # e3ffffff <__FLASH_segment_end__+0x63efffff>
8000b80c:	00279713          	sll	a4,a5,0x2
8000b810:	47b2                	lw	a5,12(sp)
8000b812:	97ba                	add	a5,a5,a4
8000b814:	0791                	add	a5,a5,4
    volatile uint32_t *priority_ptr = (volatile uint32_t *)(base +
8000b816:	c03e                	sw	a5,0(sp)
    *priority_ptr = priority;
8000b818:	4782                	lw	a5,0(sp)
8000b81a:	4712                	lw	a4,4(sp)
8000b81c:	c398                	sw	a4,0(a5)
}
8000b81e:	0001                	nop

8000b820 <.LBE90>:
}
8000b820:	0001                	nop
8000b822:	d802                	sw	zero,48(sp)
8000b824:	03e00793          	li	a5,62
8000b828:	d63e                	sw	a5,44(sp)
8000b82a:	e40007b7          	lui	a5,0xe4000
8000b82e:	d43e                	sw	a5,40(sp)
8000b830:	57c2                	lw	a5,48(sp)
8000b832:	d23e                	sw	a5,36(sp)
8000b834:	57b2                	lw	a5,44(sp)
8000b836:	d03e                	sw	a5,32(sp)

8000b838 <.LBB92>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b838:	5792                	lw	a5,36(sp)
8000b83a:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
8000b83e:	57a2                	lw	a5,40(sp)
8000b840:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
8000b842:	5782                	lw	a5,32(sp)
8000b844:	8395                	srl	a5,a5,0x5
8000b846:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b848:	973e                	add	a4,a4,a5
8000b84a:	6789                	lui	a5,0x2
8000b84c:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
8000b84e:	ce3e                	sw	a5,28(sp)
    uint32_t current = *current_ptr;
8000b850:	47f2                	lw	a5,28(sp)
8000b852:	439c                	lw	a5,0(a5)
8000b854:	cc3e                	sw	a5,24(sp)
    current = current | (1 << (irq & 0x1F));
8000b856:	5782                	lw	a5,32(sp)
8000b858:	8bfd                	and	a5,a5,31
8000b85a:	4705                	li	a4,1
8000b85c:	00f717b3          	sll	a5,a4,a5
8000b860:	873e                	mv	a4,a5
8000b862:	47e2                	lw	a5,24(sp)
8000b864:	8fd9                	or	a5,a5,a4
8000b866:	cc3e                	sw	a5,24(sp)
    *current_ptr = current;
8000b868:	47f2                	lw	a5,28(sp)
8000b86a:	4762                	lw	a4,24(sp)
8000b86c:	c398                	sw	a4,0(a5)
}
8000b86e:	0001                	nop

8000b870 <.LBE94>:
}
8000b870:	0001                	nop
8000b872:	03f00793          	li	a5,63
8000b876:	c4be                	sw	a5,72(sp)
8000b878:	478d                	li	a5,3
8000b87a:	c2be                	sw	a5,68(sp)
8000b87c:	e40007b7          	lui	a5,0xe4000
8000b880:	c0be                	sw	a5,64(sp)
8000b882:	47a6                	lw	a5,72(sp)
8000b884:	de3e                	sw	a5,60(sp)
8000b886:	4796                	lw	a5,68(sp)
8000b888:	dc3e                	sw	a5,56(sp)

8000b88a <.LBB96>:
            HPM_PLIC_PRIORITY_OFFSET + ((irq-1) << HPM_PLIC_PRIORITY_SHIFT_PER_SOURCE));
8000b88a:	57f2                	lw	a5,60(sp)
8000b88c:	17fd                	add	a5,a5,-1 # e3ffffff <__FLASH_segment_end__+0x63efffff>
8000b88e:	00279713          	sll	a4,a5,0x2
8000b892:	4786                	lw	a5,64(sp)
8000b894:	97ba                	add	a5,a5,a4
8000b896:	0791                	add	a5,a5,4
    volatile uint32_t *priority_ptr = (volatile uint32_t *)(base +
8000b898:	da3e                	sw	a5,52(sp)
    *priority_ptr = priority;
8000b89a:	57d2                	lw	a5,52(sp)
8000b89c:	5762                	lw	a4,56(sp)
8000b89e:	c398                	sw	a4,0(a5)
}
8000b8a0:	0001                	nop

8000b8a2 <.LBE98>:
}
8000b8a2:	0001                	nop
8000b8a4:	d282                	sw	zero,100(sp)
8000b8a6:	03f00793          	li	a5,63
8000b8aa:	d0be                	sw	a5,96(sp)
8000b8ac:	e40007b7          	lui	a5,0xe4000
8000b8b0:	cebe                	sw	a5,92(sp)
8000b8b2:	5796                	lw	a5,100(sp)
8000b8b4:	ccbe                	sw	a5,88(sp)
8000b8b6:	5786                	lw	a5,96(sp)
8000b8b8:	cabe                	sw	a5,84(sp)

8000b8ba <.LBB100>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b8ba:	47e6                	lw	a5,88(sp)
8000b8bc:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
8000b8c0:	47f6                	lw	a5,92(sp)
8000b8c2:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
8000b8c4:	47d6                	lw	a5,84(sp)
8000b8c6:	8395                	srl	a5,a5,0x5
8000b8c8:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b8ca:	973e                	add	a4,a4,a5
8000b8cc:	6789                	lui	a5,0x2
8000b8ce:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
8000b8d0:	c8be                	sw	a5,80(sp)
    uint32_t current = *current_ptr;
8000b8d2:	47c6                	lw	a5,80(sp)
8000b8d4:	439c                	lw	a5,0(a5)
8000b8d6:	c6be                	sw	a5,76(sp)
    current = current | (1 << (irq & 0x1F));
8000b8d8:	47d6                	lw	a5,84(sp)
8000b8da:	8bfd                	and	a5,a5,31
8000b8dc:	4705                	li	a4,1
8000b8de:	00f717b3          	sll	a5,a4,a5
8000b8e2:	873e                	mv	a4,a5
8000b8e4:	47b6                	lw	a5,76(sp)
8000b8e6:	8fd9                	or	a5,a5,a4
8000b8e8:	c6be                	sw	a5,76(sp)
    *current_ptr = current;
8000b8ea:	47c6                	lw	a5,80(sp)
8000b8ec:	4736                	lw	a4,76(sp)
8000b8ee:	c398                	sw	a4,0(a5)
}
8000b8f0:	0001                	nop

8000b8f2 <.LBE102>:
}
8000b8f2:	0001                	nop
8000b8f4:	03d00793          	li	a5,61
8000b8f8:	debe                	sw	a5,124(sp)
8000b8fa:	478d                	li	a5,3
8000b8fc:	dcbe                	sw	a5,120(sp)
8000b8fe:	e40007b7          	lui	a5,0xe4000
8000b902:	dabe                	sw	a5,116(sp)
8000b904:	57f6                	lw	a5,124(sp)
8000b906:	d8be                	sw	a5,112(sp)
8000b908:	57e6                	lw	a5,120(sp)
8000b90a:	d6be                	sw	a5,108(sp)

8000b90c <.LBB104>:
            HPM_PLIC_PRIORITY_OFFSET + ((irq-1) << HPM_PLIC_PRIORITY_SHIFT_PER_SOURCE));
8000b90c:	57c6                	lw	a5,112(sp)
8000b90e:	17fd                	add	a5,a5,-1 # e3ffffff <__FLASH_segment_end__+0x63efffff>
8000b910:	00279713          	sll	a4,a5,0x2
8000b914:	57d6                	lw	a5,116(sp)
8000b916:	97ba                	add	a5,a5,a4
8000b918:	0791                	add	a5,a5,4
    volatile uint32_t *priority_ptr = (volatile uint32_t *)(base +
8000b91a:	d4be                	sw	a5,104(sp)
    *priority_ptr = priority;
8000b91c:	57a6                	lw	a5,104(sp)
8000b91e:	5736                	lw	a4,108(sp)
8000b920:	c398                	sw	a4,0(a5)
}
8000b922:	0001                	nop

8000b924 <.LBE106>:
}
8000b924:	0001                	nop
8000b926:	cd02                	sw	zero,152(sp)
8000b928:	03d00793          	li	a5,61
8000b92c:	cb3e                	sw	a5,148(sp)
8000b92e:	e40007b7          	lui	a5,0xe4000
8000b932:	c93e                	sw	a5,144(sp)
8000b934:	47ea                	lw	a5,152(sp)
8000b936:	c73e                	sw	a5,140(sp)
8000b938:	47da                	lw	a5,148(sp)
8000b93a:	c53e                	sw	a5,136(sp)

8000b93c <.LBB108>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b93c:	47ba                	lw	a5,140(sp)
8000b93e:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
8000b942:	47ca                	lw	a5,144(sp)
8000b944:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
8000b946:	47aa                	lw	a5,136(sp)
8000b948:	8395                	srl	a5,a5,0x5
8000b94a:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b94c:	973e                	add	a4,a4,a5
8000b94e:	6789                	lui	a5,0x2
8000b950:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
8000b952:	c33e                	sw	a5,132(sp)
    uint32_t current = *current_ptr;
8000b954:	479a                	lw	a5,132(sp)
8000b956:	439c                	lw	a5,0(a5)
8000b958:	c13e                	sw	a5,128(sp)
    current = current | (1 << (irq & 0x1F));
8000b95a:	47aa                	lw	a5,136(sp)
8000b95c:	8bfd                	and	a5,a5,31
8000b95e:	4705                	li	a4,1
8000b960:	00f717b3          	sll	a5,a4,a5
8000b964:	873e                	mv	a4,a5
8000b966:	478a                	lw	a5,128(sp)
8000b968:	8fd9                	or	a5,a5,a4
8000b96a:	c13e                	sw	a5,128(sp)
    *current_ptr = current;
8000b96c:	479a                	lw	a5,132(sp)
8000b96e:	470a                	lw	a4,128(sp)
8000b970:	c398                	sw	a4,0(a5)
}
8000b972:	0001                	nop

8000b974 <.LBE110>:
}
8000b974:	0001                	nop
8000b976:	04000793          	li	a5,64
8000b97a:	d93e                	sw	a5,176(sp)
8000b97c:	478d                	li	a5,3
8000b97e:	d73e                	sw	a5,172(sp)
8000b980:	e40007b7          	lui	a5,0xe4000
8000b984:	d53e                	sw	a5,168(sp)
8000b986:	57ca                	lw	a5,176(sp)
8000b988:	d33e                	sw	a5,164(sp)
8000b98a:	57ba                	lw	a5,172(sp)
8000b98c:	d13e                	sw	a5,160(sp)

8000b98e <.LBB112>:
            HPM_PLIC_PRIORITY_OFFSET + ((irq-1) << HPM_PLIC_PRIORITY_SHIFT_PER_SOURCE));
8000b98e:	579a                	lw	a5,164(sp)
8000b990:	17fd                	add	a5,a5,-1 # e3ffffff <__FLASH_segment_end__+0x63efffff>
8000b992:	00279713          	sll	a4,a5,0x2
8000b996:	57aa                	lw	a5,168(sp)
8000b998:	97ba                	add	a5,a5,a4
8000b99a:	0791                	add	a5,a5,4
    volatile uint32_t *priority_ptr = (volatile uint32_t *)(base +
8000b99c:	cf3e                	sw	a5,156(sp)
    *priority_ptr = priority;
8000b99e:	47fa                	lw	a5,156(sp)
8000b9a0:	570a                	lw	a4,160(sp)
8000b9a2:	c398                	sw	a4,0(a5)
}
8000b9a4:	0001                	nop

8000b9a6 <.LBE114>:
}
8000b9a6:	0001                	nop
8000b9a8:	c782                	sw	zero,204(sp)
8000b9aa:	04000793          	li	a5,64
8000b9ae:	c5be                	sw	a5,200(sp)
8000b9b0:	e40007b7          	lui	a5,0xe4000
8000b9b4:	c3be                	sw	a5,196(sp)
8000b9b6:	47be                	lw	a5,204(sp)
8000b9b8:	c1be                	sw	a5,192(sp)
8000b9ba:	47ae                	lw	a5,200(sp)
8000b9bc:	df3e                	sw	a5,188(sp)

8000b9be <.LBB116>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b9be:	478e                	lw	a5,192(sp)
8000b9c0:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
8000b9c4:	479e                	lw	a5,196(sp)
8000b9c6:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
8000b9c8:	57fa                	lw	a5,188(sp)
8000b9ca:	8395                	srl	a5,a5,0x5
8000b9cc:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
8000b9ce:	973e                	add	a4,a4,a5
8000b9d0:	6789                	lui	a5,0x2
8000b9d2:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
8000b9d4:	dd3e                	sw	a5,184(sp)
    uint32_t current = *current_ptr;
8000b9d6:	57ea                	lw	a5,184(sp)
8000b9d8:	439c                	lw	a5,0(a5)
8000b9da:	db3e                	sw	a5,180(sp)
    current = current | (1 << (irq & 0x1F));
8000b9dc:	57fa                	lw	a5,188(sp)
8000b9de:	8bfd                	and	a5,a5,31
8000b9e0:	4705                	li	a4,1
8000b9e2:	00f717b3          	sll	a5,a4,a5
8000b9e6:	873e                	mv	a4,a5
8000b9e8:	57da                	lw	a5,180(sp)
8000b9ea:	8fd9                	or	a5,a5,a4
8000b9ec:	db3e                	sw	a5,180(sp)
    *current_ptr = current;
8000b9ee:	57ea                	lw	a5,184(sp)
8000b9f0:	575a                	lw	a4,180(sp)
8000b9f2:	c398                	sw	a4,0(a5)
}
8000b9f4:	0001                	nop

8000b9f6 <.LBE118>:
}
8000b9f6:	0001                	nop

8000b9f8 <.LBE116>:

    intc_m_enable_irq_with_priority(IRQn_ESC_SYNC0, 3);
    intc_m_enable_irq_with_priority(IRQn_ESC_SYNC1, 3);
    intc_m_enable_irq_with_priority(IRQn_ESC, 3);
    intc_m_enable_irq_with_priority(IRQn_ESC_RESET, 3);
}
8000b9f8:	0001                	nop
8000b9fa:	6169                	add	sp,sp,208
8000b9fc:	8082                	ret

Disassembly of section .text.HW_EepromReload:

8000b9fe <HW_EepromReload>:

/* In case that pAPPL_EEPROM_Reload is implemented the function
“HW_EepromReload()” is not used.*/
UINT16 HW_EepromReload(void)
{
    return ESC_EEPROM_EMULATION_SUCCESS;
8000b9fe:	4781                	li	a5,0
}
8000ba00:	853e                	mv	a0,a5
8000ba02:	8082                	ret

Disassembly of section .text.gpio_write_pin:

8000ba04 <gpio_write_pin>:
{
8000ba04:	1141                	add	sp,sp,-16
8000ba06:	c62a                	sw	a0,12(sp)
8000ba08:	c42e                	sw	a1,8(sp)
8000ba0a:	87b2                	mv	a5,a2
8000ba0c:	8736                	mv	a4,a3
8000ba0e:	00f103a3          	sb	a5,7(sp)
8000ba12:	87ba                	mv	a5,a4
8000ba14:	00f10323          	sb	a5,6(sp)
    if (high) {
8000ba18:	00614783          	lbu	a5,6(sp)
8000ba1c:	cf91                	beqz	a5,8000ba38 <.L2>
        ptr->DO[port].SET = 1 << pin;
8000ba1e:	00714783          	lbu	a5,7(sp)
8000ba22:	4705                	li	a4,1
8000ba24:	00f717b3          	sll	a5,a4,a5
8000ba28:	86be                	mv	a3,a5
8000ba2a:	4732                	lw	a4,12(sp)
8000ba2c:	47a2                	lw	a5,8(sp)
8000ba2e:	07c1                	add	a5,a5,16 # 2010 <__BOOT_HEADER_segment_size__+0x10>
8000ba30:	0792                	sll	a5,a5,0x4
8000ba32:	97ba                	add	a5,a5,a4
8000ba34:	c3d4                	sw	a3,4(a5)
}
8000ba36:	a829                	j	8000ba50 <.L4>

8000ba38 <.L2>:
        ptr->DO[port].CLEAR = 1 << pin;
8000ba38:	00714783          	lbu	a5,7(sp)
8000ba3c:	4705                	li	a4,1
8000ba3e:	00f717b3          	sll	a5,a4,a5
8000ba42:	86be                	mv	a3,a5
8000ba44:	4732                	lw	a4,12(sp)
8000ba46:	47a2                	lw	a5,8(sp)
8000ba48:	07c1                	add	a5,a5,16
8000ba4a:	0792                	sll	a5,a5,0x4
8000ba4c:	97ba                	add	a5,a5,a4
8000ba4e:	c794                	sw	a3,8(a5)

8000ba50 <.L4>:
}
8000ba50:	0001                	nop
8000ba52:	0141                	add	sp,sp,16
8000ba54:	8082                	ret

Disassembly of section .text.ecat_phy_keep_reset:

8000ba56 <ecat_phy_keep_reset>:
#endif
    board_delay_ms(JL11X1_RESET_WAIT_TIME_MS);
}

void ecat_phy_keep_reset(void)
{
8000ba56:	1141                	add	sp,sp,-16
8000ba58:	c606                	sw	ra,12(sp)
    gpio_write_pin(BOARD_ECAT_PHY0_RESET_GPIO, BOARD_ECAT_PHY0_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY0_RESET_PIN_INDEX, JL11X1_RESET_LEVEL);
8000ba5a:	4681                	li	a3,0
8000ba5c:	4669                	li	a2,26
8000ba5e:	4585                	li	a1,1
8000ba60:	f00d0537          	lui	a0,0xf00d0
8000ba64:	3745                	jal	8000ba04 <gpio_write_pin>
#if BOARD_ECAT_SUPPORT_PORT1
    gpio_write_pin(BOARD_ECAT_PHY1_RESET_GPIO, BOARD_ECAT_PHY1_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY1_RESET_PIN_INDEX, JL11X1_RESET_LEVEL);
8000ba66:	4681                	li	a3,0
8000ba68:	4669                	li	a2,26
8000ba6a:	4585                	li	a1,1
8000ba6c:	f00d0537          	lui	a0,0xf00d0
8000ba70:	3f51                	jal	8000ba04 <gpio_write_pin>
#endif
#if BOARD_ECAT_SUPPORT_PORT2
    gpio_write_pin(BOARD_ECAT_PHY2_RESET_GPIO, BOARD_ECAT_PHY2_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY2_RESET_PIN_INDEX, JL11X1_RESET_LEVEL);
#endif
    board_delay_ms(JL11X1_RESET_HOLD_TIME_MS);
8000ba72:	4505                	li	a0,1
8000ba74:	784060ef          	jal	800121f8 <board_delay_ms>
}
8000ba78:	0001                	nop
8000ba7a:	40b2                	lw	ra,12(sp)
8000ba7c:	0141                	add	sp,sp,16
8000ba7e:	8082                	ret

Disassembly of section .text.flash_read:

8000ba80 <flash_read>:
extern unsigned char aEepromData[]; /* EEPROM data is created in eeprom.h by SSC Tool */

e2p_t ecat_e2p_emulation;

static uint32_t flash_read(uint8_t *buf, uint32_t addr, uint32_t size)
{
8000ba80:	1101                	add	sp,sp,-32
8000ba82:	ce06                	sw	ra,28(sp)
8000ba84:	c62a                	sw	a0,12(sp)
8000ba86:	c42e                	sw	a1,8(sp)
8000ba88:	c232                	sw	a2,4(sp)
    return nor_flash_read(&ecat_e2p_emulation.nor_config, buf, addr, size);
8000ba8a:	4692                	lw	a3,4(sp)
8000ba8c:	4622                	lw	a2,8(sp)
8000ba8e:	45b2                	lw	a1,12(sp)
8000ba90:	c9c18513          	add	a0,gp,-868 # 1209014 <ecat_e2p_emulation+0x1c>
8000ba94:	7fff6097          	auipc	ra,0x7fff6
8000ba98:	ffc080e7          	jalr	-4(ra) # 1a90 <nor_flash_read>
8000ba9c:	87aa                	mv	a5,a0
}
8000ba9e:	853e                	mv	a0,a5
8000baa0:	40f2                	lw	ra,28(sp)
8000baa2:	6105                	add	sp,sp,32
8000baa4:	8082                	ret

Disassembly of section .text.flash_write:

8000baa6 <flash_write>:

static uint32_t flash_write(uint8_t *buf, uint32_t addr, uint32_t size)
{
8000baa6:	1101                	add	sp,sp,-32
8000baa8:	ce06                	sw	ra,28(sp)
8000baaa:	c62a                	sw	a0,12(sp)
8000baac:	c42e                	sw	a1,8(sp)
8000baae:	c232                	sw	a2,4(sp)
    return nor_flash_write(&ecat_e2p_emulation.nor_config, buf, addr, size);
8000bab0:	4692                	lw	a3,4(sp)
8000bab2:	4622                	lw	a2,8(sp)
8000bab4:	45b2                	lw	a1,12(sp)
8000bab6:	c9c18513          	add	a0,gp,-868 # 1209014 <ecat_e2p_emulation+0x1c>
8000baba:	7fff6097          	auipc	ra,0x7fff6
8000babe:	02a080e7          	jalr	42(ra) # 1ae4 <nor_flash_write>
8000bac2:	87aa                	mv	a5,a0
}
8000bac4:	853e                	mv	a0,a5
8000bac6:	40f2                	lw	ra,28(sp)
8000bac8:	6105                	add	sp,sp,32
8000baca:	8082                	ret

Disassembly of section .text.ecat_flash_eeprom_check_configuration_area:

8000bacc <ecat_flash_eeprom_check_configuration_area>:
    return status;
}

/* check EtherCAT Slave Controller Configuration Area is first 8 words(1 word = 2 bytes) */
static hpm_stat_t ecat_flash_eeprom_check_configuration_area(void)
{
8000bacc:	7179                	add	sp,sp,-48
8000bace:	d606                	sw	ra,44(sp)

8000bad0 <.LBB41>:
    hpm_stat_t stat;
    uint16_t config_data[8];
    uint8_t checksum;
    for (uint8_t i = 0; i < 8; i++) {
8000bad0:	00010fa3          	sb	zero,31(sp)
8000bad4:	a80d                	j	8000bb06 <.L13>

8000bad6 <.L16>:
        /* read Configuration Area data from e2p */
        stat = e2p_read(i, EEPROM_WRITE_SIZE, (uint8_t *)&config_data[i]);
8000bad6:	01f14683          	lbu	a3,31(sp)
8000bada:	01f14783          	lbu	a5,31(sp)
8000bade:	0038                	add	a4,sp,8
8000bae0:	0786                	sll	a5,a5,0x1
8000bae2:	97ba                	add	a5,a5,a4
8000bae4:	863e                	mv	a2,a5
8000bae6:	4589                	li	a1,2
8000bae8:	8536                	mv	a0,a3
8000baea:	7fff6097          	auipc	ra,0x7fff6
8000baee:	938080e7          	jalr	-1736(ra) # 1422 <e2p_read>
8000baf2:	cc2a                	sw	a0,24(sp)
        if (stat != E2P_STATUS_OK) {
8000baf4:	47e2                	lw	a5,24(sp)
8000baf6:	c399                	beqz	a5,8000bafc <.L14>
            return status_fail;
8000baf8:	4785                	li	a5,1
8000bafa:	a081                	j	8000bb3a <.L18>

8000bafc <.L14>:
    for (uint8_t i = 0; i < 8; i++) {
8000bafc:	01f14783          	lbu	a5,31(sp)
8000bb00:	0785                	add	a5,a5,1
8000bb02:	00f10fa3          	sb	a5,31(sp)

8000bb06 <.L13>:
8000bb06:	01f14703          	lbu	a4,31(sp)
8000bb0a:	479d                	li	a5,7
8000bb0c:	fce7f5e3          	bgeu	a5,a4,8000bad6 <.L16>

8000bb10 <.LBE41>:
        }
    }

    checksum = ecat_calculate_eeprom_config_data_checksum((uint8_t *)config_data, 14); /* calculate checksum value for word0 - word6 */
8000bb10:	003c                	add	a5,sp,8
8000bb12:	45b9                	li	a1,14
8000bb14:	853e                	mv	a0,a5
8000bb16:	7fff6097          	auipc	ra,0x7fff6
8000bb1a:	ab4080e7          	jalr	-1356(ra) # 15ca <ecat_calculate_eeprom_config_data_checksum>
8000bb1e:	87aa                	mv	a5,a0
8000bb20:	00f10f23          	sb	a5,30(sp)

    /* Low byte contains remainder of division of word 0 to word 6 as unsigned number divided by the polynomial x8+x2+x+1(initial value 0xFF). */
    if (checksum != config_data[7]) {
8000bb24:	01e14783          	lbu	a5,30(sp)
8000bb28:	0807c733          	zext.h	a4,a5
8000bb2c:	01615783          	lhu	a5,22(sp)
8000bb30:	00f70463          	beq	a4,a5,8000bb38 <.L17>
        return status_invalid_argument; /* checksum error */
8000bb34:	4789                	li	a5,2
8000bb36:	a011                	j	8000bb3a <.L18>

8000bb38 <.L17>:
    }

    return status_success;
8000bb38:	4781                	li	a5,0

8000bb3a <.L18>:
}
8000bb3a:	853e                	mv	a0,a5
8000bb3c:	50b2                	lw	ra,44(sp)
8000bb3e:	6145                	add	sp,sp,48
8000bb40:	8082                	ret

Disassembly of section .text.ecat_flash_eeprom_init:

8000bb42 <ecat_flash_eeprom_init>:

hpm_stat_t ecat_flash_eeprom_init(void)
{
8000bb42:	7159                	add	sp,sp,-112
8000bb44:	d686                	sw	ra,108(sp)
    /* initial EEPROM content */
    hpm_stat_t stat;
    uint16_t data, dummy_data = 0xFFFF;
8000bb46:	57fd                	li	a5,-1
8000bb48:	02f11223          	sh	a5,36(sp)
    ecat_e2p_emulation.nor_config.xpi_base = BOARD_APP_XPI_NOR_XPI_BASE;
8000bb4c:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb50:	f3000737          	lui	a4,0xf3000
8000bb54:	cfd8                	sw	a4,28(a5)
    ecat_e2p_emulation.nor_config.base_addr = BOARD_FLASH_BASE_ADDRESS;
8000bb56:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb5a:	80000737          	lui	a4,0x80000
8000bb5e:	d398                	sw	a4,32(a5)
    ecat_e2p_emulation.config.start_addr = ecat_e2p_emulation.nor_config.base_addr + ECAT_EEPROM_FLASH_OFFSET;
8000bb60:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb64:	5398                	lw	a4,32(a5)
8000bb66:	000807b7          	lui	a5,0x80
8000bb6a:	973e                	add	a4,a4,a5
8000bb6c:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb70:	c398                	sw	a4,0(a5)
    ecat_e2p_emulation.config.erase_size = ECAT_EEPROM_FLASH_SECTOR_SIZE;
8000bb72:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb76:	6705                	lui	a4,0x1
8000bb78:	00e79423          	sh	a4,8(a5) # 80008 <__AXI_SRAM_segment_size__+0x40008>
    ecat_e2p_emulation.config.sector_cnt = ECAT_EEPROM_FLASH_SECTOR_CNT;
8000bb7c:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb80:	4741                	li	a4,16
8000bb82:	c3d8                	sw	a4,4(a5)
    ecat_e2p_emulation.config.version = 0x4553; /* 'E' 'S' */
8000bb84:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb88:	6711                	lui	a4,0x4
8000bb8a:	55370713          	add	a4,a4,1363 # 4553 <__HEAPSIZE__+0x553>
8000bb8e:	c7d8                	sw	a4,12(a5)
    ecat_e2p_emulation.nor_config.opt_header = BOARD_APP_XPI_NOR_CFG_OPT_HDR;
8000bb90:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bb94:	fcf90737          	lui	a4,0xfcf90
8000bb98:	0709                	add	a4,a4,2 # fcf90002 <__AHB_SRAM_segment_end__+0xcd88002>
8000bb9a:	d798                	sw	a4,40(a5)
    ecat_e2p_emulation.nor_config.opt0 = BOARD_APP_XPI_NOR_CFG_OPT_OPT0;
8000bb9c:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bba0:	4719                	li	a4,6
8000bba2:	d7d8                	sw	a4,44(a5)
    ecat_e2p_emulation.nor_config.opt1 = BOARD_APP_XPI_NOR_CFG_OPT_OPT1;
8000bba4:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bba8:	6705                	lui	a4,0x1
8000bbaa:	db98                	sw	a4,48(a5)
    ecat_e2p_emulation.config.flash_read = flash_read;
8000bbac:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bbb0:	8000c737          	lui	a4,0x8000c
8000bbb4:	a8070713          	add	a4,a4,-1408 # 8000ba80 <flash_read>
8000bbb8:	cb98                	sw	a4,16(a5)
    ecat_e2p_emulation.config.flash_write = flash_write;
8000bbba:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bbbe:	8000c737          	lui	a4,0x8000c
8000bbc2:	aa670713          	add	a4,a4,-1370 # 8000baa6 <flash_write>
8000bbc6:	cbd8                	sw	a4,20(a5)
    ecat_e2p_emulation.config.flash_erase = flash_erase;
8000bbc8:	c8018793          	add	a5,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bbcc:	80012737          	lui	a4,0x80012
8000bbd0:	cc870713          	add	a4,a4,-824 # 80011cc8 <flash_erase>
8000bbd4:	cf98                	sw	a4,24(a5)
8000bbd6:	47a1                	li	a5,8
8000bbd8:	c2be                	sw	a5,68(sp)

8000bbda <.LBB42>:
    return read_clear_csr(CSR_MSTATUS, mask);
8000bbda:	cc02                	sw	zero,24(sp)
8000bbdc:	4796                	lw	a5,68(sp)
8000bbde:	3007b7f3          	csrrc	a5,mstatus,a5
8000bbe2:	cc3e                	sw	a5,24(sp)
8000bbe4:	47e2                	lw	a5,24(sp)

8000bbe6 <.LBE44>:
8000bbe6:	0001                	nop

8000bbe8 <.LBE42>:

    disable_global_irq(CSR_MSTATUS_MIE_MASK);
    stat = nor_flash_init(&ecat_e2p_emulation.nor_config);
8000bbe8:	c9c18513          	add	a0,gp,-868 # 1209014 <ecat_e2p_emulation+0x1c>
8000bbec:	7fff6097          	auipc	ra,0x7fff6
8000bbf0:	e46080e7          	jalr	-442(ra) # 1a32 <nor_flash_init>
8000bbf4:	ceaa                	sw	a0,92(sp)
8000bbf6:	47a1                	li	a5,8
8000bbf8:	c0be                	sw	a5,64(sp)

8000bbfa <.LBB45>:
    set_csr(CSR_MSTATUS, mask);
8000bbfa:	4786                	lw	a5,64(sp)
8000bbfc:	3007a073          	csrs	mstatus,a5
}
8000bc00:	0001                	nop

8000bc02 <.LBE45>:
    enable_global_irq(CSR_MSTATUS_MIE_MASK);
    if (status_success != stat) {
8000bc02:	47f6                	lw	a5,92(sp)
8000bc04:	c399                	beqz	a5,8000bc0a <.L21>
        return status_fail;
8000bc06:	4785                	li	a5,1
8000bc08:	a4ad                	j	8000be72 <.L47>

8000bc0a <.L21>:
8000bc0a:	47a1                	li	a5,8
8000bc0c:	dc3e                	sw	a5,56(sp)

8000bc0e <.LBB47>:
    return read_clear_csr(CSR_MSTATUS, mask);
8000bc0e:	ce02                	sw	zero,28(sp)
8000bc10:	57e2                	lw	a5,56(sp)
8000bc12:	3007b7f3          	csrrc	a5,mstatus,a5
8000bc16:	ce3e                	sw	a5,28(sp)
8000bc18:	47f2                	lw	a5,28(sp)

8000bc1a <.LBE49>:
8000bc1a:	0001                	nop

8000bc1c <.LBE47>:
    }

    disable_global_irq(CSR_MSTATUS_MIE_MASK);
    stat = e2p_config(&ecat_e2p_emulation);
8000bc1c:	c8018513          	add	a0,gp,-896 # 1208ff8 <ecat_e2p_emulation>
8000bc20:	7fff5097          	auipc	ra,0x7fff5
8000bc24:	2c8080e7          	jalr	712(ra) # ee8 <e2p_config>
8000bc28:	ceaa                	sw	a0,92(sp)
8000bc2a:	47a1                	li	a5,8
8000bc2c:	de3e                	sw	a5,60(sp)

8000bc2e <.LBB50>:
    set_csr(CSR_MSTATUS, mask);
8000bc2e:	57f2                	lw	a5,60(sp)
8000bc30:	3007a073          	csrs	mstatus,a5
}
8000bc34:	0001                	nop

8000bc36 <.LBE50>:
    enable_global_irq(CSR_MSTATUS_MIE_MASK);
    if (E2P_STATUS_OK != stat) {
8000bc36:	47f6                	lw	a5,92(sp)
8000bc38:	c399                	beqz	a5,8000bc3e <.L24>
        return status_fail;
8000bc3a:	4785                	li	a5,1
8000bc3c:	ac1d                	j	8000be72 <.L47>

8000bc3e <.L24>:
    }


    /* If the value of aEepromData is the initial value in weak declaration, it means there is no valid data in aEepromData */
    if ((aEepromData[0] == 0xa5) && (aEepromData[1] == 0xa5) && (aEepromData[2] == 0xa5) && (aEepromData[3] == 0xa5)) {
8000bc3e:	80020793          	add	a5,tp,-2048 # fffff800 <__AHB_SRAM_segment_end__+0xfdf7800>
8000bc42:	0007c703          	lbu	a4,0(a5)
8000bc46:	0a500793          	li	a5,165
8000bc4a:	04f71163          	bne	a4,a5,8000bc8c <.L25>
8000bc4e:	80020793          	add	a5,tp,-2048 # fffff800 <__AHB_SRAM_segment_end__+0xfdf7800>
8000bc52:	0017c703          	lbu	a4,1(a5)
8000bc56:	0a500793          	li	a5,165
8000bc5a:	02f71963          	bne	a4,a5,8000bc8c <.L25>
8000bc5e:	80020793          	add	a5,tp,-2048 # fffff800 <__AHB_SRAM_segment_end__+0xfdf7800>
8000bc62:	0027c703          	lbu	a4,2(a5)
8000bc66:	0a500793          	li	a5,165
8000bc6a:	02f71163          	bne	a4,a5,8000bc8c <.L25>
8000bc6e:	80020793          	add	a5,tp,-2048 # fffff800 <__AHB_SRAM_segment_end__+0xfdf7800>
8000bc72:	0037c703          	lbu	a4,3(a5)
8000bc76:	0a500793          	li	a5,165
8000bc7a:	00f71963          	bne	a4,a5,8000bc8c <.L25>
        printf("No EEPROM content in PROGRAM.\n");
8000bc7e:	800077b7          	lui	a5,0x80007
8000bc82:	29478513          	add	a0,a5,660 # 80007294 <.LC0>
8000bc86:	13a020ef          	jal	8000ddc0 <printf>
8000bc8a:	aaad                	j	8000be04 <.L26>

8000bc8c <.L25>:
    } else {
        bool require_init_eeprom = false;
8000bc8c:	04010da3          	sb	zero,91(sp)
        stat = ecat_flash_eeprom_check_configuration_area();
8000bc90:	3d35                	jal	8000bacc <ecat_flash_eeprom_check_configuration_area>
8000bc92:	ceaa                	sw	a0,92(sp)
        if (status_success == stat) {
8000bc94:	47f6                	lw	a5,92(sp)
8000bc96:	efe9                	bnez	a5,8000bd70 <.L27>

8000bc98 <.LBB53>:
            /* if eeprom configuration data checksum pass, then check Product Code and Revision Number */
#if defined(ECAT_EEPROM_CHECK_PRODUCT_CODE_AND_REVISION) && ECAT_EEPROM_CHECK_PRODUCT_CODE_AND_REVISION
            uint32_t product_code, revision_num;
            uint16_t product_code_low, product_code_high, revision_num_low, revision_num_high;
            stat = e2p_read(ESC_EEPROM_PRODUCT_CODE_WORD_INDEX, EEPROM_WRITE_SIZE, (uint8_t *)&product_code_low);
8000bc98:	01210793          	add	a5,sp,18
8000bc9c:	863e                	mv	a2,a5
8000bc9e:	4589                	li	a1,2
8000bca0:	4529                	li	a0,10
8000bca2:	7fff5097          	auipc	ra,0x7fff5
8000bca6:	780080e7          	jalr	1920(ra) # 1422 <e2p_read>
8000bcaa:	ceaa                	sw	a0,92(sp)
            if (stat != E2P_STATUS_OK) {
8000bcac:	47f6                	lw	a5,92(sp)
8000bcae:	cb89                	beqz	a5,8000bcc0 <.L28>
                printf("Read Product Code in EEPROM failed.\n");
8000bcb0:	800077b7          	lui	a5,0x80007
8000bcb4:	2b478513          	add	a0,a5,692 # 800072b4 <.LC1>
8000bcb8:	108020ef          	jal	8000ddc0 <printf>
                return status_fail;
8000bcbc:	4785                	li	a5,1
8000bcbe:	aa55                	j	8000be72 <.L47>

8000bcc0 <.L28>:
            }

            stat = e2p_read(ESC_EEPROM_PRODUCT_CODE_WORD_INDEX + 1, EEPROM_WRITE_SIZE, (uint8_t *)&product_code_high);
8000bcc0:	081c                	add	a5,sp,16
8000bcc2:	863e                	mv	a2,a5
8000bcc4:	4589                	li	a1,2
8000bcc6:	452d                	li	a0,11
8000bcc8:	7fff5097          	auipc	ra,0x7fff5
8000bccc:	75a080e7          	jalr	1882(ra) # 1422 <e2p_read>
8000bcd0:	ceaa                	sw	a0,92(sp)
            if (stat != E2P_STATUS_OK) {
8000bcd2:	47f6                	lw	a5,92(sp)
8000bcd4:	cb89                	beqz	a5,8000bce6 <.L30>
                printf("Read Product Code in EEPROM failed.\n");
8000bcd6:	800077b7          	lui	a5,0x80007
8000bcda:	2b478513          	add	a0,a5,692 # 800072b4 <.LC1>
8000bcde:	0e2020ef          	jal	8000ddc0 <printf>
                return status_fail;
8000bce2:	4785                	li	a5,1
8000bce4:	a279                	j	8000be72 <.L47>

8000bce6 <.L30>:
            }
            product_code = (uint32_t)product_code_high << 16 | product_code_low;
8000bce6:	01015783          	lhu	a5,16(sp)
8000bcea:	07c2                	sll	a5,a5,0x10
8000bcec:	01215703          	lhu	a4,18(sp)
8000bcf0:	8fd9                	or	a5,a5,a4
8000bcf2:	c6be                	sw	a5,76(sp)

            stat = e2p_read(ESC_EEPROM_REVISION_NUM_WORD_INDEX, EEPROM_WRITE_SIZE, (uint8_t *)&revision_num_low);
8000bcf4:	00e10793          	add	a5,sp,14
8000bcf8:	863e                	mv	a2,a5
8000bcfa:	4589                	li	a1,2
8000bcfc:	4531                	li	a0,12
8000bcfe:	7fff5097          	auipc	ra,0x7fff5
8000bd02:	724080e7          	jalr	1828(ra) # 1422 <e2p_read>
8000bd06:	ceaa                	sw	a0,92(sp)
            if (stat != E2P_STATUS_OK) {
8000bd08:	47f6                	lw	a5,92(sp)
8000bd0a:	cb89                	beqz	a5,8000bd1c <.L31>
                printf("Read Revision Number in EEPROM failed.\n");
8000bd0c:	800077b7          	lui	a5,0x80007
8000bd10:	2dc78513          	add	a0,a5,732 # 800072dc <.LC2>
8000bd14:	0ac020ef          	jal	8000ddc0 <printf>
                return status_fail;
8000bd18:	4785                	li	a5,1
8000bd1a:	aaa1                	j	8000be72 <.L47>

8000bd1c <.L31>:
            }

            stat = e2p_read(ESC_EEPROM_REVISION_NUM_WORD_INDEX + 1, EEPROM_WRITE_SIZE, (uint8_t *)&revision_num_high);
8000bd1c:	007c                	add	a5,sp,12
8000bd1e:	863e                	mv	a2,a5
8000bd20:	4589                	li	a1,2
8000bd22:	4535                	li	a0,13
8000bd24:	7fff5097          	auipc	ra,0x7fff5
8000bd28:	6fe080e7          	jalr	1790(ra) # 1422 <e2p_read>
8000bd2c:	ceaa                	sw	a0,92(sp)
            if (stat != E2P_STATUS_OK) {
8000bd2e:	47f6                	lw	a5,92(sp)
8000bd30:	cb89                	beqz	a5,8000bd42 <.L32>
                printf("Read Revision Number in EEPROM failed.\n");
8000bd32:	800077b7          	lui	a5,0x80007
8000bd36:	2dc78513          	add	a0,a5,732 # 800072dc <.LC2>
8000bd3a:	086020ef          	jal	8000ddc0 <printf>
                return status_fail;
8000bd3e:	4785                	li	a5,1
8000bd40:	aa0d                	j	8000be72 <.L47>

8000bd42 <.L32>:
            }
            revision_num = (uint32_t)revision_num_high << 16 | revision_num_low;
8000bd42:	00c15783          	lhu	a5,12(sp)
8000bd46:	07c2                	sll	a5,a5,0x10
8000bd48:	00e15703          	lhu	a4,14(sp)
8000bd4c:	8fd9                	or	a5,a5,a4
8000bd4e:	c4be                	sw	a5,72(sp)

            /* if Procde Code not match or aEepromData[ESC_EEPROM_REVISION_NUM_WORD_INDEX] > stored revesion, require to update eeprom by aEepromData */
            if ((product_code != ((uint32_t *)aEepromData)[ESC_EEPROM_PRODUCT_CODE_WORD_INDEX / 2]) || (revision_num < ((uint32_t *)aEepromData)[ESC_EEPROM_REVISION_NUM_WORD_INDEX / 2])) {
8000bd50:	81420793          	add	a5,tp,-2028 # fffff814 <__AHB_SRAM_segment_end__+0xfdf7814>
8000bd54:	439c                	lw	a5,0(a5)
8000bd56:	4736                	lw	a4,76(sp)
8000bd58:	00f71863          	bne	a4,a5,8000bd68 <.L33>
8000bd5c:	81820793          	add	a5,tp,-2024 # fffff818 <__AHB_SRAM_segment_end__+0xfdf7818>
8000bd60:	439c                	lw	a5,0(a5)
8000bd62:	4726                	lw	a4,72(sp)
8000bd64:	00f77963          	bgeu	a4,a5,8000bd76 <.L35>

8000bd68 <.L33>:
                require_init_eeprom = true;
8000bd68:	4785                	li	a5,1
8000bd6a:	04f10da3          	sb	a5,91(sp)
8000bd6e:	a021                	j	8000bd76 <.L35>

8000bd70 <.L27>:
            }
#endif
        } else {
            require_init_eeprom = true;
8000bd70:	4785                	li	a5,1
8000bd72:	04f10da3          	sb	a5,91(sp)

8000bd76 <.L35>:
        }

        if (require_init_eeprom) {
8000bd76:	05b14783          	lbu	a5,91(sp)
8000bd7a:	cfbd                	beqz	a5,8000bdf8 <.L36>
            printf("Init EEPROM content.\n");
8000bd7c:	800077b7          	lui	a5,0x80007
8000bd80:	30478513          	add	a0,a5,772 # 80007304 <.LC3>
8000bd84:	03c020ef          	jal	8000ddc0 <printf>
8000bd88:	47a1                	li	a5,8
8000bd8a:	da3e                	sw	a5,52(sp)

8000bd8c <.LBB54>:
    return read_clear_csr(CSR_MSTATUS, mask);
8000bd8c:	ca02                	sw	zero,20(sp)
8000bd8e:	57d2                	lw	a5,52(sp)
8000bd90:	3007b7f3          	csrrc	a5,mstatus,a5
8000bd94:	ca3e                	sw	a5,20(sp)
8000bd96:	47d2                	lw	a5,20(sp)

8000bd98 <.LBE56>:
8000bd98:	0001                	nop

8000bd9a <.LBB57>:
            disable_global_irq(CSR_MSTATUS_MIE_MASK);
            /* init eeprom content */
            for (uint32_t i = 0; i < ESC_EEPROM_SIZE / EEPROM_WRITE_SIZE; i++) {
8000bd9a:	ca82                	sw	zero,84(sp)
8000bd9c:	a825                	j	8000bdd4 <.L38>

8000bd9e <.L40>:
                stat = e2p_write(i, EEPROM_WRITE_SIZE, &aEepromData[2*i]);
8000bd9e:	47d6                	lw	a5,84(sp)
8000bda0:	00179713          	sll	a4,a5,0x1
8000bda4:	80020793          	add	a5,tp,-2048 # fffff800 <__AHB_SRAM_segment_end__+0xfdf7800>
8000bda8:	97ba                	add	a5,a5,a4
8000bdaa:	863e                	mv	a2,a5
8000bdac:	4589                	li	a1,2
8000bdae:	4556                	lw	a0,84(sp)
8000bdb0:	7fff5097          	auipc	ra,0x7fff5
8000bdb4:	61a080e7          	jalr	1562(ra) # 13ca <e2p_write>
8000bdb8:	ceaa                	sw	a0,92(sp)
                if (stat != E2P_STATUS_OK) {
8000bdba:	47f6                	lw	a5,92(sp)
8000bdbc:	cb89                	beqz	a5,8000bdce <.L39>
                    printf("Init EEPROM content failed.\n");
8000bdbe:	800077b7          	lui	a5,0x80007
8000bdc2:	31c78513          	add	a0,a5,796 # 8000731c <.LC4>
8000bdc6:	7fb010ef          	jal	8000ddc0 <printf>
                    return status_fail;
8000bdca:	4785                	li	a5,1
8000bdcc:	a05d                	j	8000be72 <.L47>

8000bdce <.L39>:
            for (uint32_t i = 0; i < ESC_EEPROM_SIZE / EEPROM_WRITE_SIZE; i++) {
8000bdce:	47d6                	lw	a5,84(sp)
8000bdd0:	0785                	add	a5,a5,1
8000bdd2:	cabe                	sw	a5,84(sp)

8000bdd4 <.L38>:
8000bdd4:	4756                	lw	a4,84(sp)
8000bdd6:	3ff00793          	li	a5,1023
8000bdda:	fce7f2e3          	bgeu	a5,a4,8000bd9e <.L40>
8000bdde:	47a1                	li	a5,8
8000bde0:	d83e                	sw	a5,48(sp)

8000bde2 <.LBB58>:
    set_csr(CSR_MSTATUS, mask);
8000bde2:	57c2                	lw	a5,48(sp)
8000bde4:	3007a073          	csrs	mstatus,a5
}
8000bde8:	0001                	nop

8000bdea <.LBE58>:
                }
            }
            enable_global_irq(CSR_MSTATUS_MIE_MASK);
            printf("Init EEPROM content successful.\n");
8000bdea:	800077b7          	lui	a5,0x80007
8000bdee:	33c78513          	add	a0,a5,828 # 8000733c <.LC5>
8000bdf2:	7cf010ef          	jal	8000ddc0 <printf>
8000bdf6:	a039                	j	8000be04 <.L26>

8000bdf8 <.L36>:
        } else {
            printf("No need to init EEPROM content.\n");
8000bdf8:	800077b7          	lui	a5,0x80007
8000bdfc:	36078513          	add	a0,a5,864 # 80007360 <.LC6>
8000be00:	7c1010ef          	jal	8000ddc0 <printf>

8000be04 <.L26>:
8000be04:	47a1                	li	a5,8
8000be06:	d63e                	sw	a5,44(sp)

8000be08 <.LBB60>:
    return read_clear_csr(CSR_MSTATUS, mask);
8000be08:	d002                	sw	zero,32(sp)
8000be0a:	57b2                	lw	a5,44(sp)
8000be0c:	3007b7f3          	csrrc	a5,mstatus,a5
8000be10:	d03e                	sw	a5,32(sp)
8000be12:	5782                	lw	a5,32(sp)

8000be14 <.LBE62>:
8000be14:	0001                	nop

8000be16 <.LBB63>:
        }
    }

    disable_global_irq(CSR_MSTATUS_MIE_MASK);
    for (uint32_t i = 0; i < ESC_EEPROM_SIZE / EEPROM_WRITE_SIZE; i++) {
8000be16:	c882                	sw	zero,80(sp)
8000be18:	a81d                	j	8000be4e <.L42>

8000be1a <.L45>:
        stat = e2p_read(i, EEPROM_WRITE_SIZE, (uint8_t *)&data);
8000be1a:	02610793          	add	a5,sp,38
8000be1e:	863e                	mv	a2,a5
8000be20:	4589                	li	a1,2
8000be22:	4546                	lw	a0,80(sp)
8000be24:	7fff5097          	auipc	ra,0x7fff5
8000be28:	5fe080e7          	jalr	1534(ra) # 1422 <e2p_read>
8000be2c:	ceaa                	sw	a0,92(sp)
        if (stat != E2P_STATUS_OK) {
8000be2e:	47f6                	lw	a5,92(sp)
8000be30:	cf81                	beqz	a5,8000be48 <.L43>
            stat = e2p_write(i, EEPROM_WRITE_SIZE, (uint8_t *)&dummy_data);
8000be32:	105c                	add	a5,sp,36
8000be34:	863e                	mv	a2,a5
8000be36:	4589                	li	a1,2
8000be38:	4546                	lw	a0,80(sp)
8000be3a:	7fff5097          	auipc	ra,0x7fff5
8000be3e:	590080e7          	jalr	1424(ra) # 13ca <e2p_write>
8000be42:	ceaa                	sw	a0,92(sp)
            if (stat != E2P_STATUS_OK) {
8000be44:	47f6                	lw	a5,92(sp)
8000be46:	eb91                	bnez	a5,8000be5a <.L48>

8000be48 <.L43>:
    for (uint32_t i = 0; i < ESC_EEPROM_SIZE / EEPROM_WRITE_SIZE; i++) {
8000be48:	47c6                	lw	a5,80(sp)
8000be4a:	0785                	add	a5,a5,1
8000be4c:	c8be                	sw	a5,80(sp)

8000be4e <.L42>:
8000be4e:	4746                	lw	a4,80(sp)
8000be50:	3ff00793          	li	a5,1023
8000be54:	fce7f3e3          	bgeu	a5,a4,8000be1a <.L45>
8000be58:	a011                	j	8000be5c <.L44>

8000be5a <.L48>:
                break;
8000be5a:	0001                	nop

8000be5c <.L44>:
8000be5c:	47a1                	li	a5,8
8000be5e:	d43e                	sw	a5,40(sp)

8000be60 <.LBB64>:
    set_csr(CSR_MSTATUS, mask);
8000be60:	57a2                	lw	a5,40(sp)
8000be62:	3007a073          	csrs	mstatus,a5
}
8000be66:	0001                	nop

8000be68 <.LBE64>:
            }
        }
    }
    enable_global_irq(CSR_MSTATUS_MIE_MASK);
    if (E2P_STATUS_OK != stat) {
8000be68:	47f6                	lw	a5,92(sp)
8000be6a:	c399                	beqz	a5,8000be70 <.L46>
        return status_fail;
8000be6c:	4785                	li	a5,1
8000be6e:	a011                	j	8000be72 <.L47>

8000be70 <.L46>:
    }

    return status_success;
8000be70:	4781                	li	a5,0

8000be72 <.L47>:
}
8000be72:	853e                	mv	a0,a5
8000be74:	50b6                	lw	ra,108(sp)
8000be76:	6165                	add	sp,sp,112
8000be78:	8082                	ret

Disassembly of section .text.ecat_flash_eeprom_read:

8000be7a <ecat_flash_eeprom_read>:
    }
    return stat;
}

hpm_stat_t ecat_flash_eeprom_read(uint32_t addr, uint8_t *data)
{
8000be7a:	7179                	add	sp,sp,-48
8000be7c:	d606                	sw	ra,44(sp)
8000be7e:	c62a                	sw	a0,12(sp)
8000be80:	c42e                	sw	a1,8(sp)
    hpm_stat_t stat;
    stat = e2p_read(addr, EEPROM_WRITE_SIZE, data);
8000be82:	4622                	lw	a2,8(sp)
8000be84:	4589                	li	a1,2
8000be86:	4532                	lw	a0,12(sp)
8000be88:	7fff5097          	auipc	ra,0x7fff5
8000be8c:	59a080e7          	jalr	1434(ra) # 1422 <e2p_read>
8000be90:	ce2a                	sw	a0,28(sp)
    if (stat == status_success) {
        e2p_info("\n READ success: addr[%d] - val[0x%x]\n", addr, *((uint16_t *)data));
    } else {
        e2p_info("\n READ failed: error code[%d]\n", stat);
    }
    return stat;
8000be92:	47f2                	lw	a5,28(sp)
}
8000be94:	853e                	mv	a0,a5
8000be96:	50b2                	lw	ra,44(sp)
8000be98:	6145                	add	sp,sp,48
8000be9a:	8082                	ret

Disassembly of section .text._clean_up:

8000be9c <_clean_up>:
#define MAIN_ENTRY main
#endif
extern int MAIN_ENTRY(void);

__attribute__((weak)) void _clean_up(void)
{
8000be9c:	7139                	add	sp,sp,-64

8000be9e <.LBB18>:
    clear_csr(CSR_MIE, CSR_MIE_MEIE_MASK);
8000be9e:	28b01793          	bset	a5,zero,0xb
8000bea2:	3047b073          	csrc	mie,a5
}
8000bea6:	0001                	nop
8000bea8:	da02                	sw	zero,52(sp)
8000beaa:	d802                	sw	zero,48(sp)
8000beac:	e40007b7          	lui	a5,0xe4000
8000beb0:	d63e                	sw	a5,44(sp)
8000beb2:	57d2                	lw	a5,52(sp)
8000beb4:	d43e                	sw	a5,40(sp)
8000beb6:	57c2                	lw	a5,48(sp)
8000beb8:	d23e                	sw	a5,36(sp)

8000beba <.LBB20>:
            (target << HPM_PLIC_THRESHOLD_SHIFT_PER_TARGET));
8000beba:	57a2                	lw	a5,40(sp)
8000bebc:	00c79713          	sll	a4,a5,0xc
            HPM_PLIC_THRESHOLD_OFFSET +
8000bec0:	57b2                	lw	a5,44(sp)
8000bec2:	973e                	add	a4,a4,a5
8000bec4:	002007b7          	lui	a5,0x200
8000bec8:	97ba                	add	a5,a5,a4
    volatile uint32_t *threshold_ptr = (volatile uint32_t *)(base +
8000beca:	d03e                	sw	a5,32(sp)
    *threshold_ptr = threshold;
8000becc:	5782                	lw	a5,32(sp)
8000bece:	5712                	lw	a4,36(sp)
8000bed0:	c398                	sw	a4,0(a5)
}
8000bed2:	0001                	nop

8000bed4 <.LBE22>:
 * @param[in] threshold Threshold of IRQ can be serviced
 */
ATTR_ALWAYS_INLINE static inline void intc_set_threshold(uint32_t target, uint32_t threshold)
{
    __plic_set_threshold(HPM_PLIC_BASE, target, threshold);
}
8000bed4:	0001                	nop

8000bed6 <.LBB24>:
    /* clean up plic, it will help while debugging */
    disable_irq_from_intc();
    intc_m_set_threshold(0);
    for (uint32_t irq = 0; irq < 128; irq++) {
8000bed6:	de02                	sw	zero,60(sp)
8000bed8:	a82d                	j	8000bf12 <.L2>

8000beda <.L3>:
8000beda:	ce02                	sw	zero,28(sp)
8000bedc:	57f2                	lw	a5,60(sp)
8000bede:	cc3e                	sw	a5,24(sp)
8000bee0:	e40007b7          	lui	a5,0xe4000
8000bee4:	ca3e                	sw	a5,20(sp)
8000bee6:	47f2                	lw	a5,28(sp)
8000bee8:	c83e                	sw	a5,16(sp)
8000beea:	47e2                	lw	a5,24(sp)
8000beec:	c63e                	sw	a5,12(sp)

8000beee <.LBB25>:
                                                          uint32_t target,
                                                          uint32_t irq)
{
    volatile uint32_t *claim_addr = (volatile uint32_t *)(base +
            HPM_PLIC_CLAIM_OFFSET +
            (target << HPM_PLIC_CLAIM_SHIFT_PER_TARGET));
8000beee:	47c2                	lw	a5,16(sp)
8000bef0:	00c79713          	sll	a4,a5,0xc
            HPM_PLIC_CLAIM_OFFSET +
8000bef4:	47d2                	lw	a5,20(sp)
8000bef6:	973e                	add	a4,a4,a5
8000bef8:	002007b7          	lui	a5,0x200
8000befc:	0791                	add	a5,a5,4 # 200004 <__DLM_segment_start__+0x4>
8000befe:	97ba                	add	a5,a5,a4
    volatile uint32_t *claim_addr = (volatile uint32_t *)(base +
8000bf00:	c43e                	sw	a5,8(sp)
    *claim_addr = irq;
8000bf02:	47a2                	lw	a5,8(sp)
8000bf04:	4732                	lw	a4,12(sp)
8000bf06:	c398                	sw	a4,0(a5)
}
8000bf08:	0001                	nop

8000bf0a <.LBE27>:
 *
 */
ATTR_ALWAYS_INLINE static inline void intc_complete_irq(uint32_t target, uint32_t irq)
{
    __plic_complete_irq(HPM_PLIC_BASE, target, irq);
}
8000bf0a:	0001                	nop

8000bf0c <.LBE25>:
8000bf0c:	57f2                	lw	a5,60(sp)
8000bf0e:	0785                	add	a5,a5,1
8000bf10:	de3e                	sw	a5,60(sp)

8000bf12 <.L2>:
8000bf12:	5772                	lw	a4,60(sp)
8000bf14:	07f00793          	li	a5,127
8000bf18:	fce7f1e3          	bgeu	a5,a4,8000beda <.L3>

8000bf1c <.LBB29>:
        intc_m_complete_irq(irq);
    }
    /* clear any bits left in plic enable register */
    for (uint32_t i = 0; i < 4; i++) {
8000bf1c:	dc02                	sw	zero,56(sp)
8000bf1e:	a821                	j	8000bf36 <.L4>

8000bf20 <.L5>:
        *(volatile uint32_t *)(HPM_PLIC_BASE + HPM_PLIC_ENABLE_OFFSET + (i << 2)) = 0;
8000bf20:	57e2                	lw	a5,56(sp)
8000bf22:	00279713          	sll	a4,a5,0x2
8000bf26:	e40027b7          	lui	a5,0xe4002
8000bf2a:	97ba                	add	a5,a5,a4
8000bf2c:	0007a023          	sw	zero,0(a5) # e4002000 <__FLASH_segment_end__+0x63f02000>
    for (uint32_t i = 0; i < 4; i++) {
8000bf30:	57e2                	lw	a5,56(sp)
8000bf32:	0785                	add	a5,a5,1
8000bf34:	dc3e                	sw	a5,56(sp)

8000bf36 <.L4>:
8000bf36:	5762                	lw	a4,56(sp)
8000bf38:	478d                	li	a5,3
8000bf3a:	fee7f3e3          	bgeu	a5,a4,8000bf20 <.L5>

8000bf3e <.LBE29>:
    }
}
8000bf3e:	0001                	nop
8000bf40:	0001                	nop
8000bf42:	6121                	add	sp,sp,64
8000bf44:	8082                	ret

Disassembly of section .text.syscall_handler:

8000bf46 <syscall_handler>:
__attribute__((weak)) void swi_isr(void)
{
}

__attribute__((weak)) void syscall_handler(long n, long a0, long a1, long a2, long a3)
{
8000bf46:	1101                	add	sp,sp,-32
8000bf48:	ce2a                	sw	a0,28(sp)
8000bf4a:	cc2e                	sw	a1,24(sp)
8000bf4c:	ca32                	sw	a2,20(sp)
8000bf4e:	c836                	sw	a3,16(sp)
8000bf50:	c63a                	sw	a4,12(sp)
    (void) n;
    (void) a0;
    (void) a1;
    (void) a2;
    (void) a3;
}
8000bf52:	0001                	nop
8000bf54:	6105                	add	sp,sp,32
8000bf56:	8082                	ret

Disassembly of section .text.system_init:

8000bf58 <system_init>:
#endif
    __plic_set_feature(HPM_PLIC_BASE, plic_feature);
}

__attribute__((weak)) void system_init(void)
{
8000bf58:	7179                	add	sp,sp,-48
8000bf5a:	d606                	sw	ra,44(sp)

8000bf5c <.LBB16>:
#ifndef CONFIG_NOT_ENALBE_ACCESS_TO_CYCLE_CSR
    uint32_t mcounteren = read_csr(CSR_MCOUNTEREN);
8000bf5c:	306027f3          	csrr	a5,mcounteren
8000bf60:	ce3e                	sw	a5,28(sp)
8000bf62:	47f2                	lw	a5,28(sp)

8000bf64 <.LBE16>:
8000bf64:	cc3e                	sw	a5,24(sp)
    write_csr(CSR_MCOUNTEREN, mcounteren | 1); /* Enable MCYCLE */
8000bf66:	47e2                	lw	a5,24(sp)
8000bf68:	0017e793          	or	a5,a5,1
8000bf6c:	30679073          	csrw	mcounteren,a5
8000bf70:	47a1                	li	a5,8
8000bf72:	c83e                	sw	a5,16(sp)

8000bf74 <.LBB17>:
    return read_clear_csr(CSR_MSTATUS, mask);
8000bf74:	c602                	sw	zero,12(sp)
8000bf76:	47c2                	lw	a5,16(sp)
8000bf78:	3007b7f3          	csrrc	a5,mstatus,a5
8000bf7c:	c63e                	sw	a5,12(sp)
8000bf7e:	47b2                	lw	a5,12(sp)

8000bf80 <.LBE19>:
8000bf80:	0001                	nop

8000bf82 <.LBB20>:
    clear_csr(CSR_MIE, CSR_MIE_MEIE_MASK);
8000bf82:	28b01793          	bset	a5,zero,0xb
8000bf86:	3047b073          	csrc	mie,a5
}
8000bf8a:	0001                	nop

8000bf8c <.LBE20>:
    disable_irq_from_intc();
#ifdef USE_S_MODE_IRQ
    disable_s_irq_from_intc();
#endif

    enable_plic_feature();
8000bf8c:	5ed050ef          	jal	80011d78 <enable_plic_feature>

8000bf90 <.LBB22>:
    set_csr(CSR_MIE, CSR_MIE_MEIE_MASK);
8000bf90:	28b01793          	bset	a5,zero,0xb
8000bf94:	3047a073          	csrs	mie,a5
}
8000bf98:	0001                	nop
8000bf9a:	47a1                	li	a5,8
8000bf9c:	ca3e                	sw	a5,20(sp)

8000bf9e <.LBB24>:
    set_csr(CSR_MSTATUS, mask);
8000bf9e:	47d2                	lw	a5,20(sp)
8000bfa0:	3007a073          	csrs	mstatus,a5
}
8000bfa4:	0001                	nop

8000bfa6 <.LBE24>:
#else
#if !CONFIG_DISABLE_GLOBAL_IRQ_ON_STARTUP
    enable_global_irq(CSR_MSTATUS_MIE_MASK);
#endif
#endif
}
8000bfa6:	0001                	nop
8000bfa8:	50b2                	lw	ra,44(sp)
8000bfaa:	6145                	add	sp,sp,48
8000bfac:	8082                	ret

Disassembly of section .text.sysctl_resource_target_is_busy:

8000bfae <sysctl_resource_target_is_busy>:
 * @param[in] ptr SYSCTL_Type base address
 * @param[in] resource target resource index
 * @return true if target resource is busy
 */
static inline bool sysctl_resource_target_is_busy(SYSCTL_Type *ptr, sysctl_resource_t resource)
{
8000bfae:	1141                	add	sp,sp,-16
8000bfb0:	c62a                	sw	a0,12(sp)
8000bfb2:	87ae                	mv	a5,a1
8000bfb4:	00f11523          	sh	a5,10(sp)
    return ptr->RESOURCE[resource] & SYSCTL_RESOURCE_LOC_BUSY_MASK;
8000bfb8:	00a15783          	lhu	a5,10(sp)
8000bfbc:	4732                	lw	a4,12(sp)
8000bfbe:	078a                	sll	a5,a5,0x2
8000bfc0:	97ba                	add	a5,a5,a4
8000bfc2:	4398                	lw	a4,0(a5)
8000bfc4:	400007b7          	lui	a5,0x40000
8000bfc8:	8ff9                	and	a5,a5,a4
8000bfca:	00f037b3          	snez	a5,a5
8000bfce:	0ff7f793          	zext.b	a5,a5
}
8000bfd2:	853e                	mv	a0,a5
8000bfd4:	0141                	add	sp,sp,16
8000bfd6:	8082                	ret

Disassembly of section .text.sysctl_config_clock:

8000bfd8 <sysctl_config_clock>:
    }
    return status_success;
}

hpm_stat_t sysctl_config_clock(SYSCTL_Type *ptr, clock_node_t node_index, clock_source_t source, uint32_t divide_by)
{
8000bfd8:	7179                	add	sp,sp,-48
8000bfda:	d606                	sw	ra,44(sp)
8000bfdc:	c62a                	sw	a0,12(sp)
8000bfde:	87ae                	mv	a5,a1
8000bfe0:	8732                	mv	a4,a2
8000bfe2:	c236                	sw	a3,4(sp)
8000bfe4:	00f105a3          	sb	a5,11(sp)
8000bfe8:	87ba                	mv	a5,a4
8000bfea:	00f10523          	sb	a5,10(sp)
    uint32_t node = (uint32_t) node_index;
8000bfee:	00b14783          	lbu	a5,11(sp)
8000bff2:	ce3e                	sw	a5,28(sp)
    if (node >= clock_node_adc_start) {
8000bff4:	4772                	lw	a4,28(sp)
8000bff6:	02800793          	li	a5,40
8000bffa:	00e7f463          	bgeu	a5,a4,8000c002 <.L76>
        return status_invalid_argument;
8000bffe:	4789                	li	a5,2
8000c000:	a8b9                	j	8000c05e <.L77>

8000c002 <.L76>:
    }

    if (source >= clock_source_general_source_end) {
8000c002:	00a14703          	lbu	a4,10(sp)
8000c006:	479d                	li	a5,7
8000c008:	00e7f463          	bgeu	a5,a4,8000c010 <.L78>
        return status_invalid_argument;
8000c00c:	4789                	li	a5,2
8000c00e:	a881                	j	8000c05e <.L77>

8000c010 <.L78>:
    }
    ptr->CLOCK[node] = (ptr->CLOCK[node] & ~(SYSCTL_CLOCK_MUX_MASK | SYSCTL_CLOCK_DIV_MASK)) |
8000c010:	4732                	lw	a4,12(sp)
8000c012:	47f2                	lw	a5,28(sp)
8000c014:	60078793          	add	a5,a5,1536 # 40000600 <__AXI_SRAM_segment_end__+0x3edc0600>
8000c018:	078a                	sll	a5,a5,0x2
8000c01a:	97ba                	add	a5,a5,a4
8000c01c:	439c                	lw	a5,0(a5)
8000c01e:	8007f713          	and	a4,a5,-2048
        (SYSCTL_CLOCK_MUX_SET(source) | SYSCTL_CLOCK_DIV_SET(divide_by - 1));
8000c022:	00a14783          	lbu	a5,10(sp)
8000c026:	07a2                	sll	a5,a5,0x8
8000c028:	7007f693          	and	a3,a5,1792
8000c02c:	4792                	lw	a5,4(sp)
8000c02e:	17fd                	add	a5,a5,-1
8000c030:	0ff7f793          	zext.b	a5,a5
8000c034:	8fd5                	or	a5,a5,a3
    ptr->CLOCK[node] = (ptr->CLOCK[node] & ~(SYSCTL_CLOCK_MUX_MASK | SYSCTL_CLOCK_DIV_MASK)) |
8000c036:	8f5d                	or	a4,a4,a5
8000c038:	46b2                	lw	a3,12(sp)
8000c03a:	47f2                	lw	a5,28(sp)
8000c03c:	60078793          	add	a5,a5,1536
8000c040:	078a                	sll	a5,a5,0x2
8000c042:	97b6                	add	a5,a5,a3
8000c044:	c398                	sw	a4,0(a5)
    while (sysctl_clock_target_is_busy(ptr, node)) {
8000c046:	0001                	nop

8000c048 <.L79>:
8000c048:	45f2                	lw	a1,28(sp)
8000c04a:	4532                	lw	a0,12(sp)
8000c04c:	559050ef          	jal	80011da4 <sysctl_clock_target_is_busy>
8000c050:	87aa                	mv	a5,a0
8000c052:	fbfd                	bnez	a5,8000c048 <.L79>
    }
    if (node == clock_node_cpu0) {
8000c054:	47f2                	lw	a5,28(sp)
8000c056:	e399                	bnez	a5,8000c05c <.L80>
        clock_update_core_clock();
8000c058:	783050ef          	jal	80011fda <clock_update_core_clock>

8000c05c <.L80>:
    }
    return status_success;
8000c05c:	4781                	li	a5,0

8000c05e <.L77>:
}
8000c05e:	853e                	mv	a0,a5
8000c060:	50b2                	lw	ra,44(sp)
8000c062:	6145                	add	sp,sp,48
8000c064:	8082                	ret

Disassembly of section .text.hpm_csr_get_core_cycle:

8000c066 <hpm_csr_get_core_cycle>:
 *          - in user mode if the device supports M/U mode
 *
 * @return CSR cycle value in 64-bit
 */
static inline uint64_t hpm_csr_get_core_cycle(void)
{
8000c066:	7179                	add	sp,sp,-48

8000c068 <.LBB2>:
    uint64_t result;
    uint32_t resultl_first = read_csr(CSR_CYCLE);
8000c068:	c0002f73          	rdcycle	t5
8000c06c:	d27a                	sw	t5,36(sp)
8000c06e:	5f12                	lw	t5,36(sp)

8000c070 <.LBE2>:
8000c070:	d07a                	sw	t5,32(sp)

8000c072 <.LBB3>:
    uint32_t resulth = read_csr(CSR_CYCLEH);
8000c072:	c8002f73          	rdcycleh	t5
8000c076:	ce7a                	sw	t5,28(sp)
8000c078:	4f72                	lw	t5,28(sp)

8000c07a <.LBE3>:
8000c07a:	cc7a                	sw	t5,24(sp)

8000c07c <.LBB4>:
    uint32_t resultl_second = read_csr(CSR_CYCLE);
8000c07c:	c0002f73          	rdcycle	t5
8000c080:	ca7a                	sw	t5,20(sp)
8000c082:	4f52                	lw	t5,20(sp)

8000c084 <.LBE4>:
8000c084:	c87a                	sw	t5,16(sp)
    if (resultl_first < resultl_second) {
8000c086:	5f82                	lw	t6,32(sp)
8000c088:	4f42                	lw	t5,16(sp)
8000c08a:	03eff263          	bgeu	t6,t5,8000c0ae <.L2>
        result = ((uint64_t)resulth << 32) | resultl_first; /* if CYCLE didn't roll over, return the value directly */
8000c08e:	47e2                	lw	a5,24(sp)
8000c090:	8e3e                	mv	t3,a5
8000c092:	4e81                	li	t4,0
8000c094:	000e1693          	sll	a3,t3,0x0
8000c098:	4601                	li	a2,0
8000c09a:	5782                	lw	a5,32(sp)
8000c09c:	883e                	mv	a6,a5
8000c09e:	4881                	li	a7,0
8000c0a0:	010667b3          	or	a5,a2,a6
8000c0a4:	d43e                	sw	a5,40(sp)
8000c0a6:	0116e7b3          	or	a5,a3,a7
8000c0aa:	d63e                	sw	a5,44(sp)
8000c0ac:	a025                	j	8000c0d4 <.L3>

8000c0ae <.L2>:
    } else {
        resulth = read_csr(CSR_CYCLEH);
8000c0ae:	c80026f3          	rdcycleh	a3
8000c0b2:	c636                	sw	a3,12(sp)
8000c0b4:	46b2                	lw	a3,12(sp)

8000c0b6 <.LBE5>:
8000c0b6:	cc36                	sw	a3,24(sp)
        result = ((uint64_t)resulth << 32) | resultl_second; /* if CYCLE rolled over, need to get the CYCLEH again */
8000c0b8:	46e2                	lw	a3,24(sp)
8000c0ba:	8336                	mv	t1,a3
8000c0bc:	4381                	li	t2,0
8000c0be:	00031793          	sll	a5,t1,0x0
8000c0c2:	4701                	li	a4,0
8000c0c4:	46c2                	lw	a3,16(sp)
8000c0c6:	8536                	mv	a0,a3
8000c0c8:	4581                	li	a1,0
8000c0ca:	00a766b3          	or	a3,a4,a0
8000c0ce:	d436                	sw	a3,40(sp)
8000c0d0:	8fcd                	or	a5,a5,a1
8000c0d2:	d63e                	sw	a5,44(sp)

8000c0d4 <.L3>:
    }
    return result;
8000c0d4:	5722                	lw	a4,40(sp)
8000c0d6:	57b2                	lw	a5,44(sp)
 }
8000c0d8:	853a                	mv	a0,a4
8000c0da:	85be                	mv	a1,a5
8000c0dc:	6145                	add	sp,sp,48
8000c0de:	8082                	ret

Disassembly of section .text.clock_get_frequency:

8000c0e0 <clock_get_frequency>:

/***********************************************************************************************************************
 * Codes
 **********************************************************************************************************************/
uint32_t clock_get_frequency(clock_name_t clock_name)
{
8000c0e0:	7179                	add	sp,sp,-48
8000c0e2:	d606                	sw	ra,44(sp)
8000c0e4:	c62a                	sw	a0,12(sp)
    uint32_t clk_freq = 0UL;
8000c0e6:	ce02                	sw	zero,28(sp)
    uint32_t clk_src_type = GET_CLK_SRC_GROUP_FROM_NAME(clock_name);
8000c0e8:	47b2                	lw	a5,12(sp)
8000c0ea:	83a1                	srl	a5,a5,0x8
8000c0ec:	0ff7f793          	zext.b	a5,a5
8000c0f0:	cc3e                	sw	a5,24(sp)
    uint32_t node_or_instance = GET_CLK_NODE_FROM_NAME(clock_name);
8000c0f2:	47b2                	lw	a5,12(sp)
8000c0f4:	0ff7f793          	zext.b	a5,a5
8000c0f8:	ca3e                	sw	a5,20(sp)
    switch (clk_src_type) {
8000c0fa:	4762                	lw	a4,24(sp)
8000c0fc:	47a9                	li	a5,10
8000c0fe:	08e7e263          	bltu	a5,a4,8000c182 <.L16>
8000c102:	47e2                	lw	a5,24(sp)
8000c104:	00279713          	sll	a4,a5,0x2
8000c108:	800057b7          	lui	a5,0x80005
8000c10c:	14478793          	add	a5,a5,324 # 80005144 <.L18>
8000c110:	97ba                	add	a5,a5,a4
8000c112:	439c                	lw	a5,0(a5)
8000c114:	8782                	jr	a5

8000c116 <.L28>:
    case CLK_SRC_GROUP_COMMON:
        clk_freq = get_frequency_for_ip_in_common_group((clock_node_t) node_or_instance);
8000c116:	47d2                	lw	a5,20(sp)
8000c118:	0ff7f793          	zext.b	a5,a5
8000c11c:	853e                	mv	a0,a5
8000c11e:	2215                	jal	8000c242 <get_frequency_for_ip_in_common_group>
8000c120:	ce2a                	sw	a0,28(sp)
        break;
8000c122:	a095                	j	8000c186 <.L29>

8000c124 <.L27>:
    case CLK_SRC_GROUP_ADC:
        clk_freq = get_frequency_for_adc(node_or_instance);
8000c124:	4552                	lw	a0,20(sp)
8000c126:	56b050ef          	jal	80011e90 <get_frequency_for_adc>
8000c12a:	ce2a                	sw	a0,28(sp)
        break;
8000c12c:	a8a9                	j	8000c186 <.L29>

8000c12e <.L26>:
    case CLK_SRC_GROUP_EWDG:
        clk_freq = get_frequency_for_ewdg(node_or_instance);
8000c12e:	4552                	lw	a0,20(sp)
8000c130:	5f5050ef          	jal	80011f24 <get_frequency_for_ewdg>
8000c134:	ce2a                	sw	a0,28(sp)
        break;
8000c136:	a881                	j	8000c186 <.L29>

8000c138 <.L20>:
    case CLK_SRC_GROUP_PEWDG:
        clk_freq = get_frequency_for_pewdg();
8000c138:	625050ef          	jal	80011f5c <get_frequency_for_pewdg>
8000c13c:	ce2a                	sw	a0,28(sp)
        break;
8000c13e:	a0a1                	j	8000c186 <.L29>

8000c140 <.L21>:
    case CLK_SRC_GROUP_PMIC:
        clk_freq = FREQ_PRESET1_OSC0_CLK0;
8000c140:	016e37b7          	lui	a5,0x16e3
8000c144:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
8000c148:	ce3e                	sw	a5,28(sp)
        break;
8000c14a:	a835                	j	8000c186 <.L29>

8000c14c <.L25>:
    case CLK_SRC_GROUP_AHB:
        clk_freq = get_frequency_for_ip_in_common_group(clock_node_ahb0);
8000c14c:	4509                	li	a0,2
8000c14e:	28d5                	jal	8000c242 <get_frequency_for_ip_in_common_group>
8000c150:	ce2a                	sw	a0,28(sp)
        break;
8000c152:	a815                	j	8000c186 <.L29>

8000c154 <.L24>:
    case CLK_SRC_GROUP_AXIF:
        clk_freq = get_frequency_for_ip_in_common_group(clock_node_axif);
8000c154:	450d                	li	a0,3
8000c156:	20f5                	jal	8000c242 <get_frequency_for_ip_in_common_group>
8000c158:	ce2a                	sw	a0,28(sp)
        break;
8000c15a:	a035                	j	8000c186 <.L29>

8000c15c <.L23>:
    case CLK_SRC_GROUP_AXIS:
        clk_freq = get_frequency_for_ip_in_common_group(clock_node_axis);
8000c15c:	4511                	li	a0,4
8000c15e:	20d5                	jal	8000c242 <get_frequency_for_ip_in_common_group>
8000c160:	ce2a                	sw	a0,28(sp)
        break;
8000c162:	a015                	j	8000c186 <.L29>

8000c164 <.L22>:
    case CLK_SRC_GROUP_AXIC:
        clk_freq = get_frequency_for_ip_in_common_group(clock_node_axic);
8000c164:	4515                	li	a0,5
8000c166:	28f1                	jal	8000c242 <get_frequency_for_ip_in_common_group>
8000c168:	ce2a                	sw	a0,28(sp)
        break;
8000c16a:	a831                	j	8000c186 <.L29>

8000c16c <.L19>:
    case CLK_SRC_GROUP_CPU0:
        clk_freq = get_frequency_for_ip_in_common_group(clock_node_cpu0);
8000c16c:	4501                	li	a0,0
8000c16e:	28d1                	jal	8000c242 <get_frequency_for_ip_in_common_group>
8000c170:	ce2a                	sw	a0,28(sp)
        break;
8000c172:	a811                	j	8000c186 <.L29>

8000c174 <.L17>:
    case CLK_SRC_GROUP_SRC:
        clk_freq = get_frequency_for_source((clock_source_t) node_or_instance);
8000c174:	47d2                	lw	a5,20(sp)
8000c176:	0ff7f793          	zext.b	a5,a5
8000c17a:	853e                	mv	a0,a5
8000c17c:	2811                	jal	8000c190 <.LFE128>
8000c17e:	ce2a                	sw	a0,28(sp)
        break;
8000c180:	a019                	j	8000c186 <.L29>

8000c182 <.L16>:
    default:
        clk_freq = 0UL;
8000c182:	ce02                	sw	zero,28(sp)
        break;
8000c184:	0001                	nop

8000c186 <.L29>:
    }
    return clk_freq;
8000c186:	47f2                	lw	a5,28(sp)
}
8000c188:	853e                	mv	a0,a5
8000c18a:	50b2                	lw	ra,44(sp)
8000c18c:	6145                	add	sp,sp,48
8000c18e:	8082                	ret

Disassembly of section .text.get_frequency_for_source:

8000c190 <get_frequency_for_source>:

uint32_t get_frequency_for_source(clock_source_t source)
{
8000c190:	7179                	add	sp,sp,-48
8000c192:	d606                	sw	ra,44(sp)
8000c194:	87aa                	mv	a5,a0
8000c196:	00f107a3          	sb	a5,15(sp)
    uint32_t clk_freq = 0UL;
8000c19a:	ce02                	sw	zero,28(sp)
    switch (source) {
8000c19c:	00f14783          	lbu	a5,15(sp)
8000c1a0:	471d                	li	a4,7
8000c1a2:	08f76963          	bltu	a4,a5,8000c234 <.L32>
8000c1a6:	00279713          	sll	a4,a5,0x2
8000c1aa:	800057b7          	lui	a5,0x80005
8000c1ae:	17078793          	add	a5,a5,368 # 80005170 <.L34>
8000c1b2:	97ba                	add	a5,a5,a4
8000c1b4:	439c                	lw	a5,0(a5)
8000c1b6:	8782                	jr	a5

8000c1b8 <.L41>:
    case clock_source_osc0_clk0:
        clk_freq = FREQ_PRESET1_OSC0_CLK0;
8000c1b8:	016e37b7          	lui	a5,0x16e3
8000c1bc:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
8000c1c0:	ce3e                	sw	a5,28(sp)
        break;
8000c1c2:	a89d                	j	8000c238 <.L42>

8000c1c4 <.L40>:
    case clock_source_pll0_clk0:
        clk_freq = pllctlv2_get_pll_postdiv_freq_in_hz(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk0);
8000c1c4:	4601                	li	a2,0
8000c1c6:	4581                	li	a1,0
8000c1c8:	f40c0537          	lui	a0,0xf40c0
8000c1cc:	3d3060ef          	jal	80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>
8000c1d0:	ce2a                	sw	a0,28(sp)
        break;
8000c1d2:	a09d                	j	8000c238 <.L42>

8000c1d4 <.L39>:
    case clock_source_pll0_clk1:
        clk_freq = pllctlv2_get_pll_postdiv_freq_in_hz(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk1);
8000c1d4:	4605                	li	a2,1
8000c1d6:	4581                	li	a1,0
8000c1d8:	f40c0537          	lui	a0,0xf40c0
8000c1dc:	3c3060ef          	jal	80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>
8000c1e0:	ce2a                	sw	a0,28(sp)
        break;
8000c1e2:	a899                	j	8000c238 <.L42>

8000c1e4 <.L38>:
    case clock_source_pll1_clk0:
        clk_freq = pllctlv2_get_pll_postdiv_freq_in_hz(HPM_PLLCTLV2, pllctlv2_pll1, pllctlv2_clk0);
8000c1e4:	4601                	li	a2,0
8000c1e6:	4585                	li	a1,1
8000c1e8:	f40c0537          	lui	a0,0xf40c0
8000c1ec:	3b3060ef          	jal	80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>
8000c1f0:	ce2a                	sw	a0,28(sp)
        break;
8000c1f2:	a099                	j	8000c238 <.L42>

8000c1f4 <.L37>:
    case clock_source_pll1_clk1:
        clk_freq = pllctlv2_get_pll_postdiv_freq_in_hz(HPM_PLLCTLV2, pllctlv2_pll1, pllctlv2_clk1);
8000c1f4:	4605                	li	a2,1
8000c1f6:	4585                	li	a1,1
8000c1f8:	f40c0537          	lui	a0,0xf40c0
8000c1fc:	3a3060ef          	jal	80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>
8000c200:	ce2a                	sw	a0,28(sp)
        break;
8000c202:	a81d                	j	8000c238 <.L42>

8000c204 <.L36>:
    case clock_source_pll1_clk2:
        clk_freq = pllctlv2_get_pll_postdiv_freq_in_hz(HPM_PLLCTLV2, pllctlv2_pll1, pllctlv2_clk2);
8000c204:	4609                	li	a2,2
8000c206:	4585                	li	a1,1
8000c208:	f40c0537          	lui	a0,0xf40c0
8000c20c:	393060ef          	jal	80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>
8000c210:	ce2a                	sw	a0,28(sp)
        break;
8000c212:	a01d                	j	8000c238 <.L42>

8000c214 <.L35>:
    case clock_source_pll2_clk0:
        clk_freq = pllctlv2_get_pll_postdiv_freq_in_hz(HPM_PLLCTLV2, pllctlv2_pll2, pllctlv2_clk0);
8000c214:	4601                	li	a2,0
8000c216:	4589                	li	a1,2
8000c218:	f40c0537          	lui	a0,0xf40c0
8000c21c:	383060ef          	jal	80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>
8000c220:	ce2a                	sw	a0,28(sp)
        break;
8000c222:	a819                	j	8000c238 <.L42>

8000c224 <.L33>:
    case clock_source_pll2_clk1:
        clk_freq = pllctlv2_get_pll_postdiv_freq_in_hz(HPM_PLLCTLV2, pllctlv2_pll2, pllctlv2_clk1);
8000c224:	4605                	li	a2,1
8000c226:	4589                	li	a1,2
8000c228:	f40c0537          	lui	a0,0xf40c0
8000c22c:	373060ef          	jal	80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>
8000c230:	ce2a                	sw	a0,28(sp)
        break;
8000c232:	a019                	j	8000c238 <.L42>

8000c234 <.L32>:
    default:
        clk_freq = 0UL;
8000c234:	ce02                	sw	zero,28(sp)
        break;
8000c236:	0001                	nop

8000c238 <.L42>:
    }

    return clk_freq;
8000c238:	47f2                	lw	a5,28(sp)
}
8000c23a:	853e                	mv	a0,a5
8000c23c:	50b2                	lw	ra,44(sp)
8000c23e:	6145                	add	sp,sp,48
8000c240:	8082                	ret

Disassembly of section .text.get_frequency_for_ip_in_common_group:

8000c242 <get_frequency_for_ip_in_common_group>:

static uint32_t get_frequency_for_ip_in_common_group(clock_node_t node)
{
8000c242:	7139                	add	sp,sp,-64
8000c244:	de06                	sw	ra,60(sp)
8000c246:	87aa                	mv	a5,a0
8000c248:	00f107a3          	sb	a5,15(sp)
    uint32_t clk_freq = 0UL;
8000c24c:	d602                	sw	zero,44(sp)
    uint32_t node_or_instance = GET_CLK_NODE_FROM_NAME(node);
8000c24e:	00f14783          	lbu	a5,15(sp)
8000c252:	d43e                	sw	a5,40(sp)

    if (node_or_instance < clock_node_end) {
8000c254:	5722                	lw	a4,40(sp)
8000c256:	02a00793          	li	a5,42
8000c25a:	04e7e563          	bltu	a5,a4,8000c2a4 <.L45>

8000c25e <.LBB6>:
        uint32_t clk_node = (uint32_t) node_or_instance;
8000c25e:	57a2                	lw	a5,40(sp)
8000c260:	d23e                	sw	a5,36(sp)

        uint32_t clk_div = 1UL + SYSCTL_CLOCK_DIV_GET(HPM_SYSCTL->CLOCK[clk_node]);
8000c262:	f4000737          	lui	a4,0xf4000
8000c266:	5792                	lw	a5,36(sp)
8000c268:	60078793          	add	a5,a5,1536
8000c26c:	078a                	sll	a5,a5,0x2
8000c26e:	97ba                	add	a5,a5,a4
8000c270:	439c                	lw	a5,0(a5)
8000c272:	0ff7f793          	zext.b	a5,a5
8000c276:	0785                	add	a5,a5,1
8000c278:	d03e                	sw	a5,32(sp)
        clock_source_t clk_mux = (clock_source_t) SYSCTL_CLOCK_MUX_GET(HPM_SYSCTL->CLOCK[clk_node]);
8000c27a:	f4000737          	lui	a4,0xf4000
8000c27e:	5792                	lw	a5,36(sp)
8000c280:	60078793          	add	a5,a5,1536
8000c284:	078a                	sll	a5,a5,0x2
8000c286:	97ba                	add	a5,a5,a4
8000c288:	439c                	lw	a5,0(a5)
8000c28a:	83a1                	srl	a5,a5,0x8
8000c28c:	8b9d                	and	a5,a5,7
8000c28e:	00f10fa3          	sb	a5,31(sp)
        clk_freq = get_frequency_for_source(clk_mux) / clk_div;
8000c292:	01f14783          	lbu	a5,31(sp)
8000c296:	853e                	mv	a0,a5
8000c298:	3de5                	jal	8000c190 <get_frequency_for_source>
8000c29a:	872a                	mv	a4,a0
8000c29c:	5782                	lw	a5,32(sp)
8000c29e:	02f757b3          	divu	a5,a4,a5
8000c2a2:	d63e                	sw	a5,44(sp)

8000c2a4 <.L45>:
    }
    return clk_freq;
8000c2a4:	57b2                	lw	a5,44(sp)
}
8000c2a6:	853e                	mv	a0,a5
8000c2a8:	50f2                	lw	ra,60(sp)
8000c2aa:	6121                	add	sp,sp,64
8000c2ac:	8082                	ret

Disassembly of section .text.clock_set_source_divider:

8000c2ae <clock_set_source_divider>:
    }
    return status_success;
}

hpm_stat_t clock_set_source_divider(clock_name_t clock_name, clk_src_t src, uint32_t div)
{
8000c2ae:	7179                	add	sp,sp,-48
8000c2b0:	d606                	sw	ra,44(sp)
8000c2b2:	c62a                	sw	a0,12(sp)
8000c2b4:	87ae                	mv	a5,a1
8000c2b6:	c232                	sw	a2,4(sp)
8000c2b8:	00f105a3          	sb	a5,11(sp)
    hpm_stat_t status = status_success;
8000c2bc:	ce02                	sw	zero,28(sp)
    uint32_t clk_src_type = GET_CLK_SRC_GROUP_FROM_NAME(clock_name);
8000c2be:	47b2                	lw	a5,12(sp)
8000c2c0:	83a1                	srl	a5,a5,0x8
8000c2c2:	0ff7f793          	zext.b	a5,a5
8000c2c6:	cc3e                	sw	a5,24(sp)
    uint32_t node_or_instance = GET_CLK_NODE_FROM_NAME(clock_name);
8000c2c8:	47b2                	lw	a5,12(sp)
8000c2ca:	0ff7f793          	zext.b	a5,a5
8000c2ce:	ca3e                	sw	a5,20(sp)
    switch (clk_src_type) {
8000c2d0:	4762                	lw	a4,24(sp)
8000c2d2:	47a9                	li	a5,10
8000c2d4:	08e7e763          	bltu	a5,a4,8000c362 <.L111>
8000c2d8:	47e2                	lw	a5,24(sp)
8000c2da:	00279713          	sll	a4,a5,0x2
8000c2de:	800057b7          	lui	a5,0x80005
8000c2e2:	19078793          	add	a5,a5,400 # 80005190 <.L113>
8000c2e6:	97ba                	add	a5,a5,a4
8000c2e8:	439c                	lw	a5,0(a5)
8000c2ea:	8782                	jr	a5

8000c2ec <.L119>:
    case CLK_SRC_GROUP_COMMON:
        if ((div < 1U) || (div > 256U)) {
8000c2ec:	4792                	lw	a5,4(sp)
8000c2ee:	c791                	beqz	a5,8000c2fa <.L120>
8000c2f0:	4712                	lw	a4,4(sp)
8000c2f2:	10000793          	li	a5,256
8000c2f6:	00e7f763          	bgeu	a5,a4,8000c304 <.L121>

8000c2fa <.L120>:
            status = status_clk_div_invalid;
8000c2fa:	6795                	lui	a5,0x5
8000c2fc:	5f078793          	add	a5,a5,1520 # 55f0 <__HEAPSIZE__+0x15f0>
8000c300:	ce3e                	sw	a5,28(sp)
        } else {
            clock_source_t source = GET_CLOCK_SOURCE_FROM_CLK_SRC(src);
            sysctl_config_clock(HPM_SYSCTL, (clock_node_t) node_or_instance, source, div);
        }
        break;
8000c302:	a0ad                	j	8000c36c <.L123>

8000c304 <.L121>:
            clock_source_t source = GET_CLOCK_SOURCE_FROM_CLK_SRC(src);
8000c304:	00b14783          	lbu	a5,11(sp)
8000c308:	8bbd                	and	a5,a5,15
8000c30a:	00f109a3          	sb	a5,19(sp)
            sysctl_config_clock(HPM_SYSCTL, (clock_node_t) node_or_instance, source, div);
8000c30e:	47d2                	lw	a5,20(sp)
8000c310:	0ff7f793          	zext.b	a5,a5
8000c314:	01314703          	lbu	a4,19(sp)
8000c318:	4692                	lw	a3,4(sp)
8000c31a:	863a                	mv	a2,a4
8000c31c:	85be                	mv	a1,a5
8000c31e:	f4000537          	lui	a0,0xf4000
8000c322:	395d                	jal	8000bfd8 <sysctl_config_clock>

8000c324 <.LBE12>:
        break;
8000c324:	a0a1                	j	8000c36c <.L123>

8000c326 <.L112>:
    case CLK_SRC_GROUP_ADC:
    case CLK_SRC_GROUP_EWDG:
    case CLK_SRC_GROUP_PEWDG:
    case CLK_SRC_GROUP_SRC:
        status = status_clk_operation_unsupported;
8000c326:	6795                	lui	a5,0x5
8000c328:	5f378793          	add	a5,a5,1523 # 55f3 <__HEAPSIZE__+0x15f3>
8000c32c:	ce3e                	sw	a5,28(sp)
        break;
8000c32e:	a83d                	j	8000c36c <.L123>

8000c330 <.L115>:
    case CLK_SRC_GROUP_PMIC:
        status = status_clk_fixed;
8000c330:	6795                	lui	a5,0x5
8000c332:	5f978793          	add	a5,a5,1529 # 55f9 <__HEAPSIZE__+0x15f9>
8000c336:	ce3e                	sw	a5,28(sp)
        break;
8000c338:	a815                	j	8000c36c <.L123>

8000c33a <.L118>:
    case CLK_SRC_GROUP_AHB:
        status = status_clk_shared_ahb;
8000c33a:	6795                	lui	a5,0x5
8000c33c:	5f478793          	add	a5,a5,1524 # 55f4 <__HEAPSIZE__+0x15f4>
8000c340:	ce3e                	sw	a5,28(sp)
        break;
8000c342:	a02d                	j	8000c36c <.L123>

8000c344 <.L117>:
    case CLK_SRC_GROUP_AXIF:
        status = status_clk_shared_axif;
8000c344:	6795                	lui	a5,0x5
8000c346:	5f578793          	add	a5,a5,1525 # 55f5 <__HEAPSIZE__+0x15f5>
8000c34a:	ce3e                	sw	a5,28(sp)
        break;
8000c34c:	a005                	j	8000c36c <.L123>

8000c34e <.L116>:
    case CLK_SRC_GROUP_AXIC:
        status = status_clk_shared_axic;
8000c34e:	6795                	lui	a5,0x5
8000c350:	5f778793          	add	a5,a5,1527 # 55f7 <__HEAPSIZE__+0x15f7>
8000c354:	ce3e                	sw	a5,28(sp)
        break;
8000c356:	a819                	j	8000c36c <.L123>

8000c358 <.L114>:
    case CLK_SRC_GROUP_CPU0:
        status = status_clk_shared_cpu0;
8000c358:	6795                	lui	a5,0x5
8000c35a:	5f878793          	add	a5,a5,1528 # 55f8 <__HEAPSIZE__+0x15f8>
8000c35e:	ce3e                	sw	a5,28(sp)
        break;
8000c360:	a031                	j	8000c36c <.L123>

8000c362 <.L111>:
    default:
        status = status_clk_src_invalid;
8000c362:	6795                	lui	a5,0x5
8000c364:	5f178793          	add	a5,a5,1521 # 55f1 <__HEAPSIZE__+0x15f1>
8000c368:	ce3e                	sw	a5,28(sp)
        break;
8000c36a:	0001                	nop

8000c36c <.L123>:
    }

    return status;
8000c36c:	47f2                	lw	a5,28(sp)
}
8000c36e:	853e                	mv	a0,a5
8000c370:	50b2                	lw	ra,44(sp)
8000c372:	6145                	add	sp,sp,48
8000c374:	8082                	ret

Disassembly of section .text.clock_add_to_group:

8000c376 <clock_add_to_group>:
{
    switch_ip_clock(clock_name, CLOCK_OFF);
}

void clock_add_to_group(clock_name_t clock_name, uint32_t group)
{
8000c376:	7179                	add	sp,sp,-48
8000c378:	d606                	sw	ra,44(sp)
8000c37a:	c62a                	sw	a0,12(sp)
8000c37c:	c42e                	sw	a1,8(sp)
    uint32_t resource = GET_CLK_RESOURCE_FROM_NAME(clock_name);
8000c37e:	47b2                	lw	a5,12(sp)
8000c380:	83c1                	srl	a5,a5,0x10
8000c382:	ce3e                	sw	a5,28(sp)

    if (resource < sysctl_resource_end) {
8000c384:	4772                	lw	a4,28(sp)
8000c386:	14000793          	li	a5,320
8000c38a:	00e7ef63          	bltu	a5,a4,8000c3a8 <.L134>
        sysctl_enable_group_resource(HPM_SYSCTL, group, resource, true);
8000c38e:	47a2                	lw	a5,8(sp)
8000c390:	0ff7f793          	zext.b	a5,a5
8000c394:	4772                	lw	a4,28(sp)
8000c396:	08074733          	zext.h	a4,a4
8000c39a:	4685                	li	a3,1
8000c39c:	863a                	mv	a2,a4
8000c39e:	85be                	mv	a1,a5
8000c3a0:	f4000537          	lui	a0,0xf4000
8000c3a4:	229050ef          	jal	80011dcc <sysctl_enable_group_resource>

8000c3a8 <.L134>:
    }
}
8000c3a8:	0001                	nop
8000c3aa:	50b2                	lw	ra,44(sp)
8000c3ac:	6145                	add	sp,sp,48
8000c3ae:	8082                	ret

Disassembly of section .text.clock_cpu_delay_ms:

8000c3b0 <clock_cpu_delay_ms>:
    while (hpm_csr_get_core_cycle() < expected_ticks) {
    }
}

void clock_cpu_delay_ms(uint32_t ms)
{
8000c3b0:	715d                	add	sp,sp,-80
8000c3b2:	c686                	sw	ra,76(sp)
8000c3b4:	c4a2                	sw	s0,72(sp)
8000c3b6:	c2a6                	sw	s1,68(sp)
8000c3b8:	c0ca                	sw	s2,64(sp)
8000c3ba:	de4e                	sw	s3,60(sp)
8000c3bc:	dc52                	sw	s4,56(sp)
8000c3be:	da56                	sw	s5,52(sp)
8000c3c0:	d85a                	sw	s6,48(sp)
8000c3c2:	d65e                	sw	s7,44(sp)
8000c3c4:	c62a                	sw	a0,12(sp)
    uint64_t expected_ticks = hpm_csr_get_core_cycle() + (uint64_t)clock_get_core_clock_ticks_per_ms() * (uint64_t)ms;
8000c3c6:	3145                	jal	8000c066 <hpm_csr_get_core_cycle>
8000c3c8:	8b2a                	mv	s6,a0
8000c3ca:	8bae                	mv	s7,a1
8000c3cc:	3e5050ef          	jal	80011fb0 <clock_get_core_clock_ticks_per_ms>
8000c3d0:	87aa                	mv	a5,a0
8000c3d2:	8a3e                	mv	s4,a5
8000c3d4:	4a81                	li	s5,0
8000c3d6:	47b2                	lw	a5,12(sp)
8000c3d8:	893e                	mv	s2,a5
8000c3da:	4981                	li	s3,0
8000c3dc:	032a8733          	mul	a4,s5,s2
8000c3e0:	034987b3          	mul	a5,s3,s4
8000c3e4:	97ba                	add	a5,a5,a4
8000c3e6:	032a0733          	mul	a4,s4,s2
8000c3ea:	032a34b3          	mulhu	s1,s4,s2
8000c3ee:	843a                	mv	s0,a4
8000c3f0:	97a6                	add	a5,a5,s1
8000c3f2:	84be                	mv	s1,a5
8000c3f4:	008b0733          	add	a4,s6,s0
8000c3f8:	86ba                	mv	a3,a4
8000c3fa:	0166b6b3          	sltu	a3,a3,s6
8000c3fe:	009b87b3          	add	a5,s7,s1
8000c402:	96be                	add	a3,a3,a5
8000c404:	87b6                	mv	a5,a3
8000c406:	cc3a                	sw	a4,24(sp)
8000c408:	ce3e                	sw	a5,28(sp)
    while (hpm_csr_get_core_cycle() < expected_ticks) {
8000c40a:	0001                	nop

8000c40c <.L158>:
8000c40c:	39a9                	jal	8000c066 <hpm_csr_get_core_cycle>
8000c40e:	872a                	mv	a4,a0
8000c410:	87ae                	mv	a5,a1
8000c412:	46f2                	lw	a3,28(sp)
8000c414:	863e                	mv	a2,a5
8000c416:	fed66be3          	bltu	a2,a3,8000c40c <.L158>
8000c41a:	46f2                	lw	a3,28(sp)
8000c41c:	863e                	mv	a2,a5
8000c41e:	00c69663          	bne	a3,a2,8000c42a <.L160>
8000c422:	46e2                	lw	a3,24(sp)
8000c424:	87ba                	mv	a5,a4
8000c426:	fed7e3e3          	bltu	a5,a3,8000c40c <.L158>

8000c42a <.L160>:
    }
}
8000c42a:	0001                	nop
8000c42c:	40b6                	lw	ra,76(sp)
8000c42e:	4426                	lw	s0,72(sp)
8000c430:	4496                	lw	s1,68(sp)
8000c432:	4906                	lw	s2,64(sp)
8000c434:	59f2                	lw	s3,60(sp)
8000c436:	5a62                	lw	s4,56(sp)
8000c438:	5ad2                	lw	s5,52(sp)
8000c43a:	5b42                	lw	s6,48(sp)
8000c43c:	5bb2                	lw	s7,44(sp)
8000c43e:	6161                	add	sp,sp,80
8000c440:	8082                	ret

Disassembly of section .text.l1c_op:

8000c442 <l1c_op>:
                                             assert(address % HPM_L1C_CACHELINE_SIZE == 0); \
                                             assert(size % HPM_L1C_CACHELINE_SIZE == 0); \
                                        } while (0)

static void l1c_op(uint8_t opcode, uint32_t address, uint32_t size)
{
8000c442:	7179                	add	sp,sp,-48
8000c444:	d622                	sw	s0,44(sp)
8000c446:	87aa                	mv	a5,a0
8000c448:	c42e                	sw	a1,8(sp)
8000c44a:	c232                	sw	a2,4(sp)
8000c44c:	00f107a3          	sb	a5,15(sp)
        l1c_cctl_address_cmd(opcode, address + i * HPM_L1C_CACHELINE_SIZE);
        tmp += HPM_L1C_CACHELINE_SIZE;
    }
#else
    register uint32_t next_address;
    next_address = address;
8000c450:	4422                	lw	s0,8(sp)
8000c452:	ce22                	sw	s0,28(sp)

8000c454 <.LBB41>:
    (uint32_t)(((x) << HPM_MCCTLBEGINADDR_WAY_SHIFT) & HPM_MCCTLBEGINADDR_WAY_MASK)

/* send IX command */
ATTR_ALWAYS_INLINE static inline void l1c_cctl_address(uint32_t address)
{
    write_csr(CSR_MCCTLBEGINADDR, address);
8000c454:	47f2                	lw	a5,28(sp)
8000c456:	7cb79073          	csrw	0x7cb,a5
}
8000c45a:	0001                	nop

8000c45c <.LBE41>:
    l1c_cctl_address(next_address);
    while ((next_address < (address + size)) && (next_address >= address)) {
8000c45c:	a005                	j	8000c47c <.L2>

8000c45e <.L5>:
8000c45e:	00f14783          	lbu	a5,15(sp)
8000c462:	00f10ba3          	sb	a5,23(sp)

8000c466 <.LBB43>:

/* send command */
ATTR_ALWAYS_INLINE static inline void l1c_cctl_cmd(uint8_t cmd)
{
    write_csr(CSR_MCCTLCOMMAND, cmd);
8000c466:	01714783          	lbu	a5,23(sp)
8000c46a:	7cc79073          	csrw	0x7cc,a5
}
8000c46e:	0001                	nop

8000c470 <.LBB45>:

ATTR_ALWAYS_INLINE static inline uint32_t l1c_cctl_get_address(void)
{
    return read_csr(CSR_MCCTLBEGINADDR);
8000c470:	7cb027f3          	csrr	a5,0x7cb
8000c474:	cc3e                	sw	a5,24(sp)
8000c476:	47e2                	lw	a5,24(sp)

8000c478 <.LBE47>:
8000c478:	0001                	nop

8000c47a <.LBE45>:
        l1c_cctl_cmd(opcode);
        next_address = l1c_cctl_get_address();
8000c47a:	843e                	mv	s0,a5

8000c47c <.L2>:
    while ((next_address < (address + size)) && (next_address >= address)) {
8000c47c:	4722                	lw	a4,8(sp)
8000c47e:	4792                	lw	a5,4(sp)
8000c480:	97ba                	add	a5,a5,a4
8000c482:	00f47563          	bgeu	s0,a5,8000c48c <.L6>
8000c486:	47a2                	lw	a5,8(sp)
8000c488:	fcf47be3          	bgeu	s0,a5,8000c45e <.L5>

8000c48c <.L6>:
    }
#endif
}
8000c48c:	0001                	nop
8000c48e:	5432                	lw	s0,44(sp)
8000c490:	6145                	add	sp,sp,48
8000c492:	8082                	ret

Disassembly of section .text.l1c_dc_enable:

8000c494 <l1c_dc_enable>:

void l1c_dc_enable(void)
{
8000c494:	1101                	add	sp,sp,-32
8000c496:	ce06                	sw	ra,28(sp)

8000c498 <.LBB48>:
    return read_csr(CSR_MCACHE_CTL);
8000c498:	7ca027f3          	csrr	a5,0x7ca
8000c49c:	c63e                	sw	a5,12(sp)
8000c49e:	47b2                	lw	a5,12(sp)

8000c4a0 <.LBE52>:
8000c4a0:	0001                	nop

8000c4a2 <.LBE50>:
    return l1c_get_control() & HPM_MCACHE_CTL_DC_EN_MASK;
8000c4a2:	8b89                	and	a5,a5,2
8000c4a4:	00f037b3          	snez	a5,a5
8000c4a8:	0ff7f793          	zext.b	a5,a5

8000c4ac <.LBE48>:
    if (!l1c_dc_is_enabled()) {
8000c4ac:	0017c793          	xor	a5,a5,1
8000c4b0:	0ff7f793          	zext.b	a5,a5
8000c4b4:	c791                	beqz	a5,8000c4c0 <.L11>
#ifdef L1C_DC_DISABLE_WRITEAROUND_ON_ENABLE
        l1c_dc_disable_writearound();
#else
        l1c_dc_enable_writearound();
8000c4b6:	2861                	jal	8000c54e <l1c_dc_enable_writearound>
#endif
        set_csr(CSR_MCACHE_CTL, HPM_MCACHE_CTL_DPREF_EN_MASK | HPM_MCACHE_CTL_DC_EN_MASK);
8000c4b8:	40200793          	li	a5,1026
8000c4bc:	7ca7a073          	csrs	0x7ca,a5

8000c4c0 <.L11>:
    }
}
8000c4c0:	0001                	nop
8000c4c2:	40f2                	lw	ra,28(sp)
8000c4c4:	6105                	add	sp,sp,32
8000c4c6:	8082                	ret

Disassembly of section .text.l1c_ic_enable:

8000c4c8 <l1c_ic_enable>:
        clear_csr(CSR_MCACHE_CTL, HPM_MCACHE_CTL_DC_EN_MASK);
    }
}

void l1c_ic_enable(void)
{
8000c4c8:	1141                	add	sp,sp,-16

8000c4ca <.LBB58>:
    return read_csr(CSR_MCACHE_CTL);
8000c4ca:	7ca027f3          	csrr	a5,0x7ca
8000c4ce:	c63e                	sw	a5,12(sp)
8000c4d0:	47b2                	lw	a5,12(sp)

8000c4d2 <.LBE62>:
8000c4d2:	0001                	nop

8000c4d4 <.LBE60>:
    return l1c_get_control() & HPM_MCACHE_CTL_IC_EN_MASK;
8000c4d4:	8b85                	and	a5,a5,1
8000c4d6:	00f037b3          	snez	a5,a5
8000c4da:	0ff7f793          	zext.b	a5,a5

8000c4de <.LBE58>:
    if (!l1c_ic_is_enabled()) {
8000c4de:	0017c793          	xor	a5,a5,1
8000c4e2:	0ff7f793          	zext.b	a5,a5
8000c4e6:	c789                	beqz	a5,8000c4f0 <.L21>
        set_csr(CSR_MCACHE_CTL, HPM_MCACHE_CTL_IPREF_EN_MASK
8000c4e8:	30100793          	li	a5,769
8000c4ec:	7ca7a073          	csrs	0x7ca,a5

8000c4f0 <.L21>:
                              | HPM_MCACHE_CTL_CCTL_SUEN_MASK
                              | HPM_MCACHE_CTL_IC_EN_MASK);
    }
}
8000c4f0:	0001                	nop
8000c4f2:	0141                	add	sp,sp,16
8000c4f4:	8082                	ret

Disassembly of section .text.l1c_dc_invalidate:

8000c4f6 <l1c_dc_invalidate>:
    ASSERT_ADDR_SIZE(address, size);
    l1c_op(HPM_L1C_CCTL_CMD_L1D_VA_UNLOCK, address, size);
}

void l1c_dc_invalidate(uint32_t address, uint32_t size)
{
8000c4f6:	1101                	add	sp,sp,-32
8000c4f8:	ce06                	sw	ra,28(sp)
8000c4fa:	c62a                	sw	a0,12(sp)
8000c4fc:	c42e                	sw	a1,8(sp)
    ASSERT_ADDR_SIZE(address, size);
8000c4fe:	47b2                	lw	a5,12(sp)
8000c500:	03f7f793          	and	a5,a5,63
8000c504:	cf89                	beqz	a5,8000c51e <.L38>
8000c506:	06900613          	li	a2,105
8000c50a:	800087b7          	lui	a5,0x80008
8000c50e:	15078593          	add	a1,a5,336 # 80008150 <.LC0>
8000c512:	800087b7          	lui	a5,0x80008
8000c516:	18c78513          	add	a0,a5,396 # 8000818c <.LC1>
8000c51a:	51b060ef          	jal	80013234 <__SEGGER_RTL_X_assert>

8000c51e <.L38>:
8000c51e:	47a2                	lw	a5,8(sp)
8000c520:	03f7f793          	and	a5,a5,63
8000c524:	cf89                	beqz	a5,8000c53e <.L39>
8000c526:	06900613          	li	a2,105
8000c52a:	800087b7          	lui	a5,0x80008
8000c52e:	15078593          	add	a1,a5,336 # 80008150 <.LC0>
8000c532:	800087b7          	lui	a5,0x80008
8000c536:	1b478513          	add	a0,a5,436 # 800081b4 <.LC2>
8000c53a:	4fb060ef          	jal	80013234 <__SEGGER_RTL_X_assert>

8000c53e <.L39>:
    l1c_op(HPM_L1C_CCTL_CMD_L1D_VA_INVAL, address, size);
8000c53e:	4622                	lw	a2,8(sp)
8000c540:	45b2                	lw	a1,12(sp)
8000c542:	4501                	li	a0,0
8000c544:	3dfd                	jal	8000c442 <l1c_op>
}
8000c546:	0001                	nop
8000c548:	40f2                	lw	ra,28(sp)
8000c54a:	6105                	add	sp,sp,32
8000c54c:	8082                	ret

Disassembly of section .text.l1c_dc_enable_writearound:

8000c54e <l1c_dc_enable_writearound>:
    l1c_op(HPM_L1C_CCTL_CMD_L1I_VA_UNLOCK, address, size);
}

void l1c_dc_enable_writearound(void)
{
    set_csr(CSR_MCACHE_CTL, HPM_MCACHE_CTL_DC_WAROUND_MASK);
8000c54e:	6799                	lui	a5,0x6
8000c550:	7ca7a073          	csrs	0x7ca,a5
}
8000c554:	0001                	nop
8000c556:	8082                	ret

Disassembly of section .text.init_esc_pins:

8000c558 <init_esc_pins>:
    HPM_IOC->PAD[IOC_PAD_PD09].PAD_CTL = IOC_PAD_PAD_CTL_OD_SET(1) | IOC_PAD_PAD_CTL_PE_SET(1) | IOC_PAD_PAD_CTL_PS_SET(1);
}

void init_esc_pins(void)
{
    HPM_IOC->PAD[IOC_PAD_PA09].FUNC_CTL = IOC_PA09_FUNC_CTL_ESC0_REFCK;
8000c558:	f40407b7          	lui	a5,0xf4040
8000c55c:	472d                	li	a4,11
8000c55e:	c7b8                	sw	a4,72(a5)
    HPM_IOC->PAD[IOC_PAD_PA30].FUNC_CTL = IOC_PA30_FUNC_CTL_ESC0_MDIO;
8000c560:	f40407b7          	lui	a5,0xf4040
8000c564:	472d                	li	a4,11
8000c566:	0ee7a823          	sw	a4,240(a5) # f40400f0 <__AHB_SRAM_segment_end__+0x3e380f0>
    HPM_IOC->PAD[IOC_PAD_PA31].FUNC_CTL = IOC_PA31_FUNC_CTL_ESC0_MDC;
8000c56a:	f40407b7          	lui	a5,0xf4040
8000c56e:	472d                	li	a4,11
8000c570:	0ee7ac23          	sw	a4,248(a5) # f40400f8 <__AHB_SRAM_segment_end__+0x3e380f8>

    /* ESC needs to configure these pins for specific functions, see ESC IOCFG registers */
    HPM_IOC->PAD[IOC_PAD_PB26].FUNC_CTL = IOC_PB26_FUNC_CTL_GPIO_B_26;  /* GPIO to reset PHY */
8000c574:	f40407b7          	lui	a5,0xf4040
8000c578:	1c07a823          	sw	zero,464(a5) # f40401d0 <__AHB_SRAM_segment_end__+0x3e381d0>
    HPM_IOC->PAD[IOC_PAD_PB27].FUNC_CTL = IOC_PB27_FUNC_CTL_ESC0_CTR_7; /* NMII_LINK0 function */
8000c57c:	f40407b7          	lui	a5,0xf4040
8000c580:	472d                	li	a4,11
8000c582:	1ce7ac23          	sw	a4,472(a5) # f40401d8 <__AHB_SRAM_segment_end__+0x3e381d8>
    HPM_IOC->PAD[IOC_PAD_PB27].PAD_CTL = IOC_PAD_PAD_CTL_PE_SET(1) | IOC_PAD_PAD_CTL_PS_SET(1); /* Internally pull up to avoid suspension */
8000c586:	f40407b7          	lui	a5,0xf4040
8000c58a:	00060737          	lui	a4,0x60
8000c58e:	1ce7ae23          	sw	a4,476(a5) # f40401dc <__AHB_SRAM_segment_end__+0x3e381dc>
    HPM_IOC->PAD[IOC_PAD_PB28].FUNC_CTL = IOC_PB28_FUNC_CTL_ESC0_CTR_8; /* NMII_LINK1 function */
8000c592:	f40407b7          	lui	a5,0xf4040
8000c596:	472d                	li	a4,11
8000c598:	1ee7a023          	sw	a4,480(a5) # f40401e0 <__AHB_SRAM_segment_end__+0x3e381e0>
    HPM_IOC->PAD[IOC_PAD_PB28].PAD_CTL = IOC_PAD_PAD_CTL_PE_SET(1) | IOC_PAD_PAD_CTL_PS_SET(1); /* Internally pull up to avoid suspension */
8000c59c:	f40407b7          	lui	a5,0xf4040
8000c5a0:	00060737          	lui	a4,0x60
8000c5a4:	1ee7a223          	sw	a4,484(a5) # f40401e4 <__AHB_SRAM_segment_end__+0x3e381e4>
    //HPM_IOC->PAD[IOC_PAD_PE02].FUNC_CTL = IOC_PE02_FUNC_CTL_ESC0_CTR_6; /* NMII_LINK2 function */
    //HPM_IOC->PAD[IOC_PAD_PE02].PAD_CTL = IOC_PAD_PAD_CTL_PE_SET(1) | IOC_PAD_PAD_CTL_PS_SET(1); /* Internally pull up to avoid suspension */

    /* ESC port0 */
    HPM_IOC->PAD[IOC_PAD_PA24].FUNC_CTL = IOC_PA24_FUNC_CTL_ESC0_P0_TXCK;
8000c5a8:	f40407b7          	lui	a5,0xf4040
8000c5ac:	472d                	li	a4,11
8000c5ae:	0ce7a023          	sw	a4,192(a5) # f40400c0 <__AHB_SRAM_segment_end__+0x3e380c0>
    HPM_IOC->PAD[IOC_PAD_PA29].FUNC_CTL = IOC_PA29_FUNC_CTL_ESC0_P0_TXEN;
8000c5b2:	f40407b7          	lui	a5,0xf4040
8000c5b6:	472d                	li	a4,11
8000c5b8:	0ee7a423          	sw	a4,232(a5) # f40400e8 <__AHB_SRAM_segment_end__+0x3e380e8>
    HPM_IOC->PAD[IOC_PAD_PA25].FUNC_CTL = IOC_PA25_FUNC_CTL_ESC0_P0_TXD_0;
8000c5bc:	f40407b7          	lui	a5,0xf4040
8000c5c0:	472d                	li	a4,11
8000c5c2:	0ce7a423          	sw	a4,200(a5) # f40400c8 <__AHB_SRAM_segment_end__+0x3e380c8>
    HPM_IOC->PAD[IOC_PAD_PA26].FUNC_CTL = IOC_PA26_FUNC_CTL_ESC0_P0_TXD_1;
8000c5c6:	f40407b7          	lui	a5,0xf4040
8000c5ca:	472d                	li	a4,11
8000c5cc:	0ce7a823          	sw	a4,208(a5) # f40400d0 <__AHB_SRAM_segment_end__+0x3e380d0>
    HPM_IOC->PAD[IOC_PAD_PA27].FUNC_CTL = IOC_PA27_FUNC_CTL_ESC0_P0_TXD_2;
8000c5d0:	f40407b7          	lui	a5,0xf4040
8000c5d4:	472d                	li	a4,11
8000c5d6:	0ce7ac23          	sw	a4,216(a5) # f40400d8 <__AHB_SRAM_segment_end__+0x3e380d8>
    HPM_IOC->PAD[IOC_PAD_PA28].FUNC_CTL = IOC_PA28_FUNC_CTL_ESC0_P0_TXD_3;
8000c5da:	f40407b7          	lui	a5,0xf4040
8000c5de:	472d                	li	a4,11
8000c5e0:	0ee7a023          	sw	a4,224(a5) # f40400e0 <__AHB_SRAM_segment_end__+0x3e380e0>
    HPM_IOC->PAD[IOC_PAD_PA21].FUNC_CTL = IOC_PA21_FUNC_CTL_ESC0_P0_RXCK;
8000c5e4:	f40407b7          	lui	a5,0xf4040
8000c5e8:	472d                	li	a4,11
8000c5ea:	0ae7a423          	sw	a4,168(a5) # f40400a8 <__AHB_SRAM_segment_end__+0x3e380a8>
    HPM_IOC->PAD[IOC_PAD_PA16].FUNC_CTL = IOC_PA16_FUNC_CTL_ESC0_P0_RXDV;
8000c5ee:	f40407b7          	lui	a5,0xf4040
8000c5f2:	472d                	li	a4,11
8000c5f4:	08e7a023          	sw	a4,128(a5) # f4040080 <__AHB_SRAM_segment_end__+0x3e38080>
    HPM_IOC->PAD[IOC_PAD_PA23].FUNC_CTL = IOC_PA23_FUNC_CTL_ESC0_P0_RXER;
8000c5f8:	f40407b7          	lui	a5,0xf4040
8000c5fc:	472d                	li	a4,11
8000c5fe:	0ae7ac23          	sw	a4,184(a5) # f40400b8 <__AHB_SRAM_segment_end__+0x3e380b8>
    HPM_IOC->PAD[IOC_PAD_PA17].FUNC_CTL = IOC_PA17_FUNC_CTL_ESC0_P0_RXD_0;
8000c602:	f40407b7          	lui	a5,0xf4040
8000c606:	472d                	li	a4,11
8000c608:	08e7a423          	sw	a4,136(a5) # f4040088 <__AHB_SRAM_segment_end__+0x3e38088>
    HPM_IOC->PAD[IOC_PAD_PA18].FUNC_CTL = IOC_PA18_FUNC_CTL_ESC0_P0_RXD_1;
8000c60c:	f40407b7          	lui	a5,0xf4040
8000c610:	472d                	li	a4,11
8000c612:	08e7a823          	sw	a4,144(a5) # f4040090 <__AHB_SRAM_segment_end__+0x3e38090>
    HPM_IOC->PAD[IOC_PAD_PA19].FUNC_CTL = IOC_PA19_FUNC_CTL_ESC0_P0_RXD_2;
8000c616:	f40407b7          	lui	a5,0xf4040
8000c61a:	472d                	li	a4,11
8000c61c:	08e7ac23          	sw	a4,152(a5) # f4040098 <__AHB_SRAM_segment_end__+0x3e38098>
    HPM_IOC->PAD[IOC_PAD_PA20].FUNC_CTL = IOC_PA20_FUNC_CTL_ESC0_P0_RXD_3;
8000c620:	f40407b7          	lui	a5,0xf4040
8000c624:	472d                	li	a4,11
8000c626:	0ae7a023          	sw	a4,160(a5) # f40400a0 <__AHB_SRAM_segment_end__+0x3e380a0>

    /* ESC port1 */
    HPM_IOC->PAD[IOC_PAD_PF02].FUNC_CTL = IOC_PF02_FUNC_CTL_ESC0_P1_TXCK;
8000c62a:	f40407b7          	lui	a5,0xf4040
8000c62e:	472d                	li	a4,11
8000c630:	50e7a823          	sw	a4,1296(a5) # f4040510 <__AHB_SRAM_segment_end__+0x3e38510>
    HPM_IOC->PAD[IOC_PAD_PF07].FUNC_CTL = IOC_PF07_FUNC_CTL_ESC0_P1_TXEN;
8000c634:	f40407b7          	lui	a5,0xf4040
8000c638:	472d                	li	a4,11
8000c63a:	52e7ac23          	sw	a4,1336(a5) # f4040538 <__AHB_SRAM_segment_end__+0x3e38538>
    HPM_IOC->PAD[IOC_PAD_PF03].FUNC_CTL = IOC_PF03_FUNC_CTL_ESC0_P1_TXD_0;
8000c63e:	f40407b7          	lui	a5,0xf4040
8000c642:	472d                	li	a4,11
8000c644:	50e7ac23          	sw	a4,1304(a5) # f4040518 <__AHB_SRAM_segment_end__+0x3e38518>
    HPM_IOC->PAD[IOC_PAD_PF04].FUNC_CTL = IOC_PF04_FUNC_CTL_ESC0_P1_TXD_1;
8000c648:	f40407b7          	lui	a5,0xf4040
8000c64c:	472d                	li	a4,11
8000c64e:	52e7a023          	sw	a4,1312(a5) # f4040520 <__AHB_SRAM_segment_end__+0x3e38520>
    HPM_IOC->PAD[IOC_PAD_PF05].FUNC_CTL = IOC_PF05_FUNC_CTL_ESC0_P1_TXD_2;
8000c652:	f40407b7          	lui	a5,0xf4040
8000c656:	472d                	li	a4,11
8000c658:	52e7a423          	sw	a4,1320(a5) # f4040528 <__AHB_SRAM_segment_end__+0x3e38528>
    HPM_IOC->PAD[IOC_PAD_PF06].FUNC_CTL = IOC_PF06_FUNC_CTL_ESC0_P1_TXD_3;
8000c65c:	f40407b7          	lui	a5,0xf4040
8000c660:	472d                	li	a4,11
8000c662:	52e7a823          	sw	a4,1328(a5) # f4040530 <__AHB_SRAM_segment_end__+0x3e38530>
    HPM_IOC->PAD[IOC_PAD_PF13].FUNC_CTL = IOC_PF13_FUNC_CTL_ESC0_P1_RXCK;
8000c666:	f40407b7          	lui	a5,0xf4040
8000c66a:	472d                	li	a4,11
8000c66c:	56e7a423          	sw	a4,1384(a5) # f4040568 <__AHB_SRAM_segment_end__+0x3e38568>
    HPM_IOC->PAD[IOC_PAD_PF08].FUNC_CTL = IOC_PF08_FUNC_CTL_ESC0_P1_RXDV;
8000c670:	f40407b7          	lui	a5,0xf4040
8000c674:	472d                	li	a4,11
8000c676:	54e7a023          	sw	a4,1344(a5) # f4040540 <__AHB_SRAM_segment_end__+0x3e38540>
    HPM_IOC->PAD[IOC_PAD_PF14].FUNC_CTL = IOC_PF14_FUNC_CTL_ESC0_P1_RXER;
8000c67a:	f40407b7          	lui	a5,0xf4040
8000c67e:	472d                	li	a4,11
8000c680:	56e7a823          	sw	a4,1392(a5) # f4040570 <__AHB_SRAM_segment_end__+0x3e38570>
    HPM_IOC->PAD[IOC_PAD_PF09].FUNC_CTL = IOC_PF09_FUNC_CTL_ESC0_P1_RXD_0;
8000c684:	f40407b7          	lui	a5,0xf4040
8000c688:	472d                	li	a4,11
8000c68a:	54e7a423          	sw	a4,1352(a5) # f4040548 <__AHB_SRAM_segment_end__+0x3e38548>
    HPM_IOC->PAD[IOC_PAD_PF10].FUNC_CTL = IOC_PF10_FUNC_CTL_ESC0_P1_RXD_1;
8000c68e:	f40407b7          	lui	a5,0xf4040
8000c692:	472d                	li	a4,11
8000c694:	54e7a823          	sw	a4,1360(a5) # f4040550 <__AHB_SRAM_segment_end__+0x3e38550>
    HPM_IOC->PAD[IOC_PAD_PF11].FUNC_CTL = IOC_PF11_FUNC_CTL_ESC0_P1_RXD_2;
8000c698:	f40407b7          	lui	a5,0xf4040
8000c69c:	472d                	li	a4,11
8000c69e:	54e7ac23          	sw	a4,1368(a5) # f4040558 <__AHB_SRAM_segment_end__+0x3e38558>
    HPM_IOC->PAD[IOC_PAD_PF12].FUNC_CTL = IOC_PF12_FUNC_CTL_ESC0_P1_RXD_3;
8000c6a2:	f40407b7          	lui	a5,0xf4040
8000c6a6:	472d                	li	a4,11
8000c6a8:	56e7a023          	sw	a4,1376(a5) # f4040560 <__AHB_SRAM_segment_end__+0x3e38560>

    /* ESC port2 */
    HPM_IOC->PAD[IOC_PAD_PD16].FUNC_CTL = IOC_PD16_FUNC_CTL_ESC0_P2_RXDV;
8000c6ac:	f40407b7          	lui	a5,0xf4040
8000c6b0:	476d                	li	a4,27
8000c6b2:	38e7a023          	sw	a4,896(a5) # f4040380 <__AHB_SRAM_segment_end__+0x3e38380>
    HPM_IOC->PAD[IOC_PAD_PD17].FUNC_CTL = IOC_PD17_FUNC_CTL_ESC0_P2_RXD_0;
8000c6b6:	f40407b7          	lui	a5,0xf4040
8000c6ba:	476d                	li	a4,27
8000c6bc:	38e7a423          	sw	a4,904(a5) # f4040388 <__AHB_SRAM_segment_end__+0x3e38388>
    HPM_IOC->PAD[IOC_PAD_PD18].FUNC_CTL = IOC_PD18_FUNC_CTL_ESC0_P2_RXD_1;
8000c6c0:	f40407b7          	lui	a5,0xf4040
8000c6c4:	476d                	li	a4,27
8000c6c6:	38e7a823          	sw	a4,912(a5) # f4040390 <__AHB_SRAM_segment_end__+0x3e38390>
    HPM_IOC->PAD[IOC_PAD_PD19].FUNC_CTL = IOC_PD19_FUNC_CTL_ESC0_P2_RXD_2;
8000c6ca:	f40407b7          	lui	a5,0xf4040
8000c6ce:	476d                	li	a4,27
8000c6d0:	38e7ac23          	sw	a4,920(a5) # f4040398 <__AHB_SRAM_segment_end__+0x3e38398>
    HPM_IOC->PAD[IOC_PAD_PD20].FUNC_CTL = IOC_PD20_FUNC_CTL_ESC0_P2_RXD_3;
8000c6d4:	f40407b7          	lui	a5,0xf4040
8000c6d8:	476d                	li	a4,27
8000c6da:	3ae7a023          	sw	a4,928(a5) # f40403a0 <__AHB_SRAM_segment_end__+0x3e383a0>
    HPM_IOC->PAD[IOC_PAD_PD21].FUNC_CTL = IOC_PD21_FUNC_CTL_ESC0_P2_RXCK;
8000c6de:	f40407b7          	lui	a5,0xf4040
8000c6e2:	476d                	li	a4,27
8000c6e4:	3ae7a423          	sw	a4,936(a5) # f40403a8 <__AHB_SRAM_segment_end__+0x3e383a8>
    HPM_IOC->PAD[IOC_PAD_PD22].FUNC_CTL = IOC_PD22_FUNC_CTL_ESC0_P2_RXER;
8000c6e8:	f40407b7          	lui	a5,0xf4040
8000c6ec:	476d                	li	a4,27
8000c6ee:	3ae7a823          	sw	a4,944(a5) # f40403b0 <__AHB_SRAM_segment_end__+0x3e383b0>
    HPM_IOC->PAD[IOC_PAD_PD23].FUNC_CTL = IOC_PD23_FUNC_CTL_ESC0_P2_TXCK;
8000c6f2:	f40407b7          	lui	a5,0xf4040
8000c6f6:	476d                	li	a4,27
8000c6f8:	3ae7ac23          	sw	a4,952(a5) # f40403b8 <__AHB_SRAM_segment_end__+0x3e383b8>
    HPM_IOC->PAD[IOC_PAD_PD24].FUNC_CTL = IOC_PD24_FUNC_CTL_ESC0_P2_TXD_0;
8000c6fc:	f40407b7          	lui	a5,0xf4040
8000c700:	476d                	li	a4,27
8000c702:	3ce7a023          	sw	a4,960(a5) # f40403c0 <__AHB_SRAM_segment_end__+0x3e383c0>
    HPM_IOC->PAD[IOC_PAD_PD25].FUNC_CTL = IOC_PD25_FUNC_CTL_ESC0_P2_TXD_1;
8000c706:	f40407b7          	lui	a5,0xf4040
8000c70a:	476d                	li	a4,27
8000c70c:	3ce7a423          	sw	a4,968(a5) # f40403c8 <__AHB_SRAM_segment_end__+0x3e383c8>
    HPM_IOC->PAD[IOC_PAD_PD26].FUNC_CTL = IOC_PD26_FUNC_CTL_ESC0_P2_TXD_2;
8000c710:	f40407b7          	lui	a5,0xf4040
8000c714:	476d                	li	a4,27
8000c716:	3ce7a823          	sw	a4,976(a5) # f40403d0 <__AHB_SRAM_segment_end__+0x3e383d0>
    HPM_IOC->PAD[IOC_PAD_PD27].FUNC_CTL = IOC_PD27_FUNC_CTL_ESC0_P2_TXD_3;
8000c71a:	f40407b7          	lui	a5,0xf4040
8000c71e:	476d                	li	a4,27
8000c720:	3ce7ac23          	sw	a4,984(a5) # f40403d8 <__AHB_SRAM_segment_end__+0x3e383d8>
    HPM_IOC->PAD[IOC_PAD_PD28].FUNC_CTL = IOC_PD28_FUNC_CTL_ESC0_P2_TXEN;
8000c724:	f40407b7          	lui	a5,0xf4040
8000c728:	476d                	li	a4,27
8000c72a:	3ee7a023          	sw	a4,992(a5) # f40403e0 <__AHB_SRAM_segment_end__+0x3e383e0>
}
8000c72e:	0001                	nop
8000c730:	8082                	ret

Disassembly of section .text.sysctl_clock_set_preset:

8000c732 <sysctl_clock_set_preset>:
 *
 * @param[in] ptr SYSCTL_Type base address
 * @param[in] preset preset
 */
static inline void sysctl_clock_set_preset(SYSCTL_Type *ptr, sysctl_preset_t preset)
{
8000c732:	1141                	add	sp,sp,-16
8000c734:	c62a                	sw	a0,12(sp)
8000c736:	87ae                	mv	a5,a1
8000c738:	00f105a3          	sb	a5,11(sp)
    ptr->GLOBAL00 = (ptr->GLOBAL00 & ~SYSCTL_GLOBAL00_MUX_MASK) | SYSCTL_GLOBAL00_MUX_SET(preset);
8000c73c:	4732                	lw	a4,12(sp)
8000c73e:	6789                	lui	a5,0x2
8000c740:	97ba                	add	a5,a5,a4
8000c742:	439c                	lw	a5,0(a5)
8000c744:	f007f713          	and	a4,a5,-256
8000c748:	00b14783          	lbu	a5,11(sp)
8000c74c:	8f5d                	or	a4,a4,a5
8000c74e:	46b2                	lw	a3,12(sp)
8000c750:	6789                	lui	a5,0x2
8000c752:	97b6                	add	a5,a5,a3
8000c754:	c398                	sw	a4,0(a5)
}
8000c756:	0001                	nop
8000c758:	0141                	add	sp,sp,16
8000c75a:	8082                	ret

Disassembly of section .text.gpio_write_pin:

8000c75c <gpio_write_pin>:
{
8000c75c:	1141                	add	sp,sp,-16
8000c75e:	c62a                	sw	a0,12(sp)
8000c760:	c42e                	sw	a1,8(sp)
8000c762:	87b2                	mv	a5,a2
8000c764:	8736                	mv	a4,a3
8000c766:	00f103a3          	sb	a5,7(sp)
8000c76a:	87ba                	mv	a5,a4
8000c76c:	00f10323          	sb	a5,6(sp)
    if (high) {
8000c770:	00614783          	lbu	a5,6(sp)
8000c774:	cf91                	beqz	a5,8000c790 <.L18>
        ptr->DO[port].SET = 1 << pin;
8000c776:	00714783          	lbu	a5,7(sp)
8000c77a:	4705                	li	a4,1
8000c77c:	00f717b3          	sll	a5,a4,a5
8000c780:	86be                	mv	a3,a5
8000c782:	4732                	lw	a4,12(sp)
8000c784:	47a2                	lw	a5,8(sp)
8000c786:	07c1                	add	a5,a5,16 # 2010 <__BOOT_HEADER_segment_size__+0x10>
8000c788:	0792                	sll	a5,a5,0x4
8000c78a:	97ba                	add	a5,a5,a4
8000c78c:	c3d4                	sw	a3,4(a5)
}
8000c78e:	a829                	j	8000c7a8 <.L20>

8000c790 <.L18>:
        ptr->DO[port].CLEAR = 1 << pin;
8000c790:	00714783          	lbu	a5,7(sp)
8000c794:	4705                	li	a4,1
8000c796:	00f717b3          	sll	a5,a4,a5
8000c79a:	86be                	mv	a3,a5
8000c79c:	4732                	lw	a4,12(sp)
8000c79e:	47a2                	lw	a5,8(sp)
8000c7a0:	07c1                	add	a5,a5,16
8000c7a2:	0792                	sll	a5,a5,0x4
8000c7a4:	97ba                	add	a5,a5,a4
8000c7a6:	c794                	sw	a3,8(a5)

8000c7a8 <.L20>:
}
8000c7a8:	0001                	nop
8000c7aa:	0141                	add	sp,sp,16
8000c7ac:	8082                	ret

Disassembly of section .text.pllctlv2_xtal_set_rampup_time:

8000c7ae <pllctlv2_xtal_set_rampup_time>:
 * @param [in] ptr Base address of the PLLCTLV2 peripheral
 * @param [in] rc24m_cycles Number of RC24M clock cycles for the ramp-up period
 * @note The ramp-up time affects how quickly the crystal oscillator reaches stable operation
 */
static inline void pllctlv2_xtal_set_rampup_time(PLLCTLV2_Type *ptr, uint32_t rc24m_cycles)
{
8000c7ae:	1141                	add	sp,sp,-16
8000c7b0:	c62a                	sw	a0,12(sp)
8000c7b2:	c42e                	sw	a1,8(sp)
    ptr->XTAL = (ptr->XTAL & ~PLLCTLV2_XTAL_RAMP_TIME_MASK) | PLLCTLV2_XTAL_RAMP_TIME_SET(rc24m_cycles);
8000c7b4:	47b2                	lw	a5,12(sp)
8000c7b6:	4398                	lw	a4,0(a5)
8000c7b8:	fff007b7          	lui	a5,0xfff00
8000c7bc:	8f7d                	and	a4,a4,a5
8000c7be:	46a2                	lw	a3,8(sp)
8000c7c0:	001007b7          	lui	a5,0x100
8000c7c4:	17fd                	add	a5,a5,-1 # fffff <__FLASH_segment_size__+0x2fff>
8000c7c6:	8ff5                	and	a5,a5,a3
8000c7c8:	8f5d                	or	a4,a4,a5
8000c7ca:	47b2                	lw	a5,12(sp)
8000c7cc:	c398                	sw	a4,0(a5)
}
8000c7ce:	0001                	nop
8000c7d0:	0141                	add	sp,sp,16
8000c7d2:	8082                	ret

Disassembly of section .text.board_print_banner:

8000c7d4 <board_print_banner>:
    init_uart_pins(ptr);
    board_init_uart_clock(ptr);
}

void board_print_banner(void)
{
8000c7d4:	d8010113          	add	sp,sp,-640
8000c7d8:	26112e23          	sw	ra,636(sp)
    const uint8_t banner[] = { "\n\
8000c7dc:	800057b7          	lui	a5,0x80005
8000c7e0:	27878713          	add	a4,a5,632 # 80005278 <.LC10>
8000c7e4:	878a                	mv	a5,sp
8000c7e6:	86ba                	mv	a3,a4
8000c7e8:	26f00713          	li	a4,623
8000c7ec:	863a                	mv	a2,a4
8000c7ee:	85b6                	mv	a1,a3
8000c7f0:	853e                	mv	a0,a5
8000c7f2:	46a010ef          	jal	8000dc5c <memcpy>
\\__|  \\__|\\__|      \\__|     \\__|\\__| \\_______|\\__|       \\______/\n\
----------------------------------------------------------------------\n" };
#ifdef SDK_VERSION_STRING
    printf("hpm_sdk: %s\n", SDK_VERSION_STRING);
#endif
    printf("%s", banner);
8000c7f6:	878a                	mv	a5,sp
8000c7f8:	85be                	mv	a1,a5
8000c7fa:	800057b7          	lui	a5,0x80005
8000c7fe:	27478513          	add	a0,a5,628 # 80005274 <.LC11>
8000c802:	5be010ef          	jal	8000ddc0 <printf>
}
8000c806:	0001                	nop
8000c808:	27c12083          	lw	ra,636(sp)
8000c80c:	28010113          	add	sp,sp,640
8000c810:	8082                	ret

Disassembly of section .text.board_get_led_gpio_off_level:

8000c812 <board_get_led_gpio_off_level>:

uint8_t board_get_led_gpio_off_level(void)
{
    return BOARD_LED_OFF_LEVEL;
8000c812:	4785                	li	a5,1
}
8000c814:	853e                	mv	a0,a5
8000c816:	8082                	ret

Disassembly of section .text.uart_init:

8000c818 <uart_init>:
    }
    return false;
}

hpm_stat_t uart_init(UART_Type *ptr, uart_config_t *config)
{
8000c818:	7179                	add	sp,sp,-48
8000c81a:	d606                	sw	ra,44(sp)
8000c81c:	c62a                	sw	a0,12(sp)
8000c81e:	c42e                	sw	a1,8(sp)
    uint32_t tmp;
    uint8_t osc;
    uint16_t div;

    /* disable all interrupts */
    ptr->IER = 0;
8000c820:	47b2                	lw	a5,12(sp)
8000c822:	0207a223          	sw	zero,36(a5)
    /* Set DLAB to 1 */
    ptr->LCR |= UART_LCR_DLAB_MASK;
8000c826:	47b2                	lw	a5,12(sp)
8000c828:	57dc                	lw	a5,44(a5)
8000c82a:	0807e713          	or	a4,a5,128
8000c82e:	47b2                	lw	a5,12(sp)
8000c830:	d7d8                	sw	a4,44(a5)

    if (!uart_calculate_baudrate(config->src_freq_in_hz, config->baudrate, &div, &osc)) {
8000c832:	47a2                	lw	a5,8(sp)
8000c834:	4398                	lw	a4,0(a5)
8000c836:	47a2                	lw	a5,8(sp)
8000c838:	43dc                	lw	a5,4(a5)
8000c83a:	01b10693          	add	a3,sp,27
8000c83e:	0830                	add	a2,sp,24
8000c840:	85be                	mv	a1,a5
8000c842:	853a                	mv	a0,a4
8000c844:	517050ef          	jal	8001255a <uart_calculate_baudrate>
8000c848:	87aa                	mv	a5,a0
8000c84a:	0017c793          	xor	a5,a5,1
8000c84e:	0ff7f793          	zext.b	a5,a5
8000c852:	c781                	beqz	a5,8000c85a <.L26>
        return status_uart_no_suitable_baudrate_parameter_found;
8000c854:	3e900793          	li	a5,1001
8000c858:	a261                	j	8000c9e0 <.L43>

8000c85a <.L26>:
    }

    ptr->OSCR = (ptr->OSCR & ~UART_OSCR_OSC_MASK)
8000c85a:	47b2                	lw	a5,12(sp)
8000c85c:	4bdc                	lw	a5,20(a5)
8000c85e:	fe07f713          	and	a4,a5,-32
        | UART_OSCR_OSC_SET(osc);
8000c862:	01b14783          	lbu	a5,27(sp)
8000c866:	8bfd                	and	a5,a5,31
8000c868:	8f5d                	or	a4,a4,a5
    ptr->OSCR = (ptr->OSCR & ~UART_OSCR_OSC_MASK)
8000c86a:	47b2                	lw	a5,12(sp)
8000c86c:	cbd8                	sw	a4,20(a5)
    ptr->DLL = UART_DLL_DLL_SET(div >> 0);
8000c86e:	01815783          	lhu	a5,24(sp)
8000c872:	0ff7f713          	zext.b	a4,a5
8000c876:	47b2                	lw	a5,12(sp)
8000c878:	d398                	sw	a4,32(a5)
    ptr->DLM = UART_DLM_DLM_SET(div >> 8);
8000c87a:	01815783          	lhu	a5,24(sp)
8000c87e:	83a1                	srl	a5,a5,0x8
8000c880:	0807c7b3          	zext.h	a5,a5
8000c884:	0ff7f713          	zext.b	a4,a5
8000c888:	47b2                	lw	a5,12(sp)
8000c88a:	d3d8                	sw	a4,36(a5)

    /* DLAB bit needs to be cleared once baudrate is configured */
    tmp = ptr->LCR & (~UART_LCR_DLAB_MASK);
8000c88c:	47b2                	lw	a5,12(sp)
8000c88e:	57dc                	lw	a5,44(a5)
8000c890:	f7f7f793          	and	a5,a5,-129
8000c894:	ce3e                	sw	a5,28(sp)

    tmp &= ~(UART_LCR_SPS_MASK | UART_LCR_EPS_MASK | UART_LCR_PEN_MASK);
8000c896:	47f2                	lw	a5,28(sp)
8000c898:	fc77f793          	and	a5,a5,-57
8000c89c:	ce3e                	sw	a5,28(sp)
    switch (config->parity) {
8000c89e:	47a2                	lw	a5,8(sp)
8000c8a0:	00a7c783          	lbu	a5,10(a5)
8000c8a4:	4711                	li	a4,4
8000c8a6:	02f76f63          	bltu	a4,a5,8000c8e4 <.L28>
8000c8aa:	00279713          	sll	a4,a5,0x2
8000c8ae:	800057b7          	lui	a5,0x80005
8000c8b2:	58478793          	add	a5,a5,1412 # 80005584 <.L30>
8000c8b6:	97ba                	add	a5,a5,a4
8000c8b8:	439c                	lw	a5,0(a5)
8000c8ba:	8782                	jr	a5

8000c8bc <.L33>:
    case parity_none:
        break;
    case parity_odd:
        tmp |= UART_LCR_PEN_MASK;
8000c8bc:	47f2                	lw	a5,28(sp)
8000c8be:	0087e793          	or	a5,a5,8
8000c8c2:	ce3e                	sw	a5,28(sp)
        break;
8000c8c4:	a01d                	j	8000c8ea <.L35>

8000c8c6 <.L32>:
    case parity_even:
        tmp |= UART_LCR_PEN_MASK | UART_LCR_EPS_MASK;
8000c8c6:	47f2                	lw	a5,28(sp)
8000c8c8:	0187e793          	or	a5,a5,24
8000c8cc:	ce3e                	sw	a5,28(sp)
        break;
8000c8ce:	a831                	j	8000c8ea <.L35>

8000c8d0 <.L31>:
    case parity_always_1:
        tmp |= UART_LCR_PEN_MASK | UART_LCR_SPS_MASK;
8000c8d0:	47f2                	lw	a5,28(sp)
8000c8d2:	0287e793          	or	a5,a5,40
8000c8d6:	ce3e                	sw	a5,28(sp)
        break;
8000c8d8:	a809                	j	8000c8ea <.L35>

8000c8da <.L29>:
    case parity_always_0:
        tmp |= UART_LCR_EPS_MASK | UART_LCR_PEN_MASK
8000c8da:	47f2                	lw	a5,28(sp)
8000c8dc:	0387e793          	or	a5,a5,56
8000c8e0:	ce3e                	sw	a5,28(sp)
            | UART_LCR_SPS_MASK;
        break;
8000c8e2:	a021                	j	8000c8ea <.L35>

8000c8e4 <.L28>:
    default:
        /* invalid configuration */
        return status_invalid_argument;
8000c8e4:	4789                	li	a5,2
8000c8e6:	a8ed                	j	8000c9e0 <.L43>

8000c8e8 <.L44>:
        break;
8000c8e8:	0001                	nop

8000c8ea <.L35>:
    }

    tmp &= ~(UART_LCR_STB_MASK | UART_LCR_WLS_MASK);
8000c8ea:	47f2                	lw	a5,28(sp)
8000c8ec:	9be1                	and	a5,a5,-8
8000c8ee:	ce3e                	sw	a5,28(sp)
    switch (config->num_of_stop_bits) {
8000c8f0:	47a2                	lw	a5,8(sp)
8000c8f2:	0087c783          	lbu	a5,8(a5)
8000c8f6:	4709                	li	a4,2
8000c8f8:	00e78e63          	beq	a5,a4,8000c914 <.L36>
8000c8fc:	4709                	li	a4,2
8000c8fe:	02f74663          	blt	a4,a5,8000c92a <.L37>
8000c902:	c795                	beqz	a5,8000c92e <.L45>
8000c904:	4705                	li	a4,1
8000c906:	02e79263          	bne	a5,a4,8000c92a <.L37>
    case stop_bits_1:
        break;
    case stop_bits_1_5:
        tmp |= UART_LCR_STB_MASK;
8000c90a:	47f2                	lw	a5,28(sp)
8000c90c:	0047e793          	or	a5,a5,4
8000c910:	ce3e                	sw	a5,28(sp)
        break;
8000c912:	a839                	j	8000c930 <.L40>

8000c914 <.L36>:
    case stop_bits_2:
        if (config->word_length < word_length_6_bits) {
8000c914:	47a2                	lw	a5,8(sp)
8000c916:	0097c783          	lbu	a5,9(a5)
8000c91a:	e399                	bnez	a5,8000c920 <.L41>
            /* invalid configuration */
            return status_invalid_argument;
8000c91c:	4789                	li	a5,2
8000c91e:	a0c9                	j	8000c9e0 <.L43>

8000c920 <.L41>:
        }
        tmp |= UART_LCR_STB_MASK;
8000c920:	47f2                	lw	a5,28(sp)
8000c922:	0047e793          	or	a5,a5,4
8000c926:	ce3e                	sw	a5,28(sp)
        break;
8000c928:	a021                	j	8000c930 <.L40>

8000c92a <.L37>:
    default:
        /* invalid configuration */
        return status_invalid_argument;
8000c92a:	4789                	li	a5,2
8000c92c:	a855                	j	8000c9e0 <.L43>

8000c92e <.L45>:
        break;
8000c92e:	0001                	nop

8000c930 <.L40>:
    }

    ptr->LCR = tmp | UART_LCR_WLS_SET(config->word_length);
8000c930:	47a2                	lw	a5,8(sp)
8000c932:	0097c783          	lbu	a5,9(a5)
8000c936:	0037f713          	and	a4,a5,3
8000c93a:	47f2                	lw	a5,28(sp)
8000c93c:	8f5d                	or	a4,a4,a5
8000c93e:	47b2                	lw	a5,12(sp)
8000c940:	d7d8                	sw	a4,44(a5)

#if defined(HPM_IP_FEATURE_UART_FINE_FIFO_THRLD) && (HPM_IP_FEATURE_UART_FINE_FIFO_THRLD == 1)
    /* reset TX and RX fifo */
    ptr->FCRR = UART_FCRR_TFIFORST_MASK | UART_FCRR_RFIFORST_MASK;
8000c942:	47b2                	lw	a5,12(sp)
8000c944:	4719                	li	a4,6
8000c946:	cf98                	sw	a4,24(a5)
    /* Enable FIFO */
    ptr->FCRR = UART_FCRR_FIFOT4EN_MASK
        | UART_FCRR_FIFOE_SET(config->fifo_enable)
8000c948:	47a2                	lw	a5,8(sp)
8000c94a:	00e7c783          	lbu	a5,14(a5)
8000c94e:	86be                	mv	a3,a5
        | UART_FCRR_TFIFOT4_SET(config->tx_fifo_level)
8000c950:	47a2                	lw	a5,8(sp)
8000c952:	00b7c783          	lbu	a5,11(a5)
8000c956:	01079713          	sll	a4,a5,0x10
8000c95a:	001f07b7          	lui	a5,0x1f0
8000c95e:	8ff9                	and	a5,a5,a4
8000c960:	00f6e733          	or	a4,a3,a5
        | UART_FCRR_RFIFOT4_SET(config->rx_fifo_level)
8000c964:	47a2                	lw	a5,8(sp)
8000c966:	00c7c783          	lbu	a5,12(a5) # 1f000c <_flash_size+0xf000c>
8000c96a:	00879693          	sll	a3,a5,0x8
8000c96e:	6789                	lui	a5,0x2
8000c970:	f0078793          	add	a5,a5,-256 # 1f00 <__ILM_segment_used_end__+0x35a>
8000c974:	8ff5                	and	a5,a5,a3
8000c976:	8f5d                	or	a4,a4,a5
#if defined(HPM_IP_FEATURE_UART_DISABLE_DMA_TIMEOUT) && (HPM_IP_FEATURE_UART_DISABLE_DMA_TIMEOUT == 1)
        | UART_FCRR_TMOUT_RXDMA_DIS_MASK /**< disable RX timeout trigger dma */
#endif
        | UART_FCRR_DMAE_SET(config->dma_enable);
8000c978:	47a2                	lw	a5,8(sp)
8000c97a:	00d7c783          	lbu	a5,13(a5)
8000c97e:	078e                	sll	a5,a5,0x3
8000c980:	8ba1                	and	a5,a5,8
8000c982:	8f5d                	or	a4,a4,a5
8000c984:	018007b7          	lui	a5,0x1800
8000c988:	8f5d                	or	a4,a4,a5
    ptr->FCRR = UART_FCRR_FIFOT4EN_MASK
8000c98a:	47b2                	lw	a5,12(sp)
8000c98c:	cf98                	sw	a4,24(a5)
    ptr->FCR = tmp;
    /* store FCR register value */
    ptr->GPR = tmp;
#endif

    uart_modem_config(ptr, &config->modem_config);
8000c98e:	47a2                	lw	a5,8(sp)
8000c990:	07bd                	add	a5,a5,15 # 180000f <__AXI_SRAM_segment_end__+0x5c000f>
8000c992:	85be                	mv	a1,a5
8000c994:	4532                	lw	a0,12(sp)
8000c996:	2c1050ef          	jal	80012456 <uart_modem_config>

#if defined(HPM_IP_FEATURE_UART_RX_IDLE_DETECT) && (HPM_IP_FEATURE_UART_RX_IDLE_DETECT == 1)
    uart_init_rxline_idle_detection(ptr, config->rxidle_config);
8000c99a:	47a2                	lw	a5,8(sp)
8000c99c:	0127d703          	lhu	a4,18(a5)
8000c9a0:	0147d783          	lhu	a5,20(a5)
8000c9a4:	07c2                	sll	a5,a5,0x10
8000c9a6:	8fd9                	or	a5,a5,a4
8000c9a8:	873e                	mv	a4,a5
8000c9aa:	85ba                	mv	a1,a4
8000c9ac:	4532                	lw	a0,12(sp)
8000c9ae:	6b9050ef          	jal	80012866 <uart_init_rxline_idle_detection>
#endif

#if defined(HPM_IP_FEATURE_UART_TX_IDLE_DETECT) && (HPM_IP_FEATURE_UART_TX_IDLE_DETECT == 1)
    uart_init_txline_idle_detection(ptr, config->txidle_config);
8000c9b2:	47a2                	lw	a5,8(sp)
8000c9b4:	0167d703          	lhu	a4,22(a5)
8000c9b8:	0187d783          	lhu	a5,24(a5)
8000c9bc:	07c2                	sll	a5,a5,0x10
8000c9be:	8fd9                	or	a5,a5,a4
8000c9c0:	873e                	mv	a4,a5
8000c9c2:	85ba                	mv	a1,a4
8000c9c4:	4532                	lw	a0,12(sp)
8000c9c6:	2885                	jal	8000ca36 <uart_init_txline_idle_detection>
#endif

#if defined(HPM_IP_FEATURE_UART_RX_EN) && (HPM_IP_FEATURE_UART_RX_EN == 1)
    if (config->rx_enable) {
8000c9c8:	47a2                	lw	a5,8(sp)
8000c9ca:	01a7c783          	lbu	a5,26(a5)
8000c9ce:	cb81                	beqz	a5,8000c9de <.L42>
        ptr->IDLE_CFG |= UART_IDLE_CFG_RXEN_MASK;
8000c9d0:	47b2                	lw	a5,12(sp)
8000c9d2:	43d8                	lw	a4,4(a5)
8000c9d4:	28b01793          	bset	a5,zero,0xb
8000c9d8:	8f5d                	or	a4,a4,a5
8000c9da:	47b2                	lw	a5,12(sp)
8000c9dc:	c3d8                	sw	a4,4(a5)

8000c9de <.L42>:
    }
#endif
    return status_success;
8000c9de:	4781                	li	a5,0

8000c9e0 <.L43>:
}
8000c9e0:	853e                	mv	a0,a5
8000c9e2:	50b2                	lw	ra,44(sp)
8000c9e4:	6145                	add	sp,sp,48
8000c9e6:	8082                	ret

Disassembly of section .text.uart_send_byte:

8000c9e8 <uart_send_byte>:

    return status_success;
}

hpm_stat_t uart_send_byte(UART_Type *ptr, uint8_t c)
{
8000c9e8:	1101                	add	sp,sp,-32
8000c9ea:	c62a                	sw	a0,12(sp)
8000c9ec:	87ae                	mv	a5,a1
8000c9ee:	00f105a3          	sb	a5,11(sp)
    uint32_t retry = 0;
8000c9f2:	ce02                	sw	zero,28(sp)

    while (!(ptr->LSR & UART_LSR_THRE_MASK)) {
8000c9f4:	a811                	j	8000ca08 <.L51>

8000c9f6 <.L54>:
        if (retry > HPM_UART_DRV_RETRY_COUNT) {
8000c9f6:	4772                	lw	a4,28(sp)
8000c9f8:	6785                	lui	a5,0x1
8000c9fa:	38878793          	add	a5,a5,904 # 1388 <.LBE11+0x4c>
8000c9fe:	00e7eb63          	bltu	a5,a4,8000ca14 <.L57>
            break;
        }
        retry++;
8000ca02:	47f2                	lw	a5,28(sp)
8000ca04:	0785                	add	a5,a5,1
8000ca06:	ce3e                	sw	a5,28(sp)

8000ca08 <.L51>:
    while (!(ptr->LSR & UART_LSR_THRE_MASK)) {
8000ca08:	47b2                	lw	a5,12(sp)
8000ca0a:	5bdc                	lw	a5,52(a5)
8000ca0c:	0207f793          	and	a5,a5,32
8000ca10:	d3fd                	beqz	a5,8000c9f6 <.L54>
8000ca12:	a011                	j	8000ca16 <.L53>

8000ca14 <.L57>:
            break;
8000ca14:	0001                	nop

8000ca16 <.L53>:
    }

    if (retry > HPM_UART_DRV_RETRY_COUNT) {
8000ca16:	4772                	lw	a4,28(sp)
8000ca18:	6785                	lui	a5,0x1
8000ca1a:	38878793          	add	a5,a5,904 # 1388 <.LBE11+0x4c>
8000ca1e:	00e7f463          	bgeu	a5,a4,8000ca26 <.L55>
        return status_timeout;
8000ca22:	478d                	li	a5,3
8000ca24:	a031                	j	8000ca30 <.L56>

8000ca26 <.L55>:
    }

    ptr->THR = UART_THR_THR_SET(c);
8000ca26:	00b14703          	lbu	a4,11(sp)
8000ca2a:	47b2                	lw	a5,12(sp)
8000ca2c:	d398                	sw	a4,32(a5)
    return status_success;
8000ca2e:	4781                	li	a5,0

8000ca30 <.L56>:
}
8000ca30:	853e                	mv	a0,a5
8000ca32:	6105                	add	sp,sp,32
8000ca34:	8082                	ret

Disassembly of section .text.uart_init_txline_idle_detection:

8000ca36 <uart_init_txline_idle_detection>:
}
#endif

#if defined(HPM_IP_FEATURE_UART_TX_IDLE_DETECT) && (HPM_IP_FEATURE_UART_TX_IDLE_DETECT == 1)
hpm_stat_t uart_init_txline_idle_detection(UART_Type *ptr, uart_rxline_idle_config_t txidle_config)
{
8000ca36:	1101                	add	sp,sp,-32
8000ca38:	ce06                	sw	ra,28(sp)
8000ca3a:	c62a                	sw	a0,12(sp)
8000ca3c:	c42e                	sw	a1,8(sp)
    ptr->IDLE_CFG &= ~(UART_IDLE_CFG_TX_IDLE_EN_MASK
8000ca3e:	47b2                	lw	a5,12(sp)
8000ca40:	43d8                	lw	a4,4(a5)
8000ca42:	fc0107b7          	lui	a5,0xfc010
8000ca46:	17fd                	add	a5,a5,-1 # fc00ffff <__AHB_SRAM_segment_end__+0xbe07fff>
8000ca48:	8f7d                	and	a4,a4,a5
8000ca4a:	47b2                	lw	a5,12(sp)
8000ca4c:	c3d8                	sw	a4,4(a5)
                    | UART_IDLE_CFG_TX_IDLE_THR_MASK
                    | UART_IDLE_CFG_TX_IDLE_COND_MASK);
    ptr->IDLE_CFG |= UART_IDLE_CFG_TX_IDLE_EN_SET(txidle_config.detect_enable)
8000ca4e:	47b2                	lw	a5,12(sp)
8000ca50:	43d8                	lw	a4,4(a5)
8000ca52:	00814783          	lbu	a5,8(sp)
8000ca56:	01879693          	sll	a3,a5,0x18
8000ca5a:	010007b7          	lui	a5,0x1000
8000ca5e:	8efd                	and	a3,a3,a5
                    | UART_IDLE_CFG_TX_IDLE_THR_SET(txidle_config.threshold)
8000ca60:	00b14783          	lbu	a5,11(sp)
8000ca64:	01079613          	sll	a2,a5,0x10
8000ca68:	00ff07b7          	lui	a5,0xff0
8000ca6c:	8ff1                	and	a5,a5,a2
8000ca6e:	8edd                	or	a3,a3,a5
                    | UART_IDLE_CFG_TX_IDLE_COND_SET(txidle_config.idle_cond);
8000ca70:	00a14783          	lbu	a5,10(sp)
8000ca74:	01979613          	sll	a2,a5,0x19
8000ca78:	020007b7          	lui	a5,0x2000
8000ca7c:	8ff1                	and	a5,a5,a2
8000ca7e:	8fd5                	or	a5,a5,a3
    ptr->IDLE_CFG |= UART_IDLE_CFG_TX_IDLE_EN_SET(txidle_config.detect_enable)
8000ca80:	8f5d                	or	a4,a4,a5
8000ca82:	47b2                	lw	a5,12(sp)
8000ca84:	c3d8                	sw	a4,4(a5)

    if (txidle_config.detect_irq_enable) {
8000ca86:	00914783          	lbu	a5,9(sp)
8000ca8a:	c799                	beqz	a5,8000ca98 <.L96>
        uart_enable_irq(ptr, uart_intr_tx_line_idle);
8000ca8c:	400005b7          	lui	a1,0x40000
8000ca90:	4532                	lw	a0,12(sp)
8000ca92:	21d050ef          	jal	800124ae <uart_enable_irq>
8000ca96:	a031                	j	8000caa2 <.L97>

8000ca98 <.L96>:
    } else {
        uart_disable_irq(ptr, uart_intr_tx_line_idle);
8000ca98:	400005b7          	lui	a1,0x40000
8000ca9c:	4532                	lw	a0,12(sp)
8000ca9e:	1f5050ef          	jal	80012492 <uart_disable_irq>

8000caa2 <.L97>:
    }

    return status_success;
8000caa2:	4781                	li	a5,0
}
8000caa4:	853e                	mv	a0,a5
8000caa6:	40f2                	lw	ra,28(sp)
8000caa8:	6105                	add	sp,sp,32
8000caaa:	8082                	ret

Disassembly of section .text.gpio_set_pin_output_with_initial:

8000caac <gpio_set_pin_output_with_initial>:
        return;
    }
}

void gpio_set_pin_output_with_initial(GPIO_Type *ptr, uint32_t port, uint8_t pin, uint8_t initial)
{
8000caac:	1141                	add	sp,sp,-16
8000caae:	c62a                	sw	a0,12(sp)
8000cab0:	c42e                	sw	a1,8(sp)
8000cab2:	87b2                	mv	a5,a2
8000cab4:	8736                	mv	a4,a3
8000cab6:	00f103a3          	sb	a5,7(sp)
8000caba:	87ba                	mv	a5,a4
8000cabc:	00f10323          	sb	a5,6(sp)
    if (initial & 1) {
8000cac0:	00614783          	lbu	a5,6(sp)
8000cac4:	8b85                	and	a5,a5,1
8000cac6:	cf91                	beqz	a5,8000cae2 <.L25>
        ptr->DO[port].SET = 1 << pin;
8000cac8:	00714783          	lbu	a5,7(sp)
8000cacc:	4705                	li	a4,1
8000cace:	00f717b3          	sll	a5,a4,a5
8000cad2:	86be                	mv	a3,a5
8000cad4:	4732                	lw	a4,12(sp)
8000cad6:	47a2                	lw	a5,8(sp)
8000cad8:	07c1                	add	a5,a5,16 # 2000010 <__AXI_SRAM_segment_end__+0xdc0010>
8000cada:	0792                	sll	a5,a5,0x4
8000cadc:	97ba                	add	a5,a5,a4
8000cade:	c3d4                	sw	a3,4(a5)
8000cae0:	a829                	j	8000cafa <.L26>

8000cae2 <.L25>:
    } else {
        ptr->DO[port].CLEAR = 1 << pin;
8000cae2:	00714783          	lbu	a5,7(sp)
8000cae6:	4705                	li	a4,1
8000cae8:	00f717b3          	sll	a5,a4,a5
8000caec:	86be                	mv	a3,a5
8000caee:	4732                	lw	a4,12(sp)
8000caf0:	47a2                	lw	a5,8(sp)
8000caf2:	07c1                	add	a5,a5,16
8000caf4:	0792                	sll	a5,a5,0x4
8000caf6:	97ba                	add	a5,a5,a4
8000caf8:	c794                	sw	a3,8(a5)

8000cafa <.L26>:
    }
    ptr->OE[port].SET = 1 << pin;
8000cafa:	00714783          	lbu	a5,7(sp)
8000cafe:	4705                	li	a4,1
8000cb00:	00f717b3          	sll	a5,a4,a5
8000cb04:	86be                	mv	a3,a5
8000cb06:	4732                	lw	a4,12(sp)
8000cb08:	47a2                	lw	a5,8(sp)
8000cb0a:	02078793          	add	a5,a5,32
8000cb0e:	0792                	sll	a5,a5,0x4
8000cb10:	97ba                	add	a5,a5,a4
8000cb12:	c3d4                	sw	a3,4(a5)
}
8000cb14:	0001                	nop
8000cb16:	0141                	add	sp,sp,16
8000cb18:	8082                	ret

Disassembly of section .text.gptmr_channel_reset_count:

8000cb1a <gptmr_channel_reset_count>:
{
8000cb1a:	1141                	add	sp,sp,-16
8000cb1c:	c62a                	sw	a0,12(sp)
8000cb1e:	87ae                	mv	a5,a1
8000cb20:	00f105a3          	sb	a5,11(sp)
    ptr->CHANNEL[ch_index].CR |= GPTMR_CHANNEL_CR_CNTRST_MASK;
8000cb24:	00b14783          	lbu	a5,11(sp)
8000cb28:	4732                	lw	a4,12(sp)
8000cb2a:	079a                	sll	a5,a5,0x6
8000cb2c:	97ba                	add	a5,a5,a4
8000cb2e:	4394                	lw	a3,0(a5)
8000cb30:	00b14783          	lbu	a5,11(sp)
8000cb34:	6711                	lui	a4,0x4
8000cb36:	8f55                	or	a4,a4,a3
8000cb38:	46b2                	lw	a3,12(sp)
8000cb3a:	079a                	sll	a5,a5,0x6
8000cb3c:	97b6                	add	a5,a5,a3
8000cb3e:	c398                	sw	a4,0(a5)
    ptr->CHANNEL[ch_index].CR &= ~GPTMR_CHANNEL_CR_CNTRST_MASK;
8000cb40:	00b14783          	lbu	a5,11(sp)
8000cb44:	4732                	lw	a4,12(sp)
8000cb46:	079a                	sll	a5,a5,0x6
8000cb48:	97ba                	add	a5,a5,a4
8000cb4a:	4394                	lw	a3,0(a5)
8000cb4c:	00b14783          	lbu	a5,11(sp)
8000cb50:	7771                	lui	a4,0xffffc
8000cb52:	177d                	add	a4,a4,-1 # ffffbfff <__AHB_SRAM_segment_end__+0xfdf3fff>
8000cb54:	8f75                	and	a4,a4,a3
8000cb56:	46b2                	lw	a3,12(sp)
8000cb58:	079a                	sll	a5,a5,0x6
8000cb5a:	97b6                	add	a5,a5,a3
8000cb5c:	c398                	sw	a4,0(a5)
}
8000cb5e:	0001                	nop
8000cb60:	0141                	add	sp,sp,16
8000cb62:	8082                	ret

Disassembly of section .text.gptmr_channel_set_capmode:

8000cb64 <gptmr_channel_set_capmode>:
{
8000cb64:	1141                	add	sp,sp,-16
8000cb66:	c62a                	sw	a0,12(sp)
8000cb68:	87ae                	mv	a5,a1
8000cb6a:	8732                	mv	a4,a2
8000cb6c:	00f105a3          	sb	a5,11(sp)
8000cb70:	87ba                	mv	a5,a4
8000cb72:	00f10523          	sb	a5,10(sp)
    ptr->CHANNEL[ch_index].CR = (ptr->CHANNEL[ch_index].CR & ~GPTMR_CHANNEL_CR_CAPMODE_MASK) | GPTMR_CHANNEL_CR_CAPMODE_SET(mode);
8000cb76:	00b14783          	lbu	a5,11(sp)
8000cb7a:	4732                	lw	a4,12(sp)
8000cb7c:	079a                	sll	a5,a5,0x6
8000cb7e:	97ba                	add	a5,a5,a4
8000cb80:	439c                	lw	a5,0(a5)
8000cb82:	ff87f693          	and	a3,a5,-8
8000cb86:	00a14783          	lbu	a5,10(sp)
8000cb8a:	0077f713          	and	a4,a5,7
8000cb8e:	00b14783          	lbu	a5,11(sp)
8000cb92:	8f55                	or	a4,a4,a3
8000cb94:	46b2                	lw	a3,12(sp)
8000cb96:	079a                	sll	a5,a5,0x6
8000cb98:	97b6                	add	a5,a5,a3
8000cb9a:	c398                	sw	a4,0(a5)
}
8000cb9c:	0001                	nop
8000cb9e:	0141                	add	sp,sp,16
8000cba0:	8082                	ret

Disassembly of section .text.gptmr_update_cmp:

8000cba2 <gptmr_update_cmp>:
{
8000cba2:	1141                	add	sp,sp,-16
8000cba4:	c62a                	sw	a0,12(sp)
8000cba6:	87ae                	mv	a5,a1
8000cba8:	8732                	mv	a4,a2
8000cbaa:	c236                	sw	a3,4(sp)
8000cbac:	00f105a3          	sb	a5,11(sp)
8000cbb0:	87ba                	mv	a5,a4
8000cbb2:	00f10523          	sb	a5,10(sp)
    if ((cmp > 0) && (cmp != 0xFFFFFFFFu)) {
8000cbb6:	4792                	lw	a5,4(sp)
8000cbb8:	cb81                	beqz	a5,8000cbc8 <.L13>
8000cbba:	4712                	lw	a4,4(sp)
8000cbbc:	57fd                	li	a5,-1
8000cbbe:	00f70563          	beq	a4,a5,8000cbc8 <.L13>
        cmp--;
8000cbc2:	4792                	lw	a5,4(sp)
8000cbc4:	17fd                	add	a5,a5,-1
8000cbc6:	c23e                	sw	a5,4(sp)

8000cbc8 <.L13>:
    ptr->CHANNEL[ch_index].CMP[cmp_index] = GPTMR_CHANNEL_CMP_CMP_SET(cmp);
8000cbc8:	00b14683          	lbu	a3,11(sp)
8000cbcc:	00a14783          	lbu	a5,10(sp)
8000cbd0:	4732                	lw	a4,12(sp)
8000cbd2:	0692                	sll	a3,a3,0x4
8000cbd4:	97b6                	add	a5,a5,a3
8000cbd6:	078a                	sll	a5,a5,0x2
8000cbd8:	97ba                	add	a5,a5,a4
8000cbda:	4712                	lw	a4,4(sp)
8000cbdc:	c3d8                	sw	a4,4(a5)
}
8000cbde:	0001                	nop
8000cbe0:	0141                	add	sp,sp,16
8000cbe2:	8082                	ret

Disassembly of section .text.gptmr_channel_config_update_reload:

8000cbe4 <gptmr_channel_config_update_reload>:
{
8000cbe4:	1141                	add	sp,sp,-16
8000cbe6:	c62a                	sw	a0,12(sp)
8000cbe8:	87ae                	mv	a5,a1
8000cbea:	c232                	sw	a2,4(sp)
8000cbec:	00f105a3          	sb	a5,11(sp)
    if ((reload > 0) && (reload != 0xFFFFFFFFu)) {
8000cbf0:	4792                	lw	a5,4(sp)
8000cbf2:	cb81                	beqz	a5,8000cc02 <.L17>
8000cbf4:	4712                	lw	a4,4(sp)
8000cbf6:	57fd                	li	a5,-1
8000cbf8:	00f70563          	beq	a4,a5,8000cc02 <.L17>
        reload--;
8000cbfc:	4792                	lw	a5,4(sp)
8000cbfe:	17fd                	add	a5,a5,-1
8000cc00:	c23e                	sw	a5,4(sp)

8000cc02 <.L17>:
    ptr->CHANNEL[ch_index].RLD = GPTMR_CHANNEL_RLD_RLD_SET(reload);
8000cc02:	00b14783          	lbu	a5,11(sp)
8000cc06:	4732                	lw	a4,12(sp)
8000cc08:	079a                	sll	a5,a5,0x6
8000cc0a:	97ba                	add	a5,a5,a4
8000cc0c:	4712                	lw	a4,4(sp)
8000cc0e:	c7d8                	sw	a4,12(a5)
}
8000cc10:	0001                	nop
8000cc12:	0141                	add	sp,sp,16
8000cc14:	8082                	ret

Disassembly of section .text.gptmr_channel_disable_monitor:

8000cc16 <gptmr_channel_disable_monitor>:
 *
 * @param [in] ptr GPTMR base address
 * @param [in] ch_index channel index
 */
static inline void gptmr_channel_disable_monitor(GPTMR_Type *ptr, uint8_t ch_index)
{
8000cc16:	1141                	add	sp,sp,-16
8000cc18:	c62a                	sw	a0,12(sp)
8000cc1a:	87ae                	mv	a5,a1
8000cc1c:	00f105a3          	sb	a5,11(sp)
    ptr->CHANNEL[ch_index].CR &= ~GPTMR_CHANNEL_CR_MONITOR_EN_MASK;
8000cc20:	00b14783          	lbu	a5,11(sp)
8000cc24:	4732                	lw	a4,12(sp)
8000cc26:	079a                	sll	a5,a5,0x6
8000cc28:	97ba                	add	a5,a5,a4
8000cc2a:	4394                	lw	a3,0(a5)
8000cc2c:	00b14783          	lbu	a5,11(sp)
8000cc30:	7761                	lui	a4,0xffff8
8000cc32:	177d                	add	a4,a4,-1 # ffff7fff <__AHB_SRAM_segment_end__+0xfdeffff>
8000cc34:	8f75                	and	a4,a4,a3
8000cc36:	46b2                	lw	a3,12(sp)
8000cc38:	079a                	sll	a5,a5,0x6
8000cc3a:	97b6                	add	a5,a5,a3
8000cc3c:	c398                	sw	a4,0(a5)
}
8000cc3e:	0001                	nop
8000cc40:	0141                	add	sp,sp,16
8000cc42:	8082                	ret

Disassembly of section .text.gptmr_channel_set_monitor_type:

8000cc44 <gptmr_channel_set_monitor_type>:
 * @param [in] ptr GPTMR base address
 * @param [in] ch_index channel index
 * @param [in] type gptmr_channel_monitor_type_t
 */
static inline void gptmr_channel_set_monitor_type(GPTMR_Type *ptr, uint8_t ch_index, gptmr_channel_monitor_type_t type)
{
8000cc44:	1141                	add	sp,sp,-16
8000cc46:	c62a                	sw	a0,12(sp)
8000cc48:	87ae                	mv	a5,a1
8000cc4a:	8732                	mv	a4,a2
8000cc4c:	00f105a3          	sb	a5,11(sp)
8000cc50:	87ba                	mv	a5,a4
8000cc52:	00f10523          	sb	a5,10(sp)
    ptr->CHANNEL[ch_index].CR = (ptr->CHANNEL[ch_index].CR & ~GPTMR_CHANNEL_CR_MONITOR_SEL_MASK) | GPTMR_CHANNEL_CR_MONITOR_SEL_SET(type);
8000cc56:	00b14783          	lbu	a5,11(sp)
8000cc5a:	4732                	lw	a4,12(sp)
8000cc5c:	079a                	sll	a5,a5,0x6
8000cc5e:	97ba                	add	a5,a5,a4
8000cc60:	4398                	lw	a4,0(a5)
8000cc62:	77c1                	lui	a5,0xffff0
8000cc64:	17fd                	add	a5,a5,-1 # fffeffff <__AHB_SRAM_segment_end__+0xfde7fff>
8000cc66:	00f776b3          	and	a3,a4,a5
8000cc6a:	00a14783          	lbu	a5,10(sp)
8000cc6e:	01079713          	sll	a4,a5,0x10
8000cc72:	67c1                	lui	a5,0x10
8000cc74:	8f7d                	and	a4,a4,a5
8000cc76:	00b14783          	lbu	a5,11(sp)
8000cc7a:	8f55                	or	a4,a4,a3
8000cc7c:	46b2                	lw	a3,12(sp)
8000cc7e:	079a                	sll	a5,a5,0x6
8000cc80:	97b6                	add	a5,a5,a3
8000cc82:	c398                	sw	a4,0(a5)
}
8000cc84:	0001                	nop
8000cc86:	0141                	add	sp,sp,16
8000cc88:	8082                	ret

Disassembly of section .text.pllctlv2_pll_is_stable:

8000cc8a <pllctlv2_pll_is_stable>:
 * @param [in] ptr Base address of the PLLCTLV2 peripheral
 * @param [in] pll Index of the PLL to check (pllctlv2_pll0 through pllctlv2_pll6)
 * @return true if the PLL is stable and locked, false otherwise
 */
static inline bool pllctlv2_pll_is_stable(PLLCTLV2_Type *ptr, pllctlv2_pll_t pll)
{
8000cc8a:	1101                	add	sp,sp,-32
8000cc8c:	c62a                	sw	a0,12(sp)
8000cc8e:	87ae                	mv	a5,a1
8000cc90:	00f105a3          	sb	a5,11(sp)
    uint32_t status = ptr->PLL[pll].MFI;
8000cc94:	00b14783          	lbu	a5,11(sp)
8000cc98:	4732                	lw	a4,12(sp)
8000cc9a:	0785                	add	a5,a5,1 # 10001 <__AXI_SRAM_segment_used_size__+0x6aa5>
8000cc9c:	079e                	sll	a5,a5,0x7
8000cc9e:	97ba                	add	a5,a5,a4
8000cca0:	439c                	lw	a5,0(a5)
8000cca2:	ce3e                	sw	a5,28(sp)
    return (IS_HPM_BITMASK_CLR(status, PLLCTLV2_PLL_MFI_ENABLE_MASK)
8000cca4:	4772                	lw	a4,28(sp)
8000cca6:	100007b7          	lui	a5,0x10000
8000ccaa:	8ff9                	and	a5,a5,a4
         || (IS_HPM_BITMASK_CLR(status, PLLCTLV2_PLL_MFI_BUSY_MASK) && IS_HPM_BITMASK_SET(status, PLLCTLV2_PLL_MFI_RESPONSE_MASK)));
8000ccac:	cb89                	beqz	a5,8000ccbe <.L2>
8000ccae:	47f2                	lw	a5,28(sp)
8000ccb0:	0007c963          	bltz	a5,8000ccc2 <.L3>
8000ccb4:	4772                	lw	a4,28(sp)
8000ccb6:	200007b7          	lui	a5,0x20000
8000ccba:	8ff9                	and	a5,a5,a4
8000ccbc:	c399                	beqz	a5,8000ccc2 <.L3>

8000ccbe <.L2>:
8000ccbe:	4785                	li	a5,1
8000ccc0:	a011                	j	8000ccc4 <.L4>

8000ccc2 <.L3>:
8000ccc2:	4781                	li	a5,0

8000ccc4 <.L4>:
8000ccc4:	8b85                	and	a5,a5,1
8000ccc6:	0ff7f793          	zext.b	a5,a5
}
8000ccca:	853e                	mv	a0,a5
8000cccc:	6105                	add	sp,sp,32
8000ccce:	8082                	ret

Disassembly of section .text.pllctlv2_get_pll_freq_in_hz:

8000ccd0 <pllctlv2_get_pll_freq_in_hz>:
        }
    }
}

uint32_t pllctlv2_get_pll_freq_in_hz(PLLCTLV2_Type *ptr, pllctlv2_pll_t pll)
{
8000ccd0:	7139                	add	sp,sp,-64
8000ccd2:	de06                	sw	ra,60(sp)
8000ccd4:	c62a                	sw	a0,12(sp)
8000ccd6:	87ae                	mv	a5,a1
8000ccd8:	00f105a3          	sb	a5,11(sp)
    uint32_t freq = 0;
8000ccdc:	d602                	sw	zero,44(sp)
    if ((ptr != NULL) && (pll < PLLCTL_SOC_PLL_MAX_COUNT)) {
8000ccde:	47b2                	lw	a5,12(sp)
8000cce0:	12078263          	beqz	a5,8000ce04 <.L36>
8000cce4:	00b14703          	lbu	a4,11(sp)
8000cce8:	4789                	li	a5,2
8000ccea:	10e7ed63          	bltu	a5,a4,8000ce04 <.L36>

8000ccee <.LBB3>:
        uint32_t mfi = PLLCTLV2_PLL_MFI_MFI_GET(ptr->PLL[pll].MFI);
8000ccee:	00b14783          	lbu	a5,11(sp)
8000ccf2:	4732                	lw	a4,12(sp)
8000ccf4:	0785                	add	a5,a5,1 # 20000001 <__AXI_SRAM_segment_end__+0x1edc0001>
8000ccf6:	079e                	sll	a5,a5,0x7
8000ccf8:	97ba                	add	a5,a5,a4
8000ccfa:	439c                	lw	a5,0(a5)
8000ccfc:	07f7f793          	and	a5,a5,127
8000cd00:	d23e                	sw	a5,36(sp)
        uint32_t mfn = PLLCTLV2_PLL_MFN_MFN_GET(ptr->PLL[pll].MFN);
8000cd02:	00b14783          	lbu	a5,11(sp)
8000cd06:	4732                	lw	a4,12(sp)
8000cd08:	0785                	add	a5,a5,1
8000cd0a:	079e                	sll	a5,a5,0x7
8000cd0c:	97ba                	add	a5,a5,a4
8000cd0e:	43d8                	lw	a4,4(a5)
8000cd10:	400007b7          	lui	a5,0x40000
8000cd14:	17fd                	add	a5,a5,-1 # 3fffffff <__AXI_SRAM_segment_end__+0x3edbffff>
8000cd16:	8ff9                	and	a5,a5,a4
8000cd18:	d03e                	sw	a5,32(sp)
        uint32_t mfd = PLLCTLV2_PLL_MFD_MFD_GET(ptr->PLL[pll].MFD);
8000cd1a:	00b14783          	lbu	a5,11(sp)
8000cd1e:	4732                	lw	a4,12(sp)
8000cd20:	0785                	add	a5,a5,1
8000cd22:	079e                	sll	a5,a5,0x7
8000cd24:	97ba                	add	a5,a5,a4
8000cd26:	4798                	lw	a4,8(a5)
8000cd28:	400007b7          	lui	a5,0x40000
8000cd2c:	17fd                	add	a5,a5,-1 # 3fffffff <__AXI_SRAM_segment_end__+0x3edbffff>
8000cd2e:	8ff9                	and	a5,a5,a4
8000cd30:	ce3e                	sw	a5,28(sp)
        /* Trade-off for avoiding the float computing.
         * Ensure both `mfd` and `PLLCTLV2_PLL_XTAL_FREQ` are n * `FREQ_1MHz`, n is a positive integer
         */
        assert((mfd / FREQ_1MHz) * FREQ_1MHz == mfd);
8000cd32:	4772                	lw	a4,28(sp)
8000cd34:	000f47b7          	lui	a5,0xf4
8000cd38:	24078793          	add	a5,a5,576 # f4240 <__AXI_SRAM_segment_size__+0xb4240>
8000cd3c:	02f777b3          	remu	a5,a4,a5
8000cd40:	cf89                	beqz	a5,8000cd5a <.L37>
8000cd42:	07400613          	li	a2,116
8000cd46:	800077b7          	lui	a5,0x80007
8000cd4a:	64478593          	add	a1,a5,1604 # 80007644 <.LC0>
8000cd4e:	800077b7          	lui	a5,0x80007
8000cd52:	68478513          	add	a0,a5,1668 # 80007684 <.LC1>
8000cd56:	4de060ef          	jal	80013234 <__SEGGER_RTL_X_assert>

8000cd5a <.L37>:
        assert((PLLCTLV2_PLL_XTAL_FREQ / FREQ_1MHz) * FREQ_1MHz == PLLCTLV2_PLL_XTAL_FREQ);

        uint32_t scaled_num;
        uint32_t scaled_denom;
        uint32_t shifted_mfn;
        uint32_t max_mfn = 0xFFFFFFFF / (PLLCTLV2_PLL_XTAL_FREQ / FREQ_1MHz);
8000cd5a:	0aaab7b7          	lui	a5,0xaaab
8000cd5e:	aaa78793          	add	a5,a5,-1366 # aaaaaaa <__AXI_SRAM_segment_end__+0x986aaaa>
8000cd62:	cc3e                	sw	a5,24(sp)
        if (mfn < max_mfn) {
8000cd64:	5702                	lw	a4,32(sp)
8000cd66:	47e2                	lw	a5,24(sp)
8000cd68:	02f77e63          	bgeu	a4,a5,8000cda4 <.L38>
            scaled_num =  (PLLCTLV2_PLL_XTAL_FREQ / FREQ_1MHz) * mfn;
8000cd6c:	5702                	lw	a4,32(sp)
8000cd6e:	87ba                	mv	a5,a4
8000cd70:	0786                	sll	a5,a5,0x1
8000cd72:	97ba                	add	a5,a5,a4
8000cd74:	078e                	sll	a5,a5,0x3
8000cd76:	c83e                	sw	a5,16(sp)
            scaled_denom = mfd / FREQ_1MHz;
8000cd78:	4772                	lw	a4,28(sp)
8000cd7a:	000f47b7          	lui	a5,0xf4
8000cd7e:	24078793          	add	a5,a5,576 # f4240 <__AXI_SRAM_segment_size__+0xb4240>
8000cd82:	02f757b3          	divu	a5,a4,a5
8000cd86:	ca3e                	sw	a5,20(sp)
            freq = PLLCTLV2_PLL_XTAL_FREQ * mfi + scaled_num / scaled_denom;
8000cd88:	5712                	lw	a4,36(sp)
8000cd8a:	016e37b7          	lui	a5,0x16e3
8000cd8e:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
8000cd92:	02f70733          	mul	a4,a4,a5
8000cd96:	46c2                	lw	a3,16(sp)
8000cd98:	47d2                	lw	a5,20(sp)
8000cd9a:	02f6d7b3          	divu	a5,a3,a5
8000cd9e:	97ba                	add	a5,a5,a4
8000cda0:	d63e                	sw	a5,44(sp)
8000cda2:	a08d                	j	8000ce04 <.L36>

8000cda4 <.L38>:
        } else {
            shifted_mfn = mfn;
8000cda4:	5782                	lw	a5,32(sp)
8000cda6:	d43e                	sw	a5,40(sp)
            while (shifted_mfn > max_mfn) {
8000cda8:	a021                	j	8000cdb0 <.L39>

8000cdaa <.L40>:
                shifted_mfn >>= 1;
8000cdaa:	57a2                	lw	a5,40(sp)
8000cdac:	8385                	srl	a5,a5,0x1
8000cdae:	d43e                	sw	a5,40(sp)

8000cdb0 <.L39>:
            while (shifted_mfn > max_mfn) {
8000cdb0:	5722                	lw	a4,40(sp)
8000cdb2:	47e2                	lw	a5,24(sp)
8000cdb4:	fee7ebe3          	bltu	a5,a4,8000cdaa <.L40>
            }
            scaled_denom = mfd / FREQ_1MHz;
8000cdb8:	4772                	lw	a4,28(sp)
8000cdba:	000f47b7          	lui	a5,0xf4
8000cdbe:	24078793          	add	a5,a5,576 # f4240 <__AXI_SRAM_segment_size__+0xb4240>
8000cdc2:	02f757b3          	divu	a5,a4,a5
8000cdc6:	ca3e                	sw	a5,20(sp)
            freq = PLLCTLV2_PLL_XTAL_FREQ * mfi + ((PLLCTLV2_PLL_XTAL_FREQ / FREQ_1MHz) * shifted_mfn) / scaled_denom +  ((PLLCTLV2_PLL_XTAL_FREQ / FREQ_1MHz) * (mfn - shifted_mfn)) / scaled_denom;
8000cdc8:	5712                	lw	a4,36(sp)
8000cdca:	016e37b7          	lui	a5,0x16e3
8000cdce:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
8000cdd2:	02f706b3          	mul	a3,a4,a5
8000cdd6:	5722                	lw	a4,40(sp)
8000cdd8:	87ba                	mv	a5,a4
8000cdda:	0786                	sll	a5,a5,0x1
8000cddc:	97ba                	add	a5,a5,a4
8000cdde:	078e                	sll	a5,a5,0x3
8000cde0:	873e                	mv	a4,a5
8000cde2:	47d2                	lw	a5,20(sp)
8000cde4:	02f757b3          	divu	a5,a4,a5
8000cde8:	96be                	add	a3,a3,a5
8000cdea:	5702                	lw	a4,32(sp)
8000cdec:	57a2                	lw	a5,40(sp)
8000cdee:	8f1d                	sub	a4,a4,a5
8000cdf0:	87ba                	mv	a5,a4
8000cdf2:	0786                	sll	a5,a5,0x1
8000cdf4:	97ba                	add	a5,a5,a4
8000cdf6:	078e                	sll	a5,a5,0x3
8000cdf8:	873e                	mv	a4,a5
8000cdfa:	47d2                	lw	a5,20(sp)
8000cdfc:	02f757b3          	divu	a5,a4,a5
8000ce00:	97b6                	add	a5,a5,a3
8000ce02:	d63e                	sw	a5,44(sp)

8000ce04 <.L36>:
        }
    }
    return freq;
8000ce04:	57b2                	lw	a5,44(sp)
}
8000ce06:	853e                	mv	a0,a5
8000ce08:	50f2                	lw	ra,60(sp)
8000ce0a:	6121                	add	sp,sp,64
8000ce0c:	8082                	ret

Disassembly of section .text.e2p_enter_critical:

8000ce0e <e2p_enter_critical>:
#include "hpm_nor_flash.h"
#include "hpm_l1c_drv.h"
#include "board.h"

void e2p_enter_critical(void)
{
8000ce0e:	1141                	add	sp,sp,-16
8000ce10:	47a1                	li	a5,8
8000ce12:	c63e                	sw	a5,12(sp)

8000ce14 <.LBB7>:
    return read_clear_csr(CSR_MSTATUS, mask);
8000ce14:	c402                	sw	zero,8(sp)
8000ce16:	47b2                	lw	a5,12(sp)
8000ce18:	3007b7f3          	csrrc	a5,mstatus,a5
8000ce1c:	c43e                	sw	a5,8(sp)
8000ce1e:	47a2                	lw	a5,8(sp)

8000ce20 <.LBE9>:
8000ce20:	0001                	nop

8000ce22 <.LBE7>:
    disable_global_irq(CSR_MSTATUS_MIE_MASK);
}
8000ce22:	0001                	nop
8000ce24:	0141                	add	sp,sp,16
8000ce26:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_xtoa:

8000ce28 <__SEGGER_RTL_xltoa>:
8000ce28:	882a                	mv	a6,a0
8000ce2a:	88ae                	mv	a7,a1
8000ce2c:	852e                	mv	a0,a1
8000ce2e:	ca89                	beqz	a3,8000ce40 <.L2>
8000ce30:	02d00793          	li	a5,45
8000ce34:	00158893          	add	a7,a1,1 # 40000001 <__AXI_SRAM_segment_end__+0x3edc0001>
8000ce38:	00f58023          	sb	a5,0(a1)
8000ce3c:	41000833          	neg	a6,a6

8000ce40 <.L2>:
8000ce40:	8746                	mv	a4,a7
8000ce42:	4325                	li	t1,9

8000ce44 <.L5>:
8000ce44:	02c876b3          	remu	a3,a6,a2
8000ce48:	85c2                	mv	a1,a6
8000ce4a:	0ff6f793          	zext.b	a5,a3
8000ce4e:	02c85833          	divu	a6,a6,a2
8000ce52:	02d37d63          	bgeu	t1,a3,8000ce8c <.L3>
8000ce56:	05778793          	add	a5,a5,87

8000ce5a <.L11>:
8000ce5a:	0ff7f793          	zext.b	a5,a5
8000ce5e:	00f70023          	sb	a5,0(a4)
8000ce62:	00170693          	add	a3,a4,1
8000ce66:	02c5f163          	bgeu	a1,a2,8000ce88 <.L8>
8000ce6a:	000700a3          	sb	zero,1(a4)

8000ce6e <.L6>:
8000ce6e:	0008c683          	lbu	a3,0(a7)
8000ce72:	00074783          	lbu	a5,0(a4)
8000ce76:	0885                	add	a7,a7,1
8000ce78:	177d                	add	a4,a4,-1
8000ce7a:	00d700a3          	sb	a3,1(a4)
8000ce7e:	fef88fa3          	sb	a5,-1(a7)
8000ce82:	fee8e6e3          	bltu	a7,a4,8000ce6e <.L6>
8000ce86:	8082                	ret

8000ce88 <.L8>:
8000ce88:	8736                	mv	a4,a3
8000ce8a:	bf6d                	j	8000ce44 <.L5>

8000ce8c <.L3>:
8000ce8c:	03078793          	add	a5,a5,48
8000ce90:	b7e9                	j	8000ce5a <.L11>

Disassembly of section .text.libc.itoa:

8000ce92 <itoa>:
8000ce92:	46a9                	li	a3,10
8000ce94:	87aa                	mv	a5,a0
8000ce96:	882e                	mv	a6,a1
8000ce98:	8732                	mv	a4,a2
8000ce9a:	00d61563          	bne	a2,a3,8000cea4 <.L301>
8000ce9e:	4685                	li	a3,1
8000cea0:	00054663          	bltz	a0,8000ceac <.L302>

8000cea4 <.L301>:
8000cea4:	4681                	li	a3,0
8000cea6:	863a                	mv	a2,a4
8000cea8:	85c2                	mv	a1,a6
8000ceaa:	853e                	mv	a0,a5

8000ceac <.L302>:
8000ceac:	bfb5                	j	8000ce28 <__SEGGER_RTL_xltoa>

Disassembly of section .text.libc.fwrite:

8000ceae <fwrite>:
8000ceae:	1101                	add	sp,sp,-32
8000ceb0:	c64e                	sw	s3,12(sp)
8000ceb2:	89aa                	mv	s3,a0
8000ceb4:	8536                	mv	a0,a3
8000ceb6:	cc22                	sw	s0,24(sp)
8000ceb8:	ca26                	sw	s1,20(sp)
8000ceba:	c84a                	sw	s2,16(sp)
8000cebc:	ce06                	sw	ra,28(sp)
8000cebe:	84ae                	mv	s1,a1
8000cec0:	8432                	mv	s0,a2
8000cec2:	8936                	mv	s2,a3
8000cec4:	266060ef          	jal	8001312a <__SEGGER_RTL_X_file_stat>
8000cec8:	02054463          	bltz	a0,8000cef0 <.L43>
8000cecc:	02848633          	mul	a2,s1,s0
8000ced0:	4501                	li	a0,0
8000ced2:	00966863          	bltu	a2,s1,8000cee2 <.L41>
8000ced6:	85ce                	mv	a1,s3
8000ced8:	854a                	mv	a0,s2
8000ceda:	1dc060ef          	jal	800130b6 <__SEGGER_RTL_X_file_write>
8000cede:	02955533          	divu	a0,a0,s1

8000cee2 <.L41>:
8000cee2:	40f2                	lw	ra,28(sp)
8000cee4:	4462                	lw	s0,24(sp)
8000cee6:	44d2                	lw	s1,20(sp)
8000cee8:	4942                	lw	s2,16(sp)
8000ceea:	49b2                	lw	s3,12(sp)
8000ceec:	6105                	add	sp,sp,32
8000ceee:	8082                	ret

8000cef0 <.L43>:
8000cef0:	4501                	li	a0,0
8000cef2:	bfc5                	j	8000cee2 <.L41>

Disassembly of section .text.libc.__subsf3:

8000cef4 <__subsf3>:
8000cef4:	80000637          	lui	a2,0x80000
8000cef8:	8db1                	xor	a1,a1,a2
8000cefa:	a009                	j	8000cefc <__addsf3>

Disassembly of section .text.libc.__addsf3:

8000cefc <__addsf3>:
8000cefc:	80000637          	lui	a2,0x80000
8000cf00:	00b546b3          	xor	a3,a0,a1
8000cf04:	0806ca63          	bltz	a3,8000cf98 <.L__addsf3_subtract>
8000cf08:	00b57563          	bgeu	a0,a1,8000cf12 <.L__addsf3_add_already_ordered>
8000cf0c:	86aa                	mv	a3,a0
8000cf0e:	852e                	mv	a0,a1
8000cf10:	85b6                	mv	a1,a3

8000cf12 <.L__addsf3_add_already_ordered>:
8000cf12:	00151713          	sll	a4,a0,0x1
8000cf16:	8361                	srl	a4,a4,0x18
8000cf18:	00159693          	sll	a3,a1,0x1
8000cf1c:	82e1                	srl	a3,a3,0x18
8000cf1e:	0ff00293          	li	t0,255
8000cf22:	06570563          	beq	a4,t0,8000cf8c <.L__addsf3_add_inf_or_nan>
8000cf26:	c325                	beqz	a4,8000cf86 <.L__addsf3_zero>
8000cf28:	ceb1                	beqz	a3,8000cf84 <.L__addsf3_add_done>
8000cf2a:	40d706b3          	sub	a3,a4,a3
8000cf2e:	42e1                	li	t0,24
8000cf30:	04d2ca63          	blt	t0,a3,8000cf84 <.L__addsf3_add_done>
8000cf34:	05a2                	sll	a1,a1,0x8
8000cf36:	8dd1                	or	a1,a1,a2
8000cf38:	01755713          	srl	a4,a0,0x17
8000cf3c:	0522                	sll	a0,a0,0x8
8000cf3e:	8d51                	or	a0,a0,a2
8000cf40:	47e5                	li	a5,25
8000cf42:	8f95                	sub	a5,a5,a3
8000cf44:	00f59633          	sll	a2,a1,a5
8000cf48:	821d                	srl	a2,a2,0x7
8000cf4a:	00d5d5b3          	srl	a1,a1,a3
8000cf4e:	00b507b3          	add	a5,a0,a1
8000cf52:	00a7f463          	bgeu	a5,a0,8000cf5a <.L__addsf3_add_no_normalization>
8000cf56:	8385                	srl	a5,a5,0x1
8000cf58:	0709                	add	a4,a4,2

8000cf5a <.L__addsf3_add_no_normalization>:
8000cf5a:	177d                	add	a4,a4,-1
8000cf5c:	0ff77593          	zext.b	a1,a4
8000cf60:	f0158593          	add	a1,a1,-255
8000cf64:	cd91                	beqz	a1,8000cf80 <.L__addsf3_inf>
8000cf66:	075e                	sll	a4,a4,0x17
8000cf68:	0087d513          	srl	a0,a5,0x8
8000cf6c:	07e2                	sll	a5,a5,0x18
8000cf6e:	8fd1                	or	a5,a5,a2
8000cf70:	0007d663          	bgez	a5,8000cf7c <.L__addsf3_no_tie>
8000cf74:	0786                	sll	a5,a5,0x1
8000cf76:	0505                	add	a0,a0,1 # f4000001 <__AHB_SRAM_segment_end__+0x3df8001>
8000cf78:	e391                	bnez	a5,8000cf7c <.L__addsf3_no_tie>
8000cf7a:	9979                	and	a0,a0,-2

8000cf7c <.L__addsf3_no_tie>:
8000cf7c:	953a                	add	a0,a0,a4
8000cf7e:	8082                	ret

8000cf80 <.L__addsf3_inf>:
8000cf80:	01771513          	sll	a0,a4,0x17

8000cf84 <.L__addsf3_add_done>:
8000cf84:	8082                	ret

8000cf86 <.L__addsf3_zero>:
8000cf86:	817d                	srl	a0,a0,0x1f
8000cf88:	057e                	sll	a0,a0,0x1f
8000cf8a:	8082                	ret

8000cf8c <.L__addsf3_add_inf_or_nan>:
8000cf8c:	00951613          	sll	a2,a0,0x9
8000cf90:	da75                	beqz	a2,8000cf84 <.L__addsf3_add_done>

8000cf92 <.L__addsf3_return_nan>:
8000cf92:	7fc00537          	lui	a0,0x7fc00
8000cf96:	8082                	ret

8000cf98 <.L__addsf3_subtract>:
8000cf98:	8db1                	xor	a1,a1,a2
8000cf9a:	40b506b3          	sub	a3,a0,a1
8000cf9e:	00b57563          	bgeu	a0,a1,8000cfa8 <.L__addsf3_sub_already_ordered>
8000cfa2:	8eb1                	xor	a3,a3,a2
8000cfa4:	8d15                	sub	a0,a0,a3
8000cfa6:	95b6                	add	a1,a1,a3

8000cfa8 <.L__addsf3_sub_already_ordered>:
8000cfa8:	00159693          	sll	a3,a1,0x1
8000cfac:	82e1                	srl	a3,a3,0x18
8000cfae:	00151713          	sll	a4,a0,0x1
8000cfb2:	8361                	srl	a4,a4,0x18
8000cfb4:	05a2                	sll	a1,a1,0x8
8000cfb6:	8dd1                	or	a1,a1,a2
8000cfb8:	0ff00293          	li	t0,255
8000cfbc:	0c570c63          	beq	a4,t0,8000d094 <.L__addsf3_sub_inf_or_nan>
8000cfc0:	c2f5                	beqz	a3,8000d0a4 <.L__addsf3_sub_zero>
8000cfc2:	40d706b3          	sub	a3,a4,a3
8000cfc6:	c695                	beqz	a3,8000cff2 <.L__addsf3_exponents_equal>
8000cfc8:	4285                	li	t0,1
8000cfca:	08569063          	bne	a3,t0,8000d04a <.L__addsf3_exponents_differ_by_more_than_1>
8000cfce:	01755693          	srl	a3,a0,0x17
8000cfd2:	0526                	sll	a0,a0,0x9
8000cfd4:	00b532b3          	sltu	t0,a0,a1
8000cfd8:	8d0d                	sub	a0,a0,a1
8000cfda:	02029263          	bnez	t0,8000cffe <.L__addsf3_normalization_steps>
8000cfde:	06de                	sll	a3,a3,0x17
8000cfe0:	01751593          	sll	a1,a0,0x17
8000cfe4:	8125                	srl	a0,a0,0x9
8000cfe6:	0005d463          	bgez	a1,8000cfee <.L__addsf3_sub_no_tie_single>
8000cfea:	0505                	add	a0,a0,1 # 7fc00001 <__AXI_SRAM_segment_end__+0x7e9c0001>
8000cfec:	9979                	and	a0,a0,-2

8000cfee <.L__addsf3_sub_no_tie_single>:
8000cfee:	9536                	add	a0,a0,a3

8000cff0 <.L__addsf3_sub_done>:
8000cff0:	8082                	ret

8000cff2 <.L__addsf3_exponents_equal>:
8000cff2:	01755693          	srl	a3,a0,0x17
8000cff6:	0526                	sll	a0,a0,0x9
8000cff8:	0586                	sll	a1,a1,0x1
8000cffa:	8d0d                	sub	a0,a0,a1
8000cffc:	d975                	beqz	a0,8000cff0 <.L__addsf3_sub_done>

8000cffe <.L__addsf3_normalization_steps>:
8000cffe:	4581                	li	a1,0
8000d000:	01055793          	srl	a5,a0,0x10
8000d004:	e399                	bnez	a5,8000d00a <.L1^B1>
8000d006:	0542                	sll	a0,a0,0x10
8000d008:	05c1                	add	a1,a1,16

8000d00a <.L1^B1>:
8000d00a:	01855793          	srl	a5,a0,0x18
8000d00e:	e399                	bnez	a5,8000d014 <.L2^B1>
8000d010:	0522                	sll	a0,a0,0x8
8000d012:	05a1                	add	a1,a1,8

8000d014 <.L2^B1>:
8000d014:	01c55793          	srl	a5,a0,0x1c
8000d018:	e399                	bnez	a5,8000d01e <.L3^B1>
8000d01a:	0512                	sll	a0,a0,0x4
8000d01c:	0591                	add	a1,a1,4

8000d01e <.L3^B1>:
8000d01e:	01e55793          	srl	a5,a0,0x1e
8000d022:	e399                	bnez	a5,8000d028 <.L4^B1>
8000d024:	050a                	sll	a0,a0,0x2
8000d026:	0589                	add	a1,a1,2

8000d028 <.L4^B1>:
8000d028:	00054463          	bltz	a0,8000d030 <.L5^B1>
8000d02c:	0506                	sll	a0,a0,0x1
8000d02e:	0585                	add	a1,a1,1

8000d030 <.L5^B1>:
8000d030:	0585                	add	a1,a1,1
8000d032:	0506                	sll	a0,a0,0x1
8000d034:	00e5f763          	bgeu	a1,a4,8000d042 <.L__addsf3_underflow>
8000d038:	8e8d                	sub	a3,a3,a1
8000d03a:	06de                	sll	a3,a3,0x17
8000d03c:	8125                	srl	a0,a0,0x9
8000d03e:	9536                	add	a0,a0,a3
8000d040:	8082                	ret

8000d042 <.L__addsf3_underflow>:
8000d042:	0086d513          	srl	a0,a3,0x8
8000d046:	057e                	sll	a0,a0,0x1f
8000d048:	8082                	ret

8000d04a <.L__addsf3_exponents_differ_by_more_than_1>:
8000d04a:	42e5                	li	t0,25
8000d04c:	fad2e2e3          	bltu	t0,a3,8000cff0 <.L__addsf3_sub_done>
8000d050:	0685                	add	a3,a3,1 # f1700001 <__AHB_SRAM_segment_end__+0x14f8001>
8000d052:	40d00733          	neg	a4,a3
8000d056:	00e59733          	sll	a4,a1,a4
8000d05a:	00d5d5b3          	srl	a1,a1,a3
8000d05e:	00e03733          	snez	a4,a4
8000d062:	95ae                	add	a1,a1,a1
8000d064:	95ba                	add	a1,a1,a4
8000d066:	01755693          	srl	a3,a0,0x17
8000d06a:	0522                	sll	a0,a0,0x8
8000d06c:	8d51                	or	a0,a0,a2
8000d06e:	40b50733          	sub	a4,a0,a1
8000d072:	00074463          	bltz	a4,8000d07a <.L__addsf3_sub_already_normalized>
8000d076:	070a                	sll	a4,a4,0x2
8000d078:	8305                	srl	a4,a4,0x1

8000d07a <.L__addsf3_sub_already_normalized>:
8000d07a:	16fd                	add	a3,a3,-1
8000d07c:	06de                	sll	a3,a3,0x17
8000d07e:	00875513          	srl	a0,a4,0x8
8000d082:	0762                	sll	a4,a4,0x18
8000d084:	00075663          	bgez	a4,8000d090 <.L__addsf3_sub_no_tie>
8000d088:	0706                	sll	a4,a4,0x1
8000d08a:	0505                	add	a0,a0,1
8000d08c:	e311                	bnez	a4,8000d090 <.L__addsf3_sub_no_tie>
8000d08e:	9979                	and	a0,a0,-2

8000d090 <.L__addsf3_sub_no_tie>:
8000d090:	9536                	add	a0,a0,a3
8000d092:	8082                	ret

8000d094 <.L__addsf3_sub_inf_or_nan>:
8000d094:	0ff00293          	li	t0,255
8000d098:	ee568de3          	beq	a3,t0,8000cf92 <.L__addsf3_return_nan>
8000d09c:	00951593          	sll	a1,a0,0x9
8000d0a0:	d9a1                	beqz	a1,8000cff0 <.L__addsf3_sub_done>
8000d0a2:	bdc5                	j	8000cf92 <.L__addsf3_return_nan>

8000d0a4 <.L__addsf3_sub_zero>:
8000d0a4:	f731                	bnez	a4,8000cff0 <.L__addsf3_sub_done>
8000d0a6:	4501                	li	a0,0
8000d0a8:	8082                	ret

Disassembly of section .text.libc.__ltsf2:

8000d0aa <__ltsf2>:
8000d0aa:	ff000637          	lui	a2,0xff000
8000d0ae:	00151693          	sll	a3,a0,0x1
8000d0b2:	02d66763          	bltu	a2,a3,8000d0e0 <.L__ltsf2_zero>
8000d0b6:	00159693          	sll	a3,a1,0x1
8000d0ba:	02d66363          	bltu	a2,a3,8000d0e0 <.L__ltsf2_zero>
8000d0be:	00b56633          	or	a2,a0,a1
8000d0c2:	00161693          	sll	a3,a2,0x1
8000d0c6:	ce89                	beqz	a3,8000d0e0 <.L__ltsf2_zero>
8000d0c8:	00064763          	bltz	a2,8000d0d6 <.L__ltsf2_negative>
8000d0cc:	00b53533          	sltu	a0,a0,a1
8000d0d0:	40a00533          	neg	a0,a0
8000d0d4:	8082                	ret

8000d0d6 <.L__ltsf2_negative>:
8000d0d6:	00a5b533          	sltu	a0,a1,a0
8000d0da:	40a00533          	neg	a0,a0
8000d0de:	8082                	ret

8000d0e0 <.L__ltsf2_zero>:
8000d0e0:	4501                	li	a0,0
8000d0e2:	8082                	ret

Disassembly of section .text.libc.__lesf2:

8000d0e4 <__lesf2>:
8000d0e4:	ff000637          	lui	a2,0xff000
8000d0e8:	00151693          	sll	a3,a0,0x1
8000d0ec:	02d66363          	bltu	a2,a3,8000d112 <.L__lesf2_nan>
8000d0f0:	00159693          	sll	a3,a1,0x1
8000d0f4:	00d66f63          	bltu	a2,a3,8000d112 <.L__lesf2_nan>
8000d0f8:	00b56633          	or	a2,a0,a1
8000d0fc:	00161693          	sll	a3,a2,0x1
8000d100:	ca99                	beqz	a3,8000d116 <.L__lesf2_zero>
8000d102:	00064563          	bltz	a2,8000d10c <.L__lesf2_negative>
8000d106:	00a5b533          	sltu	a0,a1,a0
8000d10a:	8082                	ret

8000d10c <.L__lesf2_negative>:
8000d10c:	00b53533          	sltu	a0,a0,a1
8000d110:	8082                	ret

8000d112 <.L__lesf2_nan>:
8000d112:	4505                	li	a0,1
8000d114:	8082                	ret

8000d116 <.L__lesf2_zero>:
8000d116:	4501                	li	a0,0
8000d118:	8082                	ret

Disassembly of section .text.libc.__gtsf2:

8000d11a <__gtsf2>:
8000d11a:	ff000637          	lui	a2,0xff000
8000d11e:	00151693          	sll	a3,a0,0x1
8000d122:	02d66363          	bltu	a2,a3,8000d148 <.L__gtsf2_zero>
8000d126:	00159693          	sll	a3,a1,0x1
8000d12a:	00d66f63          	bltu	a2,a3,8000d148 <.L__gtsf2_zero>
8000d12e:	00b56633          	or	a2,a0,a1
8000d132:	00161693          	sll	a3,a2,0x1
8000d136:	ca89                	beqz	a3,8000d148 <.L__gtsf2_zero>
8000d138:	00064563          	bltz	a2,8000d142 <.L__gtsf2_negative>
8000d13c:	00a5b533          	sltu	a0,a1,a0
8000d140:	8082                	ret

8000d142 <.L__gtsf2_negative>:
8000d142:	00b53533          	sltu	a0,a0,a1
8000d146:	8082                	ret

8000d148 <.L__gtsf2_zero>:
8000d148:	4501                	li	a0,0
8000d14a:	8082                	ret

Disassembly of section .text.libc.__gesf2:

8000d14c <__gesf2>:
8000d14c:	ff000637          	lui	a2,0xff000
8000d150:	00151693          	sll	a3,a0,0x1
8000d154:	02d66763          	bltu	a2,a3,8000d182 <.L__gesf2_nan>
8000d158:	00159693          	sll	a3,a1,0x1
8000d15c:	02d66363          	bltu	a2,a3,8000d182 <.L__gesf2_nan>
8000d160:	00b56633          	or	a2,a0,a1
8000d164:	00161693          	sll	a3,a2,0x1
8000d168:	ce99                	beqz	a3,8000d186 <.L__gesf2_zero>
8000d16a:	00064763          	bltz	a2,8000d178 <.L__gesf2_negative>
8000d16e:	00b53533          	sltu	a0,a0,a1
8000d172:	40a00533          	neg	a0,a0
8000d176:	8082                	ret

8000d178 <.L__gesf2_negative>:
8000d178:	00a5b533          	sltu	a0,a1,a0
8000d17c:	40a00533          	neg	a0,a0
8000d180:	8082                	ret

8000d182 <.L__gesf2_nan>:
8000d182:	557d                	li	a0,-1
8000d184:	8082                	ret

8000d186 <.L__gesf2_zero>:
8000d186:	4501                	li	a0,0
8000d188:	8082                	ret

Disassembly of section .text.libc.__floatundisf:

8000d18a <__floatundisf>:
8000d18a:	c5bd                	beqz	a1,8000d1f8 <.L__floatundisf_high_word_zero>
8000d18c:	4701                	li	a4,0
8000d18e:	0105d693          	srl	a3,a1,0x10
8000d192:	e299                	bnez	a3,8000d198 <.L8^B3>
8000d194:	0741                	add	a4,a4,16
8000d196:	05c2                	sll	a1,a1,0x10

8000d198 <.L8^B3>:
8000d198:	0185d693          	srl	a3,a1,0x18
8000d19c:	e299                	bnez	a3,8000d1a2 <.L4^B10>
8000d19e:	0721                	add	a4,a4,8
8000d1a0:	05a2                	sll	a1,a1,0x8

8000d1a2 <.L4^B10>:
8000d1a2:	01c5d693          	srl	a3,a1,0x1c
8000d1a6:	e299                	bnez	a3,8000d1ac <.L2^B10>
8000d1a8:	0711                	add	a4,a4,4
8000d1aa:	0592                	sll	a1,a1,0x4

8000d1ac <.L2^B10>:
8000d1ac:	01e5d693          	srl	a3,a1,0x1e
8000d1b0:	e299                	bnez	a3,8000d1b6 <.L1^B10>
8000d1b2:	0709                	add	a4,a4,2
8000d1b4:	058a                	sll	a1,a1,0x2

8000d1b6 <.L1^B10>:
8000d1b6:	0005c463          	bltz	a1,8000d1be <.L0^B3>
8000d1ba:	0705                	add	a4,a4,1
8000d1bc:	0586                	sll	a1,a1,0x1

8000d1be <.L0^B3>:
8000d1be:	fff74613          	not	a2,a4
8000d1c2:	00c556b3          	srl	a3,a0,a2
8000d1c6:	8285                	srl	a3,a3,0x1
8000d1c8:	8dd5                	or	a1,a1,a3
8000d1ca:	00e51533          	sll	a0,a0,a4
8000d1ce:	0be60613          	add	a2,a2,190 # ff0000be <__AHB_SRAM_segment_end__+0xedf80be>
8000d1d2:	00a03533          	snez	a0,a0
8000d1d6:	8dc9                	or	a1,a1,a0

8000d1d8 <.L__floatundisf_round_and_pack>:
8000d1d8:	065e                	sll	a2,a2,0x17
8000d1da:	0085d513          	srl	a0,a1,0x8
8000d1de:	05de                	sll	a1,a1,0x17
8000d1e0:	0005a333          	sltz	t1,a1
8000d1e4:	95ae                	add	a1,a1,a1
8000d1e6:	959a                	add	a1,a1,t1
8000d1e8:	0005d663          	bgez	a1,8000d1f4 <.L__floatundisf_round_down>
8000d1ec:	95ae                	add	a1,a1,a1
8000d1ee:	00b035b3          	snez	a1,a1
8000d1f2:	952e                	add	a0,a0,a1

8000d1f4 <.L__floatundisf_round_down>:
8000d1f4:	9532                	add	a0,a0,a2

8000d1f6 <.L__floatundisf_done>:
8000d1f6:	8082                	ret

8000d1f8 <.L__floatundisf_high_word_zero>:
8000d1f8:	dd7d                	beqz	a0,8000d1f6 <.L__floatundisf_done>
8000d1fa:	09d00613          	li	a2,157
8000d1fe:	01055693          	srl	a3,a0,0x10
8000d202:	e299                	bnez	a3,8000d208 <.L1^B11>
8000d204:	0542                	sll	a0,a0,0x10
8000d206:	1641                	add	a2,a2,-16

8000d208 <.L1^B11>:
8000d208:	01855693          	srl	a3,a0,0x18
8000d20c:	e299                	bnez	a3,8000d212 <.L2^B11>
8000d20e:	0522                	sll	a0,a0,0x8
8000d210:	1661                	add	a2,a2,-8

8000d212 <.L2^B11>:
8000d212:	01c55693          	srl	a3,a0,0x1c
8000d216:	e299                	bnez	a3,8000d21c <.L3^B8>
8000d218:	0512                	sll	a0,a0,0x4
8000d21a:	1671                	add	a2,a2,-4

8000d21c <.L3^B8>:
8000d21c:	01e55693          	srl	a3,a0,0x1e
8000d220:	e299                	bnez	a3,8000d226 <.L4^B11>
8000d222:	050a                	sll	a0,a0,0x2
8000d224:	1679                	add	a2,a2,-2

8000d226 <.L4^B11>:
8000d226:	00054463          	bltz	a0,8000d22e <.L5^B8>
8000d22a:	0506                	sll	a0,a0,0x1
8000d22c:	167d                	add	a2,a2,-1

8000d22e <.L5^B8>:
8000d22e:	85aa                	mv	a1,a0
8000d230:	4501                	li	a0,0
8000d232:	b75d                	j	8000d1d8 <.L__floatundisf_round_and_pack>

Disassembly of section .text.libc.__truncdfsf2:

8000d234 <__truncdfsf2>:
8000d234:	00159693          	sll	a3,a1,0x1
8000d238:	82d5                	srl	a3,a3,0x15
8000d23a:	7ff00613          	li	a2,2047
8000d23e:	04c68663          	beq	a3,a2,8000d28a <.L__truncdfsf2_inf_nan>
8000d242:	c8068693          	add	a3,a3,-896
8000d246:	02d05e63          	blez	a3,8000d282 <.L__truncdfsf2_underflow>
8000d24a:	0ff00613          	li	a2,255
8000d24e:	04c6f263          	bgeu	a3,a2,8000d292 <.L__truncdfsf2_inf>
8000d252:	06de                	sll	a3,a3,0x17
8000d254:	01f5d613          	srl	a2,a1,0x1f
8000d258:	067e                	sll	a2,a2,0x1f
8000d25a:	8ed1                	or	a3,a3,a2
8000d25c:	05b2                	sll	a1,a1,0xc
8000d25e:	01455613          	srl	a2,a0,0x14
8000d262:	8dd1                	or	a1,a1,a2
8000d264:	81a5                	srl	a1,a1,0x9
8000d266:	00251613          	sll	a2,a0,0x2
8000d26a:	00062733          	sltz	a4,a2
8000d26e:	9632                	add	a2,a2,a2
8000d270:	000627b3          	sltz	a5,a2
8000d274:	9632                	add	a2,a2,a2
8000d276:	963a                	add	a2,a2,a4
8000d278:	c211                	beqz	a2,8000d27c <.L__truncdfsf2_no_round_tie>
8000d27a:	95be                	add	a1,a1,a5

8000d27c <.L__truncdfsf2_no_round_tie>:
8000d27c:	00d58533          	add	a0,a1,a3
8000d280:	8082                	ret

8000d282 <.L__truncdfsf2_underflow>:
8000d282:	01f5d513          	srl	a0,a1,0x1f
8000d286:	057e                	sll	a0,a0,0x1f
8000d288:	8082                	ret

8000d28a <.L__truncdfsf2_inf_nan>:
8000d28a:	00c59693          	sll	a3,a1,0xc
8000d28e:	8ec9                	or	a3,a3,a0
8000d290:	ea81                	bnez	a3,8000d2a0 <.L__truncdfsf2_nan>

8000d292 <.L__truncdfsf2_inf>:
8000d292:	81fd                	srl	a1,a1,0x1f
8000d294:	05fe                	sll	a1,a1,0x1f
8000d296:	7f800537          	lui	a0,0x7f800
8000d29a:	8d4d                	or	a0,a0,a1
8000d29c:	4581                	li	a1,0
8000d29e:	8082                	ret

8000d2a0 <.L__truncdfsf2_nan>:
8000d2a0:	800006b7          	lui	a3,0x80000
8000d2a4:	00d5f633          	and	a2,a1,a3
8000d2a8:	058e                	sll	a1,a1,0x3
8000d2aa:	8175                	srl	a0,a0,0x1d
8000d2ac:	8d4d                	or	a0,a0,a1
8000d2ae:	0506                	sll	a0,a0,0x1
8000d2b0:	8105                	srl	a0,a0,0x1
8000d2b2:	8d51                	or	a0,a0,a2
8000d2b4:	82a5                	srl	a3,a3,0x9
8000d2b6:	8d55                	or	a0,a0,a3
8000d2b8:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ldouble_to_double:

8000d2ba <__SEGGER_RTL_ldouble_to_double>:
8000d2ba:	4158                	lw	a4,4(a0)
8000d2bc:	451c                	lw	a5,8(a0)
8000d2be:	4554                	lw	a3,12(a0)
8000d2c0:	1141                	add	sp,sp,-16
8000d2c2:	c23a                	sw	a4,4(sp)
8000d2c4:	c43e                	sw	a5,8(sp)
8000d2c6:	7771                	lui	a4,0xffffc
8000d2c8:	00169793          	sll	a5,a3,0x1
8000d2cc:	83c5                	srl	a5,a5,0x11
8000d2ce:	40070713          	add	a4,a4,1024 # ffffc400 <__AHB_SRAM_segment_end__+0xfdf4400>
8000d2d2:	c636                	sw	a3,12(sp)
8000d2d4:	97ba                	add	a5,a5,a4
8000d2d6:	00f04a63          	bgtz	a5,8000d2ea <.L27>
8000d2da:	800007b7          	lui	a5,0x80000
8000d2de:	4701                	li	a4,0
8000d2e0:	8ff5                	and	a5,a5,a3

8000d2e2 <.L28>:
8000d2e2:	853a                	mv	a0,a4
8000d2e4:	85be                	mv	a1,a5
8000d2e6:	0141                	add	sp,sp,16
8000d2e8:	8082                	ret

8000d2ea <.L27>:
8000d2ea:	6711                	lui	a4,0x4
8000d2ec:	3ff70713          	add	a4,a4,1023 # 43ff <__HEAPSIZE__+0x3ff>
8000d2f0:	00e78c63          	beq	a5,a4,8000d308 <.L29>
8000d2f4:	7ff00713          	li	a4,2047
8000d2f8:	00f75a63          	bge	a4,a5,8000d30c <.L30>
8000d2fc:	4781                	li	a5,0
8000d2fe:	4801                	li	a6,0
8000d300:	c43e                	sw	a5,8(sp)
8000d302:	c642                	sw	a6,12(sp)
8000d304:	c03e                	sw	a5,0(sp)
8000d306:	c242                	sw	a6,4(sp)

8000d308 <.L29>:
8000d308:	7ff00793          	li	a5,2047

8000d30c <.L30>:
8000d30c:	45a2                	lw	a1,8(sp)
8000d30e:	4732                	lw	a4,12(sp)
8000d310:	80000637          	lui	a2,0x80000
8000d314:	01c5d513          	srl	a0,a1,0x1c
8000d318:	8e79                	and	a2,a2,a4
8000d31a:	0712                	sll	a4,a4,0x4
8000d31c:	4692                	lw	a3,4(sp)
8000d31e:	8f49                	or	a4,a4,a0
8000d320:	0732                	sll	a4,a4,0xc
8000d322:	8331                	srl	a4,a4,0xc
8000d324:	8e59                	or	a2,a2,a4
8000d326:	82f1                	srl	a3,a3,0x1c
8000d328:	0592                	sll	a1,a1,0x4
8000d32a:	07d2                	sll	a5,a5,0x14
8000d32c:	00b6e733          	or	a4,a3,a1
8000d330:	8fd1                	or	a5,a5,a2
8000d332:	bf45                	j	8000d2e2 <.L28>

Disassembly of section .text.libc.__SEGGER_RTL_float32_isnan:

8000d334 <__SEGGER_RTL_float32_isnan>:
8000d334:	ff0007b7          	lui	a5,0xff000
8000d338:	0785                	add	a5,a5,1 # ff000001 <__AHB_SRAM_segment_end__+0xedf8001>
8000d33a:	0506                	sll	a0,a0,0x1
8000d33c:	00f53533          	sltu	a0,a0,a5
8000d340:	00154513          	xor	a0,a0,1
8000d344:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_float32_isinf:

8000d346 <__SEGGER_RTL_float32_isinf>:
8000d346:	010007b7          	lui	a5,0x1000
8000d34a:	0506                	sll	a0,a0,0x1
8000d34c:	953e                	add	a0,a0,a5
8000d34e:	00153513          	seqz	a0,a0
8000d352:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_float32_isnormal:

8000d354 <__SEGGER_RTL_float32_isnormal>:
8000d354:	ff0007b7          	lui	a5,0xff000
8000d358:	0506                	sll	a0,a0,0x1
8000d35a:	953e                	add	a0,a0,a5
8000d35c:	fe0007b7          	lui	a5,0xfe000
8000d360:	00f53533          	sltu	a0,a0,a5
8000d364:	8082                	ret

Disassembly of section .text.libc.floorf:

8000d366 <floorf>:
8000d366:	00151693          	sll	a3,a0,0x1
8000d36a:	82e1                	srl	a3,a3,0x18
8000d36c:	01755793          	srl	a5,a0,0x17
8000d370:	16fd                	add	a3,a3,-1 # 7fffffff <__AXI_SRAM_segment_end__+0x7edbffff>
8000d372:	0fd00613          	li	a2,253
8000d376:	872a                	mv	a4,a0
8000d378:	0ff7f793          	zext.b	a5,a5
8000d37c:	00d67963          	bgeu	a2,a3,8000d38e <.L1240>
8000d380:	e789                	bnez	a5,8000d38a <.L1241>
8000d382:	800007b7          	lui	a5,0x80000
8000d386:	00f57733          	and	a4,a0,a5

8000d38a <.L1241>:
8000d38a:	853a                	mv	a0,a4
8000d38c:	8082                	ret

8000d38e <.L1240>:
8000d38e:	f8178793          	add	a5,a5,-127 # 7fffff81 <__AXI_SRAM_segment_end__+0x7edbff81>
8000d392:	0007db63          	bgez	a5,8000d3a8 <.L1243>
8000d396:	00000513          	li	a0,0
8000d39a:	02075a63          	bgez	a4,8000d3ce <.L1242>
8000d39e:	800067b7          	lui	a5,0x80006
8000d3a2:	ce47a503          	lw	a0,-796(a5) # 80005ce4 <.Lmerged_single+0x18>
8000d3a6:	8082                	ret

8000d3a8 <.L1243>:
8000d3a8:	46d9                	li	a3,22
8000d3aa:	02f6c263          	blt	a3,a5,8000d3ce <.L1242>
8000d3ae:	008006b7          	lui	a3,0x800
8000d3b2:	fff68613          	add	a2,a3,-1 # 7fffff <__DLM_segment_end__+0x5dffff>
8000d3b6:	00f65633          	srl	a2,a2,a5
8000d3ba:	fff64513          	not	a0,a2
8000d3be:	8d79                	and	a0,a0,a4
8000d3c0:	8f71                	and	a4,a4,a2
8000d3c2:	c711                	beqz	a4,8000d3ce <.L1242>
8000d3c4:	00055563          	bgez	a0,8000d3ce <.L1242>
8000d3c8:	00f6d6b3          	srl	a3,a3,a5
8000d3cc:	9536                	add	a0,a0,a3

8000d3ce <.L1242>:
8000d3ce:	8082                	ret

Disassembly of section .text.libc.__ashldi3:

8000d3d0 <__ashldi3>:
8000d3d0:	02067793          	and	a5,a2,32
8000d3d4:	ef89                	bnez	a5,8000d3ee <.L__ashldi3LongShift>
8000d3d6:	00155793          	srl	a5,a0,0x1
8000d3da:	fff64713          	not	a4,a2
8000d3de:	00e7d7b3          	srl	a5,a5,a4
8000d3e2:	00c595b3          	sll	a1,a1,a2
8000d3e6:	8ddd                	or	a1,a1,a5
8000d3e8:	00c51533          	sll	a0,a0,a2
8000d3ec:	8082                	ret

8000d3ee <.L__ashldi3LongShift>:
8000d3ee:	00c515b3          	sll	a1,a0,a2
8000d3f2:	4501                	li	a0,0
8000d3f4:	8082                	ret

Disassembly of section .text.libc.__udivdi3:

8000d3f6 <__udivdi3>:
8000d3f6:	1101                	add	sp,sp,-32
8000d3f8:	cc22                	sw	s0,24(sp)
8000d3fa:	ca26                	sw	s1,20(sp)
8000d3fc:	c84a                	sw	s2,16(sp)
8000d3fe:	c64e                	sw	s3,12(sp)
8000d400:	ce06                	sw	ra,28(sp)
8000d402:	c452                	sw	s4,8(sp)
8000d404:	c256                	sw	s5,4(sp)
8000d406:	c05a                	sw	s6,0(sp)
8000d408:	842a                	mv	s0,a0
8000d40a:	892e                	mv	s2,a1
8000d40c:	89b2                	mv	s3,a2
8000d40e:	84b6                	mv	s1,a3
8000d410:	2e069263          	bnez	a3,8000d6f4 <.L47>
8000d414:	ed99                	bnez	a1,8000d432 <.L48>
8000d416:	02c55433          	divu	s0,a0,a2

8000d41a <.L49>:
8000d41a:	40f2                	lw	ra,28(sp)
8000d41c:	8522                	mv	a0,s0
8000d41e:	4462                	lw	s0,24(sp)
8000d420:	44d2                	lw	s1,20(sp)
8000d422:	49b2                	lw	s3,12(sp)
8000d424:	4a22                	lw	s4,8(sp)
8000d426:	4a92                	lw	s5,4(sp)
8000d428:	4b02                	lw	s6,0(sp)
8000d42a:	85ca                	mv	a1,s2
8000d42c:	4942                	lw	s2,16(sp)
8000d42e:	6105                	add	sp,sp,32
8000d430:	8082                	ret

8000d432 <.L48>:
8000d432:	010007b7          	lui	a5,0x1000
8000d436:	12f67863          	bgeu	a2,a5,8000d566 <.L50>
8000d43a:	4791                	li	a5,4
8000d43c:	08c7e763          	bltu	a5,a2,8000d4ca <.L52>
8000d440:	470d                	li	a4,3
8000d442:	02e60263          	beq	a2,a4,8000d466 <.L54>
8000d446:	06f60a63          	beq	a2,a5,8000d4ba <.L55>
8000d44a:	4785                	li	a5,1
8000d44c:	fcf607e3          	beq	a2,a5,8000d41a <.L49>
8000d450:	4789                	li	a5,2
8000d452:	3cf61063          	bne	a2,a5,8000d812 <.L88>
8000d456:	01f59793          	sll	a5,a1,0x1f
8000d45a:	00155413          	srl	s0,a0,0x1
8000d45e:	8c5d                	or	s0,s0,a5
8000d460:	0015d913          	srl	s2,a1,0x1
8000d464:	bf5d                	j	8000d41a <.L49>

8000d466 <.L54>:
8000d466:	555557b7          	lui	a5,0x55555
8000d46a:	55578793          	add	a5,a5,1365 # 55555555 <__AXI_SRAM_segment_end__+0x54315555>
8000d46e:	02b7b6b3          	mulhu	a3,a5,a1
8000d472:	02a7b633          	mulhu	a2,a5,a0
8000d476:	02a78733          	mul	a4,a5,a0
8000d47a:	02b787b3          	mul	a5,a5,a1
8000d47e:	97b2                	add	a5,a5,a2
8000d480:	00c7b633          	sltu	a2,a5,a2
8000d484:	9636                	add	a2,a2,a3
8000d486:	00f706b3          	add	a3,a4,a5
8000d48a:	00e6b733          	sltu	a4,a3,a4
8000d48e:	9732                	add	a4,a4,a2
8000d490:	97ba                	add	a5,a5,a4
8000d492:	00e7b5b3          	sltu	a1,a5,a4
8000d496:	9736                	add	a4,a4,a3
8000d498:	00d736b3          	sltu	a3,a4,a3
8000d49c:	0705                	add	a4,a4,1
8000d49e:	97b6                	add	a5,a5,a3
8000d4a0:	00173713          	seqz	a4,a4
8000d4a4:	00d7b6b3          	sltu	a3,a5,a3
8000d4a8:	962e                	add	a2,a2,a1
8000d4aa:	97ba                	add	a5,a5,a4
8000d4ac:	00c68933          	add	s2,a3,a2
8000d4b0:	00e7b733          	sltu	a4,a5,a4
8000d4b4:	843e                	mv	s0,a5
8000d4b6:	993a                	add	s2,s2,a4
8000d4b8:	b78d                	j	8000d41a <.L49>

8000d4ba <.L55>:
8000d4ba:	01e59793          	sll	a5,a1,0x1e
8000d4be:	00255413          	srl	s0,a0,0x2
8000d4c2:	8c5d                	or	s0,s0,a5
8000d4c4:	0025d913          	srl	s2,a1,0x2
8000d4c8:	bf89                	j	8000d41a <.L49>

8000d4ca <.L52>:
8000d4ca:	67c1                	lui	a5,0x10
8000d4cc:	02c5d6b3          	divu	a3,a1,a2
8000d4d0:	01055713          	srl	a4,a0,0x10
8000d4d4:	02f67a63          	bgeu	a2,a5,8000d508 <.L62>
8000d4d8:	01051413          	sll	s0,a0,0x10
8000d4dc:	8041                	srl	s0,s0,0x10
8000d4de:	02c687b3          	mul	a5,a3,a2
8000d4e2:	40f587b3          	sub	a5,a1,a5
8000d4e6:	07c2                	sll	a5,a5,0x10
8000d4e8:	97ba                	add	a5,a5,a4
8000d4ea:	02c7d933          	divu	s2,a5,a2
8000d4ee:	02c90733          	mul	a4,s2,a2
8000d4f2:	0942                	sll	s2,s2,0x10
8000d4f4:	8f99                	sub	a5,a5,a4
8000d4f6:	07c2                	sll	a5,a5,0x10
8000d4f8:	943e                	add	s0,s0,a5
8000d4fa:	02c45433          	divu	s0,s0,a2
8000d4fe:	944a                	add	s0,s0,s2
8000d500:	01243933          	sltu	s2,s0,s2
8000d504:	9936                	add	s2,s2,a3
8000d506:	bf11                	j	8000d41a <.L49>

8000d508 <.L62>:
8000d508:	02c687b3          	mul	a5,a3,a2
8000d50c:	01855613          	srl	a2,a0,0x18
8000d510:	0ff77713          	zext.b	a4,a4
8000d514:	0ff47413          	zext.b	s0,s0
8000d518:	8936                	mv	s2,a3
8000d51a:	40f587b3          	sub	a5,a1,a5
8000d51e:	07a2                	sll	a5,a5,0x8
8000d520:	963e                	add	a2,a2,a5
8000d522:	033657b3          	divu	a5,a2,s3
8000d526:	033785b3          	mul	a1,a5,s3
8000d52a:	07a2                	sll	a5,a5,0x8
8000d52c:	8e0d                	sub	a2,a2,a1
8000d52e:	0622                	sll	a2,a2,0x8
8000d530:	9732                	add	a4,a4,a2
8000d532:	033755b3          	divu	a1,a4,s3
8000d536:	97ae                	add	a5,a5,a1
8000d538:	07a2                	sll	a5,a5,0x8
8000d53a:	03358633          	mul	a2,a1,s3
8000d53e:	8f11                	sub	a4,a4,a2
8000d540:	00855613          	srl	a2,a0,0x8
8000d544:	0ff67613          	zext.b	a2,a2
8000d548:	0722                	sll	a4,a4,0x8
8000d54a:	9732                	add	a4,a4,a2
8000d54c:	03375633          	divu	a2,a4,s3
8000d550:	97b2                	add	a5,a5,a2
8000d552:	07a2                	sll	a5,a5,0x8
8000d554:	03360533          	mul	a0,a2,s3
8000d558:	8f09                	sub	a4,a4,a0
8000d55a:	0722                	sll	a4,a4,0x8
8000d55c:	943a                	add	s0,s0,a4
8000d55e:	03345433          	divu	s0,s0,s3
8000d562:	943e                	add	s0,s0,a5
8000d564:	bd5d                	j	8000d41a <.L49>

8000d566 <.L50>:
8000d566:	80005ab7          	lui	s5,0x80005
8000d56a:	698a8a93          	add	s5,s5,1688 # 80005698 <__SEGGER_RTL_Moeller_inverse_lut>
8000d56e:	0cc5f063          	bgeu	a1,a2,8000d62e <.L64>
8000d572:	10000737          	lui	a4,0x10000
8000d576:	87b2                	mv	a5,a2
8000d578:	00e67563          	bgeu	a2,a4,8000d582 <.L65>
8000d57c:	00461793          	sll	a5,a2,0x4
8000d580:	4491                	li	s1,4

8000d582 <.L65>:
8000d582:	40000737          	lui	a4,0x40000
8000d586:	00e7f463          	bgeu	a5,a4,8000d58e <.L66>
8000d58a:	0489                	add	s1,s1,2
8000d58c:	078a                	sll	a5,a5,0x2

8000d58e <.L66>:
8000d58e:	0007c363          	bltz	a5,8000d594 <.L67>
8000d592:	0485                	add	s1,s1,1

8000d594 <.L67>:
8000d594:	8626                	mv	a2,s1
8000d596:	8522                	mv	a0,s0
8000d598:	85ca                	mv	a1,s2
8000d59a:	3d1d                	jal	8000d3d0 <__ashldi3>
8000d59c:	009994b3          	sll	s1,s3,s1
8000d5a0:	0164d793          	srl	a5,s1,0x16
8000d5a4:	e0078793          	add	a5,a5,-512 # fe00 <__AXI_SRAM_segment_used_size__+0x68a4>
8000d5a8:	0786                	sll	a5,a5,0x1
8000d5aa:	97d6                	add	a5,a5,s5
8000d5ac:	0007d783          	lhu	a5,0(a5)
8000d5b0:	00b4d813          	srl	a6,s1,0xb
8000d5b4:	0014f713          	and	a4,s1,1
8000d5b8:	02f78633          	mul	a2,a5,a5
8000d5bc:	0792                	sll	a5,a5,0x4
8000d5be:	0014d693          	srl	a3,s1,0x1
8000d5c2:	0805                	add	a6,a6,1
8000d5c4:	03063633          	mulhu	a2,a2,a6
8000d5c8:	8f91                	sub	a5,a5,a2
8000d5ca:	96ba                	add	a3,a3,a4
8000d5cc:	17fd                	add	a5,a5,-1
8000d5ce:	c319                	beqz	a4,8000d5d4 <.L68>
8000d5d0:	0017d713          	srl	a4,a5,0x1

8000d5d4 <.L68>:
8000d5d4:	02f686b3          	mul	a3,a3,a5
8000d5d8:	8f15                	sub	a4,a4,a3
8000d5da:	02e7b733          	mulhu	a4,a5,a4
8000d5de:	07be                	sll	a5,a5,0xf
8000d5e0:	8305                	srl	a4,a4,0x1
8000d5e2:	97ba                	add	a5,a5,a4
8000d5e4:	8726                	mv	a4,s1
8000d5e6:	029786b3          	mul	a3,a5,s1
8000d5ea:	9736                	add	a4,a4,a3
8000d5ec:	00d736b3          	sltu	a3,a4,a3
8000d5f0:	8726                	mv	a4,s1
8000d5f2:	9736                	add	a4,a4,a3
8000d5f4:	0297b6b3          	mulhu	a3,a5,s1
8000d5f8:	9736                	add	a4,a4,a3
8000d5fa:	8f99                	sub	a5,a5,a4
8000d5fc:	02b7b733          	mulhu	a4,a5,a1
8000d600:	02b787b3          	mul	a5,a5,a1
8000d604:	00a786b3          	add	a3,a5,a0
8000d608:	00f6b7b3          	sltu	a5,a3,a5
8000d60c:	95be                	add	a1,a1,a5
8000d60e:	00b707b3          	add	a5,a4,a1
8000d612:	00178413          	add	s0,a5,1
8000d616:	02848733          	mul	a4,s1,s0
8000d61a:	8d19                	sub	a0,a0,a4
8000d61c:	00a6f463          	bgeu	a3,a0,8000d624 <.L69>
8000d620:	9526                	add	a0,a0,s1
8000d622:	843e                	mv	s0,a5

8000d624 <.L69>:
8000d624:	00956363          	bltu	a0,s1,8000d62a <.L109>
8000d628:	0405                	add	s0,s0,1

8000d62a <.L109>:
8000d62a:	4901                	li	s2,0
8000d62c:	b3fd                	j	8000d41a <.L49>

8000d62e <.L64>:
8000d62e:	02c5da33          	divu	s4,a1,a2
8000d632:	10000737          	lui	a4,0x10000
8000d636:	87b2                	mv	a5,a2
8000d638:	02ca05b3          	mul	a1,s4,a2
8000d63c:	40b905b3          	sub	a1,s2,a1
8000d640:	00e67563          	bgeu	a2,a4,8000d64a <.L71>
8000d644:	00461793          	sll	a5,a2,0x4
8000d648:	4491                	li	s1,4

8000d64a <.L71>:
8000d64a:	40000737          	lui	a4,0x40000
8000d64e:	00e7f463          	bgeu	a5,a4,8000d656 <.L72>
8000d652:	0489                	add	s1,s1,2
8000d654:	078a                	sll	a5,a5,0x2

8000d656 <.L72>:
8000d656:	0007c363          	bltz	a5,8000d65c <.L73>
8000d65a:	0485                	add	s1,s1,1

8000d65c <.L73>:
8000d65c:	8626                	mv	a2,s1
8000d65e:	8522                	mv	a0,s0
8000d660:	3b85                	jal	8000d3d0 <__ashldi3>
8000d662:	009994b3          	sll	s1,s3,s1
8000d666:	0164d793          	srl	a5,s1,0x16
8000d66a:	e0078793          	add	a5,a5,-512
8000d66e:	0786                	sll	a5,a5,0x1
8000d670:	9abe                	add	s5,s5,a5
8000d672:	000ad783          	lhu	a5,0(s5)
8000d676:	00b4d813          	srl	a6,s1,0xb
8000d67a:	0014f713          	and	a4,s1,1
8000d67e:	02f78633          	mul	a2,a5,a5
8000d682:	0792                	sll	a5,a5,0x4
8000d684:	0014d693          	srl	a3,s1,0x1
8000d688:	0805                	add	a6,a6,1
8000d68a:	03063633          	mulhu	a2,a2,a6
8000d68e:	8f91                	sub	a5,a5,a2
8000d690:	96ba                	add	a3,a3,a4
8000d692:	17fd                	add	a5,a5,-1
8000d694:	c319                	beqz	a4,8000d69a <.L74>
8000d696:	0017d713          	srl	a4,a5,0x1

8000d69a <.L74>:
8000d69a:	02f686b3          	mul	a3,a3,a5
8000d69e:	8f15                	sub	a4,a4,a3
8000d6a0:	02e7b733          	mulhu	a4,a5,a4
8000d6a4:	07be                	sll	a5,a5,0xf
8000d6a6:	8305                	srl	a4,a4,0x1
8000d6a8:	97ba                	add	a5,a5,a4
8000d6aa:	8726                	mv	a4,s1
8000d6ac:	029786b3          	mul	a3,a5,s1
8000d6b0:	9736                	add	a4,a4,a3
8000d6b2:	00d736b3          	sltu	a3,a4,a3
8000d6b6:	8726                	mv	a4,s1
8000d6b8:	9736                	add	a4,a4,a3
8000d6ba:	0297b6b3          	mulhu	a3,a5,s1
8000d6be:	9736                	add	a4,a4,a3
8000d6c0:	8f99                	sub	a5,a5,a4
8000d6c2:	02b7b733          	mulhu	a4,a5,a1
8000d6c6:	02b787b3          	mul	a5,a5,a1
8000d6ca:	00a786b3          	add	a3,a5,a0
8000d6ce:	00f6b7b3          	sltu	a5,a3,a5
8000d6d2:	95be                	add	a1,a1,a5
8000d6d4:	00b707b3          	add	a5,a4,a1
8000d6d8:	00178413          	add	s0,a5,1
8000d6dc:	02848733          	mul	a4,s1,s0
8000d6e0:	8d19                	sub	a0,a0,a4
8000d6e2:	00a6f463          	bgeu	a3,a0,8000d6ea <.L75>
8000d6e6:	9526                	add	a0,a0,s1
8000d6e8:	843e                	mv	s0,a5

8000d6ea <.L75>:
8000d6ea:	00956363          	bltu	a0,s1,8000d6f0 <.L76>
8000d6ee:	0405                	add	s0,s0,1

8000d6f0 <.L76>:
8000d6f0:	8952                	mv	s2,s4
8000d6f2:	b325                	j	8000d41a <.L49>

8000d6f4 <.L47>:
8000d6f4:	67c1                	lui	a5,0x10
8000d6f6:	8ab6                	mv	s5,a3
8000d6f8:	4a01                	li	s4,0
8000d6fa:	00f6f563          	bgeu	a3,a5,8000d704 <.L77>
8000d6fe:	01069493          	sll	s1,a3,0x10
8000d702:	4a41                	li	s4,16

8000d704 <.L77>:
8000d704:	010007b7          	lui	a5,0x1000
8000d708:	00f4f463          	bgeu	s1,a5,8000d710 <.L78>
8000d70c:	0a21                	add	s4,s4,8
8000d70e:	04a2                	sll	s1,s1,0x8

8000d710 <.L78>:
8000d710:	100007b7          	lui	a5,0x10000
8000d714:	00f4f463          	bgeu	s1,a5,8000d71c <.L79>
8000d718:	0a11                	add	s4,s4,4
8000d71a:	0492                	sll	s1,s1,0x4

8000d71c <.L79>:
8000d71c:	400007b7          	lui	a5,0x40000
8000d720:	00f4f463          	bgeu	s1,a5,8000d728 <.L80>
8000d724:	0a09                	add	s4,s4,2
8000d726:	048a                	sll	s1,s1,0x2

8000d728 <.L80>:
8000d728:	0004c363          	bltz	s1,8000d72e <.L81>
8000d72c:	0a05                	add	s4,s4,1

8000d72e <.L81>:
8000d72e:	01f91793          	sll	a5,s2,0x1f
8000d732:	8652                	mv	a2,s4
8000d734:	00145493          	srl	s1,s0,0x1
8000d738:	854e                	mv	a0,s3
8000d73a:	85d6                	mv	a1,s5
8000d73c:	8cdd                	or	s1,s1,a5
8000d73e:	3949                	jal	8000d3d0 <__ashldi3>
8000d740:	0165d613          	srl	a2,a1,0x16
8000d744:	800057b7          	lui	a5,0x80005
8000d748:	e0060613          	add	a2,a2,-512 # 7ffffe00 <__AXI_SRAM_segment_end__+0x7edbfe00>
8000d74c:	0606                	sll	a2,a2,0x1
8000d74e:	69878793          	add	a5,a5,1688 # 80005698 <__SEGGER_RTL_Moeller_inverse_lut>
8000d752:	97b2                	add	a5,a5,a2
8000d754:	0007d783          	lhu	a5,0(a5)
8000d758:	00b5d513          	srl	a0,a1,0xb
8000d75c:	0015f713          	and	a4,a1,1
8000d760:	02f78633          	mul	a2,a5,a5
8000d764:	0792                	sll	a5,a5,0x4
8000d766:	0015d693          	srl	a3,a1,0x1
8000d76a:	0505                	add	a0,a0,1 # 7f800001 <__AXI_SRAM_segment_end__+0x7e5c0001>
8000d76c:	02a63633          	mulhu	a2,a2,a0
8000d770:	8f91                	sub	a5,a5,a2
8000d772:	00195b13          	srl	s6,s2,0x1
8000d776:	96ba                	add	a3,a3,a4
8000d778:	17fd                	add	a5,a5,-1
8000d77a:	c319                	beqz	a4,8000d780 <.L82>
8000d77c:	0017d713          	srl	a4,a5,0x1

8000d780 <.L82>:
8000d780:	02f686b3          	mul	a3,a3,a5
8000d784:	8f15                	sub	a4,a4,a3
8000d786:	02e7b733          	mulhu	a4,a5,a4
8000d78a:	07be                	sll	a5,a5,0xf
8000d78c:	8305                	srl	a4,a4,0x1
8000d78e:	97ba                	add	a5,a5,a4
8000d790:	872e                	mv	a4,a1
8000d792:	02b786b3          	mul	a3,a5,a1
8000d796:	9736                	add	a4,a4,a3
8000d798:	00d736b3          	sltu	a3,a4,a3
8000d79c:	872e                	mv	a4,a1
8000d79e:	9736                	add	a4,a4,a3
8000d7a0:	02b7b6b3          	mulhu	a3,a5,a1
8000d7a4:	9736                	add	a4,a4,a3
8000d7a6:	8f99                	sub	a5,a5,a4
8000d7a8:	0367b733          	mulhu	a4,a5,s6
8000d7ac:	036787b3          	mul	a5,a5,s6
8000d7b0:	009786b3          	add	a3,a5,s1
8000d7b4:	00f6b7b3          	sltu	a5,a3,a5
8000d7b8:	97da                	add	a5,a5,s6
8000d7ba:	973e                	add	a4,a4,a5
8000d7bc:	00170793          	add	a5,a4,1 # 40000001 <__AXI_SRAM_segment_end__+0x3edc0001>
8000d7c0:	02f58633          	mul	a2,a1,a5
8000d7c4:	8c91                	sub	s1,s1,a2
8000d7c6:	0096f463          	bgeu	a3,s1,8000d7ce <.L83>
8000d7ca:	94ae                	add	s1,s1,a1
8000d7cc:	87ba                	mv	a5,a4

8000d7ce <.L83>:
8000d7ce:	00b4e363          	bltu	s1,a1,8000d7d4 <.L84>
8000d7d2:	0785                	add	a5,a5,1

8000d7d4 <.L84>:
8000d7d4:	477d                	li	a4,31
8000d7d6:	41470733          	sub	a4,a4,s4
8000d7da:	00e7d633          	srl	a2,a5,a4
8000d7de:	c211                	beqz	a2,8000d7e2 <.L85>
8000d7e0:	167d                	add	a2,a2,-1

8000d7e2 <.L85>:
8000d7e2:	02ca87b3          	mul	a5,s5,a2
8000d7e6:	03360733          	mul	a4,a2,s3
8000d7ea:	033636b3          	mulhu	a3,a2,s3
8000d7ee:	40e40733          	sub	a4,s0,a4
8000d7f2:	00e43433          	sltu	s0,s0,a4
8000d7f6:	97b6                	add	a5,a5,a3
8000d7f8:	40f907b3          	sub	a5,s2,a5
8000d7fc:	40878433          	sub	s0,a5,s0
8000d800:	01546763          	bltu	s0,s5,8000d80e <.L86>
8000d804:	008a9463          	bne	s5,s0,8000d80c <.L95>
8000d808:	01376363          	bltu	a4,s3,8000d80e <.L86>

8000d80c <.L95>:
8000d80c:	0605                	add	a2,a2,1

8000d80e <.L86>:
8000d80e:	8432                	mv	s0,a2
8000d810:	bd29                	j	8000d62a <.L109>

8000d812 <.L88>:
8000d812:	4401                	li	s0,0
8000d814:	bd19                	j	8000d62a <.L109>

Disassembly of section .text.libc.__umoddi3:

8000d816 <__umoddi3>:
8000d816:	1101                	add	sp,sp,-32
8000d818:	cc22                	sw	s0,24(sp)
8000d81a:	ca26                	sw	s1,20(sp)
8000d81c:	c84a                	sw	s2,16(sp)
8000d81e:	c64e                	sw	s3,12(sp)
8000d820:	c452                	sw	s4,8(sp)
8000d822:	ce06                	sw	ra,28(sp)
8000d824:	c256                	sw	s5,4(sp)
8000d826:	c05a                	sw	s6,0(sp)
8000d828:	892a                	mv	s2,a0
8000d82a:	84ae                	mv	s1,a1
8000d82c:	8432                	mv	s0,a2
8000d82e:	89b6                	mv	s3,a3
8000d830:	8a36                	mv	s4,a3
8000d832:	2e069e63          	bnez	a3,8000db2e <.L111>
8000d836:	e589                	bnez	a1,8000d840 <.L112>
8000d838:	02c557b3          	divu	a5,a0,a2

8000d83c <.L174>:
8000d83c:	4701                	li	a4,0
8000d83e:	a815                	j	8000d872 <.L113>

8000d840 <.L112>:
8000d840:	010007b7          	lui	a5,0x1000
8000d844:	16f67163          	bgeu	a2,a5,8000d9a6 <.L114>
8000d848:	4791                	li	a5,4
8000d84a:	0cc7e063          	bltu	a5,a2,8000d90a <.L116>
8000d84e:	470d                	li	a4,3
8000d850:	04e60d63          	beq	a2,a4,8000d8aa <.L118>
8000d854:	0af60363          	beq	a2,a5,8000d8fa <.L119>
8000d858:	4785                	li	a5,1
8000d85a:	3ef60763          	beq	a2,a5,8000dc48 <.L152>
8000d85e:	4789                	li	a5,2
8000d860:	3ef61763          	bne	a2,a5,8000dc4e <.L153>
8000d864:	01f59713          	sll	a4,a1,0x1f
8000d868:	00155793          	srl	a5,a0,0x1
8000d86c:	8fd9                	or	a5,a5,a4
8000d86e:	0015d713          	srl	a4,a1,0x1

8000d872 <.L113>:
8000d872:	02870733          	mul	a4,a4,s0
8000d876:	40f2                	lw	ra,28(sp)
8000d878:	4a22                	lw	s4,8(sp)
8000d87a:	4a92                	lw	s5,4(sp)
8000d87c:	4b02                	lw	s6,0(sp)
8000d87e:	02f989b3          	mul	s3,s3,a5
8000d882:	02f40533          	mul	a0,s0,a5
8000d886:	99ba                	add	s3,s3,a4
8000d888:	02f43433          	mulhu	s0,s0,a5
8000d88c:	40a90533          	sub	a0,s2,a0
8000d890:	00a935b3          	sltu	a1,s2,a0
8000d894:	4942                	lw	s2,16(sp)
8000d896:	99a2                	add	s3,s3,s0
8000d898:	4462                	lw	s0,24(sp)
8000d89a:	413484b3          	sub	s1,s1,s3
8000d89e:	40b485b3          	sub	a1,s1,a1
8000d8a2:	49b2                	lw	s3,12(sp)
8000d8a4:	44d2                	lw	s1,20(sp)
8000d8a6:	6105                	add	sp,sp,32
8000d8a8:	8082                	ret

8000d8aa <.L118>:
8000d8aa:	555557b7          	lui	a5,0x55555
8000d8ae:	55578793          	add	a5,a5,1365 # 55555555 <__AXI_SRAM_segment_end__+0x54315555>
8000d8b2:	02b7b6b3          	mulhu	a3,a5,a1
8000d8b6:	02a7b633          	mulhu	a2,a5,a0
8000d8ba:	02a78733          	mul	a4,a5,a0
8000d8be:	02b787b3          	mul	a5,a5,a1
8000d8c2:	97b2                	add	a5,a5,a2
8000d8c4:	00c7b633          	sltu	a2,a5,a2
8000d8c8:	9636                	add	a2,a2,a3
8000d8ca:	00f706b3          	add	a3,a4,a5
8000d8ce:	00e6b733          	sltu	a4,a3,a4
8000d8d2:	9732                	add	a4,a4,a2
8000d8d4:	97ba                	add	a5,a5,a4
8000d8d6:	00e7b5b3          	sltu	a1,a5,a4
8000d8da:	9736                	add	a4,a4,a3
8000d8dc:	00d736b3          	sltu	a3,a4,a3
8000d8e0:	0705                	add	a4,a4,1
8000d8e2:	97b6                	add	a5,a5,a3
8000d8e4:	00173713          	seqz	a4,a4
8000d8e8:	00d7b6b3          	sltu	a3,a5,a3
8000d8ec:	962e                	add	a2,a2,a1
8000d8ee:	97ba                	add	a5,a5,a4
8000d8f0:	96b2                	add	a3,a3,a2
8000d8f2:	00e7b733          	sltu	a4,a5,a4
8000d8f6:	9736                	add	a4,a4,a3
8000d8f8:	bfad                	j	8000d872 <.L113>

8000d8fa <.L119>:
8000d8fa:	01e59713          	sll	a4,a1,0x1e
8000d8fe:	00255793          	srl	a5,a0,0x2
8000d902:	8fd9                	or	a5,a5,a4
8000d904:	0025d713          	srl	a4,a1,0x2
8000d908:	b7ad                	j	8000d872 <.L113>

8000d90a <.L116>:
8000d90a:	67c1                	lui	a5,0x10
8000d90c:	02c5d733          	divu	a4,a1,a2
8000d910:	01055693          	srl	a3,a0,0x10
8000d914:	02f67b63          	bgeu	a2,a5,8000d94a <.L126>
8000d918:	02c707b3          	mul	a5,a4,a2
8000d91c:	40f587b3          	sub	a5,a1,a5
8000d920:	07c2                	sll	a5,a5,0x10
8000d922:	97b6                	add	a5,a5,a3
8000d924:	02c7d633          	divu	a2,a5,a2
8000d928:	028606b3          	mul	a3,a2,s0
8000d92c:	0642                	sll	a2,a2,0x10
8000d92e:	8f95                	sub	a5,a5,a3
8000d930:	01079693          	sll	a3,a5,0x10
8000d934:	01051793          	sll	a5,a0,0x10
8000d938:	83c1                	srl	a5,a5,0x10
8000d93a:	97b6                	add	a5,a5,a3
8000d93c:	0287d7b3          	divu	a5,a5,s0
8000d940:	97b2                	add	a5,a5,a2
8000d942:	00c7b633          	sltu	a2,a5,a2
8000d946:	9732                	add	a4,a4,a2
8000d948:	b72d                	j	8000d872 <.L113>

8000d94a <.L126>:
8000d94a:	02c707b3          	mul	a5,a4,a2
8000d94e:	01855613          	srl	a2,a0,0x18
8000d952:	0ff6f693          	zext.b	a3,a3
8000d956:	40f587b3          	sub	a5,a1,a5
8000d95a:	07a2                	sll	a5,a5,0x8
8000d95c:	963e                	add	a2,a2,a5
8000d95e:	028657b3          	divu	a5,a2,s0
8000d962:	028785b3          	mul	a1,a5,s0
8000d966:	07a2                	sll	a5,a5,0x8
8000d968:	8e0d                	sub	a2,a2,a1
8000d96a:	0622                	sll	a2,a2,0x8
8000d96c:	96b2                	add	a3,a3,a2
8000d96e:	0286d5b3          	divu	a1,a3,s0
8000d972:	97ae                	add	a5,a5,a1
8000d974:	07a2                	sll	a5,a5,0x8
8000d976:	02858633          	mul	a2,a1,s0
8000d97a:	8e91                	sub	a3,a3,a2
8000d97c:	00855613          	srl	a2,a0,0x8
8000d980:	0ff67613          	zext.b	a2,a2
8000d984:	06a2                	sll	a3,a3,0x8
8000d986:	96b2                	add	a3,a3,a2
8000d988:	0286d633          	divu	a2,a3,s0
8000d98c:	97b2                	add	a5,a5,a2
8000d98e:	07a2                	sll	a5,a5,0x8
8000d990:	02860533          	mul	a0,a2,s0
8000d994:	0ff97613          	zext.b	a2,s2
8000d998:	8e89                	sub	a3,a3,a0
8000d99a:	06a2                	sll	a3,a3,0x8
8000d99c:	96b2                	add	a3,a3,a2
8000d99e:	0286d6b3          	divu	a3,a3,s0
8000d9a2:	97b6                	add	a5,a5,a3
8000d9a4:	b5f9                	j	8000d872 <.L113>

8000d9a6 <.L114>:
8000d9a6:	80005b37          	lui	s6,0x80005
8000d9aa:	698b0b13          	add	s6,s6,1688 # 80005698 <__SEGGER_RTL_Moeller_inverse_lut>
8000d9ae:	0ac5fe63          	bgeu	a1,a2,8000da6a <.L128>
8000d9b2:	10000737          	lui	a4,0x10000
8000d9b6:	87b2                	mv	a5,a2
8000d9b8:	00e67563          	bgeu	a2,a4,8000d9c2 <.L129>
8000d9bc:	00461793          	sll	a5,a2,0x4
8000d9c0:	4a11                	li	s4,4

8000d9c2 <.L129>:
8000d9c2:	40000737          	lui	a4,0x40000
8000d9c6:	00e7f463          	bgeu	a5,a4,8000d9ce <.L130>
8000d9ca:	0a09                	add	s4,s4,2
8000d9cc:	078a                	sll	a5,a5,0x2

8000d9ce <.L130>:
8000d9ce:	0007c363          	bltz	a5,8000d9d4 <.L131>
8000d9d2:	0a05                	add	s4,s4,1

8000d9d4 <.L131>:
8000d9d4:	8652                	mv	a2,s4
8000d9d6:	854a                	mv	a0,s2
8000d9d8:	85a6                	mv	a1,s1
8000d9da:	3add                	jal	8000d3d0 <__ashldi3>
8000d9dc:	01441a33          	sll	s4,s0,s4
8000d9e0:	016a5793          	srl	a5,s4,0x16
8000d9e4:	e0078793          	add	a5,a5,-512 # fe00 <__AXI_SRAM_segment_used_size__+0x68a4>
8000d9e8:	0786                	sll	a5,a5,0x1
8000d9ea:	97da                	add	a5,a5,s6
8000d9ec:	0007d783          	lhu	a5,0(a5)
8000d9f0:	00ba5813          	srl	a6,s4,0xb
8000d9f4:	001a7713          	and	a4,s4,1
8000d9f8:	02f78633          	mul	a2,a5,a5
8000d9fc:	0792                	sll	a5,a5,0x4
8000d9fe:	001a5693          	srl	a3,s4,0x1
8000da02:	0805                	add	a6,a6,1
8000da04:	03063633          	mulhu	a2,a2,a6
8000da08:	8f91                	sub	a5,a5,a2
8000da0a:	96ba                	add	a3,a3,a4
8000da0c:	17fd                	add	a5,a5,-1
8000da0e:	c319                	beqz	a4,8000da14 <.L132>
8000da10:	0017d713          	srl	a4,a5,0x1

8000da14 <.L132>:
8000da14:	02f686b3          	mul	a3,a3,a5
8000da18:	8f15                	sub	a4,a4,a3
8000da1a:	02e7b733          	mulhu	a4,a5,a4
8000da1e:	07be                	sll	a5,a5,0xf
8000da20:	8305                	srl	a4,a4,0x1
8000da22:	97ba                	add	a5,a5,a4
8000da24:	8752                	mv	a4,s4
8000da26:	034786b3          	mul	a3,a5,s4
8000da2a:	9736                	add	a4,a4,a3
8000da2c:	00d736b3          	sltu	a3,a4,a3
8000da30:	8752                	mv	a4,s4
8000da32:	9736                	add	a4,a4,a3
8000da34:	0347b6b3          	mulhu	a3,a5,s4
8000da38:	9736                	add	a4,a4,a3
8000da3a:	8f99                	sub	a5,a5,a4
8000da3c:	02b7b733          	mulhu	a4,a5,a1
8000da40:	02b787b3          	mul	a5,a5,a1
8000da44:	00a786b3          	add	a3,a5,a0
8000da48:	00f6b7b3          	sltu	a5,a3,a5
8000da4c:	95be                	add	a1,a1,a5
8000da4e:	972e                	add	a4,a4,a1
8000da50:	00170793          	add	a5,a4,1 # 40000001 <__AXI_SRAM_segment_end__+0x3edc0001>
8000da54:	02fa0633          	mul	a2,s4,a5
8000da58:	8d11                	sub	a0,a0,a2
8000da5a:	00a6f463          	bgeu	a3,a0,8000da62 <.L133>
8000da5e:	9552                	add	a0,a0,s4
8000da60:	87ba                	mv	a5,a4

8000da62 <.L133>:
8000da62:	dd456de3          	bltu	a0,s4,8000d83c <.L174>

8000da66 <.L160>:
8000da66:	0785                	add	a5,a5,1
8000da68:	bbd1                	j	8000d83c <.L174>

8000da6a <.L128>:
8000da6a:	02c5dab3          	divu	s5,a1,a2
8000da6e:	10000737          	lui	a4,0x10000
8000da72:	87b2                	mv	a5,a2
8000da74:	02ca85b3          	mul	a1,s5,a2
8000da78:	40b485b3          	sub	a1,s1,a1
8000da7c:	00e67563          	bgeu	a2,a4,8000da86 <.L135>
8000da80:	00461793          	sll	a5,a2,0x4
8000da84:	4a11                	li	s4,4

8000da86 <.L135>:
8000da86:	40000737          	lui	a4,0x40000
8000da8a:	00e7f463          	bgeu	a5,a4,8000da92 <.L136>
8000da8e:	0a09                	add	s4,s4,2
8000da90:	078a                	sll	a5,a5,0x2

8000da92 <.L136>:
8000da92:	0007c363          	bltz	a5,8000da98 <.L137>
8000da96:	0a05                	add	s4,s4,1

8000da98 <.L137>:
8000da98:	8652                	mv	a2,s4
8000da9a:	854a                	mv	a0,s2
8000da9c:	3a15                	jal	8000d3d0 <__ashldi3>
8000da9e:	01441a33          	sll	s4,s0,s4
8000daa2:	016a5793          	srl	a5,s4,0x16
8000daa6:	e0078793          	add	a5,a5,-512
8000daaa:	0786                	sll	a5,a5,0x1
8000daac:	9b3e                	add	s6,s6,a5
8000daae:	000b5783          	lhu	a5,0(s6)
8000dab2:	00ba5813          	srl	a6,s4,0xb
8000dab6:	001a7713          	and	a4,s4,1
8000daba:	02f78633          	mul	a2,a5,a5
8000dabe:	0792                	sll	a5,a5,0x4
8000dac0:	001a5693          	srl	a3,s4,0x1
8000dac4:	0805                	add	a6,a6,1
8000dac6:	03063633          	mulhu	a2,a2,a6
8000daca:	8f91                	sub	a5,a5,a2
8000dacc:	96ba                	add	a3,a3,a4
8000dace:	17fd                	add	a5,a5,-1
8000dad0:	c319                	beqz	a4,8000dad6 <.L138>
8000dad2:	0017d713          	srl	a4,a5,0x1

8000dad6 <.L138>:
8000dad6:	02f686b3          	mul	a3,a3,a5
8000dada:	8f15                	sub	a4,a4,a3
8000dadc:	02e7b733          	mulhu	a4,a5,a4
8000dae0:	07be                	sll	a5,a5,0xf
8000dae2:	8305                	srl	a4,a4,0x1
8000dae4:	97ba                	add	a5,a5,a4
8000dae6:	8752                	mv	a4,s4
8000dae8:	034786b3          	mul	a3,a5,s4
8000daec:	9736                	add	a4,a4,a3
8000daee:	00d736b3          	sltu	a3,a4,a3
8000daf2:	8752                	mv	a4,s4
8000daf4:	9736                	add	a4,a4,a3
8000daf6:	0347b6b3          	mulhu	a3,a5,s4
8000dafa:	9736                	add	a4,a4,a3
8000dafc:	8f99                	sub	a5,a5,a4
8000dafe:	02b7b733          	mulhu	a4,a5,a1
8000db02:	02b787b3          	mul	a5,a5,a1
8000db06:	00a786b3          	add	a3,a5,a0
8000db0a:	00f6b7b3          	sltu	a5,a3,a5
8000db0e:	95be                	add	a1,a1,a5
8000db10:	972e                	add	a4,a4,a1
8000db12:	00170793          	add	a5,a4,1 # 40000001 <__AXI_SRAM_segment_end__+0x3edc0001>
8000db16:	02fa0633          	mul	a2,s4,a5
8000db1a:	8d11                	sub	a0,a0,a2
8000db1c:	00a6f463          	bgeu	a3,a0,8000db24 <.L139>
8000db20:	9552                	add	a0,a0,s4
8000db22:	87ba                	mv	a5,a4

8000db24 <.L139>:
8000db24:	01456363          	bltu	a0,s4,8000db2a <.L140>
8000db28:	0785                	add	a5,a5,1

8000db2a <.L140>:
8000db2a:	8756                	mv	a4,s5
8000db2c:	b399                	j	8000d872 <.L113>

8000db2e <.L111>:
8000db2e:	67c1                	lui	a5,0x10
8000db30:	4a81                	li	s5,0
8000db32:	00f6f563          	bgeu	a3,a5,8000db3c <.L141>
8000db36:	01069a13          	sll	s4,a3,0x10
8000db3a:	4ac1                	li	s5,16

8000db3c <.L141>:
8000db3c:	010007b7          	lui	a5,0x1000
8000db40:	00fa7463          	bgeu	s4,a5,8000db48 <.L142>
8000db44:	0aa1                	add	s5,s5,8
8000db46:	0a22                	sll	s4,s4,0x8

8000db48 <.L142>:
8000db48:	100007b7          	lui	a5,0x10000
8000db4c:	00fa7463          	bgeu	s4,a5,8000db54 <.L143>
8000db50:	0a91                	add	s5,s5,4
8000db52:	0a12                	sll	s4,s4,0x4

8000db54 <.L143>:
8000db54:	400007b7          	lui	a5,0x40000
8000db58:	00fa7463          	bgeu	s4,a5,8000db60 <.L144>
8000db5c:	0a89                	add	s5,s5,2
8000db5e:	0a0a                	sll	s4,s4,0x2

8000db60 <.L144>:
8000db60:	000a4363          	bltz	s4,8000db66 <.L145>
8000db64:	0a85                	add	s5,s5,1

8000db66 <.L145>:
8000db66:	01f49793          	sll	a5,s1,0x1f
8000db6a:	8656                	mv	a2,s5
8000db6c:	00195a13          	srl	s4,s2,0x1
8000db70:	8522                	mv	a0,s0
8000db72:	85ce                	mv	a1,s3
8000db74:	0147ea33          	or	s4,a5,s4
8000db78:	38a1                	jal	8000d3d0 <__ashldi3>
8000db7a:	0165d613          	srl	a2,a1,0x16
8000db7e:	800057b7          	lui	a5,0x80005
8000db82:	e0060613          	add	a2,a2,-512
8000db86:	0606                	sll	a2,a2,0x1
8000db88:	69878793          	add	a5,a5,1688 # 80005698 <__SEGGER_RTL_Moeller_inverse_lut>
8000db8c:	97b2                	add	a5,a5,a2
8000db8e:	0007d783          	lhu	a5,0(a5)
8000db92:	00b5d513          	srl	a0,a1,0xb
8000db96:	0015f713          	and	a4,a1,1
8000db9a:	02f78633          	mul	a2,a5,a5
8000db9e:	0792                	sll	a5,a5,0x4
8000dba0:	0015d693          	srl	a3,a1,0x1
8000dba4:	0505                	add	a0,a0,1
8000dba6:	02a63633          	mulhu	a2,a2,a0
8000dbaa:	8f91                	sub	a5,a5,a2
8000dbac:	0014db13          	srl	s6,s1,0x1
8000dbb0:	96ba                	add	a3,a3,a4
8000dbb2:	17fd                	add	a5,a5,-1
8000dbb4:	c319                	beqz	a4,8000dbba <.L146>
8000dbb6:	0017d713          	srl	a4,a5,0x1

8000dbba <.L146>:
8000dbba:	02f686b3          	mul	a3,a3,a5
8000dbbe:	8f15                	sub	a4,a4,a3
8000dbc0:	02e7b733          	mulhu	a4,a5,a4
8000dbc4:	07be                	sll	a5,a5,0xf
8000dbc6:	8305                	srl	a4,a4,0x1
8000dbc8:	97ba                	add	a5,a5,a4
8000dbca:	872e                	mv	a4,a1
8000dbcc:	02b786b3          	mul	a3,a5,a1
8000dbd0:	9736                	add	a4,a4,a3
8000dbd2:	00d736b3          	sltu	a3,a4,a3
8000dbd6:	872e                	mv	a4,a1
8000dbd8:	9736                	add	a4,a4,a3
8000dbda:	02b7b6b3          	mulhu	a3,a5,a1
8000dbde:	9736                	add	a4,a4,a3
8000dbe0:	8f99                	sub	a5,a5,a4
8000dbe2:	0367b733          	mulhu	a4,a5,s6
8000dbe6:	036787b3          	mul	a5,a5,s6
8000dbea:	014786b3          	add	a3,a5,s4
8000dbee:	00f6b7b3          	sltu	a5,a3,a5
8000dbf2:	97da                	add	a5,a5,s6
8000dbf4:	973e                	add	a4,a4,a5
8000dbf6:	00170793          	add	a5,a4,1
8000dbfa:	02f58633          	mul	a2,a1,a5
8000dbfe:	40ca0a33          	sub	s4,s4,a2
8000dc02:	0146f463          	bgeu	a3,s4,8000dc0a <.L147>
8000dc06:	9a2e                	add	s4,s4,a1
8000dc08:	87ba                	mv	a5,a4

8000dc0a <.L147>:
8000dc0a:	00ba6363          	bltu	s4,a1,8000dc10 <.L148>
8000dc0e:	0785                	add	a5,a5,1

8000dc10 <.L148>:
8000dc10:	477d                	li	a4,31
8000dc12:	41570733          	sub	a4,a4,s5
8000dc16:	00e7d7b3          	srl	a5,a5,a4
8000dc1a:	c391                	beqz	a5,8000dc1e <.L149>
8000dc1c:	17fd                	add	a5,a5,-1

8000dc1e <.L149>:
8000dc1e:	0287b633          	mulhu	a2,a5,s0
8000dc22:	02f98733          	mul	a4,s3,a5
8000dc26:	028786b3          	mul	a3,a5,s0
8000dc2a:	9732                	add	a4,a4,a2
8000dc2c:	40e48733          	sub	a4,s1,a4
8000dc30:	40d906b3          	sub	a3,s2,a3
8000dc34:	00d93633          	sltu	a2,s2,a3
8000dc38:	8f11                	sub	a4,a4,a2
8000dc3a:	c13761e3          	bltu	a4,s3,8000d83c <.L174>
8000dc3e:	e2e994e3          	bne	s3,a4,8000da66 <.L160>
8000dc42:	be86ede3          	bltu	a3,s0,8000d83c <.L174>
8000dc46:	b505                	j	8000da66 <.L160>

8000dc48 <.L152>:
8000dc48:	87aa                	mv	a5,a0
8000dc4a:	872e                	mv	a4,a1
8000dc4c:	b11d                	j	8000d872 <.L113>

8000dc4e <.L153>:
8000dc4e:	4781                	li	a5,0
8000dc50:	b6f5                	j	8000d83c <.L174>

Disassembly of section .text.libc.abs:

8000dc52 <abs>:
8000dc52:	41f55793          	sra	a5,a0,0x1f
8000dc56:	8d3d                	xor	a0,a0,a5
8000dc58:	8d1d                	sub	a0,a0,a5
8000dc5a:	8082                	ret

Disassembly of section .text.libc.memcpy:

8000dc5c <memcpy>:
8000dc5c:	c251                	beqz	a2,8000dce0 <.Lmemcpy_done>
8000dc5e:	87aa                	mv	a5,a0
8000dc60:	00b546b3          	xor	a3,a0,a1
8000dc64:	06fa                	sll	a3,a3,0x1e
8000dc66:	e2bd                	bnez	a3,8000dccc <.Lmemcpy_byte_copy>
8000dc68:	01e51693          	sll	a3,a0,0x1e
8000dc6c:	ce81                	beqz	a3,8000dc84 <.Lmemcpy_aligned>

8000dc6e <.Lmemcpy_word_align>:
8000dc6e:	00058683          	lb	a3,0(a1)
8000dc72:	00d50023          	sb	a3,0(a0)
8000dc76:	0585                	add	a1,a1,1
8000dc78:	0505                	add	a0,a0,1
8000dc7a:	167d                	add	a2,a2,-1
8000dc7c:	c22d                	beqz	a2,8000dcde <.Lmemcpy_memcpy_end>
8000dc7e:	01e51693          	sll	a3,a0,0x1e
8000dc82:	f6f5                	bnez	a3,8000dc6e <.Lmemcpy_word_align>

8000dc84 <.Lmemcpy_aligned>:
8000dc84:	02000693          	li	a3,32
8000dc88:	02d66763          	bltu	a2,a3,8000dcb6 <.Lmemcpy_word_copy>

8000dc8c <.Lmemcpy_aligned_block_copy_loop>:
8000dc8c:	4198                	lw	a4,0(a1)
8000dc8e:	c118                	sw	a4,0(a0)
8000dc90:	41d8                	lw	a4,4(a1)
8000dc92:	c158                	sw	a4,4(a0)
8000dc94:	4598                	lw	a4,8(a1)
8000dc96:	c518                	sw	a4,8(a0)
8000dc98:	45d8                	lw	a4,12(a1)
8000dc9a:	c558                	sw	a4,12(a0)
8000dc9c:	4998                	lw	a4,16(a1)
8000dc9e:	c918                	sw	a4,16(a0)
8000dca0:	49d8                	lw	a4,20(a1)
8000dca2:	c958                	sw	a4,20(a0)
8000dca4:	4d98                	lw	a4,24(a1)
8000dca6:	cd18                	sw	a4,24(a0)
8000dca8:	4dd8                	lw	a4,28(a1)
8000dcaa:	cd58                	sw	a4,28(a0)
8000dcac:	9536                	add	a0,a0,a3
8000dcae:	95b6                	add	a1,a1,a3
8000dcb0:	8e15                	sub	a2,a2,a3
8000dcb2:	fcd67de3          	bgeu	a2,a3,8000dc8c <.Lmemcpy_aligned_block_copy_loop>

8000dcb6 <.Lmemcpy_word_copy>:
8000dcb6:	c605                	beqz	a2,8000dcde <.Lmemcpy_memcpy_end>
8000dcb8:	4691                	li	a3,4
8000dcba:	00d66963          	bltu	a2,a3,8000dccc <.Lmemcpy_byte_copy>

8000dcbe <.Lmemcpy_word_copy_loop>:
8000dcbe:	4198                	lw	a4,0(a1)
8000dcc0:	c118                	sw	a4,0(a0)
8000dcc2:	9536                	add	a0,a0,a3
8000dcc4:	95b6                	add	a1,a1,a3
8000dcc6:	8e15                	sub	a2,a2,a3
8000dcc8:	fed67be3          	bgeu	a2,a3,8000dcbe <.Lmemcpy_word_copy_loop>

8000dccc <.Lmemcpy_byte_copy>:
8000dccc:	ca09                	beqz	a2,8000dcde <.Lmemcpy_memcpy_end>

8000dcce <.Lmemcpy_byte_copy_loop>:
8000dcce:	00058703          	lb	a4,0(a1)
8000dcd2:	00e50023          	sb	a4,0(a0)
8000dcd6:	0585                	add	a1,a1,1
8000dcd8:	0505                	add	a0,a0,1
8000dcda:	167d                	add	a2,a2,-1
8000dcdc:	fa6d                	bnez	a2,8000dcce <.Lmemcpy_byte_copy_loop>

8000dcde <.Lmemcpy_memcpy_end>:
8000dcde:	853e                	mv	a0,a5

8000dce0 <.Lmemcpy_done>:
8000dce0:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_pow10f:

8000dce2 <__SEGGER_RTL_pow10f>:
8000dce2:	1101                	add	sp,sp,-32
8000dce4:	cc22                	sw	s0,24(sp)
8000dce6:	c64e                	sw	s3,12(sp)
8000dce8:	ce06                	sw	ra,28(sp)
8000dcea:	ca26                	sw	s1,20(sp)
8000dcec:	c84a                	sw	s2,16(sp)
8000dcee:	842a                	mv	s0,a0
8000dcf0:	4981                	li	s3,0
8000dcf2:	00055563          	bgez	a0,8000dcfc <.L17>
8000dcf6:	40a00433          	neg	s0,a0
8000dcfa:	4985                	li	s3,1

8000dcfc <.L17>:
8000dcfc:	80006937          	lui	s2,0x80006
8000dd00:	cd092503          	lw	a0,-816(s2) # 80005cd0 <.Lmerged_single+0x4>
8000dd04:	800064b7          	lui	s1,0x80006
8000dd08:	a9848493          	add	s1,s1,-1384 # 80005a98 <__SEGGER_RTL_aPower2f>

8000dd0c <.L18>:
8000dd0c:	ec19                	bnez	s0,8000dd2a <.L20>
8000dd0e:	00098763          	beqz	s3,8000dd1c <.L16>
8000dd12:	85aa                	mv	a1,a0
8000dd14:	cd092503          	lw	a0,-816(s2)
8000dd18:	60e050ef          	jal	80013326 <__divsf3>

8000dd1c <.L16>:
8000dd1c:	40f2                	lw	ra,28(sp)
8000dd1e:	4462                	lw	s0,24(sp)
8000dd20:	44d2                	lw	s1,20(sp)
8000dd22:	4942                	lw	s2,16(sp)
8000dd24:	49b2                	lw	s3,12(sp)
8000dd26:	6105                	add	sp,sp,32
8000dd28:	8082                	ret

8000dd2a <.L20>:
8000dd2a:	00147793          	and	a5,s0,1
8000dd2e:	c781                	beqz	a5,8000dd36 <.L19>
8000dd30:	408c                	lw	a1,0(s1)
8000dd32:	544050ef          	jal	80013276 <__mulsf3>

8000dd36 <.L19>:
8000dd36:	8405                	sra	s0,s0,0x1
8000dd38:	0491                	add	s1,s1,4
8000dd3a:	bfc9                	j	8000dd0c <.L18>

Disassembly of section .text.libc.__SEGGER_RTL_prin_flush:

8000dd3c <__SEGGER_RTL_prin_flush>:
8000dd3c:	4950                	lw	a2,20(a0)
8000dd3e:	ce19                	beqz	a2,8000dd5c <.L20>
8000dd40:	511c                	lw	a5,32(a0)
8000dd42:	1141                	add	sp,sp,-16
8000dd44:	c422                	sw	s0,8(sp)
8000dd46:	c606                	sw	ra,12(sp)
8000dd48:	842a                	mv	s0,a0
8000dd4a:	c399                	beqz	a5,8000dd50 <.L12>
8000dd4c:	490c                	lw	a1,16(a0)
8000dd4e:	9782                	jalr	a5

8000dd50 <.L12>:
8000dd50:	40b2                	lw	ra,12(sp)
8000dd52:	00042a23          	sw	zero,20(s0)
8000dd56:	4422                	lw	s0,8(sp)
8000dd58:	0141                	add	sp,sp,16
8000dd5a:	8082                	ret

8000dd5c <.L20>:
8000dd5c:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_pre_padding:

8000dd5e <__SEGGER_RTL_pre_padding>:
8000dd5e:	0105f793          	and	a5,a1,16
8000dd62:	eb91                	bnez	a5,8000dd76 <.L40>
8000dd64:	2005f793          	and	a5,a1,512
8000dd68:	02000593          	li	a1,32
8000dd6c:	c399                	beqz	a5,8000dd72 <.L42>
8000dd6e:	03000593          	li	a1,48

8000dd72 <.L42>:
8000dd72:	4b50506f          	j	80013a26 <__SEGGER_RTL_print_padding>

8000dd76 <.L40>:
8000dd76:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_init_prin_l:

8000dd78 <__SEGGER_RTL_init_prin_l>:
8000dd78:	1141                	add	sp,sp,-16
8000dd7a:	c226                	sw	s1,4(sp)
8000dd7c:	02400613          	li	a2,36
8000dd80:	84ae                	mv	s1,a1
8000dd82:	4581                	li	a1,0
8000dd84:	c422                	sw	s0,8(sp)
8000dd86:	c606                	sw	ra,12(sp)
8000dd88:	842a                	mv	s0,a0
8000dd8a:	0c9050ef          	jal	80013652 <memset>
8000dd8e:	40b2                	lw	ra,12(sp)
8000dd90:	cc44                	sw	s1,28(s0)
8000dd92:	4422                	lw	s0,8(sp)
8000dd94:	4492                	lw	s1,4(sp)
8000dd96:	0141                	add	sp,sp,16
8000dd98:	8082                	ret

Disassembly of section .text.libc.vfprintf:

8000dd9a <vfprintf>:
8000dd9a:	1101                	add	sp,sp,-32
8000dd9c:	cc22                	sw	s0,24(sp)
8000dd9e:	ca26                	sw	s1,20(sp)
8000dda0:	ce06                	sw	ra,28(sp)
8000dda2:	84ae                	mv	s1,a1
8000dda4:	842a                	mv	s0,a0
8000dda6:	c632                	sw	a2,12(sp)
8000dda8:	35d060ef          	jal	80014904 <__SEGGER_RTL_current_locale>
8000ddac:	85aa                	mv	a1,a0
8000ddae:	8522                	mv	a0,s0
8000ddb0:	4462                	lw	s0,24(sp)
8000ddb2:	46b2                	lw	a3,12(sp)
8000ddb4:	40f2                	lw	ra,28(sp)
8000ddb6:	8626                	mv	a2,s1
8000ddb8:	44d2                	lw	s1,20(sp)
8000ddba:	6105                	add	sp,sp,32
8000ddbc:	4950506f          	j	80013a50 <vfprintf_l>

Disassembly of section .text.libc.printf:

8000ddc0 <printf>:
8000ddc0:	7139                	add	sp,sp,-64
8000ddc2:	da3e                	sw	a5,52(sp)
8000ddc4:	d22e                	sw	a1,36(sp)
8000ddc6:	85aa                	mv	a1,a0
8000ddc8:	1d41a503          	lw	a0,468(gp) # 120954c <stdout>
8000ddcc:	d432                	sw	a2,40(sp)
8000ddce:	1050                	add	a2,sp,36
8000ddd0:	ce06                	sw	ra,28(sp)
8000ddd2:	d636                	sw	a3,44(sp)
8000ddd4:	d83a                	sw	a4,48(sp)
8000ddd6:	dc42                	sw	a6,56(sp)
8000ddd8:	de46                	sw	a7,60(sp)
8000ddda:	c632                	sw	a2,12(sp)
8000dddc:	3f7d                	jal	8000dd9a <vfprintf>
8000ddde:	40f2                	lw	ra,28(sp)
8000dde0:	6121                	add	sp,sp,64
8000dde2:	8082                	ret

Disassembly of section .segger.init.__SEGGER_init_heap:

8000dde4 <__SEGGER_init_heap>:
8000dde4:	00200537          	lui	a0,0x200
8000dde8:	00050513          	mv	a0,a0
8000ddec:	002045b7          	lui	a1,0x204
8000ddf0:	00058593          	mv	a1,a1
8000ddf4:	8d89                	sub	a1,a1,a0
8000ddf6:	a009                	j	8000ddf8 <__SEGGER_RTL_init_heap>

Disassembly of section .text.libc.__SEGGER_RTL_init_heap:

8000ddf8 <__SEGGER_RTL_init_heap>:
8000ddf8:	479d                	li	a5,7
8000ddfa:	00b7f763          	bgeu	a5,a1,8000de08 <.L68>
8000ddfe:	14a1a223          	sw	a0,324(gp) # 12094bc <__SEGGER_RTL_heap_globals>
8000de02:	00052023          	sw	zero,0(a0) # 200000 <__DLM_segment_start__>
8000de06:	c14c                	sw	a1,4(a0)

8000de08 <.L68>:
8000de08:	8082                	ret

Disassembly of section .text.libc.malloc:

8000de0a <malloc>:
8000de0a:	1101                	add	sp,sp,-32
8000de0c:	ce06                	sw	ra,28(sp)
8000de0e:	c62a                	sw	a0,12(sp)
8000de10:	22f060ef          	jal	8001483e <__SEGGER_RTL_X_heap_lock>
8000de14:	4532                	lw	a0,12(sp)
8000de16:	14d060ef          	jal	80014762 <__SEGGER_RTL_alloc>
8000de1a:	c62a                	sw	a0,12(sp)
8000de1c:	237060ef          	jal	80014852 <__SEGGER_RTL_X_heap_unlock>
8000de20:	40f2                	lw	ra,28(sp)
8000de22:	4532                	lw	a0,12(sp)
8000de24:	6105                	add	sp,sp,32
8000de26:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ascii_toupper:

8000de28 <__SEGGER_RTL_ascii_toupper>:
8000de28:	f9f50713          	add	a4,a0,-97
8000de2c:	47e5                	li	a5,25
8000de2e:	00e7e363          	bltu	a5,a4,8000de34 <.L5>
8000de32:	1501                	add	a0,a0,-32

8000de34 <.L5>:
8000de34:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ascii_towupper:

8000de36 <__SEGGER_RTL_ascii_towupper>:
8000de36:	f9f50713          	add	a4,a0,-97
8000de3a:	47e5                	li	a5,25
8000de3c:	00e7e363          	bltu	a5,a4,8000de42 <.L12>
8000de40:	1501                	add	a0,a0,-32

8000de42 <.L12>:
8000de42:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ascii_mbtowc:

8000de44 <__SEGGER_RTL_ascii_mbtowc>:
8000de44:	87aa                	mv	a5,a0
8000de46:	4501                	li	a0,0
8000de48:	c195                	beqz	a1,8000de6c <.L55>
8000de4a:	c20d                	beqz	a2,8000de6c <.L55>
8000de4c:	0005c703          	lbu	a4,0(a1) # 204000 <__heap_end__>
8000de50:	07f00613          	li	a2,127
8000de54:	5579                	li	a0,-2
8000de56:	00e66b63          	bltu	a2,a4,8000de6c <.L55>
8000de5a:	c391                	beqz	a5,8000de5e <.L57>
8000de5c:	c398                	sw	a4,0(a5)

8000de5e <.L57>:
8000de5e:	0006a023          	sw	zero,0(a3)
8000de62:	0006a223          	sw	zero,4(a3)
8000de66:	00e03533          	snez	a0,a4
8000de6a:	8082                	ret

8000de6c <.L55>:
8000de6c:	8082                	ret

Disassembly of section .text.IIC_delay:

8000de6e <IIC_delay>:
{
8000de6e:	1141                	add	sp,sp,-16
	uint8_t t = 30;
8000de70:	47f9                	li	a5,30
8000de72:	00f107a3          	sb	a5,15(sp)
	while (t--)
8000de76:	0001                	nop

8000de78 <.L14>:
8000de78:	00f14783          	lbu	a5,15(sp)
8000de7c:	fff78713          	add	a4,a5,-1
8000de80:	00e107a3          	sb	a4,15(sp)
8000de84:	fbf5                	bnez	a5,8000de78 <.L14>
}
8000de86:	0001                	nop
8000de88:	0001                	nop
8000de8a:	0141                	add	sp,sp,16
8000de8c:	8082                	ret

Disassembly of section .text.I2C_Start:

8000de8e <I2C_Start>:
{
8000de8e:	1141                	add	sp,sp,-16
8000de90:	c606                	sw	ra,12(sp)
	OLED_SDA_Set();
8000de92:	4685                	li	a3,1
8000de94:	4619                	li	a2,6
8000de96:	458d                	li	a1,3
8000de98:	f00d0537          	lui	a0,0xf00d0
8000de9c:	e7ff70ef          	jal	80005d1a <gpio_write_pin>
	OLED_SCL_Set();
8000dea0:	4685                	li	a3,1
8000dea2:	461d                	li	a2,7
8000dea4:	458d                	li	a1,3
8000dea6:	f00d0537          	lui	a0,0xf00d0
8000deaa:	e71f70ef          	jal	80005d1a <gpio_write_pin>
	IIC_delay();
8000deae:	37c1                	jal	8000de6e <IIC_delay>
	OLED_SDA_Clr();
8000deb0:	4681                	li	a3,0
8000deb2:	4619                	li	a2,6
8000deb4:	458d                	li	a1,3
8000deb6:	f00d0537          	lui	a0,0xf00d0
8000deba:	e61f70ef          	jal	80005d1a <gpio_write_pin>
	IIC_delay();
8000debe:	3f45                	jal	8000de6e <IIC_delay>
	OLED_SCL_Clr();
8000dec0:	4681                	li	a3,0
8000dec2:	461d                	li	a2,7
8000dec4:	458d                	li	a1,3
8000dec6:	f00d0537          	lui	a0,0xf00d0
8000deca:	e51f70ef          	jal	80005d1a <gpio_write_pin>
	IIC_delay();
8000dece:	3745                	jal	8000de6e <IIC_delay>
}
8000ded0:	0001                	nop
8000ded2:	40b2                	lw	ra,12(sp)
8000ded4:	0141                	add	sp,sp,16
8000ded6:	8082                	ret

Disassembly of section .text.OLED_Refresh:

8000ded8 <OLED_Refresh>:
{
8000ded8:	1101                	add	sp,sp,-32
8000deda:	ce06                	sw	ra,28(sp)
	for (i = 0; i < 8; i++)
8000dedc:	000107a3          	sb	zero,15(sp)
8000dee0:	a059                	j	8000df66 <.L29>

8000dee2 <.L32>:
		OLED_WR_Byte(0xb0 + i, OLED_CMD); // 设置行起始地址
8000dee2:	00f14783          	lbu	a5,15(sp)
8000dee6:	fb078793          	add	a5,a5,-80
8000deea:	0ff7f793          	zext.b	a5,a5
8000deee:	4581                	li	a1,0
8000def0:	853e                	mv	a0,a5
8000def2:	80cf80ef          	jal	80005efe <OLED_WR_Byte>
		OLED_WR_Byte(0x00, OLED_CMD);	  // 设置低列起始地址
8000def6:	4581                	li	a1,0
8000def8:	4501                	li	a0,0
8000defa:	804f80ef          	jal	80005efe <OLED_WR_Byte>
		OLED_WR_Byte(0x10, OLED_CMD);	  // 设置高列起始地址
8000defe:	4581                	li	a1,0
8000df00:	4541                	li	a0,16
8000df02:	ffdf70ef          	jal	80005efe <OLED_WR_Byte>
		I2C_Start();
8000df06:	3761                	jal	8000de8e <I2C_Start>
		Send_Byte(0x78);
8000df08:	07800513          	li	a0,120
8000df0c:	f73f70ef          	jal	80005e7e <Send_Byte>
		I2C_WaitAck();
8000df10:	f2bf70ef          	jal	80005e3a <I2C_WaitAck>
		Send_Byte(0x40);
8000df14:	04000513          	li	a0,64
8000df18:	f67f70ef          	jal	80005e7e <Send_Byte>
		I2C_WaitAck();
8000df1c:	f1ff70ef          	jal	80005e3a <I2C_WaitAck>
		for (n = 0; n < 128; n++)
8000df20:	00010723          	sb	zero,14(sp)
8000df24:	a035                	j	8000df50 <.L30>

8000df26 <.L31>:
			Send_Byte(OLED_GRAM[n][i]);
8000df26:	00e14703          	lbu	a4,14(sp)
8000df2a:	00f14783          	lbu	a5,15(sp)
8000df2e:	80018693          	add	a3,gp,-2048 # 1208b78 <OLED_GRAM>
8000df32:	070e                	sll	a4,a4,0x3
8000df34:	9736                	add	a4,a4,a3
8000df36:	97ba                	add	a5,a5,a4
8000df38:	0007c783          	lbu	a5,0(a5)
8000df3c:	853e                	mv	a0,a5
8000df3e:	f41f70ef          	jal	80005e7e <Send_Byte>
			I2C_WaitAck();
8000df42:	ef9f70ef          	jal	80005e3a <I2C_WaitAck>
		for (n = 0; n < 128; n++)
8000df46:	00e14783          	lbu	a5,14(sp)
8000df4a:	0785                	add	a5,a5,1
8000df4c:	00f10723          	sb	a5,14(sp)

8000df50 <.L30>:
8000df50:	00e10783          	lb	a5,14(sp)
8000df54:	fc07d9e3          	bgez	a5,8000df26 <.L31>
		I2C_Stop();
8000df58:	ea7f70ef          	jal	80005dfe <I2C_Stop>
	for (i = 0; i < 8; i++)
8000df5c:	00f14783          	lbu	a5,15(sp)
8000df60:	0785                	add	a5,a5,1
8000df62:	00f107a3          	sb	a5,15(sp)

8000df66 <.L29>:
8000df66:	00f14703          	lbu	a4,15(sp)
8000df6a:	479d                	li	a5,7
8000df6c:	f6e7fbe3          	bgeu	a5,a4,8000dee2 <.L32>
}
8000df70:	0001                	nop
8000df72:	0001                	nop
8000df74:	40f2                	lw	ra,28(sp)
8000df76:	6105                	add	sp,sp,32
8000df78:	8082                	ret

Disassembly of section .text.OLED_Clear:

8000df7a <OLED_Clear>:
{
8000df7a:	1101                	add	sp,sp,-32
8000df7c:	ce06                	sw	ra,28(sp)
	for (i = 0; i < 8; i++)
8000df7e:	000107a3          	sb	zero,15(sp)
8000df82:	a82d                	j	8000dfbc <.L34>

8000df84 <.L37>:
		for (n = 0; n < 128; n++)
8000df84:	00010723          	sb	zero,14(sp)
8000df88:	a00d                	j	8000dfaa <.L35>

8000df8a <.L36>:
			OLED_GRAM[n][i] = 0; // 清除所有数据
8000df8a:	00e14703          	lbu	a4,14(sp)
8000df8e:	00f14783          	lbu	a5,15(sp)
8000df92:	80018693          	add	a3,gp,-2048 # 1208b78 <OLED_GRAM>
8000df96:	070e                	sll	a4,a4,0x3
8000df98:	9736                	add	a4,a4,a3
8000df9a:	97ba                	add	a5,a5,a4
8000df9c:	00078023          	sb	zero,0(a5)
		for (n = 0; n < 128; n++)
8000dfa0:	00e14783          	lbu	a5,14(sp)
8000dfa4:	0785                	add	a5,a5,1
8000dfa6:	00f10723          	sb	a5,14(sp)

8000dfaa <.L35>:
8000dfaa:	00e10783          	lb	a5,14(sp)
8000dfae:	fc07dee3          	bgez	a5,8000df8a <.L36>
	for (i = 0; i < 8; i++)
8000dfb2:	00f14783          	lbu	a5,15(sp)
8000dfb6:	0785                	add	a5,a5,1
8000dfb8:	00f107a3          	sb	a5,15(sp)

8000dfbc <.L34>:
8000dfbc:	00f14703          	lbu	a4,15(sp)
8000dfc0:	479d                	li	a5,7
8000dfc2:	fce7f1e3          	bgeu	a5,a4,8000df84 <.L37>
	OLED_Refresh(); // 更新显示
8000dfc6:	3f09                	jal	8000ded8 <OLED_Refresh>
}
8000dfc8:	0001                	nop
8000dfca:	40f2                	lw	ra,28(sp)
8000dfcc:	6105                	add	sp,sp,32
8000dfce:	8082                	ret

Disassembly of section .text.OLED_DrawPoint:

8000dfd0 <OLED_DrawPoint>:
{
8000dfd0:	1101                	add	sp,sp,-32
8000dfd2:	87aa                	mv	a5,a0
8000dfd4:	86ae                	mv	a3,a1
8000dfd6:	8732                	mv	a4,a2
8000dfd8:	00f107a3          	sb	a5,15(sp)
8000dfdc:	87b6                	mv	a5,a3
8000dfde:	00f10723          	sb	a5,14(sp)
8000dfe2:	87ba                	mv	a5,a4
8000dfe4:	00f106a3          	sb	a5,13(sp)
	i = y / 8;
8000dfe8:	00e14783          	lbu	a5,14(sp)
8000dfec:	838d                	srl	a5,a5,0x3
8000dfee:	00f10fa3          	sb	a5,31(sp)
	m = y % 8;
8000dff2:	00e14783          	lbu	a5,14(sp)
8000dff6:	8b9d                	and	a5,a5,7
8000dff8:	00f10f23          	sb	a5,30(sp)
	n = 1 << m;
8000dffc:	01e14783          	lbu	a5,30(sp)
8000e000:	4705                	li	a4,1
8000e002:	00f717b3          	sll	a5,a4,a5
8000e006:	00f10ea3          	sb	a5,29(sp)
	if (t)
8000e00a:	00d14783          	lbu	a5,13(sp)
8000e00e:	cf8d                	beqz	a5,8000e048 <.L39>
		OLED_GRAM[x][i] |= n;
8000e010:	00f14703          	lbu	a4,15(sp)
8000e014:	01f14783          	lbu	a5,31(sp)
8000e018:	80018693          	add	a3,gp,-2048 # 1208b78 <OLED_GRAM>
8000e01c:	070e                	sll	a4,a4,0x3
8000e01e:	9736                	add	a4,a4,a3
8000e020:	97ba                	add	a5,a5,a4
8000e022:	0007c703          	lbu	a4,0(a5)
8000e026:	00f14683          	lbu	a3,15(sp)
8000e02a:	01f14783          	lbu	a5,31(sp)
8000e02e:	01d14603          	lbu	a2,29(sp)
8000e032:	8f51                	or	a4,a4,a2
8000e034:	0ff77713          	zext.b	a4,a4
8000e038:	80018613          	add	a2,gp,-2048 # 1208b78 <OLED_GRAM>
8000e03c:	068e                	sll	a3,a3,0x3
8000e03e:	96b2                	add	a3,a3,a2
8000e040:	97b6                	add	a5,a5,a3
8000e042:	00e78023          	sb	a4,0(a5)
}
8000e046:	a045                	j	8000e0e6 <.L41>

8000e048 <.L39>:
		OLED_GRAM[x][i] = ~OLED_GRAM[x][i];
8000e048:	00f14703          	lbu	a4,15(sp)
8000e04c:	01f14783          	lbu	a5,31(sp)
8000e050:	80018693          	add	a3,gp,-2048 # 1208b78 <OLED_GRAM>
8000e054:	070e                	sll	a4,a4,0x3
8000e056:	9736                	add	a4,a4,a3
8000e058:	97ba                	add	a5,a5,a4
8000e05a:	0007c703          	lbu	a4,0(a5)
8000e05e:	00f14683          	lbu	a3,15(sp)
8000e062:	01f14783          	lbu	a5,31(sp)
8000e066:	fff74713          	not	a4,a4
8000e06a:	0ff77713          	zext.b	a4,a4
8000e06e:	80018613          	add	a2,gp,-2048 # 1208b78 <OLED_GRAM>
8000e072:	068e                	sll	a3,a3,0x3
8000e074:	96b2                	add	a3,a3,a2
8000e076:	97b6                	add	a5,a5,a3
8000e078:	00e78023          	sb	a4,0(a5)
		OLED_GRAM[x][i] |= n;
8000e07c:	00f14703          	lbu	a4,15(sp)
8000e080:	01f14783          	lbu	a5,31(sp)
8000e084:	80018693          	add	a3,gp,-2048 # 1208b78 <OLED_GRAM>
8000e088:	070e                	sll	a4,a4,0x3
8000e08a:	9736                	add	a4,a4,a3
8000e08c:	97ba                	add	a5,a5,a4
8000e08e:	0007c703          	lbu	a4,0(a5)
8000e092:	00f14683          	lbu	a3,15(sp)
8000e096:	01f14783          	lbu	a5,31(sp)
8000e09a:	01d14603          	lbu	a2,29(sp)
8000e09e:	8f51                	or	a4,a4,a2
8000e0a0:	0ff77713          	zext.b	a4,a4
8000e0a4:	80018613          	add	a2,gp,-2048 # 1208b78 <OLED_GRAM>
8000e0a8:	068e                	sll	a3,a3,0x3
8000e0aa:	96b2                	add	a3,a3,a2
8000e0ac:	97b6                	add	a5,a5,a3
8000e0ae:	00e78023          	sb	a4,0(a5)
		OLED_GRAM[x][i] = ~OLED_GRAM[x][i];
8000e0b2:	00f14703          	lbu	a4,15(sp)
8000e0b6:	01f14783          	lbu	a5,31(sp)
8000e0ba:	80018693          	add	a3,gp,-2048 # 1208b78 <OLED_GRAM>
8000e0be:	070e                	sll	a4,a4,0x3
8000e0c0:	9736                	add	a4,a4,a3
8000e0c2:	97ba                	add	a5,a5,a4
8000e0c4:	0007c703          	lbu	a4,0(a5)
8000e0c8:	00f14683          	lbu	a3,15(sp)
8000e0cc:	01f14783          	lbu	a5,31(sp)
8000e0d0:	fff74713          	not	a4,a4
8000e0d4:	0ff77713          	zext.b	a4,a4
8000e0d8:	80018613          	add	a2,gp,-2048 # 1208b78 <OLED_GRAM>
8000e0dc:	068e                	sll	a3,a3,0x3
8000e0de:	96b2                	add	a3,a3,a2
8000e0e0:	97b6                	add	a5,a5,a3
8000e0e2:	00e78023          	sb	a4,0(a5)

8000e0e6 <.L41>:
}
8000e0e6:	0001                	nop
8000e0e8:	6105                	add	sp,sp,32
8000e0ea:	8082                	ret

Disassembly of section .text.OLED_ShowChar:

8000e0ec <OLED_ShowChar>:
{
8000e0ec:	7179                	add	sp,sp,-48
8000e0ee:	d606                	sw	ra,44(sp)
8000e0f0:	87aa                	mv	a5,a0
8000e0f2:	00f107a3          	sb	a5,15(sp)
8000e0f6:	87ae                	mv	a5,a1
8000e0f8:	00f10723          	sb	a5,14(sp)
8000e0fc:	87b2                	mv	a5,a2
8000e0fe:	00f106a3          	sb	a5,13(sp)
8000e102:	87b6                	mv	a5,a3
8000e104:	00f10623          	sb	a5,12(sp)
8000e108:	87ba                	mv	a5,a4
8000e10a:	00f105a3          	sb	a5,11(sp)
	uint8_t x0 = x, y0 = y;
8000e10e:	00f14783          	lbu	a5,15(sp)
8000e112:	00f10d23          	sb	a5,26(sp)
8000e116:	00e14783          	lbu	a5,14(sp)
8000e11a:	00f10da3          	sb	a5,27(sp)
	if (size1 == 8)
8000e11e:	00c14703          	lbu	a4,12(sp)
8000e122:	47a1                	li	a5,8
8000e124:	00f71663          	bne	a4,a5,8000e130 <.L59>
		size2 = 6;
8000e128:	4799                	li	a5,6
8000e12a:	00f10e23          	sb	a5,28(sp)
8000e12e:	a825                	j	8000e166 <.L60>

8000e130 <.L59>:
		size2 = (size1 / 8 + ((size1 % 8) ? 1 : 0)) * (size1 / 2); // 得到字体一个字符对应点阵集所占的字节数
8000e130:	00c14783          	lbu	a5,12(sp)
8000e134:	838d                	srl	a5,a5,0x3
8000e136:	0ff7f793          	zext.b	a5,a5
8000e13a:	873e                	mv	a4,a5
8000e13c:	00c14783          	lbu	a5,12(sp)
8000e140:	8b9d                	and	a5,a5,7
8000e142:	0ff7f793          	zext.b	a5,a5
8000e146:	00f037b3          	snez	a5,a5
8000e14a:	0ff7f793          	zext.b	a5,a5
8000e14e:	97ba                	add	a5,a5,a4
8000e150:	0ff7f713          	zext.b	a4,a5
8000e154:	00c14783          	lbu	a5,12(sp)
8000e158:	8385                	srl	a5,a5,0x1
8000e15a:	0ff7f793          	zext.b	a5,a5
8000e15e:	02f707b3          	mul	a5,a4,a5
8000e162:	00f10e23          	sb	a5,28(sp)

8000e166 <.L60>:
	chr1 = chr - ' ';											   // 计算偏移后的值
8000e166:	00d14783          	lbu	a5,13(sp)
8000e16a:	1781                	add	a5,a5,-32
8000e16c:	00f10ca3          	sb	a5,25(sp)
	for (i = 0; i < size2; i++)
8000e170:	00010fa3          	sb	zero,31(sp)
8000e174:	aa9d                	j	8000e2ea <.L61>

8000e176 <.L73>:
		if (size1 == 8)
8000e176:	00c14703          	lbu	a4,12(sp)
8000e17a:	47a1                	li	a5,8
8000e17c:	02f71563          	bne	a4,a5,8000e1a6 <.L62>
			temp = asc2_0806[chr1][i];
8000e180:	01914703          	lbu	a4,25(sp)
8000e184:	01f14683          	lbu	a3,31(sp)
8000e188:	800037b7          	lui	a5,0x80003
8000e18c:	10878613          	add	a2,a5,264 # 80003108 <asc2_0806>
8000e190:	87ba                	mv	a5,a4
8000e192:	0786                	sll	a5,a5,0x1
8000e194:	97ba                	add	a5,a5,a4
8000e196:	0786                	sll	a5,a5,0x1
8000e198:	97b2                	add	a5,a5,a2
8000e19a:	97b6                	add	a5,a5,a3
8000e19c:	0007c783          	lbu	a5,0(a5)
8000e1a0:	00f10ea3          	sb	a5,29(sp)
8000e1a4:	a069                	j	8000e22e <.L63>

8000e1a6 <.L62>:
		else if (size1 == 12)
8000e1a6:	00c14703          	lbu	a4,12(sp)
8000e1aa:	47b1                	li	a5,12
8000e1ac:	02f71563          	bne	a4,a5,8000e1d6 <.L64>
			temp = asc2_1206[chr1][i];
8000e1b0:	01914703          	lbu	a4,25(sp)
8000e1b4:	01f14683          	lbu	a3,31(sp)
8000e1b8:	800037b7          	lui	a5,0x80003
8000e1bc:	33078613          	add	a2,a5,816 # 80003330 <asc2_1206>
8000e1c0:	87ba                	mv	a5,a4
8000e1c2:	0786                	sll	a5,a5,0x1
8000e1c4:	97ba                	add	a5,a5,a4
8000e1c6:	078a                	sll	a5,a5,0x2
8000e1c8:	97b2                	add	a5,a5,a2
8000e1ca:	97b6                	add	a5,a5,a3
8000e1cc:	0007c783          	lbu	a5,0(a5)
8000e1d0:	00f10ea3          	sb	a5,29(sp)
8000e1d4:	a8a9                	j	8000e22e <.L63>

8000e1d6 <.L64>:
		else if (size1 == 16)
8000e1d6:	00c14703          	lbu	a4,12(sp)
8000e1da:	47c1                	li	a5,16
8000e1dc:	02f71263          	bne	a4,a5,8000e200 <.L65>
			temp = asc2_1608[chr1][i];
8000e1e0:	01914703          	lbu	a4,25(sp)
8000e1e4:	01f14783          	lbu	a5,31(sp)
8000e1e8:	800036b7          	lui	a3,0x80003
8000e1ec:	7a468693          	add	a3,a3,1956 # 800037a4 <asc2_1608>
8000e1f0:	0712                	sll	a4,a4,0x4
8000e1f2:	9736                	add	a4,a4,a3
8000e1f4:	97ba                	add	a5,a5,a4
8000e1f6:	0007c783          	lbu	a5,0(a5)
8000e1fa:	00f10ea3          	sb	a5,29(sp)
8000e1fe:	a805                	j	8000e22e <.L63>

8000e200 <.L65>:
		else if (size1 == 24)
8000e200:	00c14703          	lbu	a4,12(sp)
8000e204:	47e1                	li	a5,24
8000e206:	0ef71963          	bne	a4,a5,8000e2f8 <.L74>
			temp = asc2_2412[chr1][i];
8000e20a:	01914703          	lbu	a4,25(sp)
8000e20e:	01f14683          	lbu	a3,31(sp)
8000e212:	800047b7          	lui	a5,0x80004
8000e216:	d9478613          	add	a2,a5,-620 # 80003d94 <asc2_2412>
8000e21a:	87ba                	mv	a5,a4
8000e21c:	078e                	sll	a5,a5,0x3
8000e21e:	97ba                	add	a5,a5,a4
8000e220:	078a                	sll	a5,a5,0x2
8000e222:	97b2                	add	a5,a5,a2
8000e224:	97b6                	add	a5,a5,a3
8000e226:	0007c783          	lbu	a5,0(a5)
8000e22a:	00f10ea3          	sb	a5,29(sp)

8000e22e <.L63>:
		for (m = 0; m < 8; m++)
8000e22e:	00010f23          	sb	zero,30(sp)
8000e232:	a8b1                	j	8000e28e <.L68>

8000e234 <.L71>:
			if (temp & 0x01)
8000e234:	01d14783          	lbu	a5,29(sp)
8000e238:	8b85                	and	a5,a5,1
8000e23a:	cf81                	beqz	a5,8000e252 <.L69>
				OLED_DrawPoint(x, y, mode);
8000e23c:	00b14683          	lbu	a3,11(sp)
8000e240:	00e14703          	lbu	a4,14(sp)
8000e244:	00f14783          	lbu	a5,15(sp)
8000e248:	8636                	mv	a2,a3
8000e24a:	85ba                	mv	a1,a4
8000e24c:	853e                	mv	a0,a5
8000e24e:	3349                	jal	8000dfd0 <OLED_DrawPoint>
8000e250:	a005                	j	8000e270 <.L70>

8000e252 <.L69>:
				OLED_DrawPoint(x, y, !mode);
8000e252:	00b14783          	lbu	a5,11(sp)
8000e256:	0017b793          	seqz	a5,a5
8000e25a:	0ff7f793          	zext.b	a5,a5
8000e25e:	86be                	mv	a3,a5
8000e260:	00e14703          	lbu	a4,14(sp)
8000e264:	00f14783          	lbu	a5,15(sp)
8000e268:	8636                	mv	a2,a3
8000e26a:	85ba                	mv	a1,a4
8000e26c:	853e                	mv	a0,a5
8000e26e:	338d                	jal	8000dfd0 <OLED_DrawPoint>

8000e270 <.L70>:
			temp >>= 1;
8000e270:	01d14783          	lbu	a5,29(sp)
8000e274:	8385                	srl	a5,a5,0x1
8000e276:	00f10ea3          	sb	a5,29(sp)
			y++;
8000e27a:	00e14783          	lbu	a5,14(sp)
8000e27e:	0785                	add	a5,a5,1
8000e280:	00f10723          	sb	a5,14(sp)
		for (m = 0; m < 8; m++)
8000e284:	01e14783          	lbu	a5,30(sp)
8000e288:	0785                	add	a5,a5,1
8000e28a:	00f10f23          	sb	a5,30(sp)

8000e28e <.L68>:
8000e28e:	01e14703          	lbu	a4,30(sp)
8000e292:	479d                	li	a5,7
8000e294:	fae7f0e3          	bgeu	a5,a4,8000e234 <.L71>
		x++;
8000e298:	00f14783          	lbu	a5,15(sp)
8000e29c:	0785                	add	a5,a5,1
8000e29e:	00f107a3          	sb	a5,15(sp)
		if ((size1 != 8) && ((x - x0) == size1 / 2))
8000e2a2:	00c14703          	lbu	a4,12(sp)
8000e2a6:	47a1                	li	a5,8
8000e2a8:	02f70863          	beq	a4,a5,8000e2d8 <.L72>
8000e2ac:	00f14703          	lbu	a4,15(sp)
8000e2b0:	01a14783          	lbu	a5,26(sp)
8000e2b4:	40f707b3          	sub	a5,a4,a5
8000e2b8:	00c14703          	lbu	a4,12(sp)
8000e2bc:	8305                	srl	a4,a4,0x1
8000e2be:	0ff77713          	zext.b	a4,a4
8000e2c2:	00e79b63          	bne	a5,a4,8000e2d8 <.L72>
			x = x0;
8000e2c6:	01a14783          	lbu	a5,26(sp)
8000e2ca:	00f107a3          	sb	a5,15(sp)
			y0 = y0 + 8;
8000e2ce:	01b14783          	lbu	a5,27(sp)
8000e2d2:	07a1                	add	a5,a5,8
8000e2d4:	00f10da3          	sb	a5,27(sp)

8000e2d8 <.L72>:
		y = y0;
8000e2d8:	01b14783          	lbu	a5,27(sp)
8000e2dc:	00f10723          	sb	a5,14(sp)
	for (i = 0; i < size2; i++)
8000e2e0:	01f14783          	lbu	a5,31(sp)
8000e2e4:	0785                	add	a5,a5,1
8000e2e6:	00f10fa3          	sb	a5,31(sp)

8000e2ea <.L61>:
8000e2ea:	01f14703          	lbu	a4,31(sp)
8000e2ee:	01c14783          	lbu	a5,28(sp)
8000e2f2:	e8f762e3          	bltu	a4,a5,8000e176 <.L73>
8000e2f6:	a011                	j	8000e2fa <.L58>

8000e2f8 <.L74>:
			return;
8000e2f8:	0001                	nop

8000e2fa <.L58>:
}
8000e2fa:	50b2                	lw	ra,44(sp)
8000e2fc:	6145                	add	sp,sp,48
8000e2fe:	8082                	ret

Disassembly of section .text.OLED_Pow:

8000e300 <OLED_Pow>:
{
8000e300:	1101                	add	sp,sp,-32
8000e302:	87aa                	mv	a5,a0
8000e304:	872e                	mv	a4,a1
8000e306:	00f107a3          	sb	a5,15(sp)
8000e30a:	87ba                	mv	a5,a4
8000e30c:	00f10723          	sb	a5,14(sp)
	uint32_t result = 1;
8000e310:	4785                	li	a5,1
8000e312:	ce3e                	sw	a5,28(sp)
	while (n--)
8000e314:	a039                	j	8000e322 <.L83>

8000e316 <.L84>:
		result *= m;
8000e316:	00f14783          	lbu	a5,15(sp)
8000e31a:	4772                	lw	a4,28(sp)
8000e31c:	02f707b3          	mul	a5,a4,a5
8000e320:	ce3e                	sw	a5,28(sp)

8000e322 <.L83>:
	while (n--)
8000e322:	00e14783          	lbu	a5,14(sp)
8000e326:	fff78713          	add	a4,a5,-1
8000e32a:	00e10723          	sb	a4,14(sp)
8000e32e:	f7e5                	bnez	a5,8000e316 <.L84>
	return result;
8000e330:	47f2                	lw	a5,28(sp)
}
8000e332:	853e                	mv	a0,a5
8000e334:	6105                	add	sp,sp,32
8000e336:	8082                	ret

Disassembly of section .text.COE_SyncTimeStamp:

8000e338 <COE_SyncTimeStamp>:
{
8000e338:	1101                	add	sp,sp,-32
8000e33a:	ce06                	sw	ra,28(sp)
    if (b32BitDc)
8000e33c:	1a61c803          	lbu	a6,422(gp) # 120951e <b32BitDc>
8000e340:	08080263          	beqz	a6,8000e3c4 <.L8>

8000e344 <.LBB2>:
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
8000e344:	37422883          	lw	a7,884(tp) # 374 <default_isr_62+0x7e>
8000e348:	37022803          	lw	a6,880(tp) # 370 <default_isr_62+0x7a>
8000e34c:	c642                	sw	a6,12(sp)
        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
8000e34e:	0e41a883          	lw	a7,228(gp) # 120945c <pEsc>
8000e352:	6805                	lui	a6,0x1
8000e354:	91080813          	add	a6,a6,-1776 # 910 <e2p_data_crc_calc>
8000e358:	9846                	add	a6,a6,a7
8000e35a:	00082803          	lw	a6,0(a6)
8000e35e:	c642                	sw	a6,12(sp)
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
8000e360:	37422883          	lw	a7,884(tp) # 374 <default_isr_62+0x7e>
8000e364:	37022803          	lw	a6,880(tp) # 370 <default_isr_62+0x7a>
8000e368:	00087713          	and	a4,a6,0
8000e36c:	fff8f793          	and	a5,a7,-1
8000e370:	4832                	lw	a6,12(sp)
8000e372:	8642                	mv	a2,a6
8000e374:	4681                	li	a3,0
8000e376:	00c76533          	or	a0,a4,a2
8000e37a:	00d7e5b3          	or	a1,a5,a3
8000e37e:	36a22823          	sw	a0,880(tp) # 370 <default_isr_62+0x7a>
8000e382:	36b22a23          	sw	a1,884(tp) # 374 <default_isr_62+0x7e>
        if (DcTime < u32LastDc32Value)
8000e386:	0ac1a783          	lw	a5,172(gp) # 1209424 <u32LastDc32Value>
8000e38a:	4732                	lw	a4,12(sp)
8000e38c:	02f77863          	bgeu	a4,a5,8000e3bc <.L9>
            u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
8000e390:	37022703          	lw	a4,880(tp) # 370 <default_isr_62+0x7a>
8000e394:	37422783          	lw	a5,884(tp) # 374 <default_isr_62+0x7e>
8000e398:	4501                	li	a0,0
8000e39a:	4585                	li	a1,1
8000e39c:	00a70633          	add	a2,a4,a0
8000e3a0:	8832                	mv	a6,a2
8000e3a2:	00e83833          	sltu	a6,a6,a4
8000e3a6:	00b786b3          	add	a3,a5,a1
8000e3aa:	00d807b3          	add	a5,a6,a3
8000e3ae:	86be                	mv	a3,a5
8000e3b0:	8732                	mv	a4,a2
8000e3b2:	87b6                	mv	a5,a3
8000e3b4:	36e22823          	sw	a4,880(tp) # 370 <default_isr_62+0x7a>
8000e3b8:	36f22a23          	sw	a5,884(tp) # 374 <default_isr_62+0x7e>

8000e3bc <.L9>:
        u32LastDc32Value = DcTime;
8000e3bc:	4732                	lw	a4,12(sp)
8000e3be:	0ae1a623          	sw	a4,172(gp) # 1209424 <u32LastDc32Value>

8000e3c2 <.LBE2>:
8000e3c2:	a821                	j	8000e3da <.L10>

8000e3c4 <.L8>:
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
8000e3c4:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000e3c8:	6785                	lui	a5,0x1
8000e3ca:	91078793          	add	a5,a5,-1776 # 910 <e2p_data_crc_calc>
8000e3ce:	97ba                	add	a5,a5,a4
8000e3d0:	4621                	li	a2,8
8000e3d2:	85be                	mv	a1,a5
8000e3d4:	37020513          	add	a0,tp,880 # 370 <default_isr_62+0x7a>
8000e3d8:	3051                	jal	8000dc5c <memcpy>

8000e3da <.L10>:
    u32CheckForDcOverrunCnt = 0;
8000e3da:	0a01aa23          	sw	zero,180(gp) # 120942c <u32CheckForDcOverrunCnt>
}
8000e3de:	0001                	nop
8000e3e0:	40f2                	lw	ra,28(sp)
8000e3e2:	6105                	add	sp,sp,32
8000e3e4:	8082                	ret

Disassembly of section .text.COE_GetObjectDictionary:

8000e3e6 <COE_GetObjectDictionary>:
    return (OBJCONST TOBJECT OBJMEM *) ObjDicList;
8000e3e6:	1341a783          	lw	a5,308(gp) # 12094ac <ObjDicList>
}
8000e3ea:	853e                	mv	a0,a5
8000e3ec:	8082                	ret

Disassembly of section .text.COE_ObjInit:

8000e3ee <COE_ObjInit>:
{
8000e3ee:	1101                	add	sp,sp,-32
8000e3f0:	ce06                	sw	ra,28(sp)
    sSyncManOutPar.subindex0         = 32;
8000e3f2:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e3f6:	0007c703          	lbu	a4,0(a5)
8000e3fa:	8b01                	and	a4,a4,0
8000e3fc:	02076713          	or	a4,a4,32
8000e400:	00e78023          	sb	a4,0(a5)
8000e404:	0017c703          	lbu	a4,1(a5)
8000e408:	8b01                	and	a4,a4,0
8000e40a:	00e780a3          	sb	a4,1(a5)
    sSyncManOutPar.u16SyncType     = SYNCTYPE_FREERUN;
8000e40e:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e412:	0027c703          	lbu	a4,2(a5)
8000e416:	8b01                	and	a4,a4,0
8000e418:	00e78123          	sb	a4,2(a5)
8000e41c:	0037c703          	lbu	a4,3(a5)
8000e420:	8b01                	and	a4,a4,0
8000e422:	00e781a3          	sb	a4,3(a5)
    sSyncManOutPar.u32CycleTime     = 0;
8000e426:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e42a:	0047c703          	lbu	a4,4(a5)
8000e42e:	8b01                	and	a4,a4,0
8000e430:	00e78223          	sb	a4,4(a5)
8000e434:	0057c703          	lbu	a4,5(a5)
8000e438:	8b01                	and	a4,a4,0
8000e43a:	00e782a3          	sb	a4,5(a5)
8000e43e:	0067c703          	lbu	a4,6(a5)
8000e442:	8b01                	and	a4,a4,0
8000e444:	00e78323          	sb	a4,6(a5)
8000e448:	0077c703          	lbu	a4,7(a5)
8000e44c:	8b01                	and	a4,a4,0
8000e44e:	00e783a3          	sb	a4,7(a5)
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
8000e452:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e456:	00c7c703          	lbu	a4,12(a5)
8000e45a:	8b01                	and	a4,a4,0
8000e45c:	01f76713          	or	a4,a4,31
8000e460:	00e78623          	sb	a4,12(a5)
8000e464:	00d7c703          	lbu	a4,13(a5)
8000e468:	8b01                	and	a4,a4,0
8000e46a:	04076713          	or	a4,a4,64
8000e46e:	00e786a3          	sb	a4,13(a5)
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
8000e472:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e476:	00e7c703          	lbu	a4,14(a5)
8000e47a:	8b01                	and	a4,a4,0
8000e47c:	fe076713          	or	a4,a4,-32
8000e480:	00e78723          	sb	a4,14(a5)
8000e484:	00f7c703          	lbu	a4,15(a5)
8000e488:	8b01                	and	a4,a4,0
8000e48a:	07976713          	or	a4,a4,121
8000e48e:	00e787a3          	sb	a4,15(a5)
8000e492:	0107c703          	lbu	a4,16(a5)
8000e496:	8b01                	and	a4,a4,0
8000e498:	00e78823          	sb	a4,16(a5)
8000e49c:	0117c703          	lbu	a4,17(a5)
8000e4a0:	8b01                	and	a4,a4,0
8000e4a2:	00e788a3          	sb	a4,17(a5)
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
8000e4a6:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e4aa:	0127c703          	lbu	a4,18(a5)
8000e4ae:	8b01                	and	a4,a4,0
8000e4b0:	00e78923          	sb	a4,18(a5)
8000e4b4:	0137c703          	lbu	a4,19(a5)
8000e4b8:	8b01                	and	a4,a4,0
8000e4ba:	00e789a3          	sb	a4,19(a5)
8000e4be:	0147c703          	lbu	a4,20(a5)
8000e4c2:	8b01                	and	a4,a4,0
8000e4c4:	00e78a23          	sb	a4,20(a5)
8000e4c8:	0157c703          	lbu	a4,21(a5)
8000e4cc:	8b01                	and	a4,a4,0
8000e4ce:	00e78aa3          	sb	a4,21(a5)
    sSyncManOutPar.u16GetCycleTime = 0;
8000e4d2:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e4d6:	01a7c703          	lbu	a4,26(a5)
8000e4da:	8b01                	and	a4,a4,0
8000e4dc:	00e78d23          	sb	a4,26(a5)
8000e4e0:	01b7c703          	lbu	a4,27(a5)
8000e4e4:	8b01                	and	a4,a4,0
8000e4e6:	00e78da3          	sb	a4,27(a5)
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
8000e4ea:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e4ee:	01c7c703          	lbu	a4,28(a5)
8000e4f2:	8b01                	and	a4,a4,0
8000e4f4:	00e78e23          	sb	a4,28(a5)
8000e4f8:	01d7c703          	lbu	a4,29(a5)
8000e4fc:	8b01                	and	a4,a4,0
8000e4fe:	00e78ea3          	sb	a4,29(a5)
8000e502:	01e7c703          	lbu	a4,30(a5)
8000e506:	8b01                	and	a4,a4,0
8000e508:	00e78f23          	sb	a4,30(a5)
8000e50c:	01f7c703          	lbu	a4,31(a5)
8000e510:	8b01                	and	a4,a4,0
8000e512:	00e78fa3          	sb	a4,31(a5)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
8000e516:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e51a:	0247c703          	lbu	a4,36(a5)
8000e51e:	8b01                	and	a4,a4,0
8000e520:	02e78223          	sb	a4,36(a5)
8000e524:	0257c703          	lbu	a4,37(a5)
8000e528:	8b01                	and	a4,a4,0
8000e52a:	02e782a3          	sb	a4,37(a5)
    sSyncManOutPar.u16CycleExceededCounter = 0;
8000e52e:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e532:	0267c703          	lbu	a4,38(a5)
8000e536:	8b01                	and	a4,a4,0
8000e538:	02e78323          	sb	a4,38(a5)
8000e53c:	0277c703          	lbu	a4,39(a5)
8000e540:	8b01                	and	a4,a4,0
8000e542:	02e783a3          	sb	a4,39(a5)
    sSyncManOutPar.u8SyncError = 0;
8000e546:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e54a:	02078e23          	sb	zero,60(a5)
    sSyncManInPar.subindex0         = 32;
8000e54e:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e552:	0007c703          	lbu	a4,0(a5)
8000e556:	8b01                	and	a4,a4,0
8000e558:	02076713          	or	a4,a4,32
8000e55c:	00e78023          	sb	a4,0(a5)
8000e560:	0017c703          	lbu	a4,1(a5)
8000e564:	8b01                	and	a4,a4,0
8000e566:	00e780a3          	sb	a4,1(a5)
    sSyncManInPar.u16SyncType         = SYNCTYPE_FREERUN;
8000e56a:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e56e:	0027c703          	lbu	a4,2(a5)
8000e572:	8b01                	and	a4,a4,0
8000e574:	00e78123          	sb	a4,2(a5)
8000e578:	0037c703          	lbu	a4,3(a5)
8000e57c:	8b01                	and	a4,a4,0
8000e57e:	00e781a3          	sb	a4,3(a5)
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
8000e582:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e586:	0047c703          	lbu	a4,4(a5)
8000e58a:	0057c683          	lbu	a3,5(a5)
8000e58e:	06a2                	sll	a3,a3,0x8
8000e590:	8f55                	or	a4,a4,a3
8000e592:	0067c683          	lbu	a3,6(a5)
8000e596:	06c2                	sll	a3,a3,0x10
8000e598:	8f55                	or	a4,a4,a3
8000e59a:	0077c783          	lbu	a5,7(a5)
8000e59e:	07e2                	sll	a5,a5,0x18
8000e5a0:	8fd9                	or	a5,a5,a4
8000e5a2:	873e                	mv	a4,a5
8000e5a4:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e5a8:	0ff77693          	zext.b	a3,a4
8000e5ac:	0047c603          	lbu	a2,4(a5)
8000e5b0:	8a01                	and	a2,a2,0
8000e5b2:	8ed1                	or	a3,a3,a2
8000e5b4:	00d78223          	sb	a3,4(a5)
8000e5b8:	00875693          	srl	a3,a4,0x8
8000e5bc:	0ff6f693          	zext.b	a3,a3
8000e5c0:	0057c603          	lbu	a2,5(a5)
8000e5c4:	8a01                	and	a2,a2,0
8000e5c6:	8ed1                	or	a3,a3,a2
8000e5c8:	00d782a3          	sb	a3,5(a5)
8000e5cc:	01075693          	srl	a3,a4,0x10
8000e5d0:	0ff6f693          	zext.b	a3,a3
8000e5d4:	0067c603          	lbu	a2,6(a5)
8000e5d8:	8a01                	and	a2,a2,0
8000e5da:	8ed1                	or	a3,a3,a2
8000e5dc:	00d78323          	sb	a3,6(a5)
8000e5e0:	8361                	srl	a4,a4,0x18
8000e5e2:	0077c683          	lbu	a3,7(a5)
8000e5e6:	8a81                	and	a3,a3,0
8000e5e8:	8f55                	or	a4,a4,a3
8000e5ea:	00e783a3          	sb	a4,7(a5)
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
8000e5ee:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e5f2:	00c7c703          	lbu	a4,12(a5)
8000e5f6:	00d7c783          	lbu	a5,13(a5)
8000e5fa:	07a2                	sll	a5,a5,0x8
8000e5fc:	8fd9                	or	a5,a5,a4
8000e5fe:	0807c733          	zext.h	a4,a5
8000e602:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e606:	0ff77693          	zext.b	a3,a4
8000e60a:	00c7c603          	lbu	a2,12(a5)
8000e60e:	8a01                	and	a2,a2,0
8000e610:	8ed1                	or	a3,a3,a2
8000e612:	00d78623          	sb	a3,12(a5)
8000e616:	8321                	srl	a4,a4,0x8
8000e618:	08074733          	zext.h	a4,a4
8000e61c:	00d7c683          	lbu	a3,13(a5)
8000e620:	8a81                	and	a3,a3,0
8000e622:	8f55                	or	a4,a4,a3
8000e624:	00e786a3          	sb	a4,13(a5)
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
8000e628:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e62c:	00e7c703          	lbu	a4,14(a5)
8000e630:	8b01                	and	a4,a4,0
8000e632:	fe076713          	or	a4,a4,-32
8000e636:	00e78723          	sb	a4,14(a5)
8000e63a:	00f7c703          	lbu	a4,15(a5)
8000e63e:	8b01                	and	a4,a4,0
8000e640:	07976713          	or	a4,a4,121
8000e644:	00e787a3          	sb	a4,15(a5)
8000e648:	0107c703          	lbu	a4,16(a5)
8000e64c:	8b01                	and	a4,a4,0
8000e64e:	00e78823          	sb	a4,16(a5)
8000e652:	0117c703          	lbu	a4,17(a5)
8000e656:	8b01                	and	a4,a4,0
8000e658:	00e788a3          	sb	a4,17(a5)
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
8000e65c:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e660:	0127c703          	lbu	a4,18(a5)
8000e664:	8b01                	and	a4,a4,0
8000e666:	00e78923          	sb	a4,18(a5)
8000e66a:	0137c703          	lbu	a4,19(a5)
8000e66e:	8b01                	and	a4,a4,0
8000e670:	00e789a3          	sb	a4,19(a5)
8000e674:	0147c703          	lbu	a4,20(a5)
8000e678:	8b01                	and	a4,a4,0
8000e67a:	00e78a23          	sb	a4,20(a5)
8000e67e:	0157c703          	lbu	a4,21(a5)
8000e682:	8b01                	and	a4,a4,0
8000e684:	00e78aa3          	sb	a4,21(a5)
    sSyncManInPar.u16GetCycleTime = 0;
8000e688:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e68c:	01a7c703          	lbu	a4,26(a5)
8000e690:	8b01                	and	a4,a4,0
8000e692:	00e78d23          	sb	a4,26(a5)
8000e696:	01b7c703          	lbu	a4,27(a5)
8000e69a:	8b01                	and	a4,a4,0
8000e69c:	00e78da3          	sb	a4,27(a5)
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
8000e6a0:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e6a4:	01c7c703          	lbu	a4,28(a5)
8000e6a8:	8b01                	and	a4,a4,0
8000e6aa:	00e78e23          	sb	a4,28(a5)
8000e6ae:	01d7c703          	lbu	a4,29(a5)
8000e6b2:	8b01                	and	a4,a4,0
8000e6b4:	00e78ea3          	sb	a4,29(a5)
8000e6b8:	01e7c703          	lbu	a4,30(a5)
8000e6bc:	8b01                	and	a4,a4,0
8000e6be:	00e78f23          	sb	a4,30(a5)
8000e6c2:	01f7c703          	lbu	a4,31(a5)
8000e6c6:	8b01                	and	a4,a4,0
8000e6c8:	00e78fa3          	sb	a4,31(a5)
    sSyncManInPar.u16SmEventMissedCounter = 0;
8000e6cc:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e6d0:	0247c703          	lbu	a4,36(a5)
8000e6d4:	8b01                	and	a4,a4,0
8000e6d6:	02e78223          	sb	a4,36(a5)
8000e6da:	0257c703          	lbu	a4,37(a5)
8000e6de:	8b01                	and	a4,a4,0
8000e6e0:	02e782a3          	sb	a4,37(a5)
    sSyncManInPar.u16CycleExceededCounter = 0;
8000e6e4:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e6e8:	0267c703          	lbu	a4,38(a5)
8000e6ec:	8b01                	and	a4,a4,0
8000e6ee:	02e78323          	sb	a4,38(a5)
8000e6f2:	0277c703          	lbu	a4,39(a5)
8000e6f6:	8b01                	and	a4,a4,0
8000e6f8:	02e783a3          	sb	a4,39(a5)
    sSyncManInPar.u8SyncError = 0;
8000e6fc:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e700:	02078e23          	sb	zero,60(a5)
    bSyncSetByUser = FALSE;
8000e704:	180186a3          	sb	zero,397(gp) # 1209505 <bSyncSetByUser>

8000e708 <.LBB3>:
    UINT16 result = COE_ObjDictionaryInit();
8000e708:	2895                	jal	8000e77c <.LFE232>
8000e70a:	87aa                	mv	a5,a0
8000e70c:	00f11723          	sh	a5,14(sp)
    if(result != 0)
8000e710:	00e15783          	lhu	a5,14(sp)
8000e714:	c399                	beqz	a5,8000e71a <.L21>
        COE_ClearObjDictionary();
8000e716:	f95f70ef          	jal	800066aa <COE_ClearObjDictionary>

8000e71a <.L21>:
    u8PendingSdo = 0;
8000e71a:	360207a3          	sb	zero,879(tp) # 36f <default_isr_62+0x79>
    bStoreCompleteAccess = FALSE;
8000e71e:	18018723          	sb	zero,398(gp) # 1209506 <bStoreCompleteAccess>
    u16StoreIndex   =   0;
8000e722:	34021323          	sh	zero,838(tp) # 346 <default_isr_62+0x50>
    u8StoreSubindex = 0;
8000e726:	34020aa3          	sb	zero,853(tp) # 355 <default_isr_62+0x5f>
    u32StoreDataSize = 0;
8000e72a:	0a01a023          	sw	zero,160(gp) # 1209418 <u32StoreDataSize>
    pStoreData = NULL;
8000e72e:	0c01a623          	sw	zero,204(gp) # 1209444 <pStoreData>
    pSdoPendFunc    = NULL;
8000e732:	0c01ae23          	sw	zero,220(gp) # 1209454 <pSdoPendFunc>
    pSdoSegData = NULL;
8000e736:	0c01aa23          	sw	zero,212(gp) # 120944c <pSdoSegData>

8000e73a <.LBB4>:
        UINT32 EscFeature = 0;
8000e73a:	c402                	sw	zero,8(sp)
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
8000e73c:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000e740:	07a1                	add	a5,a5,8
8000e742:	439c                	lw	a5,0(a5)
8000e744:	c43e                	sw	a5,8(sp)
        if ((EscFeature & ESC_DC_32BIT_MASK) > 0)
8000e746:	47a2                	lw	a5,8(sp)
8000e748:	8ba1                	and	a5,a5,8
8000e74a:	c781                	beqz	a5,8000e752 <.L22>
            b32BitDc = FALSE;
8000e74c:	1a018323          	sb	zero,422(gp) # 120951e <b32BitDc>
8000e750:	a829                	j	8000e76a <.L23>

8000e752 <.L22>:
            b32BitDc = TRUE;
8000e752:	4705                	li	a4,1
8000e754:	1ae18323          	sb	a4,422(gp) # 120951e <b32BitDc>
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
8000e758:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000e75c:	6785                	lui	a5,0x1
8000e75e:	91078793          	add	a5,a5,-1776 # 910 <e2p_data_crc_calc>
8000e762:	97ba                	add	a5,a5,a4
8000e764:	4398                	lw	a4,0(a5)
8000e766:	0ae1a623          	sw	a4,172(gp) # 1209424 <u32LastDc32Value>

8000e76a <.L23>:
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
8000e76a:	6705                	lui	a4,0x1
8000e76c:	fa070713          	add	a4,a4,-96 # fa0 <.L75+0xe>
8000e770:	0ae1aa23          	sw	a4,180(gp) # 120942c <u32CheckForDcOverrunCnt>

8000e774 <.LBE4>:
}
8000e774:	0001                	nop
8000e776:	40f2                	lw	ra,28(sp)
8000e778:	6105                	add	sp,sp,32
8000e77a:	8082                	ret

Disassembly of section .text.COE_ObjDictionaryInit:

8000e77c <COE_ObjDictionaryInit>:
{
8000e77c:	1101                	add	sp,sp,-32
8000e77e:	ce06                	sw	ra,28(sp)
    UINT16 result = 0;
8000e780:	00011723          	sh	zero,14(sp)
    ObjDicList = NULL;
8000e784:	1201aa23          	sw	zero,308(gp) # 12094ac <ObjDicList>
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
8000e788:	00020513          	mv	a0,tp
8000e78c:	f5bf70ef          	jal	800066e6 <AddObjectsToObjDictionary>
8000e790:	87aa                	mv	a5,a0
8000e792:	00f11723          	sh	a5,14(sp)
    if(result != 0)
8000e796:	00e15783          	lhu	a5,14(sp)
8000e79a:	c781                	beqz	a5,8000e7a2 <.L53>
        return result;
8000e79c:	00e15783          	lhu	a5,14(sp)
8000e7a0:	a811                	j	8000e7b4 <.L54>

8000e7a2 <.L53>:
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
8000e7a2:	1e020513          	add	a0,tp,480 # 1e0 <default_isr_11+0x64>
8000e7a6:	f41f70ef          	jal	800066e6 <AddObjectsToObjDictionary>
8000e7aa:	87aa                	mv	a5,a0
8000e7ac:	00f11723          	sh	a5,14(sp)
    return result;
8000e7b0:	00e15783          	lhu	a5,14(sp)

8000e7b4 <.L54>:
}
8000e7b4:	853e                	mv	a0,a5
8000e7b6:	40f2                	lw	ra,28(sp)
8000e7b8:	6105                	add	sp,sp,32
8000e7ba:	8082                	ret

Disassembly of section .text.ECAT_CheckTimer:

8000e7bc <ECAT_CheckTimer>:
{
8000e7bc:	1141                	add	sp,sp,-16
8000e7be:	c606                	sw	ra,12(sp)
8000e7c0:	c422                	sw	s0,8(sp)
8000e7c2:	c226                	sw	s1,4(sp)
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
8000e7c4:	19e1c783          	lbu	a5,414(gp) # 1209516 <bEcatWaitForAlControlRes>
8000e7c8:	c385                	beqz	a5,8000e7e8 <.L14>
8000e7ca:	17e19783          	lh	a5,382(gp) # 12094f6 <EsmTimeoutCounter>
8000e7ce:	00f05d63          	blez	a5,8000e7e8 <.L14>
        EsmTimeoutCounter--;
8000e7d2:	17e19783          	lh	a5,382(gp) # 12094f6 <EsmTimeoutCounter>
8000e7d6:	0807c7b3          	zext.h	a5,a5
8000e7da:	17fd                	add	a5,a5,-1
8000e7dc:	0807c7b3          	zext.h	a5,a5
8000e7e0:	60579713          	sext.h	a4,a5
8000e7e4:	16e19f23          	sh	a4,382(gp) # 12094f6 <EsmTimeoutCounter>

8000e7e8 <.L14>:
    DC_CheckWatchdog();
8000e7e8:	1ab000ef          	jal	8000f192 <DC_CheckWatchdog>
    if (u16EepromStoreTimeoutValue > 0)
8000e7ec:	1561d783          	lhu	a5,342(gp) # 12094ce <u16EepromStoreTimeoutValue>
8000e7f0:	cb85                	beqz	a5,8000e820 <.L15>
        u16EepromStoreTimeoutCounter++;
8000e7f2:	1581d783          	lhu	a5,344(gp) # 12094d0 <u16EepromStoreTimeoutCounter>
8000e7f6:	0785                	add	a5,a5,1
8000e7f8:	0807c733          	zext.h	a4,a5
8000e7fc:	14e19c23          	sh	a4,344(gp) # 12094d0 <u16EepromStoreTimeoutCounter>
        if (u16EepromStoreTimeoutValue <= u16EepromStoreTimeoutCounter)
8000e800:	1561d703          	lhu	a4,342(gp) # 12094ce <u16EepromStoreTimeoutValue>
8000e804:	1581d783          	lhu	a5,344(gp) # 12094d0 <u16EepromStoreTimeoutCounter>
8000e808:	00e7ec63          	bltu	a5,a4,8000e820 <.L15>
            u16EepromStoreTimeoutValue = 0;
8000e80c:	14019b23          	sh	zero,342(gp) # 12094ce <u16EepromStoreTimeoutValue>
            u16EepromStoreTimeoutCounter = 0;
8000e810:	14019c23          	sh	zero,344(gp) # 12094d0 <u16EepromStoreTimeoutCounter>
            if (pAPPL_EEPROM_Store != NULL)
8000e814:	0f81a783          	lw	a5,248(gp) # 1209470 <pAPPL_EEPROM_Store>
8000e818:	c781                	beqz	a5,8000e820 <.L15>
                pAPPL_EEPROM_Store();
8000e81a:	0f81a783          	lw	a5,248(gp) # 1209470 <pAPPL_EEPROM_Store>
8000e81e:	9782                	jalr	a5

8000e820 <.L15>:
    if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
8000e820:	1a61c783          	lbu	a5,422(gp) # 120951e <b32BitDc>
8000e824:	c785                	beqz	a5,8000e84c <.L16>
8000e826:	37022703          	lw	a4,880(tp) # 370 <default_isr_62+0x7a>
8000e82a:	37422783          	lw	a5,884(tp) # 374 <default_isr_62+0x7e>
8000e82e:	fff77413          	and	s0,a4,-1
8000e832:	0007f493          	and	s1,a5,0
8000e836:	87a6                	mv	a5,s1
8000e838:	e7a1                	bnez	a5,8000e880 <.L17>
8000e83a:	87a6                	mv	a5,s1
8000e83c:	eb81                	bnez	a5,8000e84c <.L16>
8000e83e:	8722                	mv	a4,s0
8000e840:	ffe207b7          	lui	a5,0xffe20
8000e844:	b4078793          	add	a5,a5,-1216 # ffe1fb40 <__AHB_SRAM_segment_end__+0xfc17b40>
8000e848:	02e7ec63          	bltu	a5,a4,8000e880 <.L17>

8000e84c <.L16>:
        u64Timestamp = u64Timestamp + 1000000;
8000e84c:	37022703          	lw	a4,880(tp) # 370 <default_isr_62+0x7a>
8000e850:	37422783          	lw	a5,884(tp) # 374 <default_isr_62+0x7e>
8000e854:	000f4537          	lui	a0,0xf4
8000e858:	24050513          	add	a0,a0,576 # f4240 <__AXI_SRAM_segment_size__+0xb4240>
8000e85c:	4581                	li	a1,0
8000e85e:	00a70633          	add	a2,a4,a0
8000e862:	8832                	mv	a6,a2
8000e864:	00e83833          	sltu	a6,a6,a4
8000e868:	00b786b3          	add	a3,a5,a1
8000e86c:	00d807b3          	add	a5,a6,a3
8000e870:	86be                	mv	a3,a5
8000e872:	8732                	mv	a4,a2
8000e874:	87b6                	mv	a5,a3
8000e876:	36e22823          	sw	a4,880(tp) # 370 <default_isr_62+0x7a>
8000e87a:	36f22a23          	sw	a5,884(tp) # 374 <default_isr_62+0x7e>
8000e87e:	a809                	j	8000e890 <.L19>

8000e880 <.L17>:
    else if(b32BitDc)
8000e880:	1a61c783          	lbu	a5,422(gp) # 120951e <b32BitDc>
8000e884:	c791                	beqz	a5,8000e890 <.L19>
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
8000e886:	6705                	lui	a4,0x1
8000e888:	fa070713          	add	a4,a4,-96 # fa0 <.L75+0xe>
8000e88c:	0ae1aa23          	sw	a4,180(gp) # 120942c <u32CheckForDcOverrunCnt>

8000e890 <.L19>:
    u32CheckForDcOverrunCnt++;
8000e890:	0b41a783          	lw	a5,180(gp) # 120942c <u32CheckForDcOverrunCnt>
8000e894:	00178713          	add	a4,a5,1
8000e898:	0ae1aa23          	sw	a4,180(gp) # 120942c <u32CheckForDcOverrunCnt>
}
8000e89c:	0001                	nop
8000e89e:	40b2                	lw	ra,12(sp)
8000e8a0:	4422                	lw	s0,8(sp)
8000e8a2:	4492                	lw	s1,4(sp)
8000e8a4:	0141                	add	sp,sp,16
8000e8a6:	8082                	ret

Disassembly of section .text.HandleCycleTimeMeasurement:

8000e8a8 <HandleCycleTimeMeasurement>:
{
8000e8a8:	1141                	add	sp,sp,-16
8000e8aa:	c606                	sw	ra,12(sp)
    if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
8000e8ac:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
8000e8b0:	14079e63          	bnez	a5,8000ea0c <.L26>
        if (u32CycleTimeStartValue > 0)
8000e8b4:	0b01a783          	lw	a5,176(gp) # 1209428 <u32CycleTimeStartValue>
8000e8b8:	14078463          	beqz	a5,8000ea00 <.L22>
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
8000e8bc:	0b01a783          	lw	a5,176(gp) # 1209428 <u32CycleTimeStartValue>
8000e8c0:	853e                	mv	a0,a5
8000e8c2:	a60f80ef          	jal	80006b22 <GetSystemTimeDelay>
8000e8c6:	872a                	mv	a4,a0
8000e8c8:	0ae1a823          	sw	a4,176(gp) # 1209428 <u32CycleTimeStartValue>
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
8000e8cc:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e8d0:	0047c703          	lbu	a4,4(a5)
8000e8d4:	0057c683          	lbu	a3,5(a5)
8000e8d8:	06a2                	sll	a3,a3,0x8
8000e8da:	8f55                	or	a4,a4,a3
8000e8dc:	0067c683          	lbu	a3,6(a5)
8000e8e0:	06c2                	sll	a3,a3,0x10
8000e8e2:	8f55                	or	a4,a4,a3
8000e8e4:	0077c783          	lbu	a5,7(a5)
8000e8e8:	07e2                	sll	a5,a5,0x18
8000e8ea:	8fd9                	or	a5,a5,a4
8000e8ec:	c795                	beqz	a5,8000e918 <.L23>
8000e8ee:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e8f2:	0047c703          	lbu	a4,4(a5)
8000e8f6:	0057c683          	lbu	a3,5(a5)
8000e8fa:	06a2                	sll	a3,a3,0x8
8000e8fc:	8f55                	or	a4,a4,a3
8000e8fe:	0067c683          	lbu	a3,6(a5)
8000e902:	06c2                	sll	a3,a3,0x10
8000e904:	8f55                	or	a4,a4,a3
8000e906:	0077c783          	lbu	a5,7(a5)
8000e90a:	07e2                	sll	a5,a5,0x18
8000e90c:	8fd9                	or	a5,a5,a4
8000e90e:	873e                	mv	a4,a5
8000e910:	0b01a783          	lw	a5,176(gp) # 1209428 <u32CycleTimeStartValue>
8000e914:	04e7f963          	bgeu	a5,a4,8000e966 <.L24>

8000e918 <.L23>:
                    sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
8000e918:	0b01a703          	lw	a4,176(gp) # 1209428 <u32CycleTimeStartValue>
8000e91c:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000e920:	0ff77693          	zext.b	a3,a4
8000e924:	0047c603          	lbu	a2,4(a5)
8000e928:	8a01                	and	a2,a2,0
8000e92a:	8ed1                	or	a3,a3,a2
8000e92c:	00d78223          	sb	a3,4(a5)
8000e930:	00875693          	srl	a3,a4,0x8
8000e934:	0ff6f693          	zext.b	a3,a3
8000e938:	0057c603          	lbu	a2,5(a5)
8000e93c:	8a01                	and	a2,a2,0
8000e93e:	8ed1                	or	a3,a3,a2
8000e940:	00d782a3          	sb	a3,5(a5)
8000e944:	01075693          	srl	a3,a4,0x10
8000e948:	0ff6f693          	zext.b	a3,a3
8000e94c:	0067c603          	lbu	a2,6(a5)
8000e950:	8a01                	and	a2,a2,0
8000e952:	8ed1                	or	a3,a3,a2
8000e954:	00d78323          	sb	a3,6(a5)
8000e958:	8361                	srl	a4,a4,0x18
8000e95a:	0077c683          	lbu	a3,7(a5)
8000e95e:	8a81                	and	a3,a3,0
8000e960:	8f55                	or	a4,a4,a3
8000e962:	00e783a3          	sb	a4,7(a5)

8000e966 <.L24>:
            if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
8000e966:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e96a:	0047c703          	lbu	a4,4(a5)
8000e96e:	0057c683          	lbu	a3,5(a5)
8000e972:	06a2                	sll	a3,a3,0x8
8000e974:	8f55                	or	a4,a4,a3
8000e976:	0067c683          	lbu	a3,6(a5)
8000e97a:	06c2                	sll	a3,a3,0x10
8000e97c:	8f55                	or	a4,a4,a3
8000e97e:	0077c783          	lbu	a5,7(a5)
8000e982:	07e2                	sll	a5,a5,0x18
8000e984:	8fd9                	or	a5,a5,a4
8000e986:	c795                	beqz	a5,8000e9b2 <.L25>
8000e988:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e98c:	0047c703          	lbu	a4,4(a5)
8000e990:	0057c683          	lbu	a3,5(a5)
8000e994:	06a2                	sll	a3,a3,0x8
8000e996:	8f55                	or	a4,a4,a3
8000e998:	0067c683          	lbu	a3,6(a5)
8000e99c:	06c2                	sll	a3,a3,0x10
8000e99e:	8f55                	or	a4,a4,a3
8000e9a0:	0077c783          	lbu	a5,7(a5)
8000e9a4:	07e2                	sll	a5,a5,0x18
8000e9a6:	8fd9                	or	a5,a5,a4
8000e9a8:	873e                	mv	a4,a5
8000e9aa:	0b01a783          	lw	a5,176(gp) # 1209428 <u32CycleTimeStartValue>
8000e9ae:	04e7f963          	bgeu	a5,a4,8000ea00 <.L22>

8000e9b2 <.L25>:
                    sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
8000e9b2:	0b01a703          	lw	a4,176(gp) # 1209428 <u32CycleTimeStartValue>
8000e9b6:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000e9ba:	0ff77693          	zext.b	a3,a4
8000e9be:	0047c603          	lbu	a2,4(a5)
8000e9c2:	8a01                	and	a2,a2,0
8000e9c4:	8ed1                	or	a3,a3,a2
8000e9c6:	00d78223          	sb	a3,4(a5)
8000e9ca:	00875693          	srl	a3,a4,0x8
8000e9ce:	0ff6f693          	zext.b	a3,a3
8000e9d2:	0057c603          	lbu	a2,5(a5)
8000e9d6:	8a01                	and	a2,a2,0
8000e9d8:	8ed1                	or	a3,a3,a2
8000e9da:	00d782a3          	sb	a3,5(a5)
8000e9de:	01075693          	srl	a3,a4,0x10
8000e9e2:	0ff6f693          	zext.b	a3,a3
8000e9e6:	0067c603          	lbu	a2,6(a5)
8000e9ea:	8a01                	and	a2,a2,0
8000e9ec:	8ed1                	or	a3,a3,a2
8000e9ee:	00d78323          	sb	a3,6(a5)
8000e9f2:	8361                	srl	a4,a4,0x18
8000e9f4:	0077c683          	lbu	a3,7(a5)
8000e9f8:	8a81                	and	a3,a3,0
8000e9fa:	8f55                	or	a4,a4,a3
8000e9fc:	00e783a3          	sb	a4,7(a5)

8000ea00 <.L22>:
        u32CycleTimeStartValue = GetSystemTimeDelay(0);
8000ea00:	4501                	li	a0,0
8000ea02:	920f80ef          	jal	80006b22 <GetSystemTimeDelay>
8000ea06:	872a                	mv	a4,a0
8000ea08:	0ae1a823          	sw	a4,176(gp) # 1209428 <u32CycleTimeStartValue>

8000ea0c <.L26>:
}
8000ea0c:	0001                	nop
8000ea0e:	40b2                	lw	ra,12(sp)
8000ea10:	0141                	add	sp,sp,16
8000ea12:	8082                	ret

Disassembly of section .text.Sync0_Isr:

8000ea14 <Sync0_Isr>:
{
8000ea14:	1101                	add	sp,sp,-32
8000ea16:	ce06                	sw	ra,28(sp)
     Sync0WdCounter = 0;
8000ea18:	16019c23          	sh	zero,376(gp) # 12094f0 <Sync0WdCounter>
    if(bDcSyncActive)
8000ea1c:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
8000ea20:	1e078463          	beqz	a5,8000ec08 <.L46>

8000ea24 <.LBB3>:
        BOOL bCallInputMapping = FALSE;
8000ea24:	000107a3          	sb	zero,15(sp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
8000ea28:	1a01c703          	lbu	a4,416(gp) # 1209518 <bEcatInputUpdateRunning>
8000ea2c:	4785                	li	a5,1
8000ea2e:	02f71e63          	bne	a4,a5,8000ea6a <.L47>
8000ea32:	17a1d783          	lhu	a5,378(gp) # 12094f2 <LatchInputSync0Value>
8000ea36:	cb95                	beqz	a5,8000ea6a <.L47>
8000ea38:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
8000ea3c:	c79d                	beqz	a5,8000ea6a <.L47>
            if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
8000ea3e:	17a1d703          	lhu	a4,378(gp) # 12094f2 <LatchInputSync0Value>
8000ea42:	17c1d783          	lhu	a5,380(gp) # 12094f4 <LatchInputSync0Counter>
8000ea46:	00e7f963          	bgeu	a5,a4,8000ea58 <.L48>
                LatchInputSync0Counter++;
8000ea4a:	17c1d783          	lhu	a5,380(gp) # 12094f4 <LatchInputSync0Counter>
8000ea4e:	0785                	add	a5,a5,1
8000ea50:	0807c733          	zext.h	a4,a5
8000ea54:	16e19e23          	sh	a4,380(gp) # 12094f4 <LatchInputSync0Counter>

8000ea58 <.L48>:
            if (LatchInputSync0Value == LatchInputSync0Counter)
8000ea58:	17a1d703          	lhu	a4,378(gp) # 12094f2 <LatchInputSync0Value>
8000ea5c:	17c1d783          	lhu	a5,380(gp) # 12094f4 <LatchInputSync0Counter>
8000ea60:	00f71563          	bne	a4,a5,8000ea6a <.L47>
                bCallInputMapping = TRUE;
8000ea64:	4785                	li	a5,1
8000ea66:	00f107a3          	sb	a5,15(sp)

8000ea6a <.L47>:
        if(u16SmSync0Value > 0)
8000ea6a:	35625783          	lhu	a5,854(tp) # 356 <default_isr_62+0x60>
8000ea6e:	16078d63          	beqz	a5,8000ebe8 <.L49>
           if (u16SmSync0Counter > u16SmSync0Value)
8000ea72:	fbe1d703          	lhu	a4,-66(gp) # 1209336 <u16SmSync0Counter>
8000ea76:	35625783          	lhu	a5,854(tp) # 356 <default_isr_62+0x60>
8000ea7a:	0ee7f763          	bgeu	a5,a4,8000eb68 <.L50>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
8000ea7e:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000ea82:	c7bd                	beqz	a5,8000eaf0 <.L51>
8000ea84:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ea88:	0247c703          	lbu	a4,36(a5)
8000ea8c:	0257c783          	lbu	a5,37(a5)
8000ea90:	07a2                	sll	a5,a5,0x8
8000ea92:	8fd9                	or	a5,a5,a4
8000ea94:	0807c733          	zext.h	a4,a5
8000ea98:	1a818793          	add	a5,gp,424 # 1209520 <sErrorSettings>
8000ea9c:	0067c683          	lbu	a3,6(a5)
8000eaa0:	0077c783          	lbu	a5,7(a5)
8000eaa4:	07a2                	sll	a5,a5,0x8
8000eaa6:	8fd5                	or	a5,a5,a3
8000eaa8:	0807c7b3          	zext.h	a5,a5
8000eaac:	04e7e263          	bltu	a5,a4,8000eaf0 <.L51>
                 sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
8000eab0:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000eab4:	0247c703          	lbu	a4,36(a5)
8000eab8:	0257c783          	lbu	a5,37(a5)
8000eabc:	07a2                	sll	a5,a5,0x8
8000eabe:	8fd9                	or	a5,a5,a4
8000eac0:	0807c7b3          	zext.h	a5,a5
8000eac4:	078d                	add	a5,a5,3
8000eac6:	0807c733          	zext.h	a4,a5
8000eaca:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000eace:	0ff77693          	zext.b	a3,a4
8000ead2:	0247c603          	lbu	a2,36(a5)
8000ead6:	8a01                	and	a2,a2,0
8000ead8:	8ed1                	or	a3,a3,a2
8000eada:	02d78223          	sb	a3,36(a5)
8000eade:	8321                	srl	a4,a4,0x8
8000eae0:	08074733          	zext.h	a4,a4
8000eae4:	0257c683          	lbu	a3,37(a5)
8000eae8:	8a81                	and	a3,a3,0
8000eaea:	8f55                	or	a4,a4,a3
8000eaec:	02e782a3          	sb	a4,37(a5)

8000eaf0 <.L51>:
               if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
8000eaf0:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
8000eaf4:	cbb5                	beqz	a5,8000eb68 <.L50>
8000eaf6:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000eafa:	e7bd                	bnez	a5,8000eb68 <.L50>
8000eafc:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000eb00:	0247c703          	lbu	a4,36(a5)
8000eb04:	0257c783          	lbu	a5,37(a5)
8000eb08:	07a2                	sll	a5,a5,0x8
8000eb0a:	8fd9                	or	a5,a5,a4
8000eb0c:	0807c733          	zext.h	a4,a5
8000eb10:	1a818793          	add	a5,gp,424 # 1209520 <sErrorSettings>
8000eb14:	0067c683          	lbu	a3,6(a5)
8000eb18:	0077c783          	lbu	a5,7(a5)
8000eb1c:	07a2                	sll	a5,a5,0x8
8000eb1e:	8fd5                	or	a5,a5,a3
8000eb20:	0807c7b3          	zext.h	a5,a5
8000eb24:	04e7e263          	bltu	a5,a4,8000eb68 <.L50>
                   sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
8000eb28:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000eb2c:	0247c703          	lbu	a4,36(a5)
8000eb30:	0257c783          	lbu	a5,37(a5)
8000eb34:	07a2                	sll	a5,a5,0x8
8000eb36:	8fd9                	or	a5,a5,a4
8000eb38:	0807c7b3          	zext.h	a5,a5
8000eb3c:	078d                	add	a5,a5,3
8000eb3e:	0807c733          	zext.h	a4,a5
8000eb42:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000eb46:	0ff77693          	zext.b	a3,a4
8000eb4a:	0247c603          	lbu	a2,36(a5)
8000eb4e:	8a01                	and	a2,a2,0
8000eb50:	8ed1                	or	a3,a3,a2
8000eb52:	02d78223          	sb	a3,36(a5)
8000eb56:	8321                	srl	a4,a4,0x8
8000eb58:	08074733          	zext.h	a4,a4
8000eb5c:	0257c683          	lbu	a3,37(a5)
8000eb60:	8a81                	and	a3,a3,0
8000eb62:	8f55                	or	a4,a4,a3
8000eb64:	02e782a3          	sb	a4,37(a5)

8000eb68 <.L50>:
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
8000eb68:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000eb6c:	efb9                	bnez	a5,8000ebca <.L52>
8000eb6e:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
8000eb72:	cfa1                	beqz	a5,8000ebca <.L52>

8000eb74 <.LBB4>:
              UINT16  ALEvent = HW_GetALEventRegister_Isr();
8000eb74:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000eb78:	22078793          	add	a5,a5,544
8000eb7c:	0007d783          	lhu	a5,0(a5)
8000eb80:	00f11623          	sh	a5,12(sp)
              if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
8000eb84:	00c15703          	lhu	a4,12(sp)
8000eb88:	28b01793          	bset	a5,zero,0xb
8000eb8c:	8ff9                	and	a5,a5,a4
8000eb8e:	ef99                	bnez	a5,8000ebac <.L53>
                if (u16SmSync0Counter <= u16SmSync0Value)
8000eb90:	fbe1d703          	lhu	a4,-66(gp) # 1209336 <u16SmSync0Counter>
8000eb94:	35625783          	lhu	a5,854(tp) # 356 <default_isr_62+0x60>
8000eb98:	04e7e763          	bltu	a5,a4,8000ebe6 <.L55>
                    u16SmSync0Counter++;
8000eb9c:	fbe1d783          	lhu	a5,-66(gp) # 1209336 <u16SmSync0Counter>
8000eba0:	0785                	add	a5,a5,1
8000eba2:	0807c733          	zext.h	a4,a5
8000eba6:	fae19f23          	sh	a4,-66(gp) # 1209336 <u16SmSync0Counter>

8000ebaa <.LBE4>:
           {
8000ebaa:	a835                	j	8000ebe6 <.L55>

8000ebac <.L53>:
                 u16SmSync0Counter = 0;
8000ebac:	fa019f23          	sh	zero,-66(gp) # 1209336 <u16SmSync0Counter>
                 sSyncManInPar.u16SmEventMissedCounter = 0;
8000ebb0:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ebb4:	0247c703          	lbu	a4,36(a5)
8000ebb8:	8b01                	and	a4,a4,0
8000ebba:	02e78223          	sb	a4,36(a5)
8000ebbe:	0257c703          	lbu	a4,37(a5)
8000ebc2:	8b01                	and	a4,a4,0
8000ebc4:	02e782a3          	sb	a4,37(a5)

8000ebc8 <.LBE5>:
           {
8000ebc8:	a839                	j	8000ebe6 <.L55>

8000ebca <.L52>:
           else if (u16SmSync0Counter <= u16SmSync0Value)
8000ebca:	fbe1d703          	lhu	a4,-66(gp) # 1209336 <u16SmSync0Counter>
8000ebce:	35625783          	lhu	a5,854(tp) # 356 <default_isr_62+0x60>
8000ebd2:	00e7eb63          	bltu	a5,a4,8000ebe8 <.L49>
               u16SmSync0Counter++;
8000ebd6:	fbe1d783          	lhu	a5,-66(gp) # 1209336 <u16SmSync0Counter>
8000ebda:	0785                	add	a5,a5,1
8000ebdc:	0807c733          	zext.h	a4,a5
8000ebe0:	fae19f23          	sh	a4,-66(gp) # 1209336 <u16SmSync0Counter>
8000ebe4:	a011                	j	8000ebe8 <.L49>

8000ebe6 <.L55>:
           {
8000ebe6:	0001                	nop

8000ebe8 <.L49>:
        ECAT_Application();
8000ebe8:	e62f80ef          	jal	8000724a <ECAT_Application>
        if (bCallInputMapping == TRUE)
8000ebec:	00f14703          	lbu	a4,15(sp)
8000ebf0:	4785                	li	a5,1
8000ebf2:	00f71b63          	bne	a4,a5,8000ec08 <.L46>
            PDO_InputMapping();
8000ebf6:	cc9f70ef          	jal	800068be <PDO_InputMapping>
            if(LatchInputSync0Value == 1)
8000ebfa:	17a1d703          	lhu	a4,378(gp) # 12094f2 <LatchInputSync0Value>
8000ebfe:	4785                	li	a5,1
8000ec00:	00f71463          	bne	a4,a5,8000ec08 <.L46>
                LatchInputSync0Counter = 0;
8000ec04:	16019e23          	sh	zero,380(gp) # 12094f4 <LatchInputSync0Counter>

8000ec08 <.L46>:
    COE_UpdateSyncErrorStatus();
8000ec08:	fc2f70ef          	jal	800063ca <COE_UpdateSyncErrorStatus>
}
8000ec0c:	0001                	nop
8000ec0e:	40f2                	lw	ra,28(sp)
8000ec10:	6105                	add	sp,sp,32
8000ec12:	8082                	ret

Disassembly of section .text.Sync1_Isr:

8000ec14 <Sync1_Isr>:
{
8000ec14:	1141                	add	sp,sp,-16
8000ec16:	c606                	sw	ra,12(sp)
    Sync1WdCounter = 0;
8000ec18:	16019a23          	sh	zero,372(gp) # 12094ec <Sync1WdCounter>
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
8000ec1c:	1a01c703          	lbu	a4,416(gp) # 1209518 <bEcatInputUpdateRunning>
8000ec20:	4785                	li	a5,1
8000ec22:	02f71763          	bne	a4,a5,8000ec50 <.L57>
8000ec26:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
8000ec2a:	c39d                	beqz	a5,8000ec50 <.L57>
            && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
8000ec2c:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ec30:	0027c703          	lbu	a4,2(a5)
8000ec34:	0037c783          	lbu	a5,3(a5)
8000ec38:	07a2                	sll	a5,a5,0x8
8000ec3a:	8fd9                	or	a5,a5,a4
8000ec3c:	0807c733          	zext.h	a4,a5
8000ec40:	478d                	li	a5,3
8000ec42:	00f71763          	bne	a4,a5,8000ec50 <.L57>
            && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
8000ec46:	17a1d783          	lhu	a5,378(gp) # 12094f2 <LatchInputSync0Value>
8000ec4a:	e399                	bnez	a5,8000ec50 <.L57>
            PDO_InputMapping();
8000ec4c:	c73f70ef          	jal	800068be <PDO_InputMapping>

8000ec50 <.L57>:
        LatchInputSync0Counter = 0;
8000ec50:	16019e23          	sh	zero,380(gp) # 12094f4 <LatchInputSync0Counter>
}
8000ec54:	0001                	nop
8000ec56:	40b2                	lw	ra,12(sp)
8000ec58:	0141                	add	sp,sp,16
8000ec5a:	8082                	ret

Disassembly of section .text.COE_Init:

8000ec5c <COE_Init>:
    pCoeSendStored = 0;
8000ec5c:	0e01a623          	sw	zero,236(gp) # 1209464 <pCoeSendStored>
    nSdoInfoFragmentsLeft = 0;
8000ec60:	16019023          	sh	zero,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>
}
8000ec64:	0001                	nop
8000ec66:	8082                	ret

Disassembly of section .text.COE_ContinueInd:

8000ec68 <COE_ContinueInd>:
 \brief    This function is called when a CoE service to be sent is stored and can
 \brief  be put in the send mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ContinueInd(TMBX MBXMEM * pMbx)
{
8000ec68:	1101                	add	sp,sp,-32
8000ec6a:	ce06                	sw	ra,28(sp)
8000ec6c:	c62a                	sw	a0,12(sp)
    if (pCoeSendStored)
8000ec6e:	0ec1a783          	lw	a5,236(gp) # 1209464 <pCoeSendStored>
8000ec72:	cf81                	beqz	a5,8000ec8a <.L9>
    {
        /* send the stored CoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) COE8*/
        if (MBX_MailboxSendReq(pCoeSendStored, COE_SERVICE) == 0)
8000ec74:	0ec1a783          	lw	a5,236(gp) # 1209464 <pCoeSendStored>
8000ec78:	4589                	li	a1,2
8000ec7a:	853e                	mv	a0,a5
8000ec7c:	a65fa0ef          	jal	800096e0 <MBX_MailboxSendReq>
8000ec80:	87aa                	mv	a5,a0
8000ec82:	e795                	bnez	a5,8000ecae <.L10>
        {
            pCoeSendStored = 0;
8000ec84:	0e01a623          	sw	zero,236(gp) # 1209464 <pCoeSendStored>
8000ec88:	a01d                	j	8000ecae <.L10>

8000ec8a <.L9>:
    }
    else
    {
        /* send the next fragment of the last CoE service (only for SDO-Information possible) */
        /* in mailbox queue mode pMbx is always 0, so a mailbox buffer shall be get */
        pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(SIZEOF(TMBX));
8000ec8a:	08000513          	li	a0,128
8000ec8e:	97cff0ef          	jal	8000de0a <malloc>
8000ec92:	c62a                	sw	a0,12(sp)
        /* it shall be checked if a valid pointer was returned */
        if (pMbx == NULL)
8000ec94:	47b2                	lw	a5,12(sp)
8000ec96:	e399                	bnez	a5,8000ec9c <.L11>
        {
            return MBXERR_NOMOREMEMORY;
8000ec98:	479d                	li	a5,7
8000ec9a:	a819                	j	8000ecb0 <.L12>

8000ec9c <.L11>:
        }
        else
        {
            /* copy the stored SDO-Info-Header in the request */
            MBXMEMCPY(pMbx, aSdoInfoHeader, SDO_INFO_HEADER_BYTE_SIZE);
8000ec9c:	4639                	li	a2,14
8000ec9e:	08018593          	add	a1,gp,128 # 12093f8 <aSdoInfoHeader>
8000eca2:	4532                	lw	a0,12(sp)
8000eca4:	fb9fe0ef          	jal	8000dc5c <memcpy>
            /* call SDOS_SdoInfoInd to generate and send the next fragment */
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
8000eca8:	4532                	lw	a0,12(sp)
8000ecaa:	114020ef          	jal	80010dbe <SDOS_SdoInfoInd>

8000ecae <.L10>:
        }
    }

    return 0;
8000ecae:	4781                	li	a5,0

8000ecb0 <.L12>:
}
8000ecb0:	853e                	mv	a0,a5
8000ecb2:	40f2                	lw	ra,28(sp)
8000ecb4:	6105                	add	sp,sp,32
8000ecb6:	8082                	ret

Disassembly of section .text.UpdateEEPROMLoadedState:

8000ecb8 <UpdateEEPROMLoadedState>:
{
8000ecb8:	1141                	add	sp,sp,-16
   UINT32 TmpVar = 0;
8000ecba:	c602                	sw	zero,12(sp)
   HW_EscReadDWord(TmpVar, ESC_EEPROM_CONFIG_OFFSET);
8000ecbc:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000ecc0:	50078793          	add	a5,a5,1280
8000ecc4:	439c                	lw	a5,0(a5)
8000ecc6:	c63e                	sw	a5,12(sp)
    if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
8000ecc8:	4732                	lw	a4,12(sp)
8000ecca:	080007b7          	lui	a5,0x8000
8000ecce:	8ff9                	and	a5,a5,a4
8000ecd0:	e791                	bnez	a5,8000ecdc <.L4>
        || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
8000ecd2:	4732                	lw	a4,12(sp)
8000ecd4:	100007b7          	lui	a5,0x10000
8000ecd8:	8ff9                	and	a5,a5,a4
8000ecda:	c781                	beqz	a5,8000ece2 <.L5>

8000ecdc <.L4>:
        EepromLoaded = FALSE;
8000ecdc:	1a0183a3          	sb	zero,423(gp) # 120951f <EepromLoaded>
8000ece0:	a029                	j	8000ecea <.L6>

8000ece2 <.L5>:
        EepromLoaded = TRUE;
8000ece2:	4705                	li	a4,1
8000ece4:	1ae183a3          	sb	a4,423(gp) # 120951f <EepromLoaded>
}
8000ece8:	0001                	nop

8000ecea <.L6>:
8000ecea:	0001                	nop
8000ecec:	0141                	add	sp,sp,16
8000ecee:	8082                	ret

Disassembly of section .text.StartOutputHandler:

8000ecf0 <StartOutputHandler>:
{
8000ecf0:	1141                	add	sp,sp,-16
    UINT16 result = NOERROR_INWORK;
8000ecf2:	0ff00793          	li	a5,255
8000ecf6:	00f11723          	sh	a5,14(sp)
    if(STATE_VALID(u8LocalErrorState))
8000ecfa:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
8000ecfe:	00f7f713          	and	a4,a5,15
8000ed02:	4785                	li	a5,1
8000ed04:	02f70763          	beq	a4,a5,8000ed32 <.L135>
8000ed08:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
8000ed0c:	00f7f713          	and	a4,a5,15
8000ed10:	4789                	li	a5,2
8000ed12:	02f70063          	beq	a4,a5,8000ed32 <.L135>
8000ed16:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
8000ed1a:	00f7f713          	and	a4,a5,15
8000ed1e:	4791                	li	a5,4
8000ed20:	00f70963          	beq	a4,a5,8000ed32 <.L135>
8000ed24:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
8000ed28:	00f7f713          	and	a4,a5,15
8000ed2c:	47a1                	li	a5,8
8000ed2e:	00f71563          	bne	a4,a5,8000ed38 <.L136>

8000ed32 <.L135>:
        return u16LocalErrorCode;
8000ed32:	14c1d783          	lhu	a5,332(gp) # 12094c4 <u16LocalErrorCode>
8000ed36:	a8a1                	j	8000ed8e <.L137>

8000ed38 <.L136>:
    if(bDcSyncActive)
8000ed38:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
8000ed3c:	c799                	beqz	a5,8000ed4a <.L138>
        i16WaitForPllRunningTimeout = 200;
8000ed3e:	0c800713          	li	a4,200
8000ed42:	16e19723          	sh	a4,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>
        i16WaitForPllRunningCnt = 0;
8000ed46:	16019823          	sh	zero,368(gp) # 12094e8 <i16WaitForPllRunningCnt>

8000ed4a <.L138>:
    sSyncManOutPar.u16SmEventMissedCounter = 0;
8000ed4a:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ed4e:	0247c703          	lbu	a4,36(a5) # 10000024 <__AXI_SRAM_segment_end__+0xedc0024>
8000ed52:	8b01                	and	a4,a4,0
8000ed54:	02e78223          	sb	a4,36(a5)
8000ed58:	0257c703          	lbu	a4,37(a5)
8000ed5c:	8b01                	and	a4,a4,0
8000ed5e:	02e782a3          	sb	a4,37(a5)
    sSyncManOutPar.u8SyncError = 0;
8000ed62:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ed66:	02078e23          	sb	zero,60(a5)
    sSyncManInPar.u16SmEventMissedCounter = 0;
8000ed6a:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ed6e:	0247c703          	lbu	a4,36(a5)
8000ed72:	8b01                	and	a4,a4,0
8000ed74:	02e78223          	sb	a4,36(a5)
8000ed78:	0257c703          	lbu	a4,37(a5)
8000ed7c:	8b01                	and	a4,a4,0
8000ed7e:	02e782a3          	sb	a4,37(a5)
    sSyncManInPar.u8SyncError = 0;
8000ed82:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ed86:	02078e23          	sb	zero,60(a5)
    return result;
8000ed8a:	00e15783          	lhu	a5,14(sp)

8000ed8e <.L137>:
}
8000ed8e:	853e                	mv	a0,a5
8000ed90:	0141                	add	sp,sp,16
8000ed92:	8082                	ret

Disassembly of section .text.StopOutputHandler:

8000ed94 <StopOutputHandler>:
    bEcatFirstOutputsReceived = FALSE;
8000ed94:	1a0180a3          	sb	zero,417(gp) # 1209519 <bEcatFirstOutputsReceived>
    bEcatOutputUpdateRunning = FALSE;
8000ed98:	18018fa3          	sb	zero,415(gp) # 1209517 <bEcatOutputUpdateRunning>
}
8000ed9c:	0001                	nop
8000ed9e:	8082                	ret

Disassembly of section .text.StopInputHandler:

8000eda0 <StopInputHandler>:
{
8000eda0:	1101                	add	sp,sp,-32
8000eda2:	ce06                	sw	ra,28(sp)
    if(nPdOutputSize > 0)
8000eda4:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000eda8:	c781                	beqz	a5,8000edb0 <.L141>
        DisableSyncManChannel(PROCESS_DATA_OUT);
8000edaa:	4509                	li	a0,2
8000edac:	a8ff80ef          	jal	8000783a <DisableSyncManChannel>

8000edb0 <.L141>:
    if(nPdInputSize > 0)
8000edb0:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
8000edb4:	c781                	beqz	a5,8000edbc <.L142>
        DisableSyncManChannel(PROCESS_DATA_IN);
8000edb6:	450d                	li	a0,3
8000edb8:	a83f80ef          	jal	8000783a <DisableSyncManChannel>

8000edbc <.L142>:
        UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
8000edbc:	47b1                	li	a5,12
8000edbe:	00f11723          	sh	a5,14(sp)
        ResetMask |= PROCESS_OUTPUT_EVENT;
8000edc2:	00e15783          	lhu	a5,14(sp)
8000edc6:	4007e793          	or	a5,a5,1024
8000edca:	00f11723          	sh	a5,14(sp)
        ResetMask |= PROCESS_INPUT_EVENT;
8000edce:	00e15783          	lhu	a5,14(sp)
8000edd2:	873e                	mv	a4,a5
8000edd4:	28b01793          	bset	a5,zero,0xb
8000edd8:	8fd9                	or	a5,a5,a4
8000edda:	00f11723          	sh	a5,14(sp)
    ResetALEventMask( ~(ResetMask) );
8000edde:	00e15783          	lhu	a5,14(sp)
8000ede2:	fff7c793          	not	a5,a5
8000ede6:	0807c7b3          	zext.h	a5,a5
8000edea:	853e                	mv	a0,a5
8000edec:	93ff80ef          	jal	8000772a <ResetALEventMask>

8000edf0 <.LBE10>:
    bEcatFirstOutputsReceived = FALSE;
8000edf0:	1a0180a3          	sb	zero,417(gp) # 1209519 <bEcatFirstOutputsReceived>
    bEscIntEnabled = FALSE;
8000edf4:	18018ea3          	sb	zero,413(gp) # 1209515 <bEscIntEnabled>
    bDcSyncActive = FALSE;
8000edf8:	1a018123          	sb	zero,418(gp) # 120951a <bDcSyncActive>
    bDcRunning = FALSE;
8000edfc:	1a0181a3          	sb	zero,419(gp) # 120951b <bDcRunning>
    bSmSyncSequenceValid = FALSE;
8000ee00:	180187a3          	sb	zero,399(gp) # 1209507 <bSmSyncSequenceValid>
    u16SmSync0Value = 0;
8000ee04:	34021b23          	sh	zero,854(tp) # 356 <default_isr_62+0x60>
    u16SmSync0Counter = 0;
8000ee08:	fa019f23          	sh	zero,-66(gp) # 1209336 <u16SmSync0Counter>
    Sync0WdValue = 0;
8000ee0c:	16019b23          	sh	zero,374(gp) # 12094ee <Sync0WdValue>
    Sync0WdCounter = 0;
8000ee10:	16019c23          	sh	zero,376(gp) # 12094f0 <Sync0WdCounter>
    Sync1WdCounter = 0;
8000ee14:	16019a23          	sh	zero,372(gp) # 12094ec <Sync1WdCounter>
    Sync1WdValue = 0;
8000ee18:	16019923          	sh	zero,370(gp) # 12094ea <Sync1WdValue>
    LatchInputSync0Value = 0;
8000ee1c:	16019d23          	sh	zero,378(gp) # 12094f2 <LatchInputSync0Value>
    LatchInputSync0Counter = 0;
8000ee20:	16019e23          	sh	zero,380(gp) # 12094f4 <LatchInputSync0Counter>
    sSyncManOutPar.u16SmEventMissedCounter = 0;
8000ee24:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ee28:	0247c703          	lbu	a4,36(a5)
8000ee2c:	8b01                	and	a4,a4,0
8000ee2e:	02e78223          	sb	a4,36(a5)
8000ee32:	0257c703          	lbu	a4,37(a5)
8000ee36:	8b01                	and	a4,a4,0
8000ee38:	02e782a3          	sb	a4,37(a5)
    sSyncManOutPar.u16CycleExceededCounter = 0;
8000ee3c:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ee40:	0267c703          	lbu	a4,38(a5)
8000ee44:	8b01                	and	a4,a4,0
8000ee46:	02e78323          	sb	a4,38(a5)
8000ee4a:	0277c703          	lbu	a4,39(a5)
8000ee4e:	8b01                	and	a4,a4,0
8000ee50:	02e783a3          	sb	a4,39(a5)
    sSyncManOutPar.u8SyncError = 0;
8000ee54:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000ee58:	02078e23          	sb	zero,60(a5)
    sSyncManInPar.u16SmEventMissedCounter = 0;
8000ee5c:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ee60:	0247c703          	lbu	a4,36(a5)
8000ee64:	8b01                	and	a4,a4,0
8000ee66:	02e78223          	sb	a4,36(a5)
8000ee6a:	0257c703          	lbu	a4,37(a5)
8000ee6e:	8b01                	and	a4,a4,0
8000ee70:	02e782a3          	sb	a4,37(a5)
    sSyncManInPar.u16CycleExceededCounter = 0;
8000ee74:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ee78:	0267c703          	lbu	a4,38(a5)
8000ee7c:	8b01                	and	a4,a4,0
8000ee7e:	02e78323          	sb	a4,38(a5)
8000ee82:	0277c703          	lbu	a4,39(a5)
8000ee86:	8b01                	and	a4,a4,0
8000ee88:	02e783a3          	sb	a4,39(a5)
    sSyncManInPar.u8SyncError = 0;
8000ee8c:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8000ee90:	02078e23          	sb	zero,60(a5)
    i16WaitForPllRunningTimeout = 0;
8000ee94:	16019723          	sh	zero,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>
    bWdTrigger = FALSE;
8000ee98:	18018623          	sb	zero,396(gp) # 1209504 <bWdTrigger>
    bEcatInputUpdateRunning = FALSE;
8000ee9c:	1a018023          	sb	zero,416(gp) # 1209518 <bEcatInputUpdateRunning>
    bSyncSetByUser = FALSE;
8000eea0:	180186a3          	sb	zero,397(gp) # 1209505 <bSyncSetByUser>
}
8000eea4:	0001                	nop
8000eea6:	40f2                	lw	ra,28(sp)
8000eea8:	6105                	add	sp,sp,32
8000eeaa:	8082                	ret

Disassembly of section .text.BackToInitTransition:

8000eeac <BackToInitTransition>:
    bSyncSetByUser = FALSE;
8000eeac:	180186a3          	sb	zero,397(gp) # 1209505 <bSyncSetByUser>
}
8000eeb0:	0001                	nop
8000eeb2:	8082                	ret

Disassembly of section .text.AL_ControlRes:

8000eeb4 <AL_ControlRes>:
{
8000eeb4:	1101                	add	sp,sp,-32
8000eeb6:	ce06                	sw	ra,28(sp)
    if(bEcatWaitForAlControlRes)
8000eeb8:	19e1c783          	lbu	a5,414(gp) # 1209516 <bEcatWaitForAlControlRes>
8000eebc:	2c078763          	beqz	a5,8000f18a <.L275>

8000eec0 <.LBB12>:
        UINT16 result = 0;
8000eec0:	00011523          	sh	zero,10(sp)
        UINT8 Status = 0;
8000eec4:	000107a3          	sb	zero,15(sp)
        UINT16 StatusCode = 0;
8000eec8:	00011623          	sh	zero,12(sp)
        if(EsmTimeoutCounter == 0)
8000eecc:	17e19783          	lh	a5,382(gp) # 12094f6 <EsmTimeoutCounter>
8000eed0:	12079663          	bnez	a5,8000effc <.L238>
            Status =  (UINT8)(nEcatStateTrans >> 4);
8000eed4:	16c1d783          	lhu	a5,364(gp) # 12094e4 <nEcatStateTrans>
8000eed8:	8391                	srl	a5,a5,0x4
8000eeda:	0807c7b3          	zext.h	a5,a5
8000eede:	00f107a3          	sb	a5,15(sp)
            switch(nEcatStateTrans)
8000eee2:	16c1d783          	lhu	a5,364(gp) # 12094e4 <nEcatStateTrans>
8000eee6:	04800713          	li	a4,72
8000eeea:	06e78e63          	beq	a5,a4,8000ef66 <.L239>
8000eeee:	04800713          	li	a4,72
8000eef2:	26f74663          	blt	a4,a5,8000f15e <.L260>
8000eef6:	474d                	li	a4,19
8000eef8:	00f74663          	blt	a4,a5,8000ef04 <.L241>
8000eefc:	4749                	li	a4,18
8000eefe:	00e7d863          	bge	a5,a4,8000ef0e <.L242>
8000ef02:	acb1                	j	8000f15e <.L260>

8000ef04 <.L241>:
8000ef04:	02400713          	li	a4,36
8000ef08:	02e78963          	beq	a5,a4,8000ef3a <.L243>
8000ef0c:	ac89                	j	8000f15e <.L260>

8000ef0e <.L242>:
                        if (!bApplEsmPending)
8000ef0e:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
8000ef12:	e399                	bnez	a5,8000ef18 <.L244>
                            APPL_StopMailboxHandler();
8000ef14:	c1afc0ef          	jal	8000b32e <APPL_StopMailboxHandler>

8000ef18 <.L244>:
                    MBX_StopMailboxHandler();
8000ef18:	2fb5                	jal	8000f694 <MBX_StopMailboxHandler>
                    if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
8000ef1a:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
8000ef1e:	00f7f713          	and	a4,a5,15
8000ef22:	4785                	li	a5,1
8000ef24:	00f71763          	bne	a4,a5,8000ef32 <.L245>
                        StatusCode = u16LocalErrorCode;
8000ef28:	14c1d783          	lhu	a5,332(gp) # 12094c4 <u16LocalErrorCode>
8000ef2c:	00f11623          	sh	a5,12(sp)
                break;
8000ef30:	a43d                	j	8000f15e <.L260>

8000ef32 <.L245>:
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
8000ef32:	4785                	li	a5,1
8000ef34:	00f11623          	sh	a5,12(sp)
                break;
8000ef38:	a41d                	j	8000f15e <.L260>

8000ef3a <.L243>:
                        if (!bApplEsmPending)
8000ef3a:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
8000ef3e:	e399                	bnez	a5,8000ef44 <.L247>
                            APPL_StopInputHandler();
8000ef40:	bf4fc0ef          	jal	8000b334 <APPL_StopInputHandler>

8000ef44 <.L247>:
                    StopInputHandler();
8000ef44:	3db1                	jal	8000eda0 <StopInputHandler>
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
8000ef46:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
8000ef4a:	00f7f713          	and	a4,a5,15
8000ef4e:	4789                	li	a5,2
8000ef50:	00f71763          	bne	a4,a5,8000ef5e <.L248>
                        StatusCode = u16LocalErrorCode;
8000ef54:	14c1d783          	lhu	a5,332(gp) # 12094c4 <u16LocalErrorCode>
8000ef58:	00f11623          	sh	a5,12(sp)
                break;
8000ef5c:	a409                	j	8000f15e <.L260>

8000ef5e <.L248>:
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
8000ef5e:	4785                	li	a5,1
8000ef60:	00f11623          	sh	a5,12(sp)
                break;
8000ef64:	aaed                	j	8000f15e <.L260>

8000ef66 <.L239>:
                    if(bDcSyncActive)
8000ef66:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
8000ef6a:	c3b9                	beqz	a5,8000efb0 <.L250>
                        if(!bDcRunning)
8000ef6c:	1a31c783          	lbu	a5,419(gp) # 120951b <bDcRunning>
8000ef70:	e791                	bnez	a5,8000ef7c <.L251>
                            StatusCode = ALSTATUSCODE_NOSYNCERROR;
8000ef72:	02d00793          	li	a5,45
8000ef76:	00f11623          	sh	a5,12(sp)
8000ef7a:	a0b5                	j	8000efe6 <.L255>

8000ef7c <.L251>:
                        else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
8000ef7c:	1a11c783          	lbu	a5,417(gp) # 1209519 <bEcatFirstOutputsReceived>
8000ef80:	eb81                	bnez	a5,8000ef90 <.L253>
8000ef82:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000ef86:	c789                	beqz	a5,8000ef90 <.L253>
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
8000ef88:	47ed                	li	a5,27
8000ef8a:	00f11623          	sh	a5,12(sp)
8000ef8e:	a8a1                	j	8000efe6 <.L255>

8000ef90 <.L253>:
                        else if (!bSmSyncSequenceValid)
8000ef90:	18f1c783          	lbu	a5,399(gp) # 1209507 <bSmSyncSequenceValid>
8000ef94:	e789                	bnez	a5,8000ef9e <.L254>
                            StatusCode = ALSTATUSCODE_SYNCERROR;
8000ef96:	47e9                	li	a5,26
8000ef98:	00f11623          	sh	a5,12(sp)
8000ef9c:	a0a9                	j	8000efe6 <.L255>

8000ef9e <.L254>:
                            Status = STATE_OP;
8000ef9e:	47a1                	li	a5,8
8000efa0:	00f107a3          	sb	a5,15(sp)
                            StatusCode = 0;
8000efa4:	00011623          	sh	zero,12(sp)
                            bEcatOutputUpdateRunning = TRUE;
8000efa8:	4705                	li	a4,1
8000efaa:	18e18fa3          	sb	a4,415(gp) # 1209517 <bEcatOutputUpdateRunning>
8000efae:	a825                	j	8000efe6 <.L255>

8000efb0 <.L250>:
                        if (nPdOutputSize > 0)
8000efb0:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000efb4:	c789                	beqz	a5,8000efbe <.L256>
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
8000efb6:	47ed                	li	a5,27
8000efb8:	00f11623          	sh	a5,12(sp)
8000efbc:	a02d                	j	8000efe6 <.L255>

8000efbe <.L256>:
                            if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
8000efbe:	1851c783          	lbu	a5,389(gp) # 12094fd <u8LocalErrorState>
8000efc2:	00f7f713          	and	a4,a5,15
8000efc6:	4791                	li	a5,4
8000efc8:	00f71763          	bne	a4,a5,8000efd6 <.L257>
                                StatusCode = u16LocalErrorCode;
8000efcc:	14c1d783          	lhu	a5,332(gp) # 12094c4 <u16LocalErrorCode>
8000efd0:	00f11623          	sh	a5,12(sp)
8000efd4:	a809                	j	8000efe6 <.L255>

8000efd6 <.L257>:
                                Status = STATE_OP;
8000efd6:	47a1                	li	a5,8
8000efd8:	00f107a3          	sb	a5,15(sp)
                                StatusCode = 0;
8000efdc:	00011623          	sh	zero,12(sp)
                                bEcatOutputUpdateRunning = TRUE;
8000efe0:	4705                	li	a4,1
8000efe2:	18e18fa3          	sb	a4,415(gp) # 1209517 <bEcatOutputUpdateRunning>

8000efe6 <.L255>:
                    if(StatusCode != 0)
8000efe6:	00c15783          	lhu	a5,12(sp)
8000efea:	16078363          	beqz	a5,8000f150 <.L276>
                            if (!bApplEsmPending)
8000efee:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
8000eff2:	e399                	bnez	a5,8000eff8 <.L259>
                                APPL_StopOutputHandler();
8000eff4:	b4cfc0ef          	jal	8000b340 <APPL_StopOutputHandler>

8000eff8 <.L259>:
                        StopOutputHandler();
8000eff8:	3b71                	jal	8000ed94 <StopOutputHandler>
                break;
8000effa:	aa99                	j	8000f150 <.L276>

8000effc <.L238>:
            switch(nEcatStateTrans)
8000effc:	16c1d783          	lhu	a5,364(gp) # 12094e4 <nEcatStateTrans>
8000f000:	04800713          	li	a4,72
8000f004:	0ae78663          	beq	a5,a4,8000f0b0 <.L261>
8000f008:	04800713          	li	a4,72
8000f00c:	14f74963          	blt	a4,a5,8000f15e <.L260>
8000f010:	474d                	li	a4,19
8000f012:	00f74663          	blt	a4,a5,8000f01e <.L262>
8000f016:	4749                	li	a4,18
8000f018:	00e7d863          	bge	a5,a4,8000f028 <.L263>
8000f01c:	a289                	j	8000f15e <.L260>

8000f01e <.L262>:
8000f01e:	02400713          	li	a4,36
8000f022:	04e78663          	beq	a5,a4,8000f06e <.L264>
8000f026:	aa25                	j	8000f15e <.L260>

8000f028 <.L263>:
                    if(bApplEsmPending)
8000f028:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
8000f02c:	12078463          	beqz	a5,8000f154 <.L277>
                        bApplEsmPending = FALSE;
8000f030:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
                        result = APPL_StartMailboxHandler();
8000f034:	af4fc0ef          	jal	8000b328 <APPL_StartMailboxHandler>
8000f038:	87aa                	mv	a5,a0
8000f03a:	00f11523          	sh	a5,10(sp)
                        if(result == 0)
8000f03e:	00a15783          	lhu	a5,10(sp)
8000f042:	ef81                	bnez	a5,8000f05a <.L266>
                            bMbxRunning = TRUE;
8000f044:	4705                	li	a4,1
8000f046:	18e18ca3          	sb	a4,409(gp) # 1209511 <bMbxRunning>
                            Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
8000f04a:	16c1d783          	lhu	a5,364(gp) # 12094e4 <nEcatStateTrans>
8000f04e:	0ff7f793          	zext.b	a5,a5
8000f052:	8bbd                	and	a5,a5,15
8000f054:	00f107a3          	sb	a5,15(sp)
                break;
8000f058:	a8f5                	j	8000f154 <.L277>

8000f05a <.L266>:
                            if(result != NOERROR_INWORK)
8000f05a:	00a15703          	lhu	a4,10(sp)
8000f05e:	0ff00793          	li	a5,255
8000f062:	0ef70963          	beq	a4,a5,8000f154 <.L277>
                                APPL_StopMailboxHandler();
8000f066:	ac8fc0ef          	jal	8000b32e <APPL_StopMailboxHandler>
                                MBX_StopMailboxHandler();
8000f06a:	252d                	jal	8000f694 <MBX_StopMailboxHandler>
                break;
8000f06c:	a0e5                	j	8000f154 <.L277>

8000f06e <.L264>:
                    if(bApplEsmPending)
8000f06e:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
8000f072:	0e078363          	beqz	a5,8000f158 <.L278>
                        bApplEsmPending = FALSE;
8000f076:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
                        result = APPL_StartInputHandler(&u16ALEventMask);
8000f07a:	15a18513          	add	a0,gp,346 # 12094d2 <u16ALEventMask>
8000f07e:	504020ef          	jal	80011582 <APPL_StartInputHandler>
8000f082:	87aa                	mv	a5,a0
8000f084:	00f11523          	sh	a5,10(sp)
                        if(result == 0)
8000f088:	00a15783          	lhu	a5,10(sp)
8000f08c:	eb81                	bnez	a5,8000f09c <.L268>
                            bEcatInputUpdateRunning = TRUE;
8000f08e:	4705                	li	a4,1
8000f090:	1ae18023          	sb	a4,416(gp) # 1209518 <bEcatInputUpdateRunning>
                            Status = STATE_SAFEOP;
8000f094:	4791                	li	a5,4
8000f096:	00f107a3          	sb	a5,15(sp)
                break;
8000f09a:	a87d                	j	8000f158 <.L278>

8000f09c <.L268>:
                            if(result != NOERROR_INWORK)
8000f09c:	00a15703          	lhu	a4,10(sp)
8000f0a0:	0ff00793          	li	a5,255
8000f0a4:	0af70a63          	beq	a4,a5,8000f158 <.L278>
                                APPL_StopInputHandler();
8000f0a8:	a8cfc0ef          	jal	8000b334 <APPL_StopInputHandler>
                                StopInputHandler();
8000f0ac:	39d5                	jal	8000eda0 <StopInputHandler>
                break;
8000f0ae:	a06d                	j	8000f158 <.L278>

8000f0b0 <.L261>:
                   if(bApplEsmPending)
8000f0b0:	1a41c783          	lbu	a5,420(gp) # 120951c <bApplEsmPending>
8000f0b4:	c7c5                	beqz	a5,8000f15c <.L279>
                        if(bDcSyncActive)
8000f0b6:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
8000f0ba:	cbb1                	beqz	a5,8000f10e <.L270>
                            if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
8000f0bc:	16e19783          	lh	a5,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>
8000f0c0:	08f05e63          	blez	a5,8000f15c <.L279>
8000f0c4:	16e19703          	lh	a4,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>
8000f0c8:	17019783          	lh	a5,368(gp) # 12094e8 <i16WaitForPllRunningCnt>
8000f0cc:	08e7c863          	blt	a5,a4,8000f15c <.L279>
                                i16WaitForPllRunningTimeout = 0;
8000f0d0:	16019723          	sh	zero,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>
                                i16WaitForPllRunningCnt = 0;
8000f0d4:	16019823          	sh	zero,368(gp) # 12094e8 <i16WaitForPllRunningCnt>
                                bApplEsmPending = FALSE;
8000f0d8:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
                                result = APPL_StartOutputHandler();
8000f0dc:	a5efc0ef          	jal	8000b33a <APPL_StartOutputHandler>
8000f0e0:	87aa                	mv	a5,a0
8000f0e2:	00f11523          	sh	a5,10(sp)
                                if(result == 0)
8000f0e6:	00a15783          	lhu	a5,10(sp)
8000f0ea:	eb81                	bnez	a5,8000f0fa <.L271>
                                    bEcatOutputUpdateRunning = TRUE;
8000f0ec:	4705                	li	a4,1
8000f0ee:	18e18fa3          	sb	a4,415(gp) # 1209517 <bEcatOutputUpdateRunning>
                                    Status = STATE_OP;
8000f0f2:	47a1                	li	a5,8
8000f0f4:	00f107a3          	sb	a5,15(sp)
                break;
8000f0f8:	a095                	j	8000f15c <.L279>

8000f0fa <.L271>:
                                    if(result != NOERROR_INWORK)
8000f0fa:	00a15703          	lhu	a4,10(sp)
8000f0fe:	0ff00793          	li	a5,255
8000f102:	04f70d63          	beq	a4,a5,8000f15c <.L279>
                                        APPL_StopOutputHandler();
8000f106:	a3afc0ef          	jal	8000b340 <APPL_StopOutputHandler>
                                        StopOutputHandler();
8000f10a:	3169                	jal	8000ed94 <StopOutputHandler>
                break;
8000f10c:	a881                	j	8000f15c <.L279>

8000f10e <.L270>:
                            if(nPdOutputSize == 0 || bEcatFirstOutputsReceived)
8000f10e:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000f112:	c781                	beqz	a5,8000f11a <.L272>
8000f114:	1a11c783          	lbu	a5,417(gp) # 1209519 <bEcatFirstOutputsReceived>
8000f118:	c3b1                	beqz	a5,8000f15c <.L279>

8000f11a <.L272>:
                                bApplEsmPending = FALSE;  
8000f11a:	1a018223          	sb	zero,420(gp) # 120951c <bApplEsmPending>
                                result = APPL_StartOutputHandler();
8000f11e:	a1cfc0ef          	jal	8000b33a <APPL_StartOutputHandler>
8000f122:	87aa                	mv	a5,a0
8000f124:	00f11523          	sh	a5,10(sp)
                                if(result == 0)
8000f128:	00a15783          	lhu	a5,10(sp)
8000f12c:	eb81                	bnez	a5,8000f13c <.L273>
                                    bEcatOutputUpdateRunning = TRUE;
8000f12e:	4705                	li	a4,1
8000f130:	18e18fa3          	sb	a4,415(gp) # 1209517 <bEcatOutputUpdateRunning>
                                    Status = STATE_OP;
8000f134:	47a1                	li	a5,8
8000f136:	00f107a3          	sb	a5,15(sp)
                break;
8000f13a:	a00d                	j	8000f15c <.L279>

8000f13c <.L273>:
                                    if(result != NOERROR_INWORK)
8000f13c:	00a15703          	lhu	a4,10(sp)
8000f140:	0ff00793          	li	a5,255
8000f144:	00f70c63          	beq	a4,a5,8000f15c <.L279>
                                        APPL_StopOutputHandler();
8000f148:	9f8fc0ef          	jal	8000b340 <APPL_StopOutputHandler>
                                        StopOutputHandler();
8000f14c:	31a1                	jal	8000ed94 <StopOutputHandler>
                break;
8000f14e:	a039                	j	8000f15c <.L279>

8000f150 <.L276>:
                break;
8000f150:	0001                	nop
8000f152:	a031                	j	8000f15e <.L260>

8000f154 <.L277>:
                break;
8000f154:	0001                	nop
8000f156:	a021                	j	8000f15e <.L260>

8000f158 <.L278>:
                break;
8000f158:	0001                	nop
8000f15a:	a011                	j	8000f15e <.L260>

8000f15c <.L279>:
                break;
8000f15c:	0001                	nop

8000f15e <.L260>:
        if(Status != 0)
8000f15e:	00f14783          	lbu	a5,15(sp)
8000f162:	c785                	beqz	a5,8000f18a <.L275>
            bEcatWaitForAlControlRes = FALSE;
8000f164:	18018f23          	sb	zero,414(gp) # 1209516 <bEcatWaitForAlControlRes>
            if (StatusCode != 0)
8000f168:	00c15783          	lhu	a5,12(sp)
8000f16c:	c799                	beqz	a5,8000f17a <.L274>
                Status |= STATE_CHANGE;
8000f16e:	00f14783          	lbu	a5,15(sp)
8000f172:	0107e793          	or	a5,a5,16
8000f176:	00f107a3          	sb	a5,15(sp)

8000f17a <.L274>:
            SetALStatus(Status,StatusCode);
8000f17a:	00c15703          	lhu	a4,12(sp)
8000f17e:	00f14783          	lbu	a5,15(sp)
8000f182:	85ba                	mv	a1,a4
8000f184:	853e                	mv	a0,a5
8000f186:	bc9f90ef          	jal	80008d4e <SetALStatus>

8000f18a <.L275>:
}
8000f18a:	0001                	nop
8000f18c:	40f2                	lw	ra,28(sp)
8000f18e:	6105                	add	sp,sp,32
8000f190:	8082                	ret

Disassembly of section .text.DC_CheckWatchdog:

8000f192 <DC_CheckWatchdog>:
{
8000f192:	1141                	add	sp,sp,-16
8000f194:	c606                	sw	ra,12(sp)
    DISABLE_ESC_INT();
8000f196:	017020ef          	jal	800119ac <DISABLE_ESC_INT>
    if(bDcSyncActive && bEcatInputUpdateRunning)
8000f19a:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
8000f19e:	10078063          	beqz	a5,8000f29e <.L281>
8000f1a2:	1a01c783          	lbu	a5,416(gp) # 1209518 <bEcatInputUpdateRunning>
8000f1a6:	0e078c63          	beqz	a5,8000f29e <.L281>
        if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
8000f1aa:	1761d783          	lhu	a5,374(gp) # 12094ee <Sync0WdValue>
8000f1ae:	cb91                	beqz	a5,8000f1c2 <.L282>
8000f1b0:	1781d703          	lhu	a4,376(gp) # 12094f0 <Sync0WdCounter>
8000f1b4:	1761d783          	lhu	a5,374(gp) # 12094ee <Sync0WdValue>
8000f1b8:	00f76563          	bltu	a4,a5,8000f1c2 <.L282>
                bDcRunning = FALSE;        
8000f1bc:	1a0181a3          	sb	zero,419(gp) # 120951b <bDcRunning>
8000f1c0:	a00d                	j	8000f1e2 <.L283>

8000f1c2 <.L282>:
            if(Sync0WdCounter < Sync0WdValue)
8000f1c2:	1781d703          	lhu	a4,376(gp) # 12094f0 <Sync0WdCounter>
8000f1c6:	1761d783          	lhu	a5,374(gp) # 12094ee <Sync0WdValue>
8000f1ca:	00f77963          	bgeu	a4,a5,8000f1dc <.L284>
                Sync0WdCounter ++;
8000f1ce:	1781d783          	lhu	a5,376(gp) # 12094f0 <Sync0WdCounter>
8000f1d2:	0785                	add	a5,a5,1
8000f1d4:	0807c733          	zext.h	a4,a5
8000f1d8:	16e19c23          	sh	a4,376(gp) # 12094f0 <Sync0WdCounter>

8000f1dc <.L284>:
            bDcRunning = TRUE;
8000f1dc:	4705                	li	a4,1
8000f1de:	1ae181a3          	sb	a4,419(gp) # 120951b <bDcRunning>

8000f1e2 <.L283>:
        if(bDcRunning)
8000f1e2:	1a31c783          	lbu	a5,419(gp) # 120951b <bDcRunning>
8000f1e6:	c785                	beqz	a5,8000f20e <.L285>
            if(Sync1WdValue > 0)
8000f1e8:	1721d783          	lhu	a5,370(gp) # 12094ea <Sync1WdValue>
8000f1ec:	c38d                	beqz	a5,8000f20e <.L285>
                if(Sync1WdCounter < Sync1WdValue)
8000f1ee:	1741d703          	lhu	a4,372(gp) # 12094ec <Sync1WdCounter>
8000f1f2:	1721d783          	lhu	a5,370(gp) # 12094ea <Sync1WdValue>
8000f1f6:	00f77a63          	bgeu	a4,a5,8000f20a <.L286>
                    Sync1WdCounter ++;
8000f1fa:	1741d783          	lhu	a5,372(gp) # 12094ec <Sync1WdCounter>
8000f1fe:	0785                	add	a5,a5,1
8000f200:	0807c733          	zext.h	a4,a5
8000f204:	16e19a23          	sh	a4,372(gp) # 12094ec <Sync1WdCounter>
8000f208:	a019                	j	8000f20e <.L285>

8000f20a <.L286>:
                    bDcRunning = FALSE;
8000f20a:	1a0181a3          	sb	zero,419(gp) # 120951b <bDcRunning>

8000f20e <.L285>:
        if(bDcRunning)
8000f20e:	1a31c783          	lbu	a5,419(gp) # 120951b <bDcRunning>
8000f212:	c3c9                	beqz	a5,8000f294 <.L287>
           if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
8000f214:	1a818793          	add	a5,gp,424 # 1209520 <sErrorSettings>
8000f218:	0067c703          	lbu	a4,6(a5)
8000f21c:	0077c783          	lbu	a5,7(a5)
8000f220:	07a2                	sll	a5,a5,0x8
8000f222:	8fd9                	or	a5,a5,a4
8000f224:	0807c7b3          	zext.h	a5,a5
8000f228:	c79d                	beqz	a5,8000f256 <.L288>
8000f22a:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8000f22e:	0247c703          	lbu	a4,36(a5)
8000f232:	0257c783          	lbu	a5,37(a5)
8000f236:	07a2                	sll	a5,a5,0x8
8000f238:	8fd9                	or	a5,a5,a4
8000f23a:	0807c733          	zext.h	a4,a5
8000f23e:	1a818793          	add	a5,gp,424 # 1209520 <sErrorSettings>
8000f242:	0067c683          	lbu	a3,6(a5)
8000f246:	0077c783          	lbu	a5,7(a5)
8000f24a:	07a2                	sll	a5,a5,0x8
8000f24c:	8fd5                	or	a5,a5,a3
8000f24e:	0807c7b3          	zext.h	a5,a5
8000f252:	02f77563          	bgeu	a4,a5,8000f27c <.L289>

8000f256 <.L288>:
                bSmSyncSequenceValid = TRUE;
8000f256:	4705                	li	a4,1
8000f258:	18e187a3          	sb	a4,399(gp) # 1209507 <bSmSyncSequenceValid>
                if (i16WaitForPllRunningTimeout > 0)
8000f25c:	16e19783          	lh	a5,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>
8000f260:	02f05f63          	blez	a5,8000f29e <.L281>
                    i16WaitForPllRunningCnt++;
8000f264:	17019783          	lh	a5,368(gp) # 12094e8 <i16WaitForPllRunningCnt>
8000f268:	0807c7b3          	zext.h	a5,a5
8000f26c:	0785                	add	a5,a5,1
8000f26e:	0807c7b3          	zext.h	a5,a5
8000f272:	60579713          	sext.h	a4,a5
8000f276:	16e19823          	sh	a4,368(gp) # 12094e8 <i16WaitForPllRunningCnt>
                if (i16WaitForPllRunningTimeout > 0)
8000f27a:	a015                	j	8000f29e <.L281>

8000f27c <.L289>:
            else if (bSmSyncSequenceValid)
8000f27c:	18f1c783          	lbu	a5,399(gp) # 1209507 <bSmSyncSequenceValid>
8000f280:	cf99                	beqz	a5,8000f29e <.L281>
                    bSmSyncSequenceValid = FALSE;
8000f282:	180187a3          	sb	zero,399(gp) # 1209507 <bSmSyncSequenceValid>
                if (i16WaitForPllRunningTimeout > 0)
8000f286:	16e19783          	lh	a5,366(gp) # 12094e6 <i16WaitForPllRunningTimeout>
8000f28a:	00f05a63          	blez	a5,8000f29e <.L281>
                    i16WaitForPllRunningCnt = 0;
8000f28e:	16019823          	sh	zero,368(gp) # 12094e8 <i16WaitForPllRunningCnt>
8000f292:	a031                	j	8000f29e <.L281>

8000f294 <.L287>:
        else if(bSmSyncSequenceValid)
8000f294:	18f1c783          	lbu	a5,399(gp) # 1209507 <bSmSyncSequenceValid>
8000f298:	c399                	beqz	a5,8000f29e <.L281>
           bSmSyncSequenceValid = FALSE;
8000f29a:	180187a3          	sb	zero,399(gp) # 1209507 <bSmSyncSequenceValid>

8000f29e <.L281>:
    ENABLE_ESC_INT();
8000f29e:	d36fc0ef          	jal	8000b7d4 <ENABLE_ESC_INT>
}
8000f2a2:	0001                	nop
8000f2a4:	40b2                	lw	ra,12(sp)
8000f2a6:	0141                	add	sp,sp,16
8000f2a8:	8082                	ret

Disassembly of section .text.CheckIfEcatError:

8000f2aa <CheckIfEcatError>:
{
8000f2aa:	1101                	add	sp,sp,-32
8000f2ac:	ce06                	sw	ra,28(sp)
   if (EcatWdValue != 0)
8000f2ae:	1821d783          	lhu	a5,386(gp) # 12094fa <EcatWdValue>
8000f2b2:	cb85                	beqz	a5,8000f2e2 <.L293>

8000f2b4 <.LBB13>:
      UINT32 WdStatusOK = 0;
8000f2b4:	c602                	sw	zero,12(sp)
      HW_EscReadDWord(WdStatusOK, ESC_PD_WD_STATE);
8000f2b6:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000f2ba:	44078793          	add	a5,a5,1088
8000f2be:	439c                	lw	a5,0(a5)
8000f2c0:	c63e                	sw	a5,12(sp)
      if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
8000f2c2:	47b2                	lw	a5,12(sp)
8000f2c4:	8b85                	and	a5,a5,1
8000f2c6:	ef91                	bnez	a5,8000f2e2 <.L293>
8000f2c8:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8000f2cc:	cb99                	beqz	a5,8000f2e2 <.L293>
         if (bEcatOutputUpdateRunning
8000f2ce:	19f1c783          	lbu	a5,415(gp) # 1209517 <bEcatOutputUpdateRunning>
8000f2d2:	c791                	beqz	a5,8000f2de <.L294>
            AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
8000f2d4:	45ed                	li	a1,27
8000f2d6:	4511                	li	a0,4
8000f2d8:	c05f90ef          	jal	80008edc <AL_ControlInd>
            return;
8000f2dc:	a815                	j	8000f310 <.L292>

8000f2de <.L294>:
            bEcatFirstOutputsReceived = FALSE;
8000f2de:	1a0180a3          	sb	zero,417(gp) # 1209519 <bEcatFirstOutputsReceived>

8000f2e2 <.L293>:
   if(bDcSyncActive)
8000f2e2:	1a21c783          	lbu	a5,418(gp) # 120951a <bDcSyncActive>
8000f2e6:	c78d                	beqz	a5,8000f310 <.L292>
       if(bEcatOutputUpdateRunning)
8000f2e8:	19f1c783          	lbu	a5,415(gp) # 1209517 <bEcatOutputUpdateRunning>
8000f2ec:	c395                	beqz	a5,8000f310 <.L292>
           if(!bDcRunning)
8000f2ee:	1a31c783          	lbu	a5,419(gp) # 120951b <bDcRunning>
8000f2f2:	e799                	bnez	a5,8000f300 <.L296>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
8000f2f4:	02c00593          	li	a1,44
8000f2f8:	4511                	li	a0,4
8000f2fa:	be3f90ef          	jal	80008edc <AL_ControlInd>
               return;
8000f2fe:	a809                	j	8000f310 <.L292>

8000f300 <.L296>:
           else if(!bSmSyncSequenceValid)
8000f300:	18f1c783          	lbu	a5,399(gp) # 1209507 <bSmSyncSequenceValid>
8000f304:	e791                	bnez	a5,8000f310 <.L292>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
8000f306:	45e9                	li	a1,26
8000f308:	4511                	li	a0,4
8000f30a:	bd3f90ef          	jal	80008edc <AL_ControlInd>
               return;
8000f30e:	0001                	nop

8000f310 <.L292>:
}
8000f310:	40f2                	lw	ra,28(sp)
8000f312:	6105                	add	sp,sp,32
8000f314:	8082                	ret

Disassembly of section .text.ECAT_Main:

8000f316 <ECAT_Main>:
/**
 \brief        This function has to be called cyclically.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Main(void)
{
8000f316:	7179                	add	sp,sp,-48
8000f318:	d606                	sw	ra,44(sp)
    UINT16 ALEventReg;
    UINT16 EscAlControl = 0x0000;
8000f31a:	00011923          	sh	zero,18(sp)
/*ECATCHANGE_START(V5.13) MBX1*/
     UINT32 sm1Activate = SM_SETTING_ENABLE_VALUE;
8000f31e:	67c1                	lui	a5,0x10
8000f320:	cc3e                	sw	a5,24(sp)
     UINT32 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes with invalid CRCs*/
8000f322:	ca02                	sw	zero,20(sp)
/*ECATCHANGE_END(V5.13) MBX1*/


    /* check if services are stored in the mailbox */
    MBX_Main();
8000f324:	e32fa0ef          	jal	80009956 <MBX_Main>


    if ( bMbxRunning )
8000f328:	1991c783          	lbu	a5,409(gp) # 1209511 <bMbxRunning>
8000f32c:	cb99                	beqz	a5,8000f342 <.L327>
    {
        /* Slave is at least in PREOP, Mailbox is running */

/*ECATCHANGE_START(V5.13) MBX1*/
        /*get registers 0x80C:0x80F and mask for SM active state (this is required to access an valid 32bit address)*/
        HW_EscReadDWord(sm1Activate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
8000f32e:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000f332:	6785                	lui	a5,0x1
8000f334:	80c78793          	add	a5,a5,-2036 # 80c <.L13+0x32>
8000f338:	97ba                	add	a5,a5,a4
8000f33a:	439c                	lw	a5,0(a5)
8000f33c:	cc3e                	sw	a5,24(sp)
        sm1Activate = SWAPDWORD(sm1Activate);
        sm1Status = sm1Activate;
8000f33e:	47e2                	lw	a5,24(sp)
8000f340:	ca3e                	sw	a5,20(sp)

8000f342 <.L327>:
/*ECATCHANGE_END(V5.13) MBX1*/
    }

    /* Read AL Event-Register from ESC */
    ALEventReg = HW_GetALEventRegister();
8000f342:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000f346:	22078793          	add	a5,a5,544
8000f34a:	0007d783          	lhu	a5,0(a5)
8000f34e:	00f11f23          	sh	a5,30(sp)
    ALEventReg = SWAPWORD(ALEventReg);

    if ((ALEventReg & EEPROM_CMD_PENDING)) 
8000f352:	01e15783          	lhu	a5,30(sp)
8000f356:	0207f793          	and	a5,a5,32
8000f35a:	c399                	beqz	a5,8000f360 <.L328>
    {
        EEPROM_CommandHandler();
8000f35c:	826f80ef          	jal	80007382 <EEPROM_CommandHandler>

8000f360 <.L328>:
    }

    if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
8000f360:	01e15783          	lhu	a5,30(sp)
8000f364:	8b85                	and	a5,a5,1
8000f366:	c3a5                	beqz	a5,8000f3c6 <.L329>
8000f368:	19e1c783          	lbu	a5,414(gp) # 1209516 <bEcatWaitForAlControlRes>
8000f36c:	efa9                	bnez	a5,8000f3c6 <.L329>

8000f36e <.LBB15>:
    {
        /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
          (that the corresponding bit in the AL Event register will be reset) */
        UINT32 tmpVal = 0;
8000f36e:	c602                	sw	zero,12(sp)

        HW_EscReadDWord( tmpVal, ESC_AL_CONTROL_OFFSET);
8000f370:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000f374:	12078793          	add	a5,a5,288
8000f378:	439c                	lw	a5,0(a5)
8000f37a:	c63e                	sw	a5,12(sp)
        EscAlControl = (UINT16) SWAPDWORD(tmpVal);
8000f37c:	47b2                	lw	a5,12(sp)
8000f37e:	00f11923          	sh	a5,18(sp)


            /*ECATCHANGE_START(V5.13) ECAT2*/
                /*Evaluate if register 0x120 Bit5 (Request Explicit DeviceID) is set*/
            if ((EscAlControl & (UINT16)STATE_DEVID) == STATE_DEVID)
8000f382:	01215783          	lhu	a5,18(sp)
8000f386:	0207f793          	and	a5,a5,32
8000f38a:	cf91                	beqz	a5,8000f3a6 <.L330>
            {
                if (bExplicitDevIdRequested == FALSE)
8000f38c:	19c1c783          	lbu	a5,412(gp) # 1209514 <bExplicitDevIdRequested>
8000f390:	e799                	bnez	a5,8000f39e <.L331>
                {
                    u16IdValue = APPL_GetDeviceID();
8000f392:	9b2fc0ef          	jal	8000b544 <APPL_GetDeviceID>
8000f396:	87aa                	mv	a5,a0
8000f398:	873e                	mv	a4,a5
8000f39a:	14e19723          	sh	a4,334(gp) # 12094c6 <u16IdValue>

8000f39e <.L331>:
                }

                bExplicitDevIdRequested = TRUE;
8000f39e:	4705                	li	a4,1
8000f3a0:	18e18e23          	sb	a4,412(gp) # 1209514 <bExplicitDevIdRequested>
8000f3a4:	a019                	j	8000f3aa <.L332>

8000f3a6 <.L330>:
            }
            else
            {
                bExplicitDevIdRequested = FALSE;
8000f3a6:	18018e23          	sb	zero,412(gp) # 1209514 <bExplicitDevIdRequested>

8000f3aa <.L332>:
            }
            /*ECATCHANGE_END(V5.13) ECAT2*/

        /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
           in AL_ControlInd, too)*/
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
8000f3aa:	01e15783          	lhu	a5,30(sp)
8000f3ae:	9bf9                	and	a5,a5,-2
8000f3b0:	9bbd                	and	a5,a5,-17
8000f3b2:	00f11f23          	sh	a5,30(sp)

            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
8000f3b6:	01215783          	lhu	a5,18(sp)
8000f3ba:	0ff7f793          	zext.b	a5,a5
8000f3be:	4581                	li	a1,0
8000f3c0:	853e                	mv	a0,a5
8000f3c2:	b1bf90ef          	jal	80008edc <AL_ControlInd>

8000f3c6 <.L329>:

            /* SM-Change-Event was handled too */

    }

    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
8000f3c6:	01e15783          	lhu	a5,30(sp)
8000f3ca:	8bc1                	and	a5,a5,16
8000f3cc:	cf8d                	beqz	a5,8000f406 <.L333>
8000f3ce:	19e1c783          	lbu	a5,414(gp) # 1209516 <bEcatWaitForAlControlRes>
8000f3d2:	eb95                	bnez	a5,8000f406 <.L333>
8000f3d4:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000f3d8:	8bc1                	and	a5,a5,16
8000f3da:	e795                	bnez	a5,8000f406 <.L333>
8000f3dc:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000f3e0:	fef7f713          	and	a4,a5,-17
8000f3e4:	4785                	li	a5,1
8000f3e6:	02f70063          	beq	a4,a5,8000f406 <.L333>
    {
        /* the SM Change event is set (Bit 4 of Register 0x220), when the Byte 6 (Enable, Lo-Byte of Register 0x806, 0x80E, 0x816,...)
           of a Sync Manager channel was written */
        ALEventReg &= ~(SM_CHANGE_EVENT);
8000f3ea:	01e15783          	lhu	a5,30(sp)
8000f3ee:	9bbd                	and	a5,a5,-17
8000f3f0:	00f11f23          	sh	a5,30(sp)

        /* AL_ControlInd is called with the actual state, so that the correct SM settings will be checked */
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
8000f3f4:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000f3f8:	8bbd                	and	a5,a5,15
8000f3fa:	0ff7f793          	zext.b	a5,a5
8000f3fe:	4581                	li	a1,0
8000f400:	853e                	mv	a0,a5
8000f402:	adbf90ef          	jal	80008edc <AL_ControlInd>

8000f406 <.L333>:
    }

    if(bEcatWaitForAlControlRes)
8000f406:	19e1c783          	lbu	a5,414(gp) # 1209516 <bEcatWaitForAlControlRes>
8000f40a:	c391                	beqz	a5,8000f40e <.L334>
    {
        AL_ControlRes();
8000f40c:	3465                	jal	8000eeb4 <AL_ControlRes>

8000f40e <.L334>:
        The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
        1. Handle Mailbox Read event
        2. Handle repeat toggle request
        3. Handle Mailbox write event
    */
    if ( bMbxRunning )
8000f40e:	1991c783          	lbu	a5,409(gp) # 1209511 <bMbxRunning>
8000f412:	0c078963          	beqz	a5,8000f4e4 <.L343>
    {
        /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
        => check if the SyncManger 1 is still enabled*/
            if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
8000f416:	4762                	lw	a4,24(sp)
8000f418:	67c1                	lui	a5,0x10
8000f41a:	8ff9                	and	a5,a5,a4
8000f41c:	eb91                	bnez	a5,8000f430 <.L336>
            {
                AL_ControlInd(nAlStatus & STATE_MASK, 0);
8000f41e:	18b1c783          	lbu	a5,395(gp) # 1209503 <nAlStatus>
8000f422:	8bbd                	and	a5,a5,15
8000f424:	0ff7f793          	zext.b	a5,a5
8000f428:	4581                	li	a1,0
8000f42a:	853e                	mv	a0,a5
8000f42c:	ab1f90ef          	jal	80008edc <AL_ControlInd>

8000f430 <.L336>:
            }

/*ECATCHANGE_START(V5.13) MBX1*/
        if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
8000f430:	4752                	lw	a4,20(sp)
8000f432:	28b01793          	bset	a5,zero,0xb
8000f436:	8ff9                	and	a5,a5,a4
8000f438:	eb95                	bnez	a5,8000f46c <.L337>
            && bSendMbxIsFull) 
8000f43a:	1901c783          	lbu	a5,400(gp) # 1209508 <bSendMbxIsFull>
8000f43e:	c79d                	beqz	a5,8000f46c <.L337>
/*ECATCHANGE_END(V5.13) MBX1*/
        {
            /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
               to acknowledge the event the first byte of the mailbox has to be written,
               by writing the first byte the mailbox is locked, too */
            u32dummy = 0;
8000f440:	0801ac23          	sw	zero,152(gp) # 1209410 <u32dummy>
            HW_EscWriteDWord(u32dummy,u16EscAddrSendMbx);
8000f444:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000f448:	1501d783          	lhu	a5,336(gp) # 12094c8 <u16EscAddrSendMbx>
8000f44c:	8389                	srl	a5,a5,0x2
8000f44e:	0807c7b3          	zext.h	a5,a5
8000f452:	078a                	sll	a5,a5,0x2
8000f454:	97ba                	add	a5,a5,a4
8000f456:	0981a703          	lw	a4,152(gp) # 1209410 <u32dummy>
8000f45a:	c398                	sw	a4,0(a5)

            /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
               MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
            ALEventReg &= ~(MAILBOX_READ_EVENT);
8000f45c:	01e15783          	lhu	a5,30(sp)
8000f460:	dff7f793          	and	a5,a5,-513
8000f464:	00f11f23          	sh	a5,30(sp)
            MBX_MailboxReadInd();
8000f468:	9d0fa0ef          	jal	80009638 <MBX_MailboxReadInd>

8000f46c <.L337>:
        }

            /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */

            if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
8000f46c:	4762                	lw	a4,24(sp)
8000f46e:	000207b7          	lui	a5,0x20
8000f472:	8ff9                	and	a5,a5,a4
8000f474:	c781                	beqz	a5,8000f47c <.L338>
8000f476:	19a1c783          	lbu	a5,410(gp) # 1209512 <bMbxRepeatToggle>
8000f47a:	cb89                	beqz	a5,8000f48c <.L339>

8000f47c <.L338>:
                || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
8000f47c:	4762                	lw	a4,24(sp)
8000f47e:	000207b7          	lui	a5,0x20
8000f482:	8ff9                	and	a5,a5,a4
8000f484:	ef85                	bnez	a5,8000f4bc <.L340>
8000f486:	19a1c783          	lbu	a5,410(gp) # 1209512 <bMbxRepeatToggle>
8000f48a:	cb8d                	beqz	a5,8000f4bc <.L340>

8000f48c <.L339>:
            {
                /* Repeat Bit (Bit 1) has toggled, there is a repeat request, in MBX_MailboxRepeatReq the correct
                   response will put in the send mailbox again */
                MBX_MailboxRepeatReq();
8000f48c:	2959                	jal	8000f922 <MBX_MailboxRepeatReq>
                /* acknowledge the repeat request after the send mailbox was updated by writing the Repeat Bit
                   in the Repeat Ack Bit (Bit 1) of the PDI Ctrl-Byte of SM 1 (Register 0x80F) */
                if (bMbxRepeatToggle)
8000f48e:	19a1c783          	lbu	a5,410(gp) # 1209512 <bMbxRepeatToggle>
8000f492:	c799                	beqz	a5,8000f4a0 <.L341>
                {
                    sm1Activate |= SM_SETTING_REPEAT_ACK; //set repeat acknowledge bit (bit 25)
8000f494:	4762                	lw	a4,24(sp)
8000f496:	020007b7          	lui	a5,0x2000
8000f49a:	8fd9                	or	a5,a5,a4
8000f49c:	cc3e                	sw	a5,24(sp)
8000f49e:	a039                	j	8000f4ac <.L342>

8000f4a0 <.L341>:
                }
                else
                {
                    sm1Activate &= ~SM_SETTING_REPEAT_ACK; //clear repeat acknowledge bit (bit 25)
8000f4a0:	4762                	lw	a4,24(sp)
8000f4a2:	fe0007b7          	lui	a5,0xfe000
8000f4a6:	17fd                	add	a5,a5,-1 # fdffffff <__AHB_SRAM_segment_end__+0xddf7fff>
8000f4a8:	8ff9                	and	a5,a5,a4
8000f4aa:	cc3e                	sw	a5,24(sp)

8000f4ac <.L342>:
                }

                sm1Activate = SWAPDWORD(sm1Activate);
                HW_EscWriteDWord(sm1Activate, (ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
8000f4ac:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000f4b0:	6785                	lui	a5,0x1
8000f4b2:	80c78793          	add	a5,a5,-2036 # 80c <.L13+0x32>
8000f4b6:	97ba                	add	a5,a5,a4
8000f4b8:	4762                	lw	a4,24(sp)
8000f4ba:	c398                	sw	a4,0(a5)

8000f4bc <.L340>:
            }


        /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
        ALEventReg = HW_GetALEventRegister();
8000f4bc:	0e41a783          	lw	a5,228(gp) # 120945c <pEsc>
8000f4c0:	22078793          	add	a5,a5,544
8000f4c4:	0007d783          	lhu	a5,0(a5)
8000f4c8:	00f11f23          	sh	a5,30(sp)
        ALEventReg = SWAPWORD(ALEventReg);

        if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
8000f4cc:	01e15783          	lhu	a5,30(sp)
8000f4d0:	1007f793          	and	a5,a5,256
8000f4d4:	cb81                	beqz	a5,8000f4e4 <.L343>
            /* SM 0 (Mailbox Write) event is set, when the mailbox was written from the master,
               to acknowledge the event the first byte of the mailbox has to be read,
               which will be done in MBX_CheckAndCopyMailbox */
            /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
               MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
            ALEventReg &= ~(MAILBOX_WRITE_EVENT);
8000f4d6:	01e15783          	lhu	a5,30(sp)
8000f4da:	eff7f793          	and	a5,a5,-257
8000f4de:	00f11f23          	sh	a5,30(sp)
            MBX_CheckAndCopyMailbox();
8000f4e2:	2961                	jal	8000f97a <MBX_CheckAndCopyMailbox>

8000f4e4 <.L343>:

        }
    }
}
8000f4e4:	0001                	nop
8000f4e6:	50b2                	lw	ra,44(sp)
8000f4e8:	6145                	add	sp,sp,48
8000f4ea:	8082                	ret

Disassembly of section .text.PutInMbxQueue:

8000f4ec <PutInMbxQueue>:
{
8000f4ec:	1101                	add	sp,sp,-32
8000f4ee:	c62a                	sw	a0,12(sp)
8000f4f0:	c42e                	sw	a1,8(sp)
    lastInQueue = pQueue->lastInQueue+1;
8000f4f2:	47a2                	lw	a5,8(sp)
8000f4f4:	0027d783          	lhu	a5,2(a5)
8000f4f8:	0785                	add	a5,a5,1
8000f4fa:	00f11f23          	sh	a5,30(sp)
    if (lastInQueue == pQueue->maxQueueSize)
8000f4fe:	47a2                	lw	a5,8(sp)
8000f500:	0047d783          	lhu	a5,4(a5)
8000f504:	01e15703          	lhu	a4,30(sp)
8000f508:	00f71463          	bne	a4,a5,8000f510 <.L2>
        lastInQueue = 0;
8000f50c:	00011f23          	sh	zero,30(sp)

8000f510 <.L2>:
    if (pQueue->firstInQueue == lastInQueue)
8000f510:	47a2                	lw	a5,8(sp)
8000f512:	0007d783          	lhu	a5,0(a5)
8000f516:	01e15703          	lhu	a4,30(sp)
8000f51a:	00f71463          	bne	a4,a5,8000f522 <.L3>
        return MBXERR_NOMOREMEMORY;
8000f51e:	479d                	li	a5,7
8000f520:	a839                	j	8000f53e <.L4>

8000f522 <.L3>:
    pQueue->queue[pQueue->lastInQueue] = pMbx;
8000f522:	47a2                	lw	a5,8(sp)
8000f524:	0027d783          	lhu	a5,2(a5)
8000f528:	4722                	lw	a4,8(sp)
8000f52a:	078a                	sll	a5,a5,0x2
8000f52c:	97ba                	add	a5,a5,a4
8000f52e:	4732                	lw	a4,12(sp)
8000f530:	c798                	sw	a4,8(a5)
    pQueue->lastInQueue = lastInQueue;
8000f532:	47a2                	lw	a5,8(sp)
8000f534:	01e15703          	lhu	a4,30(sp)
8000f538:	00e79123          	sh	a4,2(a5)
    return 0;
8000f53c:	4781                	li	a5,0

8000f53e <.L4>:
}
8000f53e:	853e                	mv	a0,a5
8000f540:	6105                	add	sp,sp,32
8000f542:	8082                	ret

Disassembly of section .text.MBX_StartMailboxHandler:

8000f544 <MBX_StartMailboxHandler>:
{
8000f544:	1101                	add	sp,sp,-32
8000f546:	ce06                	sw	ra,28(sp)
    UINT16 result = 0;
8000f548:	00011723          	sh	zero,14(sp)
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
8000f54c:	4501                	li	a0,0
8000f54e:	aa8f80ef          	jal	800077f6 <GetSyncMan>
8000f552:	c42a                	sw	a0,8(sp)
    u16ReceiveMbxSize     = (UINT16) ((pSyncMan->AddressLength & SM_LENGTH_MASK) >>SM_LENGTH_SHIFT);
8000f554:	47a2                	lw	a5,8(sp)
8000f556:	0007c703          	lbu	a4,0(a5)
8000f55a:	0017c683          	lbu	a3,1(a5)
8000f55e:	06a2                	sll	a3,a3,0x8
8000f560:	8f55                	or	a4,a4,a3
8000f562:	0027c683          	lbu	a3,2(a5)
8000f566:	06c2                	sll	a3,a3,0x10
8000f568:	8f55                	or	a4,a4,a3
8000f56a:	0037c783          	lbu	a5,3(a5)
8000f56e:	07e2                	sll	a5,a5,0x18
8000f570:	8fd9                	or	a5,a5,a4
8000f572:	83c1                	srl	a5,a5,0x10
8000f574:	0807c733          	zext.h	a4,a5
8000f578:	14e19523          	sh	a4,330(gp) # 12094c2 <u16ReceiveMbxSize>
    u16EscAddrReceiveMbx = (UINT16) (pSyncMan->AddressLength & SM_ADDRESS_MASK);
8000f57c:	47a2                	lw	a5,8(sp)
8000f57e:	0007c703          	lbu	a4,0(a5)
8000f582:	0017c683          	lbu	a3,1(a5)
8000f586:	06a2                	sll	a3,a3,0x8
8000f588:	8f55                	or	a4,a4,a3
8000f58a:	0027c683          	lbu	a3,2(a5)
8000f58e:	06c2                	sll	a3,a3,0x10
8000f590:	8f55                	or	a4,a4,a3
8000f592:	0037c783          	lbu	a5,3(a5)
8000f596:	07e2                	sll	a5,a5,0x18
8000f598:	8fd9                	or	a5,a5,a4
8000f59a:	0807c733          	zext.h	a4,a5
8000f59e:	14e19923          	sh	a4,338(gp) # 12094ca <u16EscAddrReceiveMbx>
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
8000f5a2:	4505                	li	a0,1
8000f5a4:	a52f80ef          	jal	800077f6 <GetSyncMan>
8000f5a8:	c42a                	sw	a0,8(sp)
    u16SendMbxSize = (UINT16) ((pSyncMan->AddressLength & SM_LENGTH_MASK) >>SM_LENGTH_SHIFT);
8000f5aa:	47a2                	lw	a5,8(sp)
8000f5ac:	0007c703          	lbu	a4,0(a5)
8000f5b0:	0017c683          	lbu	a3,1(a5)
8000f5b4:	06a2                	sll	a3,a3,0x8
8000f5b6:	8f55                	or	a4,a4,a3
8000f5b8:	0027c683          	lbu	a3,2(a5)
8000f5bc:	06c2                	sll	a3,a3,0x10
8000f5be:	8f55                	or	a4,a4,a3
8000f5c0:	0037c783          	lbu	a5,3(a5)
8000f5c4:	07e2                	sll	a5,a5,0x18
8000f5c6:	8fd9                	or	a5,a5,a4
8000f5c8:	83c1                	srl	a5,a5,0x10
8000f5ca:	0807c733          	zext.h	a4,a5
8000f5ce:	fee19f23          	sh	a4,-2(gp) # 1209376 <u16SendMbxSize>
    u16EscAddrSendMbx = (UINT16) (pSyncMan->AddressLength & SM_ADDRESS_MASK);
8000f5d2:	47a2                	lw	a5,8(sp)
8000f5d4:	0007c703          	lbu	a4,0(a5)
8000f5d8:	0017c683          	lbu	a3,1(a5)
8000f5dc:	06a2                	sll	a3,a3,0x8
8000f5de:	8f55                	or	a4,a4,a3
8000f5e0:	0027c683          	lbu	a3,2(a5)
8000f5e4:	06c2                	sll	a3,a3,0x10
8000f5e6:	8f55                	or	a4,a4,a3
8000f5e8:	0037c783          	lbu	a5,3(a5)
8000f5ec:	07e2                	sll	a5,a5,0x18
8000f5ee:	8fd9                	or	a5,a5,a4
8000f5f0:	0807c733          	zext.h	a4,a5
8000f5f4:	14e19823          	sh	a4,336(gp) # 12094c8 <u16EscAddrSendMbx>
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
8000f5f8:	1521d783          	lhu	a5,338(gp) # 12094ca <u16EscAddrReceiveMbx>
8000f5fc:	873e                	mv	a4,a5
8000f5fe:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
8000f602:	97ba                	add	a5,a5,a4
8000f604:	1501d703          	lhu	a4,336(gp) # 12094c8 <u16EscAddrSendMbx>
8000f608:	00f75f63          	bge	a4,a5,8000f626 <.L11>
8000f60c:	1521d783          	lhu	a5,338(gp) # 12094ca <u16EscAddrReceiveMbx>
8000f610:	873e                	mv	a4,a5
8000f612:	1501d783          	lhu	a5,336(gp) # 12094c8 <u16EscAddrSendMbx>
8000f616:	86be                	mv	a3,a5
8000f618:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
8000f61c:	97b6                	add	a5,a5,a3
8000f61e:	00f75463          	bge	a4,a5,8000f626 <.L11>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
8000f622:	47d9                	li	a5,22
8000f624:	a0a5                	j	8000f68c <.L12>

8000f626 <.L11>:
    EnableSyncManChannel(MAILBOX_WRITE);
8000f626:	4501                	li	a0,0
8000f628:	a82f80ef          	jal	800078aa <EnableSyncManChannel>
    EnableSyncManChannel(MAILBOX_READ);
8000f62c:	4505                	li	a0,1
8000f62e:	a7cf80ef          	jal	800078aa <EnableSyncManChannel>
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
8000f632:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
8000f636:	853e                	mv	a0,a5
8000f638:	fd2fe0ef          	jal	8000de0a <malloc>
8000f63c:	872a                	mv	a4,a0
8000f63e:	0ae1ae23          	sw	a4,188(gp) # 1209434 <psWriteMbx>
        if(psWriteMbx == NULL)
8000f642:	0bc1a783          	lw	a5,188(gp) # 1209434 <psWriteMbx>
8000f646:	eb85                	bnez	a5,8000f676 <.L13>
            bNoMbxMemoryAvailable = TRUE;
8000f648:	4705                	li	a4,1
8000f64a:	18e18ba3          	sb	a4,407(gp) # 120950f <bNoMbxMemoryAvailable>
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
8000f64e:	4529                	li	a0,10
8000f650:	fbafe0ef          	jal	8000de0a <malloc>
8000f654:	872a                	mv	a4,a0
8000f656:	0ae1ae23          	sw	a4,188(gp) # 1209434 <psWriteMbx>
            if(psWriteMbx == NULL)
8000f65a:	0bc1a783          	lw	a5,188(gp) # 1209434 <psWriteMbx>
8000f65e:	e781                	bnez	a5,8000f666 <.L14>
                result = ALSTATUSCODE_NOMEMORY;
8000f660:	4789                	li	a5,2
8000f662:	00f11723          	sh	a5,14(sp)

8000f666 <.L14>:
            APPL_FreeMailboxBuffer(psWriteMbx);
8000f666:	0bc1a783          	lw	a5,188(gp) # 1209434 <psWriteMbx>
8000f66a:	853e                	mv	a0,a5
8000f66c:	1fa050ef          	jal	80014866 <free>
            psWriteMbx = NULL;
8000f670:	0a01ae23          	sw	zero,188(gp) # 1209434 <psWriteMbx>
8000f674:	a811                	j	8000f688 <.L15>

8000f676 <.L13>:
            bNoMbxMemoryAvailable = FALSE;
8000f676:	18018ba3          	sb	zero,407(gp) # 120950f <bNoMbxMemoryAvailable>
            APPL_FreeMailboxBuffer(psWriteMbx);
8000f67a:	0bc1a783          	lw	a5,188(gp) # 1209434 <psWriteMbx>
8000f67e:	853e                	mv	a0,a5
8000f680:	1e6050ef          	jal	80014866 <free>
            psWriteMbx = NULL;
8000f684:	0a01ae23          	sw	zero,188(gp) # 1209434 <psWriteMbx>

8000f688 <.L15>:
    return result;
8000f688:	00e15783          	lhu	a5,14(sp)

8000f68c <.L12>:
}
8000f68c:	853e                	mv	a0,a5
8000f68e:	40f2                	lw	ra,28(sp)
8000f690:	6105                	add	sp,sp,32
8000f692:	8082                	ret

Disassembly of section .text.MBX_StopMailboxHandler:

8000f694 <MBX_StopMailboxHandler>:
{
8000f694:	1101                	add	sp,sp,-32
8000f696:	ce06                	sw	ra,28(sp)
    bMbxRunning = FALSE;
8000f698:	18018ca3          	sb	zero,409(gp) # 1209511 <bMbxRunning>
    DisableSyncManChannel(MAILBOX_WRITE);
8000f69c:	4501                	li	a0,0
8000f69e:	99cf80ef          	jal	8000783a <DisableSyncManChannel>
    DisableSyncManChannel(MAILBOX_READ);
8000f6a2:	4505                	li	a0,1
8000f6a4:	996f80ef          	jal	8000783a <DisableSyncManChannel>
    if (psRepeatMbx != NULL)
8000f6a8:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000f6ac:	c791                	beqz	a5,8000f6b8 <.L17>
        APPL_FreeMailboxBuffer(psRepeatMbx);
8000f6ae:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000f6b2:	853e                	mv	a0,a5
8000f6b4:	1b2050ef          	jal	80014866 <free>

8000f6b8 <.L17>:
    if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
8000f6b8:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
8000f6bc:	cf81                	beqz	a5,8000f6d4 <.L18>
8000f6be:	0c01a703          	lw	a4,192(gp) # 1209438 <psStoreMbx>
8000f6c2:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000f6c6:	00f70763          	beq	a4,a5,8000f6d4 <.L18>
        APPL_FreeMailboxBuffer(psStoreMbx);
8000f6ca:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
8000f6ce:	853e                	mv	a0,a5
8000f6d0:	196050ef          	jal	80014866 <free>

8000f6d4 <.L18>:
    if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
8000f6d4:	0c81a783          	lw	a5,200(gp) # 1209440 <psReadMbx>
8000f6d8:	c395                	beqz	a5,8000f6fc <.L19>
8000f6da:	0c81a703          	lw	a4,200(gp) # 1209440 <psReadMbx>
8000f6de:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000f6e2:	00f70d63          	beq	a4,a5,8000f6fc <.L19>
8000f6e6:	0c81a703          	lw	a4,200(gp) # 1209440 <psReadMbx>
8000f6ea:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
8000f6ee:	00f70763          	beq	a4,a5,8000f6fc <.L19>
        APPL_FreeMailboxBuffer(psReadMbx);
8000f6f2:	0c81a783          	lw	a5,200(gp) # 1209440 <psReadMbx>
8000f6f6:	853e                	mv	a0,a5
8000f6f8:	16e050ef          	jal	80014866 <free>

8000f6fc <.L19>:
    SDOS_ClearPendingResponse();
8000f6fc:	ba1fb0ef          	jal	8000b29c <SDOS_ClearPendingResponse>
    psWriteMbx = NULL;
8000f700:	0a01ae23          	sw	zero,188(gp) # 1209434 <psWriteMbx>
    psRepeatMbx = NULL;
8000f704:	0c01a223          	sw	zero,196(gp) # 120943c <psRepeatMbx>
    psReadMbx = NULL;
8000f708:	0c01a423          	sw	zero,200(gp) # 1209440 <psReadMbx>
    psStoreMbx = NULL;
8000f70c:	0c01a023          	sw	zero,192(gp) # 1209438 <psStoreMbx>
    bMbxRepeatToggle    = FALSE;
8000f710:	18018d23          	sb	zero,410(gp) # 1209512 <bMbxRepeatToggle>

8000f714 <.LBB4>:
        UINT32 sm1Activate = 0;
8000f714:	c602                	sw	zero,12(sp)
        HW_EscReadDWord(sm1Activate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
8000f716:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000f71a:	6785                	lui	a5,0x1
8000f71c:	80c78793          	add	a5,a5,-2036 # 80c <.L13+0x32>
8000f720:	97ba                	add	a5,a5,a4
8000f722:	439c                	lw	a5,0(a5)
8000f724:	c63e                	sw	a5,12(sp)
        sm1Activate &= SWAPDWORD(~0x02000000);
8000f726:	4732                	lw	a4,12(sp)
8000f728:	fe0007b7          	lui	a5,0xfe000
8000f72c:	17fd                	add	a5,a5,-1 # fdffffff <__AHB_SRAM_segment_end__+0xddf7fff>
8000f72e:	8ff9                	and	a5,a5,a4
8000f730:	c63e                	sw	a5,12(sp)
        HW_EscWriteDWord(sm1Activate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
8000f732:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000f736:	6785                	lui	a5,0x1
8000f738:	80c78793          	add	a5,a5,-2036 # 80c <.L13+0x32>
8000f73c:	97ba                	add	a5,a5,a4
8000f73e:	4732                	lw	a4,12(sp)
8000f740:	c398                	sw	a4,0(a5)

8000f742 <.LBE4>:
    bSendMbxIsFull         = FALSE;
8000f742:	18018823          	sb	zero,400(gp) # 1209508 <bSendMbxIsFull>
    bReceiveMbxIsLocked = FALSE;
8000f746:	18018b23          	sb	zero,406(gp) # 120950e <bReceiveMbxIsLocked>
    u8MailboxSendReqStored    = 0;
8000f74a:	18018223          	sb	zero,388(gp) # 12094fc <u8MailboxSendReqStored>
    u8MbxWriteCounter         = 0;
8000f74e:	fa018ea3          	sb	zero,-67(gp) # 1209335 <u8MbxWriteCounter>
    u8MbxReadCounter        = 0;
8000f752:	fe018ea3          	sb	zero,-3(gp) # 1209375 <u8MbxReadCounter>

8000f756 <.L21>:
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
8000f756:	03418513          	add	a0,gp,52 # 12093ac <sMbxReceiveQueue>
8000f75a:	dcbf90ef          	jal	80009524 <GetOutOfMbxQueue>
8000f75e:	c42a                	sw	a0,8(sp)
        if (pMbx)
8000f760:	47a2                	lw	a5,8(sp)
8000f762:	c781                	beqz	a5,8000f76a <.L20>
            APPL_FreeMailboxBuffer(pMbx);
8000f764:	4522                	lw	a0,8(sp)
8000f766:	100050ef          	jal	80014866 <free>

8000f76a <.L20>:
    } while (pMbx != NULL);
8000f76a:	47a2                	lw	a5,8(sp)
8000f76c:	f7ed                	bnez	a5,8000f756 <.L21>

8000f76e <.L23>:
        pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
8000f76e:	00018513          	mv	a0,gp
8000f772:	db3f90ef          	jal	80009524 <GetOutOfMbxQueue>
8000f776:	c42a                	sw	a0,8(sp)
        if (pMbx)
8000f778:	47a2                	lw	a5,8(sp)
8000f77a:	c781                	beqz	a5,8000f782 <.L22>
            APPL_FreeMailboxBuffer(pMbx);
8000f77c:	4522                	lw	a0,8(sp)
8000f77e:	0e8050ef          	jal	80014866 <free>

8000f782 <.L22>:
    } while (pMbx != NULL);
8000f782:	47a2                	lw	a5,8(sp)
8000f784:	f7ed                	bnez	a5,8000f76e <.L23>
}
8000f786:	0001                	nop
8000f788:	0001                	nop
8000f78a:	40f2                	lw	ra,28(sp)
8000f78c:	6105                	add	sp,sp,32
8000f78e:	8082                	ret

Disassembly of section .text.MailboxServiceInd:

8000f790 <MailboxServiceInd>:
{
8000f790:	7179                	add	sp,sp,-48
8000f792:	d606                	sw	ra,44(sp)
8000f794:	c62a                	sw	a0,12(sp)
    switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
8000f796:	47b2                	lw	a5,12(sp)
8000f798:	0057c783          	lbu	a5,5(a5)
8000f79c:	00f7f713          	and	a4,a5,15
8000f7a0:	478d                	li	a5,3
8000f7a2:	00f71963          	bne	a4,a5,8000f7b4 <.L25>
        result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
8000f7a6:	4532                	lw	a0,12(sp)
8000f7a8:	f03f70ef          	jal	800076aa <COE_ServiceInd>
8000f7ac:	87aa                	mv	a5,a0
8000f7ae:	00f10fa3          	sb	a5,31(sp)
        break;
8000f7b2:	a029                	j	8000f7bc <.L26>

8000f7b4 <.L25>:
        result = MBXERR_UNSUPPORTEDPROTOCOL;
8000f7b4:	4789                	li	a5,2
8000f7b6:	00f10fa3          	sb	a5,31(sp)
        break;
8000f7ba:	0001                	nop

8000f7bc <.L26>:
    return result;
8000f7bc:	01f14783          	lbu	a5,31(sp)
}
8000f7c0:	853e                	mv	a0,a5
8000f7c2:	50b2                	lw	ra,44(sp)
8000f7c4:	6145                	add	sp,sp,48
8000f7c6:	8082                	ret

Disassembly of section .text.MBX_MailboxWriteInd:

8000f7c8 <MBX_MailboxWriteInd>:
{
8000f7c8:	7179                	add	sp,sp,-48
8000f7ca:	d606                	sw	ra,44(sp)
8000f7cc:	c62a                	sw	a0,12(sp)
    UINT8 result = 0;
8000f7ce:	00010fa3          	sb	zero,31(sp)
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
8000f7d2:	47b2                	lw	a5,12(sp)
8000f7d4:	0057c783          	lbu	a5,5(a5)
8000f7d8:	8391                	srl	a5,a5,0x4
8000f7da:	00f10f23          	sb	a5,30(sp)
    UINT16 MbxLen = SWAPWORD(pMbx->MbxHeader.Length);
8000f7de:	47b2                	lw	a5,12(sp)
8000f7e0:	0007c703          	lbu	a4,0(a5)
8000f7e4:	0017c783          	lbu	a5,1(a5)
8000f7e8:	07a2                	sll	a5,a5,0x8
8000f7ea:	8fd9                	or	a5,a5,a4
8000f7ec:	00f11e23          	sh	a5,28(sp)
    if(MbxLen > MAX_MBX_SIZE)
8000f7f0:	01c15703          	lhu	a4,28(sp)
8000f7f4:	08000793          	li	a5,128
8000f7f8:	06e7f763          	bgeu	a5,a4,8000f866 <.L29>
        pMbx->MbxHeader.Length     = 4;
8000f7fc:	47b2                	lw	a5,12(sp)
8000f7fe:	0007c703          	lbu	a4,0(a5)
8000f802:	8b01                	and	a4,a4,0
8000f804:	00476713          	or	a4,a4,4
8000f808:	00e78023          	sb	a4,0(a5)
8000f80c:	0017c703          	lbu	a4,1(a5)
8000f810:	8b01                	and	a4,a4,0
8000f812:	00e780a3          	sb	a4,1(a5)
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
8000f816:	47b2                	lw	a5,12(sp)
8000f818:	0057c783          	lbu	a5,5(a5)
8000f81c:	9bc1                	and	a5,a5,-16
8000f81e:	0ff7f713          	zext.b	a4,a5
8000f822:	47b2                	lw	a5,12(sp)
8000f824:	00e782a3          	sb	a4,5(a5)
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
8000f828:	47b2                	lw	a5,12(sp)
8000f82a:	0067c703          	lbu	a4,6(a5)
8000f82e:	8b01                	and	a4,a4,0
8000f830:	00176713          	or	a4,a4,1
8000f834:	00e78323          	sb	a4,6(a5)
8000f838:	0077c703          	lbu	a4,7(a5)
8000f83c:	8b01                	and	a4,a4,0
8000f83e:	00e783a3          	sb	a4,7(a5)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
8000f842:	47b2                	lw	a5,12(sp)
8000f844:	0087c703          	lbu	a4,8(a5)
8000f848:	8b01                	and	a4,a4,0
8000f84a:	00876713          	or	a4,a4,8
8000f84e:	00e78423          	sb	a4,8(a5)
8000f852:	0097c703          	lbu	a4,9(a5)
8000f856:	8b01                	and	a4,a4,0
8000f858:	00e784a3          	sb	a4,9(a5)
        MBX_MailboxSendReq(pMbx, 0);
8000f85c:	4581                	li	a1,0
8000f85e:	4532                	lw	a0,12(sp)
8000f860:	e81f90ef          	jal	800096e0 <MBX_MailboxSendReq>
}
8000f864:	a85d                	j	8000f91a <.L30>

8000f866 <.L29>:
    if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
8000f866:	01e14783          	lbu	a5,30(sp)
8000f86a:	c799                	beqz	a5,8000f878 <.L31>
8000f86c:	fbd1c783          	lbu	a5,-67(gp) # 1209335 <u8MbxWriteCounter>
8000f870:	01e14703          	lbu	a4,30(sp)
8000f874:	08f70e63          	beq	a4,a5,8000f910 <.L32>

8000f878 <.L31>:
        u8MbxWriteCounter = mbxCounter;
8000f878:	01e14703          	lbu	a4,30(sp)
8000f87c:	fae18ea3          	sb	a4,-67(gp) # 1209335 <u8MbxWriteCounter>
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
8000f880:	03418593          	add	a1,gp,52 # 12093ac <sMbxReceiveQueue>
8000f884:	4532                	lw	a0,12(sp)
8000f886:	319d                	jal	8000f4ec <PutInMbxQueue>
8000f888:	87aa                	mv	a5,a0
8000f88a:	00f10fa3          	sb	a5,31(sp)
        if ( result != 0 )
8000f88e:	01f14783          	lbu	a5,31(sp)
8000f892:	c7c1                	beqz	a5,8000f91a <.L30>
            pMbx->MbxHeader.Length     = 4;
8000f894:	47b2                	lw	a5,12(sp)
8000f896:	0007c703          	lbu	a4,0(a5)
8000f89a:	8b01                	and	a4,a4,0
8000f89c:	00476713          	or	a4,a4,4
8000f8a0:	00e78023          	sb	a4,0(a5)
8000f8a4:	0017c703          	lbu	a4,1(a5)
8000f8a8:	8b01                	and	a4,a4,0
8000f8aa:	00e780a3          	sb	a4,1(a5)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
8000f8ae:	47b2                	lw	a5,12(sp)
8000f8b0:	0057c783          	lbu	a5,5(a5)
8000f8b4:	9bc1                	and	a5,a5,-16
8000f8b6:	0ff7f713          	zext.b	a4,a5
8000f8ba:	47b2                	lw	a5,12(sp)
8000f8bc:	00e782a3          	sb	a4,5(a5)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
8000f8c0:	47b2                	lw	a5,12(sp)
8000f8c2:	0067c703          	lbu	a4,6(a5)
8000f8c6:	8b01                	and	a4,a4,0
8000f8c8:	00176713          	or	a4,a4,1
8000f8cc:	00e78323          	sb	a4,6(a5)
8000f8d0:	0077c703          	lbu	a4,7(a5)
8000f8d4:	8b01                	and	a4,a4,0
8000f8d6:	00e783a3          	sb	a4,7(a5)
            pMbx->Data[1]                        = SWAPWORD(result);
8000f8da:	01f14783          	lbu	a5,31(sp)
8000f8de:	0807c733          	zext.h	a4,a5
8000f8e2:	47b2                	lw	a5,12(sp)
8000f8e4:	0ff77693          	zext.b	a3,a4
8000f8e8:	0087c603          	lbu	a2,8(a5)
8000f8ec:	8a01                	and	a2,a2,0
8000f8ee:	8ed1                	or	a3,a3,a2
8000f8f0:	00d78423          	sb	a3,8(a5)
8000f8f4:	8321                	srl	a4,a4,0x8
8000f8f6:	08074733          	zext.h	a4,a4
8000f8fa:	0097c683          	lbu	a3,9(a5)
8000f8fe:	8a81                	and	a3,a3,0
8000f900:	8f55                	or	a4,a4,a3
8000f902:	00e784a3          	sb	a4,9(a5)
            MBX_MailboxSendReq(pMbx, 0);
8000f906:	4581                	li	a1,0
8000f908:	4532                	lw	a0,12(sp)
8000f90a:	dd7f90ef          	jal	800096e0 <MBX_MailboxSendReq>
        if ( result != 0 )
8000f90e:	a031                	j	8000f91a <.L30>

8000f910 <.L32>:
        APPL_FreeMailboxBuffer(pMbx);
8000f910:	4532                	lw	a0,12(sp)
8000f912:	755040ef          	jal	80014866 <free>
        pMbx = NULL;
8000f916:	c602                	sw	zero,12(sp)
}
8000f918:	a009                	j	8000f91a <.L30>

8000f91a <.L30>:
8000f91a:	0001                	nop
8000f91c:	50b2                	lw	ra,44(sp)
8000f91e:	6145                	add	sp,sp,48
8000f920:	8082                	ret

Disassembly of section .text.MBX_MailboxRepeatReq:

8000f922 <MBX_MailboxRepeatReq>:
{
8000f922:	1101                	add	sp,sp,-32
8000f924:	ce06                	sw	ra,28(sp)
    if (psRepeatMbx)
8000f926:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000f92a:	cb9d                	beqz	a5,8000f960 <.L42>

8000f92c <.LBB7>:
        TMBX MBXMEM *pMbx = psRepeatMbx;
8000f92c:	0c41a783          	lw	a5,196(gp) # 120943c <psRepeatMbx>
8000f930:	c63e                	sw	a5,12(sp)
       if (bSendMbxIsFull && psStoreMbx == NULL)
8000f932:	1901c783          	lbu	a5,400(gp) # 1209508 <bSendMbxIsFull>
8000f936:	c385                	beqz	a5,8000f956 <.L43>
8000f938:	0c01a783          	lw	a5,192(gp) # 1209438 <psStoreMbx>
8000f93c:	ef89                	bnez	a5,8000f956 <.L43>
            DisableSyncManChannel(MAILBOX_READ);
8000f93e:	4505                	li	a0,1
8000f940:	efbf70ef          	jal	8000783a <DisableSyncManChannel>
            psStoreMbx = psReadMbx;
8000f944:	0c81a703          	lw	a4,200(gp) # 1209440 <psReadMbx>
8000f948:	0ce1a023          	sw	a4,192(gp) # 1209438 <psStoreMbx>
            EnableSyncManChannel(MAILBOX_READ);
8000f94c:	4505                	li	a0,1
8000f94e:	f5df70ef          	jal	800078aa <EnableSyncManChannel>
            bSendMbxIsFull = FALSE;
8000f952:	18018823          	sb	zero,400(gp) # 1209508 <bSendMbxIsFull>

8000f956 <.L43>:
        MBX_CopyToSendMailbox(pMbx);
8000f956:	4532                	lw	a0,12(sp)
8000f958:	e75f90ef          	jal	800097cc <MBX_CopyToSendMailbox>
        psRepeatMbx = NULL;
8000f95c:	0c01a223          	sw	zero,196(gp) # 120943c <psRepeatMbx>

8000f960 <.L42>:
    bMbxRepeatToggle = !bMbxRepeatToggle;
8000f960:	19a1c783          	lbu	a5,410(gp) # 1209512 <bMbxRepeatToggle>
8000f964:	0017b793          	seqz	a5,a5
8000f968:	0ff7f793          	zext.b	a5,a5
8000f96c:	873e                	mv	a4,a5
8000f96e:	18e18d23          	sb	a4,410(gp) # 1209512 <bMbxRepeatToggle>
}
8000f972:	0001                	nop
8000f974:	40f2                	lw	ra,28(sp)
8000f976:	6105                	add	sp,sp,32
8000f978:	8082                	ret

Disassembly of section .text.MBX_CheckAndCopyMailbox:

8000f97a <MBX_CheckAndCopyMailbox>:
{
8000f97a:	1101                	add	sp,sp,-32
8000f97c:	ce06                	sw	ra,28(sp)
    UINT32 tmpValue= 0;
8000f97e:	c402                	sw	zero,8(sp)
    HW_EscReadDWord(tmpValue,u16EscAddrReceiveMbx);
8000f980:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000f984:	1521d783          	lhu	a5,338(gp) # 12094ca <u16EscAddrReceiveMbx>
8000f988:	8389                	srl	a5,a5,0x2
8000f98a:	0807c7b3          	zext.h	a5,a5
8000f98e:	078a                	sll	a5,a5,0x2
8000f990:	97ba                	add	a5,a5,a4
8000f992:	439c                	lw	a5,0(a5)
8000f994:	c43e                	sw	a5,8(sp)
    tmpValue = (SWAPDWORD(tmpValue) & 0x0000FFFF);
8000f996:	4722                	lw	a4,8(sp)
8000f998:	67c1                	lui	a5,0x10
8000f99a:	17fd                	add	a5,a5,-1 # ffff <__AXI_SRAM_segment_used_size__+0x6aa3>
8000f99c:	8ff9                	and	a5,a5,a4
8000f99e:	c43e                	sw	a5,8(sp)
    mbxLen = (UINT16) tmpValue;
8000f9a0:	47a2                	lw	a5,8(sp)
8000f9a2:	00f11723          	sh	a5,14(sp)
    if(bNoMbxMemoryAvailable == TRUE)
8000f9a6:	1971c703          	lbu	a4,407(gp) # 120950f <bNoMbxMemoryAvailable>
8000f9aa:	4785                	li	a5,1
8000f9ac:	08f71463          	bne	a4,a5,8000fa34 <.L53>

8000f9b0 <.LBB8>:
        TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
8000f9b0:	4529                	li	a0,10
8000f9b2:	c58fe0ef          	jal	8000de0a <malloc>
8000f9b6:	c22a                	sw	a0,4(sp)
        if(pMbx != NULL)
8000f9b8:	4792                	lw	a5,4(sp)
8000f9ba:	cfad                	beqz	a5,8000fa34 <.L53>
            HMEMSET(pMbx,0x00,10);
8000f9bc:	4629                	li	a2,10
8000f9be:	4581                	li	a1,0
8000f9c0:	4512                	lw	a0,4(sp)
8000f9c2:	491030ef          	jal	80013652 <memset>
            pMbx->MbxHeader.Length     = 4;
8000f9c6:	4792                	lw	a5,4(sp)
8000f9c8:	0007c703          	lbu	a4,0(a5)
8000f9cc:	8b01                	and	a4,a4,0
8000f9ce:	00476713          	or	a4,a4,4
8000f9d2:	00e78023          	sb	a4,0(a5)
8000f9d6:	0017c703          	lbu	a4,1(a5)
8000f9da:	8b01                	and	a4,a4,0
8000f9dc:	00e780a3          	sb	a4,1(a5)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
8000f9e0:	4792                	lw	a5,4(sp)
8000f9e2:	0057c783          	lbu	a5,5(a5)
8000f9e6:	9bc1                	and	a5,a5,-16
8000f9e8:	0ff7f713          	zext.b	a4,a5
8000f9ec:	4792                	lw	a5,4(sp)
8000f9ee:	00e782a3          	sb	a4,5(a5)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
8000f9f2:	4792                	lw	a5,4(sp)
8000f9f4:	0067c703          	lbu	a4,6(a5)
8000f9f8:	8b01                	and	a4,a4,0
8000f9fa:	00176713          	or	a4,a4,1
8000f9fe:	00e78323          	sb	a4,6(a5)
8000fa02:	0077c703          	lbu	a4,7(a5)
8000fa06:	8b01                	and	a4,a4,0
8000fa08:	00e783a3          	sb	a4,7(a5)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
8000fa0c:	4792                	lw	a5,4(sp)
8000fa0e:	0087c703          	lbu	a4,8(a5)
8000fa12:	8b01                	and	a4,a4,0
8000fa14:	00776713          	or	a4,a4,7
8000fa18:	00e78423          	sb	a4,8(a5)
8000fa1c:	0097c703          	lbu	a4,9(a5)
8000fa20:	8b01                	and	a4,a4,0
8000fa22:	00e784a3          	sb	a4,9(a5)
            MBX_MailboxSendReq(pMbx, 0);
8000fa26:	4581                	li	a1,0
8000fa28:	4512                	lw	a0,4(sp)
8000fa2a:	cb7f90ef          	jal	800096e0 <MBX_MailboxSendReq>
            APPL_FreeMailboxBuffer(pMbx);
8000fa2e:	4512                	lw	a0,4(sp)
8000fa30:	637040ef          	jal	80014866 <free>

8000fa34 <.L53>:
    mbxLen += MBX_HEADER_SIZE;
8000fa34:	00e15783          	lhu	a5,14(sp)
8000fa38:	0799                	add	a5,a5,6
8000fa3a:	00f11723          	sh	a5,14(sp)
    if ( ( bSendMbxIsFull )                /* a received mailbox service will not be processed
8000fa3e:	1901c783          	lbu	a5,400(gp) # 1209508 <bSendMbxIsFull>
8000fa42:	e781                	bnez	a5,8000fa4a <.L54>
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
8000fa44:	1841c783          	lbu	a5,388(gp) # 12094fc <u8MailboxSendReqStored>
8000fa48:	c789                	beqz	a5,8000fa52 <.L55>

8000fa4a <.L54>:
        bReceiveMbxIsLocked = TRUE;
8000fa4a:	4705                	li	a4,1
8000fa4c:	18e18b23          	sb	a4,406(gp) # 120950e <bReceiveMbxIsLocked>
8000fa50:	a05d                	j	8000faf6 <.L52>

8000fa52 <.L55>:
        bReceiveMbxIsLocked = FALSE;
8000fa52:	18018b23          	sb	zero,406(gp) # 120950e <bReceiveMbxIsLocked>
        if (mbxLen > u16ReceiveMbxSize)
8000fa56:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
8000fa5a:	00e15703          	lhu	a4,14(sp)
8000fa5e:	00e7f663          	bgeu	a5,a4,8000fa6a <.L57>
            mbxLen = u16ReceiveMbxSize;
8000fa62:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
8000fa66:	00f11723          	sh	a5,14(sp)

8000fa6a <.L57>:
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
8000fa6a:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
8000fa6e:	853e                	mv	a0,a5
8000fa70:	b9afe0ef          	jal	8000de0a <malloc>
8000fa74:	872a                	mv	a4,a0
8000fa76:	0ae1ae23          	sw	a4,188(gp) # 1209434 <psWriteMbx>
        if (psWriteMbx == NULL)
8000fa7a:	0bc1a783          	lw	a5,188(gp) # 1209434 <psWriteMbx>
8000fa7e:	e789                	bnez	a5,8000fa88 <.L58>
            bReceiveMbxIsLocked = TRUE;
8000fa80:	4705                	li	a4,1
8000fa82:	18e18b23          	sb	a4,406(gp) # 120950e <bReceiveMbxIsLocked>
            return;
8000fa86:	a885                	j	8000faf6 <.L52>

8000fa88 <.L58>:
        HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
8000fa88:	0bc1a683          	lw	a3,188(gp) # 1209434 <psWriteMbx>
8000fa8c:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000fa90:	1521d783          	lhu	a5,338(gp) # 12094ca <u16EscAddrReceiveMbx>
8000fa94:	8389                	srl	a5,a5,0x2
8000fa96:	0807c7b3          	zext.h	a5,a5
8000fa9a:	078a                	sll	a5,a5,0x2
8000fa9c:	97ba                	add	a5,a5,a4
8000fa9e:	00e15703          	lhu	a4,14(sp)
8000faa2:	863a                	mv	a2,a4
8000faa4:	85be                	mv	a1,a5
8000faa6:	8536                	mv	a0,a3
8000faa8:	9b4fe0ef          	jal	8000dc5c <memcpy>

8000faac <.LBB9>:
        VARVOLATILE UINT32 smstate = 0x00;
8000faac:	c002                	sw	zero,0(sp)
        HW_EscReadDWord(smstate,ESC_SYNCMAN_CONTROL_OFFSET);
8000faae:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000fab2:	6785                	lui	a5,0x1
8000fab4:	80478793          	add	a5,a5,-2044 # 804 <.L13+0x2a>
8000fab8:	97ba                	add	a5,a5,a4
8000faba:	439c                	lw	a5,0(a5)
8000fabc:	c03e                	sw	a5,0(sp)
        smstate = SWAPDWORD(smstate);
8000fabe:	4782                	lw	a5,0(sp)
8000fac0:	c03e                	sw	a5,0(sp)
        if(smstate & SM_STATUS_MBX_BUFFER_FULL)
8000fac2:	4702                	lw	a4,0(sp)
8000fac4:	28b01793          	bset	a5,zero,0xb
8000fac8:	8ff9                	and	a5,a5,a4
8000faca:	c395                	beqz	a5,8000faee <.L59>
            u32dummy = 0;
8000facc:	0801ac23          	sw	zero,152(gp) # 1209410 <u32dummy>
            HW_EscReadDWord(u32dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 4));
8000fad0:	0e41a703          	lw	a4,228(gp) # 120945c <pEsc>
8000fad4:	1521d783          	lhu	a5,338(gp) # 12094ca <u16EscAddrReceiveMbx>
8000fad8:	86be                	mv	a3,a5
8000fada:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
8000fade:	97b6                	add	a5,a5,a3
8000fae0:	17f1                	add	a5,a5,-4
8000fae2:	8789                	sra	a5,a5,0x2
8000fae4:	078a                	sll	a5,a5,0x2
8000fae6:	97ba                	add	a5,a5,a4
8000fae8:	4398                	lw	a4,0(a5)
8000faea:	08e1ac23          	sw	a4,152(gp) # 1209410 <u32dummy>

8000faee <.L59>:
        MBX_MailboxWriteInd( psWriteMbx );
8000faee:	0bc1a783          	lw	a5,188(gp) # 1209434 <psWriteMbx>
8000faf2:	853e                	mv	a0,a5
8000faf4:	39d1                	jal	8000f7c8 <MBX_MailboxWriteInd>

8000faf6 <.L52>:
}
8000faf6:	40f2                	lw	ra,28(sp)
8000faf8:	6105                	add	sp,sp,32
8000fafa:	8082                	ret

Disassembly of section .text.OBJ_GetObjectHandle:

8000fafc <OBJ_GetObjectHandle>:
{
8000fafc:	7179                	add	sp,sp,-48
8000fafe:	d606                	sw	ra,44(sp)
8000fb00:	87aa                	mv	a5,a0
8000fb02:	00f11723          	sh	a5,14(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
8000fb06:	8e1fe0ef          	jal	8000e3e6 <COE_GetObjectDictionary>
8000fb0a:	ce2a                	sw	a0,28(sp)
    while (pObjEntry!= NULL)
8000fb0c:	a829                	j	8000fb26 <.L2>

8000fb0e <.L5>:
        if (pObjEntry->Index == index)
8000fb0e:	47f2                	lw	a5,28(sp)
8000fb10:	0087d783          	lhu	a5,8(a5)
8000fb14:	00e15703          	lhu	a4,14(sp)
8000fb18:	00f71463          	bne	a4,a5,8000fb20 <.L3>
            return pObjEntry;
8000fb1c:	47f2                	lw	a5,28(sp)
8000fb1e:	a039                	j	8000fb2c <.L4>

8000fb20 <.L3>:
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
8000fb20:	47f2                	lw	a5,28(sp)
8000fb22:	43dc                	lw	a5,4(a5)
8000fb24:	ce3e                	sw	a5,28(sp)

8000fb26 <.L2>:
    while (pObjEntry!= NULL)
8000fb26:	47f2                	lw	a5,28(sp)
8000fb28:	f3fd                	bnez	a5,8000fb0e <.L5>
    return 0;
8000fb2a:	4781                	li	a5,0

8000fb2c <.L4>:
}
8000fb2c:	853e                	mv	a0,a5
8000fb2e:	50b2                	lw	ra,44(sp)
8000fb30:	6145                	add	sp,sp,48
8000fb32:	8082                	ret

Disassembly of section .text.OBJ_GetNoOfObjects:

8000fb34 <OBJ_GetNoOfObjects>:
{
8000fb34:	7179                	add	sp,sp,-48
8000fb36:	d606                	sw	ra,44(sp)
8000fb38:	87aa                	mv	a5,a0
8000fb3a:	00f107a3          	sb	a5,15(sp)
    UINT16 listFlags = 0x0020 << listType;
8000fb3e:	00f14783          	lbu	a5,15(sp)
8000fb42:	02000713          	li	a4,32
8000fb46:	00f717b3          	sll	a5,a4,a5
8000fb4a:	00f11a23          	sh	a5,20(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
8000fb4e:	899fe0ef          	jal	8000e3e6 <COE_GetObjectDictionary>
8000fb52:	ce2a                	sw	a0,28(sp)
    UINT16 n = 0;
8000fb54:	00011d23          	sh	zero,26(sp)
    while (pObjEntry != NULL)
8000fb58:	a851                	j	8000fbec <.L21>

8000fb5a <.L27>:
        if ( pObjEntry->Index >= 0x1000 )
8000fb5a:	47f2                	lw	a5,28(sp)
8000fb5c:	0087d703          	lhu	a4,8(a5)
8000fb60:	6785                	lui	a5,0x1
8000fb62:	08f76263          	bltu	a4,a5,8000fbe6 <.L22>

8000fb66 <.LBB3>:
            UINT8 t = listType;
8000fb66:	00f14783          	lbu	a5,15(sp)
8000fb6a:	00f10ca3          	sb	a5,25(sp)
            if ( t )
8000fb6e:	01914783          	lbu	a5,25(sp)
8000fb72:	c3b5                	beqz	a5,8000fbd6 <.L23>

8000fb74 <.LBB4>:
                UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
8000fb74:	47f2                	lw	a5,28(sp)
8000fb76:	00c7d783          	lhu	a5,12(a5) # 100c <.L79+0x6>
8000fb7a:	00f109a3          	sb	a5,19(sp)
                UINT16 i = 0;
8000fb7e:	00011b23          	sh	zero,22(sp)
                while ( t && i <= maxSubindex )
8000fb82:	a83d                	j	8000fbc0 <.L24>

8000fb84 <.L26>:
                    if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
8000fb84:	01615783          	lhu	a5,22(sp)
8000fb88:	0ff7f793          	zext.b	a5,a5
8000fb8c:	85be                	mv	a1,a5
8000fb8e:	4572                	lw	a0,28(sp)
8000fb90:	8a0fa0ef          	jal	80009c30 <OBJ_GetEntryDesc>
8000fb94:	87aa                	mv	a5,a0
8000fb96:	0047c703          	lbu	a4,4(a5)
8000fb9a:	0057c783          	lbu	a5,5(a5)
8000fb9e:	07a2                	sll	a5,a5,0x8
8000fba0:	8fd9                	or	a5,a5,a4
8000fba2:	0807c7b3          	zext.h	a5,a5
8000fba6:	01415703          	lhu	a4,20(sp)
8000fbaa:	8ff9                	and	a5,a5,a4
8000fbac:	0807c7b3          	zext.h	a5,a5
8000fbb0:	c399                	beqz	a5,8000fbb6 <.L25>
                        t = 0;
8000fbb2:	00010ca3          	sb	zero,25(sp)

8000fbb6 <.L25>:
                    i++;
8000fbb6:	01615783          	lhu	a5,22(sp)
8000fbba:	0785                	add	a5,a5,1
8000fbbc:	00f11b23          	sh	a5,22(sp)

8000fbc0 <.L24>:
                while ( t && i <= maxSubindex )
8000fbc0:	01914783          	lbu	a5,25(sp)
8000fbc4:	cb89                	beqz	a5,8000fbd6 <.L23>
8000fbc6:	01314783          	lbu	a5,19(sp)
8000fbca:	0807c7b3          	zext.h	a5,a5
8000fbce:	01615703          	lhu	a4,22(sp)
8000fbd2:	fae7f9e3          	bgeu	a5,a4,8000fb84 <.L26>

8000fbd6 <.L23>:
            if ( !t )
8000fbd6:	01914783          	lbu	a5,25(sp)
8000fbda:	e791                	bnez	a5,8000fbe6 <.L22>
                n++;
8000fbdc:	01a15783          	lhu	a5,26(sp)
8000fbe0:	0785                	add	a5,a5,1
8000fbe2:	00f11d23          	sh	a5,26(sp)

8000fbe6 <.L22>:
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
8000fbe6:	47f2                	lw	a5,28(sp)
8000fbe8:	43dc                	lw	a5,4(a5)
8000fbea:	ce3e                	sw	a5,28(sp)

8000fbec <.L21>:
    while (pObjEntry != NULL)
8000fbec:	47f2                	lw	a5,28(sp)
8000fbee:	f7b5                	bnez	a5,8000fb5a <.L27>
    return n;
8000fbf0:	01a15783          	lhu	a5,26(sp)
}
8000fbf4:	853e                	mv	a0,a5
8000fbf6:	50b2                	lw	ra,44(sp)
8000fbf8:	6145                	add	sp,sp,48
8000fbfa:	8082                	ret

Disassembly of section .text.OBJ_GetObjectList:

8000fbfc <OBJ_GetObjectList>:
{
8000fbfc:	7179                	add	sp,sp,-48
8000fbfe:	d606                	sw	ra,44(sp)
8000fc00:	87aa                	mv	a5,a0
8000fc02:	c42e                	sw	a1,8(sp)
8000fc04:	c236                	sw	a3,4(sp)
8000fc06:	c03a                	sw	a4,0(sp)
8000fc08:	00f11723          	sh	a5,14(sp)
8000fc0c:	87b2                	mv	a5,a2
8000fc0e:	00f11623          	sh	a5,12(sp)
    UINT16 listFlags = 0x0020 << listType;
8000fc12:	00e15783          	lhu	a5,14(sp)
8000fc16:	02000713          	li	a4,32
8000fc1a:	00f717b3          	sll	a5,a4,a5
8000fc1e:	00f11b23          	sh	a5,22(sp)
    if ( pIndex[0] == 0x1000 )
8000fc22:	47a2                	lw	a5,8(sp)
8000fc24:	0007d703          	lhu	a4,0(a5)
8000fc28:	6785                	lui	a5,0x1
8000fc2a:	00f71e63          	bne	a4,a5,8000fc46 <.L30>
       pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
8000fc2e:	fb8fe0ef          	jal	8000e3e6 <COE_GetObjectDictionary>
8000fc32:	ce2a                	sw	a0,28(sp)
        if((pObjEntry == NULL) && (pAbort != NULL))
8000fc34:	47f2                	lw	a5,28(sp)
8000fc36:	eb99                	bnez	a5,8000fc4c <.L31>
8000fc38:	4782                	lw	a5,0(sp)
8000fc3a:	cb89                	beqz	a5,8000fc4c <.L31>
            *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
8000fc3c:	4782                	lw	a5,0(sp)
8000fc3e:	476d                	li	a4,27
8000fc40:	00e78023          	sb	a4,0(a5) # 1000 <.L76+0x3a>
8000fc44:	a021                	j	8000fc4c <.L31>

8000fc46 <.L30>:
        pObjEntry = pSdoInfoObjEntry;
8000fc46:	0e01a783          	lw	a5,224(gp) # 1209458 <pSdoInfoObjEntry>
8000fc4a:	ce3e                	sw	a5,28(sp)

8000fc4c <.L31>:
    if ( pObjEntry != NULL )
8000fc4c:	47f2                	lw	a5,28(sp)
8000fc4e:	cbdd                	beqz	a5,8000fd04 <.L32>
        while (pObjEntry != NULL && size > 1 )
8000fc50:	a05d                	j	8000fcf6 <.L33>

8000fc52 <.L39>:
            if ( pObjEntry->Index >= 0x1000 )
8000fc52:	47f2                	lw	a5,28(sp)
8000fc54:	0087d703          	lhu	a4,8(a5)
8000fc58:	6785                	lui	a5,0x1
8000fc5a:	08f76b63          	bltu	a4,a5,8000fcf0 <.L34>

8000fc5e <.LBB5>:
                UINT16 t = listType;
8000fc5e:	00e15783          	lhu	a5,14(sp)
8000fc62:	00f11d23          	sh	a5,26(sp)
                if ( t )
8000fc66:	01a15783          	lhu	a5,26(sp)
8000fc6a:	c3b5                	beqz	a5,8000fcce <.L35>

8000fc6c <.LBB6>:
                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
8000fc6c:	47f2                	lw	a5,28(sp)
8000fc6e:	00c7d783          	lhu	a5,12(a5) # 100c <.L79+0x6>
8000fc72:	00f10aa3          	sb	a5,21(sp)
                    UINT16 i = 0;
8000fc76:	00011c23          	sh	zero,24(sp)
                    while ( t && i <= maxSubindex )
8000fc7a:	a83d                	j	8000fcb8 <.L36>

8000fc7c <.L38>:
                        if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
8000fc7c:	01815783          	lhu	a5,24(sp)
8000fc80:	0ff7f793          	zext.b	a5,a5
8000fc84:	85be                	mv	a1,a5
8000fc86:	4572                	lw	a0,28(sp)
8000fc88:	fa9f90ef          	jal	80009c30 <OBJ_GetEntryDesc>
8000fc8c:	87aa                	mv	a5,a0
8000fc8e:	0047c703          	lbu	a4,4(a5)
8000fc92:	0057c783          	lbu	a5,5(a5)
8000fc96:	07a2                	sll	a5,a5,0x8
8000fc98:	8fd9                	or	a5,a5,a4
8000fc9a:	0807c7b3          	zext.h	a5,a5
8000fc9e:	01615703          	lhu	a4,22(sp)
8000fca2:	8ff9                	and	a5,a5,a4
8000fca4:	0807c7b3          	zext.h	a5,a5
8000fca8:	c399                	beqz	a5,8000fcae <.L37>
                            t = 0;
8000fcaa:	00011d23          	sh	zero,26(sp)

8000fcae <.L37>:
                        i++;
8000fcae:	01815783          	lhu	a5,24(sp)
8000fcb2:	0785                	add	a5,a5,1
8000fcb4:	00f11c23          	sh	a5,24(sp)

8000fcb8 <.L36>:
                    while ( t && i <= maxSubindex )
8000fcb8:	01a15783          	lhu	a5,26(sp)
8000fcbc:	cb89                	beqz	a5,8000fcce <.L35>
8000fcbe:	01514783          	lbu	a5,21(sp)
8000fcc2:	0807c7b3          	zext.h	a5,a5
8000fcc6:	01815703          	lhu	a4,24(sp)
8000fcca:	fae7f9e3          	bgeu	a5,a4,8000fc7c <.L38>

8000fcce <.L35>:
                if ( !t )
8000fcce:	01a15783          	lhu	a5,26(sp)
8000fcd2:	ef99                	bnez	a5,8000fcf0 <.L34>
                    *pData = SWAPWORD(pObjEntry->Index);
8000fcd4:	47f2                	lw	a5,28(sp)
8000fcd6:	0087d703          	lhu	a4,8(a5)
8000fcda:	4792                	lw	a5,4(sp)
8000fcdc:	00e79023          	sh	a4,0(a5)
                    pData++;
8000fce0:	4792                	lw	a5,4(sp)
8000fce2:	0789                	add	a5,a5,2
8000fce4:	c23e                	sw	a5,4(sp)
                    size -= 2;
8000fce6:	00c15783          	lhu	a5,12(sp)
8000fcea:	17f9                	add	a5,a5,-2
8000fcec:	00f11623          	sh	a5,12(sp)

8000fcf0 <.L34>:
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
8000fcf0:	47f2                	lw	a5,28(sp)
8000fcf2:	43dc                	lw	a5,4(a5)
8000fcf4:	ce3e                	sw	a5,28(sp)

8000fcf6 <.L33>:
        while (pObjEntry != NULL && size > 1 )
8000fcf6:	47f2                	lw	a5,28(sp)
8000fcf8:	c791                	beqz	a5,8000fd04 <.L32>
8000fcfa:	00c15703          	lhu	a4,12(sp)
8000fcfe:	4785                	li	a5,1
8000fd00:	f4e7e9e3          	bltu	a5,a4,8000fc52 <.L39>

8000fd04 <.L32>:
        if(pObjEntry != NULL)
8000fd04:	47f2                	lw	a5,28(sp)
8000fd06:	cb81                	beqz	a5,8000fd16 <.L40>
            pIndex[0] = pObjEntry->Index;
8000fd08:	47f2                	lw	a5,28(sp)
8000fd0a:	0087d703          	lhu	a4,8(a5)
8000fd0e:	47a2                	lw	a5,8(sp)
8000fd10:	00e79023          	sh	a4,0(a5)
8000fd14:	a029                	j	8000fd1e <.L41>

8000fd16 <.L40>:
            pIndex[0] = 0xFFFF;
8000fd16:	47a2                	lw	a5,8(sp)
8000fd18:	577d                	li	a4,-1
8000fd1a:	00e79023          	sh	a4,0(a5)

8000fd1e <.L41>:
    pSdoInfoObjEntry = pObjEntry;
8000fd1e:	4772                	lw	a4,28(sp)
8000fd20:	0ee1a023          	sw	a4,224(gp) # 1209458 <pSdoInfoObjEntry>
    return size;
8000fd24:	00c15783          	lhu	a5,12(sp)
}
8000fd28:	853e                	mv	a0,a5
8000fd2a:	50b2                	lw	ra,44(sp)
8000fd2c:	6145                	add	sp,sp,48
8000fd2e:	8082                	ret

Disassembly of section .text.OBJ_GetDesc:

8000fd30 <OBJ_GetDesc>:
{
8000fd30:	7139                	add	sp,sp,-64
8000fd32:	de06                	sw	ra,60(sp)
8000fd34:	87aa                	mv	a5,a0
8000fd36:	872e                	mv	a4,a1
8000fd38:	c432                	sw	a2,8(sp)
8000fd3a:	c236                	sw	a3,4(sp)
8000fd3c:	00f11723          	sh	a5,14(sp)
8000fd40:	87ba                	mv	a5,a4
8000fd42:	00f106a3          	sb	a5,13(sp)
    UINT16 strSize = 0;
8000fd46:	02011723          	sh	zero,46(sp)
    OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
8000fd4a:	47a2                	lw	a5,8(sp)
8000fd4c:	4bdc                	lw	a5,20(a5)
8000fd4e:	d23e                	sw	a5,36(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
8000fd50:	47a2                	lw	a5,8(sp)
8000fd52:	00c7d783          	lhu	a5,12(a5)
8000fd56:	87a1                	sra	a5,a5,0x8
8000fd58:	0ff7f793          	zext.b	a5,a5
8000fd5c:	8bbd                	and	a5,a5,15
8000fd5e:	02f101a3          	sb	a5,35(sp)
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
8000fd62:	00d14783          	lbu	a5,13(sp)
8000fd66:	c791                	beqz	a5,8000fd72 <.L44>
8000fd68:	02314703          	lbu	a4,35(sp)
8000fd6c:	479d                	li	a5,7
8000fd6e:	02f71363          	bne	a4,a5,8000fd94 <.L45>

8000fd72 <.L44>:
       strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
8000fd72:	5512                	lw	a0,36(sp)
8000fd74:	147030ef          	jal	800136ba <strlen>
8000fd78:	87aa                	mv	a5,a0
8000fd7a:	02f11723          	sh	a5,46(sp)
        if ( pData )
8000fd7e:	4792                	lw	a5,4(sp)
8000fd80:	0e078863          	beqz	a5,8000fe70 <.L47>
            OBJTOMBXSTRCPY( pData, pDesc, strSize );
8000fd84:	02e15783          	lhu	a5,46(sp)
8000fd88:	863e                	mv	a2,a5
8000fd8a:	5592                	lw	a1,36(sp)
8000fd8c:	4512                	lw	a0,4(sp)
8000fd8e:	ecffd0ef          	jal	8000dc5c <memcpy>
        if ( pData )
8000fd92:	a8f9                	j	8000fe70 <.L47>

8000fd94 <.L45>:
        if ( objCode == OBJCODE_REC )
8000fd94:	02314703          	lbu	a4,35(sp)
8000fd98:	47a5                	li	a5,9
8000fd9a:	08f71e63          	bne	a4,a5,8000fe36 <.L48>

8000fd9e <.LBB7>:
            UINT16 i = 1;
8000fd9e:	4785                	li	a5,1
8000fda0:	02f11623          	sh	a5,44(sp)
            UINT16 tmpSubindex = subindex;
8000fda4:	00d14783          	lbu	a5,13(sp)
8000fda8:	02f11023          	sh	a5,32(sp)

8000fdac <.LBB8>:
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
8000fdac:	5512                	lw	a0,36(sp)
8000fdae:	10d030ef          	jal	800136ba <strlen>
8000fdb2:	87aa                	mv	a5,a0
8000fdb4:	0785                	add	a5,a5,1
8000fdb6:	5712                	lw	a4,36(sp)
8000fdb8:	97ba                	add	a5,a5,a4
8000fdba:	d43e                	sw	a5,40(sp)
            while (( i <= tmpSubindex )
8000fdbc:	a0b9                	j	8000fe0a <.L49>

8000fdbe <.L52>:
                if ( i == tmpSubindex )
8000fdbe:	02c15703          	lhu	a4,44(sp)
8000fdc2:	02015783          	lhu	a5,32(sp)
8000fdc6:	02f71563          	bne	a4,a5,8000fdf0 <.L50>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
8000fdca:	5522                	lw	a0,40(sp)
8000fdcc:	0ef030ef          	jal	800136ba <strlen>
8000fdd0:	87aa                	mv	a5,a0
8000fdd2:	02f11723          	sh	a5,46(sp)
                    if ( pData && strSize )
8000fdd6:	4792                	lw	a5,4(sp)
8000fdd8:	cfb1                	beqz	a5,8000fe34 <.L54>
8000fdda:	02e15783          	lhu	a5,46(sp)
8000fdde:	cbb9                	beqz	a5,8000fe34 <.L54>
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
8000fde0:	02e15783          	lhu	a5,46(sp)
8000fde4:	863e                	mv	a2,a5
8000fde6:	55a2                	lw	a1,40(sp)
8000fde8:	4512                	lw	a0,4(sp)
8000fdea:	e73fd0ef          	jal	8000dc5c <memcpy>
                    break;
8000fdee:	a099                	j	8000fe34 <.L54>

8000fdf0 <.L50>:
                    i++;
8000fdf0:	02c15783          	lhu	a5,44(sp)
8000fdf4:	0785                	add	a5,a5,1
8000fdf6:	02f11623          	sh	a5,44(sp)
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
8000fdfa:	5522                	lw	a0,40(sp)
8000fdfc:	0bf030ef          	jal	800136ba <strlen>
8000fe00:	87aa                	mv	a5,a0
8000fe02:	0785                	add	a5,a5,1
8000fe04:	5722                	lw	a4,40(sp)
8000fe06:	97ba                	add	a5,a5,a4
8000fe08:	d43e                	sw	a5,40(sp)

8000fe0a <.L49>:
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
8000fe0a:	02c15703          	lhu	a4,44(sp)
8000fe0e:	02015783          	lhu	a5,32(sp)
8000fe12:	02e7e263          	bltu	a5,a4,8000fe36 <.L48>
8000fe16:	57a2                	lw	a5,40(sp)
8000fe18:	0007c703          	lbu	a4,0(a5)
8000fe1c:	0ff00793          	li	a5,255
8000fe20:	00f70b63          	beq	a4,a5,8000fe36 <.L48>
8000fe24:	57a2                	lw	a5,40(sp)
8000fe26:	0007c703          	lbu	a4,0(a5)
8000fe2a:	0fe00793          	li	a5,254
8000fe2e:	f8f718e3          	bne	a4,a5,8000fdbe <.L52>
8000fe32:	a011                	j	8000fe36 <.L48>

8000fe34 <.L54>:
                    break;
8000fe34:	0001                	nop

8000fe36 <.L48>:
        if ( strSize == 0 )
8000fe36:	02e15783          	lhu	a5,46(sp)
8000fe3a:	eb9d                	bnez	a5,8000fe70 <.L47>
            strSize =    12;
8000fe3c:	47b1                	li	a5,12
8000fe3e:	02f11723          	sh	a5,46(sp)
            if ( pData )
8000fe42:	4792                	lw	a5,4(sp)
8000fe44:	c795                	beqz	a5,8000fe70 <.L47>

8000fe46 <.LBB9>:
                MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
8000fe46:	0818                	add	a4,sp,16
8000fe48:	4635                	li	a2,13
8000fe4a:	34820593          	add	a1,tp,840 # 348 <default_isr_62+0x52>
8000fe4e:	853a                	mv	a0,a4
8000fe50:	e0dfd0ef          	jal	8000dc5c <memcpy>
                OBJ_CopyNumberToString( &TmpDescr[9], subindex );
8000fe54:	00d14703          	lbu	a4,13(sp)
8000fe58:	081c                	add	a5,sp,16
8000fe5a:	07a5                	add	a5,a5,9
8000fe5c:	85ba                	mv	a1,a4
8000fe5e:	853e                	mv	a0,a5
8000fe60:	d3bf90ef          	jal	80009b9a <OBJ_CopyNumberToString>
                MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
8000fe64:	081c                	add	a5,sp,16
8000fe66:	4635                	li	a2,13
8000fe68:	85be                	mv	a1,a5
8000fe6a:	4512                	lw	a0,4(sp)
8000fe6c:	df1fd0ef          	jal	8000dc5c <memcpy>

8000fe70 <.L47>:
    return strSize;
8000fe70:	02e15783          	lhu	a5,46(sp)
}
8000fe74:	853e                	mv	a0,a5
8000fe76:	50f2                	lw	ra,60(sp)
8000fe78:	6121                	add	sp,sp,64
8000fe7a:	8082                	ret

Disassembly of section .text.OBJ_GetEntryOffset:

8000fe7c <OBJ_GetEntryOffset>:
{
8000fe7c:	1101                	add	sp,sp,-32
8000fe7e:	87aa                	mv	a5,a0
8000fe80:	c42e                	sw	a1,8(sp)
8000fe82:	00f107a3          	sb	a5,15(sp)
    UINT16 bitOffset = 0;
8000fe86:	00011e23          	sh	zero,28(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
8000fe8a:	47a2                	lw	a5,8(sp)
8000fe8c:	00c7d783          	lhu	a5,12(a5)
8000fe90:	87a1                	sra	a5,a5,0x8
8000fe92:	0ff7f793          	zext.b	a5,a5
8000fe96:	8bbd                	and	a5,a5,15
8000fe98:	00f10ba3          	sb	a5,23(sp)
    if(subindex > 0)
8000fe9c:	00f14783          	lbu	a5,15(sp)
8000fea0:	c791                	beqz	a5,8000feac <.L63>
        bitOffset +=16;
8000fea2:	01c15783          	lhu	a5,28(sp)
8000fea6:	07c1                	add	a5,a5,16
8000fea8:	00f11e23          	sh	a5,28(sp)

8000feac <.L63>:
    if (objCode == OBJCODE_VAR)
8000feac:	01714703          	lbu	a4,23(sp)
8000feb0:	479d                	li	a5,7
8000feb2:	00f71463          	bne	a4,a5,8000feba <.L64>
        return 0;
8000feb6:	4781                	li	a5,0
8000feb8:	ac1d                	j	800100ee <.L65>

8000feba <.L64>:
    for (i = 1; i <= subindex; i++)
8000feba:	4785                	li	a5,1
8000febc:	00f11f23          	sh	a5,30(sp)
8000fec0:	ac29                	j	800100da <.L66>

8000fec2 <.L85>:
        if ((objCode == OBJCODE_ARR)
8000fec2:	01714703          	lbu	a4,23(sp)
8000fec6:	47a1                	li	a5,8
8000fec8:	00f71763          	bne	a4,a5,8000fed6 <.L67>
            pEntry = &pObjEntry->pEntryDesc[1];
8000fecc:	47a2                	lw	a5,8(sp)
8000fece:	4b9c                	lw	a5,16(a5)
8000fed0:	0799                	add	a5,a5,6
8000fed2:	cc3e                	sw	a5,24(sp)
8000fed4:	a819                	j	8000feea <.L68>

8000fed6 <.L67>:
            pEntry = &pObjEntry->pEntryDesc[i];
8000fed6:	47a2                	lw	a5,8(sp)
8000fed8:	4b94                	lw	a3,16(a5)
8000feda:	01e15703          	lhu	a4,30(sp)
8000fede:	87ba                	mv	a5,a4
8000fee0:	0786                	sll	a5,a5,0x1
8000fee2:	97ba                	add	a5,a5,a4
8000fee4:	0786                	sll	a5,a5,0x1
8000fee6:	97b6                	add	a5,a5,a3
8000fee8:	cc3e                	sw	a5,24(sp)

8000feea <.L68>:
        switch (pEntry->DataType)
8000feea:	47e2                	lw	a5,24(sp)
8000feec:	0007c703          	lbu	a4,0(a5)
8000fef0:	0017c783          	lbu	a5,1(a5)
8000fef4:	07a2                	sll	a5,a5,0x8
8000fef6:	8fd9                	or	a5,a5,a4
8000fef8:	0807c7b3          	zext.h	a5,a5
8000fefc:	26300713          	li	a4,611
8000ff00:	18f74a63          	blt	a4,a5,80010094 <.L69>
8000ff04:	26200713          	li	a4,610
8000ff08:	0ee7df63          	bge	a5,a4,80010006 <.L70>
8000ff0c:	26000713          	li	a4,608
8000ff10:	08e78563          	beq	a5,a4,8000ff9a <.L71>
8000ff14:	26000713          	li	a4,608
8000ff18:	16f74e63          	blt	a4,a5,80010094 <.L69>
8000ff1c:	472d                	li	a4,11
8000ff1e:	06f74663          	blt	a4,a5,8000ff8a <.L72>
8000ff22:	470d                	li	a4,3
8000ff24:	04e7d063          	bge	a5,a4,8000ff64 <.L73>
8000ff28:	a2b5                	j	80010094 <.L69>

8000ff2a <.L75>:
8000ff2a:	17bd                	add	a5,a5,-17
8000ff2c:	4705                	li	a4,1
8000ff2e:	00f717b3          	sll	a5,a4,a5
8000ff32:	4117f713          	and	a4,a5,1041
8000ff36:	00e03733          	snez	a4,a4
8000ff3a:	0ff77713          	zext.b	a4,a4
8000ff3e:	12071c63          	bnez	a4,80010076 <.L74>
8000ff42:	40008737          	lui	a4,0x40008
8000ff46:	8f7d                	and	a4,a4,a5
8000ff48:	00e03733          	snez	a4,a4
8000ff4c:	0ff77713          	zext.b	a4,a4
8000ff50:	eb5d                	bnez	a4,80010006 <.L70>
8000ff52:	20004737          	lui	a4,0x20004
8000ff56:	8ff9                	and	a5,a5,a4
8000ff58:	00f037b3          	snez	a5,a5
8000ff5c:	0ff7f793          	zext.b	a5,a5
8000ff60:	ef8d                	bnez	a5,8000ff9a <.L71>
8000ff62:	aa0d                	j	80010094 <.L69>

8000ff64 <.L73>:
8000ff64:	17f5                	add	a5,a5,-3
8000ff66:	4705                	li	a4,1
8000ff68:	00f717b3          	sll	a5,a4,a5
8000ff6c:	0327f713          	and	a4,a5,50
8000ff70:	00e03733          	snez	a4,a4
8000ff74:	0ff77713          	zext.b	a4,a4
8000ff78:	e759                	bnez	a4,80010006 <.L70>
8000ff7a:	1097f793          	and	a5,a5,265
8000ff7e:	00f037b3          	snez	a5,a5
8000ff82:	0ff7f793          	zext.b	a5,a5
8000ff86:	eb91                	bnez	a5,8000ff9a <.L71>
8000ff88:	a231                	j	80010094 <.L69>

8000ff8a <.L72>:
8000ff8a:	02f00713          	li	a4,47
8000ff8e:	10f74363          	blt	a4,a5,80010094 <.L69>
8000ff92:	4745                	li	a4,17
8000ff94:	f8e7dbe3          	bge	a5,a4,8000ff2a <.L75>
8000ff98:	a8f5                	j	80010094 <.L69>

8000ff9a <.L71>:
            if (i < subindex)
8000ff9a:	00f14783          	lbu	a5,15(sp)
8000ff9e:	0807c7b3          	zext.h	a5,a5
8000ffa2:	01e15703          	lhu	a4,30(sp)
8000ffa6:	10f77e63          	bgeu	a4,a5,800100c2 <.L86>
                if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
8000ffaa:	47e2                	lw	a5,24(sp)
8000ffac:	0007c703          	lbu	a4,0(a5)
8000ffb0:	0017c783          	lbu	a5,1(a5)
8000ffb4:	07a2                	sll	a5,a5,0x8
8000ffb6:	8fd9                	or	a5,a5,a4
8000ffb8:	0807c733          	zext.h	a4,a5
8000ffbc:	47ad                	li	a5,11
8000ffbe:	00f70f63          	beq	a4,a5,8000ffdc <.L77>
                    ||(pEntry->DataType == DEFTYPE_ARRAY_OF_INT))
8000ffc2:	47e2                	lw	a5,24(sp)
8000ffc4:	0007c703          	lbu	a4,0(a5)
8000ffc8:	0017c783          	lbu	a5,1(a5)
8000ffcc:	07a2                	sll	a5,a5,0x8
8000ffce:	8fd9                	or	a5,a5,a4
8000ffd0:	0807c733          	zext.h	a4,a5
8000ffd4:	26000793          	li	a5,608
8000ffd8:	02f71163          	bne	a4,a5,8000fffa <.L78>

8000ffdc <.L77>:
                    bitOffset += pEntry->BitLength;
8000ffdc:	47e2                	lw	a5,24(sp)
8000ffde:	0027c703          	lbu	a4,2(a5)
8000ffe2:	0037c783          	lbu	a5,3(a5)
8000ffe6:	07a2                	sll	a5,a5,0x8
8000ffe8:	8fd9                	or	a5,a5,a4
8000ffea:	0807c7b3          	zext.h	a5,a5
8000ffee:	01c15703          	lhu	a4,28(sp)
8000fff2:	97ba                	add	a5,a5,a4
8000fff4:	00f11e23          	sh	a5,28(sp)
            break;
8000fff8:	a0e9                	j	800100c2 <.L86>

8000fffa <.L78>:
                    bitOffset += 16;
8000fffa:	01c15783          	lhu	a5,28(sp)
8000fffe:	07c1                	add	a5,a5,16
80010000:	00f11e23          	sh	a5,28(sp)
            break;
80010004:	a87d                	j	800100c2 <.L86>

80010006 <.L70>:
            if (i < subindex)
80010006:	00f14783          	lbu	a5,15(sp)
8001000a:	0807c7b3          	zext.h	a5,a5
8001000e:	01e15703          	lhu	a4,30(sp)
80010012:	0af77a63          	bgeu	a4,a5,800100c6 <.L87>
                if((pEntry->DataType == DEFTYPE_ARRAY_OF_DINT)
80010016:	47e2                	lw	a5,24(sp)
80010018:	0007c703          	lbu	a4,0(a5)
8001001c:	0017c783          	lbu	a5,1(a5)
80010020:	07a2                	sll	a5,a5,0x8
80010022:	8fd9                	or	a5,a5,a4
80010024:	0807c733          	zext.h	a4,a5
80010028:	26200793          	li	a5,610
8001002c:	00f70f63          	beq	a4,a5,8001004a <.L81>
                    ||(pEntry->DataType == DEFTYPE_ARRAY_OF_UDINT))
80010030:	47e2                	lw	a5,24(sp)
80010032:	0007c703          	lbu	a4,0(a5)
80010036:	0017c783          	lbu	a5,1(a5)
8001003a:	07a2                	sll	a5,a5,0x8
8001003c:	8fd9                	or	a5,a5,a4
8001003e:	0807c733          	zext.h	a4,a5
80010042:	26300793          	li	a5,611
80010046:	02f71163          	bne	a4,a5,80010068 <.L82>

8001004a <.L81>:
                    bitOffset += pEntry->BitLength;
8001004a:	47e2                	lw	a5,24(sp)
8001004c:	0027c703          	lbu	a4,2(a5)
80010050:	0037c783          	lbu	a5,3(a5)
80010054:	07a2                	sll	a5,a5,0x8
80010056:	8fd9                	or	a5,a5,a4
80010058:	0807c7b3          	zext.h	a5,a5
8001005c:	01c15703          	lhu	a4,28(sp)
80010060:	97ba                	add	a5,a5,a4
80010062:	00f11e23          	sh	a5,28(sp)
            break;
80010066:	a085                	j	800100c6 <.L87>

80010068 <.L82>:
                   bitOffset += 32;
80010068:	01c15783          	lhu	a5,28(sp)
8001006c:	02078793          	add	a5,a5,32
80010070:	00f11e23          	sh	a5,28(sp)
            break;
80010074:	a889                	j	800100c6 <.L87>

80010076 <.L74>:
            if (i < subindex)
80010076:	00f14783          	lbu	a5,15(sp)
8001007a:	0807c7b3          	zext.h	a5,a5
8001007e:	01e15703          	lhu	a4,30(sp)
80010082:	04f77463          	bgeu	a4,a5,800100ca <.L88>
                bitOffset += 64;
80010086:	01c15783          	lhu	a5,28(sp)
8001008a:	04078793          	add	a5,a5,64
8001008e:	00f11e23          	sh	a5,28(sp)
            break;
80010092:	a825                	j	800100ca <.L88>

80010094 <.L69>:
            if (i < subindex)
80010094:	00f14783          	lbu	a5,15(sp)
80010098:	0807c7b3          	zext.h	a5,a5
8001009c:	01e15703          	lhu	a4,30(sp)
800100a0:	02f77763          	bgeu	a4,a5,800100ce <.L89>
                bitOffset += pEntry->BitLength;
800100a4:	47e2                	lw	a5,24(sp)
800100a6:	0027c703          	lbu	a4,2(a5)
800100aa:	0037c783          	lbu	a5,3(a5)
800100ae:	07a2                	sll	a5,a5,0x8
800100b0:	8fd9                	or	a5,a5,a4
800100b2:	0807c7b3          	zext.h	a5,a5
800100b6:	01c15703          	lhu	a4,28(sp)
800100ba:	97ba                	add	a5,a5,a4
800100bc:	00f11e23          	sh	a5,28(sp)
            break;
800100c0:	a039                	j	800100ce <.L89>

800100c2 <.L86>:
            break;
800100c2:	0001                	nop
800100c4:	a031                	j	800100d0 <.L79>

800100c6 <.L87>:
            break;
800100c6:	0001                	nop
800100c8:	a021                	j	800100d0 <.L79>

800100ca <.L88>:
            break;
800100ca:	0001                	nop
800100cc:	a011                	j	800100d0 <.L79>

800100ce <.L89>:
            break;
800100ce:	0001                	nop

800100d0 <.L79>:
    for (i = 1; i <= subindex; i++)
800100d0:	01e15783          	lhu	a5,30(sp)
800100d4:	0785                	add	a5,a5,1
800100d6:	00f11f23          	sh	a5,30(sp)

800100da <.L66>:
800100da:	00f14783          	lbu	a5,15(sp)
800100de:	0807c7b3          	zext.h	a5,a5
800100e2:	01e15703          	lhu	a4,30(sp)
800100e6:	dce7fee3          	bgeu	a5,a4,8000fec2 <.L85>
    return bitOffset;
800100ea:	01c15783          	lhu	a5,28(sp)

800100ee <.L65>:
}
800100ee:	853e                	mv	a0,a5
800100f0:	6105                	add	sp,sp,32
800100f2:	8082                	ret

Disassembly of section .text.CheckSyncTypeValue:

800100f4 <CheckSyncTypeValue>:
{
800100f4:	1141                	add	sp,sp,-16
800100f6:	87aa                	mv	a5,a0
800100f8:	872e                	mv	a4,a1
800100fa:	00f11723          	sh	a5,14(sp)
800100fe:	87ba                	mv	a5,a4
80010100:	00f11623          	sh	a5,12(sp)
    switch (NewSyncType)
80010104:	00c15783          	lhu	a5,12(sp)
80010108:	02200713          	li	a4,34
8001010c:	12f76063          	bltu	a4,a5,8001022c <.L91>
80010110:	00279713          	sll	a4,a5,0x2
80010114:	800057b7          	lui	a5,0x80005
80010118:	f6078793          	add	a5,a5,-160 # 80004f60 <.L93>
8001011c:	97ba                	add	a5,a5,a4
8001011e:	439c                	lw	a5,0(a5)
80010120:	8782                	jr	a5

80010122 <.L97>:
        return 0; //free run sync mode is always accepted
80010122:	4781                	li	a5,0
80010124:	a229                	j	8001022e <.L98>

80010126 <.L96>:
        if ((index == 0x1C32) 
80010126:	00e15703          	lhu	a4,14(sp)
8001012a:	6789                	lui	a5,0x2
8001012c:	c3278793          	add	a5,a5,-974 # 1c32 <__ILM_segment_used_end__+0x8c>
80010130:	00f71e63          	bne	a4,a5,8001014c <.L99>
            && (nPdOutputSize > 0) 
80010134:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80010138:	cb91                	beqz	a5,8001014c <.L99>
            && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
8001013a:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
8001013e:	00c7d783          	lhu	a5,12(a5)
80010142:	8b89                	and	a5,a5,2
80010144:	00f05463          	blez	a5,8001014c <.L99>
            return 0;
80010148:	4781                	li	a5,0
8001014a:	a0d5                	j	8001022e <.L98>

8001014c <.L99>:
        if ((index == 0x1C33) 
8001014c:	00e15703          	lhu	a4,14(sp)
80010150:	6789                	lui	a5,0x2
80010152:	c3378793          	add	a5,a5,-973 # 1c33 <__ILM_segment_used_end__+0x8d>
80010156:	0cf71463          	bne	a4,a5,8001021e <.L106>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
8001015a:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8001015e:	00c7d783          	lhu	a5,12(a5)
80010162:	8b89                	and	a5,a5,2
80010164:	0af05d63          	blez	a5,8001021e <.L106>
            && (nPdOutputSize == 0) 
80010168:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
8001016c:	ebcd                	bnez	a5,8001021e <.L106>
            && (nPdInputSize > 0))
8001016e:	1641d783          	lhu	a5,356(gp) # 12094dc <nPdInputSize>
80010172:	c7d5                	beqz	a5,8001021e <.L106>
                return 0;
80010174:	4781                	li	a5,0
80010176:	a865                	j	8001022e <.L98>

80010178 <.L92>:
        if ((index == 0x1C33) 
80010178:	00e15703          	lhu	a4,14(sp)
8001017c:	6789                	lui	a5,0x2
8001017e:	c3378793          	add	a5,a5,-973 # 1c33 <__ILM_segment_used_end__+0x8d>
80010182:	0af71063          	bne	a4,a5,80010222 <.L107>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
80010186:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
8001018a:	00c7d783          	lhu	a5,12(a5)
8001018e:	8b89                	and	a5,a5,2
80010190:	08f05963          	blez	a5,80010222 <.L107>
            && (nPdOutputSize > 0))
80010194:	1621d783          	lhu	a5,354(gp) # 12094da <nPdOutputSize>
80010198:	c7c9                	beqz	a5,80010222 <.L107>
                return 0;
8001019a:	4781                	li	a5,0
8001019c:	a849                	j	8001022e <.L98>

8001019e <.L95>:
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
8001019e:	00e15703          	lhu	a4,14(sp)
800101a2:	6789                	lui	a5,0x2
800101a4:	c3278793          	add	a5,a5,-974 # 1c32 <__ILM_segment_used_end__+0x8c>
800101a8:	00f71b63          	bne	a4,a5,800101be <.L102>
800101ac:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800101b0:	00c7d783          	lhu	a5,12(a5)
800101b4:	8b91                	and	a5,a5,4
800101b6:	00f05463          	blez	a5,800101be <.L102>
            return 0;
800101ba:	4781                	li	a5,0
800101bc:	a88d                	j	8001022e <.L98>

800101be <.L102>:
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
800101be:	00e15703          	lhu	a4,14(sp)
800101c2:	6789                	lui	a5,0x2
800101c4:	c3378793          	add	a5,a5,-973 # 1c33 <__ILM_segment_used_end__+0x8d>
800101c8:	04f71f63          	bne	a4,a5,80010226 <.L108>
800101cc:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
800101d0:	00c7d783          	lhu	a5,12(a5)
800101d4:	8b91                	and	a5,a5,4
800101d6:	04f05863          	blez	a5,80010226 <.L108>
            return 0;
800101da:	4781                	li	a5,0
800101dc:	a889                	j	8001022e <.L98>

800101de <.L94>:
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
800101de:	00e15703          	lhu	a4,14(sp)
800101e2:	6789                	lui	a5,0x2
800101e4:	c3278793          	add	a5,a5,-974 # 1c32 <__ILM_segment_used_end__+0x8c>
800101e8:	00f71b63          	bne	a4,a5,800101fe <.L104>
800101ec:	f8018793          	add	a5,gp,-128 # 12092f8 <sSyncManOutPar>
800101f0:	00c7d783          	lhu	a5,12(a5)
800101f4:	8ba1                	and	a5,a5,8
800101f6:	00f05463          	blez	a5,800101fe <.L104>
            return 0;
800101fa:	4781                	li	a5,0
800101fc:	a80d                	j	8001022e <.L98>

800101fe <.L104>:
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
800101fe:	00e15703          	lhu	a4,14(sp)
80010202:	6789                	lui	a5,0x2
80010204:	c3378793          	add	a5,a5,-973 # 1c33 <__ILM_segment_used_end__+0x8d>
80010208:	02f71163          	bne	a4,a5,8001022a <.L109>
8001020c:	fc018793          	add	a5,gp,-64 # 1209338 <sSyncManInPar>
80010210:	00c7d783          	lhu	a5,12(a5)
80010214:	8ba1                	and	a5,a5,8
80010216:	00f05a63          	blez	a5,8001022a <.L109>
            return 0;
8001021a:	4781                	li	a5,0
8001021c:	a809                	j	8001022e <.L98>

8001021e <.L106>:
        break;
8001021e:	0001                	nop
80010220:	a031                	j	8001022c <.L91>

80010222 <.L107>:
        break;
80010222:	0001                	nop
80010224:	a021                	j	8001022c <.L91>

80010226 <.L108>:
        break;
80010226:	0001                	nop
80010228:	a011                	j	8001022c <.L91>

8001022a <.L109>:
        break;
8001022a:	0001                	nop

8001022c <.L91>:
    return ABORTIDX_VALUE_EXCEEDED;
8001022c:	47c9                	li	a5,18

8001022e <.L98>:
}
8001022e:	853e                	mv	a0,a5
80010230:	0141                	add	sp,sp,16
80010232:	8082                	ret

Disassembly of section .text.SdoDownloadSegmentInd:

80010234 <SdoDownloadSegmentInd>:
{
80010234:	7179                	add	sp,sp,-48
80010236:	d606                	sw	ra,44(sp)
80010238:	c62a                	sw	a0,12(sp)
	UINT8 abort = 0;
8001023a:	00010fa3          	sb	zero,31(sp)
	UINT32 bytesToSave = 0;
8001023e:	cc02                	sw	zero,24(sp)
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
80010240:	47b2                	lw	a5,12(sp)
80010242:	0087c783          	lbu	a5,8(a5)
80010246:	8bc1                	and	a5,a5,16
80010248:	1911c703          	lbu	a4,401(gp) # 1209509 <bSdoSegLastToggle>
8001024c:	00e79663          	bne	a5,a4,80010258 <.L2>
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
80010250:	4785                	li	a5,1
80010252:	00f10fa3          	sb	a5,31(sp)
80010256:	a279                	j	800103e4 <.L3>

80010258 <.L2>:
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
80010258:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
8001025c:	17dd                	add	a5,a5,-9
8001025e:	00f11b23          	sh	a5,22(sp)
		bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
80010262:	47b2                	lw	a5,12(sp)
80010264:	0087c783          	lbu	a5,8(a5)
80010268:	8bc1                	and	a5,a5,16
8001026a:	0ff7f713          	zext.b	a4,a5
8001026e:	18e188a3          	sb	a4,401(gp) # 1209509 <bSdoSegLastToggle>
		if (pSdoSegData)
80010272:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
80010276:	16078463          	beqz	a5,800103de <.L4>
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
8001027a:	10c1a703          	lw	a4,268(gp) # 1209484 <nSdoSegCompleteSize>
8001027e:	1101a783          	lw	a5,272(gp) # 1209488 <nSdoSegBytesToHandle>
80010282:	40f707b3          	sub	a5,a4,a5
80010286:	cc3e                	sw	a5,24(sp)
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
80010288:	47b2                	lw	a5,12(sp)
8001028a:	0087c783          	lbu	a5,8(a5)
8001028e:	8b85                	and	a5,a5,1
80010290:	cbb5                	beqz	a5,80010304 <.L5>
				if (bytesToSave <= maxData)
80010292:	01615783          	lhu	a5,22(sp)
80010296:	4762                	lw	a4,24(sp)
80010298:	06e7e263          	bltu	a5,a4,800102fc <.L6>

8001029c <.LBB3>:
					UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
8001029c:	47b2                	lw	a5,12(sp)
8001029e:	0007c703          	lbu	a4,0(a5)
800102a2:	0017c783          	lbu	a5,1(a5)
800102a6:	07a2                	sll	a5,a5,0x8
800102a8:	8fd9                	or	a5,a5,a4
800102aa:	00f11a23          	sh	a5,20(sp)
					if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
800102ae:	01415783          	lhu	a5,20(sp)
800102b2:	17f5                	add	a5,a5,-3
800102b4:	873e                	mv	a4,a5
800102b6:	47e2                	lw	a5,24(sp)
800102b8:	02f76063          	bltu	a4,a5,800102d8 <.L7>
						&& (bytesToSave == ((UINT16)(MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))))
800102bc:	47b2                	lw	a5,12(sp)
800102be:	0087c783          	lbu	a5,8(a5)
800102c2:	8785                	sra	a5,a5,0x1
800102c4:	0807c7b3          	zext.h	a5,a5
800102c8:	fff7c793          	not	a5,a5
800102cc:	0807c7b3          	zext.h	a5,a5
800102d0:	8b9d                	and	a5,a5,7
800102d2:	4762                	lw	a4,24(sp)
800102d4:	00f70d63          	beq	a4,a5,800102ee <.L8>

800102d8 <.L7>:
						|| ((bytesToSave > MIN_SEGMENTED_DATA)
800102d8:	4762                	lw	a4,24(sp)
800102da:	479d                	li	a5,7
800102dc:	00e7fc63          	bgeu	a5,a4,800102f4 <.L9>
							&& (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
800102e0:	01415783          	lhu	a5,20(sp)
800102e4:	ffd78713          	add	a4,a5,-3
800102e8:	47e2                	lw	a5,24(sp)
800102ea:	00f71563          	bne	a4,a5,800102f4 <.L9>

800102ee <.L8>:
						bSdoSegFollows = FALSE;
800102ee:	18018923          	sb	zero,402(gp) # 120950a <bSdoSegFollows>
800102f2:	a805                	j	80010322 <.L11>

800102f4 <.L9>:
						abort = ABORTIDX_PARAM_LENGTH_ERROR;
800102f4:	47b9                	li	a5,14
800102f6:	00f10fa3          	sb	a5,31(sp)
800102fa:	a025                	j	80010322 <.L11>

800102fc <.L6>:
					abort = ABORTIDX_PARAM_LENGTH_ERROR;
800102fc:	47b9                	li	a5,14
800102fe:	00f10fa3          	sb	a5,31(sp)
80010302:	a005                	j	80010322 <.L11>

80010304 <.L5>:
				bSdoSegFollows = TRUE;
80010304:	4705                	li	a4,1
80010306:	18e18923          	sb	a4,402(gp) # 120950a <bSdoSegFollows>
				if (bytesToSave <= maxData)
8001030a:	01615783          	lhu	a5,22(sp)
8001030e:	4762                	lw	a4,24(sp)
80010310:	00e7e663          	bltu	a5,a4,8001031c <.L12>
					abort = ABORTIDX_PARAM_LENGTH_ERROR;
80010314:	47b9                	li	a5,14
80010316:	00f10fa3          	sb	a5,31(sp)
8001031a:	a021                	j	80010322 <.L11>

8001031c <.L12>:
					bytesToSave = maxData;
8001031c:	01615783          	lhu	a5,22(sp)
80010320:	cc3e                	sw	a5,24(sp)

80010322 <.L11>:
			if (abort == 0)
80010322:	01f14783          	lbu	a5,31(sp)
80010326:	0a079f63          	bnez	a5,800103e4 <.L3>
				MBXMEMCPY(((UINT8*)pSdoSegData) + (nSdoSegBytesToHandle), pSdoInd->SdoHeader.Data, bytesToSave);
8001032a:	0d41a703          	lw	a4,212(gp) # 120944c <pSdoSegData>
8001032e:	1101a783          	lw	a5,272(gp) # 1209488 <nSdoSegBytesToHandle>
80010332:	973e                	add	a4,a4,a5
80010334:	47b2                	lw	a5,12(sp)
80010336:	07a5                	add	a5,a5,9
80010338:	4662                	lw	a2,24(sp)
8001033a:	85be                	mv	a1,a5
8001033c:	853a                	mv	a0,a4
8001033e:	91ffd0ef          	jal	8000dc5c <memcpy>
				if (bSdoSegFollows == FALSE)
80010342:	1921c783          	lbu	a5,402(gp) # 120950a <bSdoSegFollows>
80010346:	08079f63          	bnez	a5,800103e4 <.L3>
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
8001034a:	15c1d503          	lhu	a0,348(gp) # 12094d4 <nSdoSegIndex>
8001034e:	1881c583          	lbu	a1,392(gp) # 1209500 <nSdoSegSubindex>
80010352:	10c1a603          	lw	a2,268(gp) # 1209484 <nSdoSegCompleteSize>
80010356:	0d01a683          	lw	a3,208(gp) # 1209448 <pSdoSegObjEntry>
8001035a:	0d41a703          	lw	a4,212(gp) # 120944c <pSdoSegData>
8001035e:	1931c783          	lbu	a5,403(gp) # 120950b <bSdoSegAccess>
80010362:	94afa0ef          	jal	8000a4ac <OBJ_Write>
80010366:	87aa                	mv	a5,a0
80010368:	00f10fa3          	sb	a5,31(sp)
					if (abort == ABORTIDX_WORKING)
8001036c:	01f14703          	lbu	a4,31(sp)
80010370:	0ff00793          	li	a5,255
80010374:	04f71d63          	bne	a4,a5,800103ce <.L13>
						u8PendingSdo = SDO_PENDING_SEG_WRITE;
80010378:	4709                	li	a4,2
8001037a:	36e207a3          	sb	a4,879(tp) # 36f <default_isr_62+0x79>
						bStoreCompleteAccess = bSdoSegAccess;
8001037e:	1931c703          	lbu	a4,403(gp) # 120950b <bSdoSegAccess>
80010382:	18e18723          	sb	a4,398(gp) # 1209506 <bStoreCompleteAccess>
						u8StoreSubindex = nSdoSegSubindex;
80010386:	1881c703          	lbu	a4,392(gp) # 1209500 <nSdoSegSubindex>
8001038a:	34e20aa3          	sb	a4,853(tp) # 355 <default_isr_62+0x5f>
						u16StoreIndex = nSdoSegIndex;
8001038e:	15c1d703          	lhu	a4,348(gp) # 12094d4 <nSdoSegIndex>
80010392:	34e21323          	sh	a4,838(tp) # 346 <default_isr_62+0x50>
						u32StoreDataSize = nSdoSegCompleteSize;
80010396:	10c1a703          	lw	a4,268(gp) # 1209484 <nSdoSegCompleteSize>
8001039a:	0ae1a023          	sw	a4,160(gp) # 1209418 <u32StoreDataSize>
						pStoreData = pSdoSegData;
8001039e:	0d41a703          	lw	a4,212(gp) # 120944c <pSdoSegData>
800103a2:	0ce1a623          	sw	a4,204(gp) # 1209444 <pStoreData>
						pSdoPendFunc = pSdoSegObjEntry->Write;
800103a6:	0d01a783          	lw	a5,208(gp) # 1209448 <pSdoSegObjEntry>
800103aa:	5398                	lw	a4,32(a5)
800103ac:	0ce1ae23          	sw	a4,220(gp) # 1209454 <pSdoPendFunc>
						bSdoInWork = TRUE;
800103b0:	4705                	li	a4,1
800103b2:	18e18a23          	sb	a4,404(gp) # 120950c <bSdoInWork>
						pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
800103b6:	4732                	lw	a4,12(sp)
800103b8:	0ce1ac23          	sw	a4,216(gp) # 1209450 <pSdoResStored>
						bSdoSegFollows = FALSE;
800103bc:	18018923          	sb	zero,402(gp) # 120950a <bSdoSegFollows>
						nSdoSegService = 0;
800103c0:	180184a3          	sb	zero,393(gp) # 1209501 <nSdoSegService>
						nSdoSegBytesToHandle = 0;
800103c4:	1001a823          	sw	zero,272(gp) # 1209488 <nSdoSegBytesToHandle>
						return ABORTIDX_WORKING;
800103c8:	0ff00793          	li	a5,255
800103cc:	aa21                	j	800104e4 <.L14>

800103ce <.L13>:
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
800103ce:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
800103d2:	853e                	mv	a0,a5
800103d4:	492040ef          	jal	80014866 <free>
						pSdoSegData = NULL;
800103d8:	0c01aa23          	sw	zero,212(gp) # 120944c <pSdoSegData>
800103dc:	a021                	j	800103e4 <.L3>

800103de <.L4>:
			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
800103de:	478d                	li	a5,3
800103e0:	00f10fa3          	sb	a5,31(sp)

800103e4 <.L3>:
	if (abort == 0)
800103e4:	01f14783          	lbu	a5,31(sp)
800103e8:	efe1                	bnez	a5,800104c0 <.L15>
		pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
800103ea:	47b2                	lw	a5,12(sp)
800103ec:	0007c703          	lbu	a4,0(a5)
800103f0:	8b01                	and	a4,a4,0
800103f2:	00a76713          	or	a4,a4,10
800103f6:	00e78023          	sb	a4,0(a5)
800103fa:	0017c703          	lbu	a4,1(a5)
800103fe:	8b01                	and	a4,a4,0
80010400:	00e780a3          	sb	a4,1(a5)
		pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
80010404:	47b2                	lw	a5,12(sp)
80010406:	0067c703          	lbu	a4,6(a5)
8001040a:	0077c783          	lbu	a5,7(a5)
8001040e:	07a2                	sll	a5,a5,0x8
80010410:	8fd9                	or	a5,a5,a4
80010412:	0807c733          	zext.h	a4,a5
80010416:	6785                	lui	a5,0x1
80010418:	17fd                	add	a5,a5,-1 # fff <.L76+0x39>
8001041a:	8ff9                	and	a5,a5,a4
8001041c:	0807c733          	zext.h	a4,a5
80010420:	47b2                	lw	a5,12(sp)
80010422:	0ff77693          	zext.b	a3,a4
80010426:	0067c603          	lbu	a2,6(a5)
8001042a:	8a01                	and	a2,a2,0
8001042c:	8ed1                	or	a3,a3,a2
8001042e:	00d78323          	sb	a3,6(a5)
80010432:	8321                	srl	a4,a4,0x8
80010434:	08074733          	zext.h	a4,a4
80010438:	0077c683          	lbu	a3,7(a5)
8001043c:	8a81                	and	a3,a3,0
8001043e:	8f55                	or	a4,a4,a3
80010440:	00e783a3          	sb	a4,7(a5)
		pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
80010444:	47b2                	lw	a5,12(sp)
80010446:	0067c703          	lbu	a4,6(a5)
8001044a:	0077c783          	lbu	a5,7(a5)
8001044e:	07a2                	sll	a5,a5,0x8
80010450:	8fd9                	or	a5,a5,a4
80010452:	0807c733          	zext.h	a4,a5
80010456:	678d                	lui	a5,0x3
80010458:	8fd9                	or	a5,a5,a4
8001045a:	0807c733          	zext.h	a4,a5
8001045e:	47b2                	lw	a5,12(sp)
80010460:	0ff77693          	zext.b	a3,a4
80010464:	0067c603          	lbu	a2,6(a5) # 3006 <__BOOT_HEADER_segment_size__+0x1006>
80010468:	8a01                	and	a2,a2,0
8001046a:	8ed1                	or	a3,a3,a2
8001046c:	00d78323          	sb	a3,6(a5)
80010470:	8321                	srl	a4,a4,0x8
80010472:	08074733          	zext.h	a4,a4
80010476:	0077c683          	lbu	a3,7(a5)
8001047a:	8a81                	and	a3,a3,0
8001047c:	8f55                	or	a4,a4,a3
8001047e:	00e783a3          	sb	a4,7(a5)
		if (bSdoSegLastToggle)
80010482:	1911c783          	lbu	a5,401(gp) # 1209509 <bSdoSegLastToggle>
80010486:	c799                	beqz	a5,80010494 <.L16>
			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES | SEGHEADER_TOGGLE);
80010488:	47b2                	lw	a5,12(sp)
8001048a:	03000713          	li	a4,48
8001048e:	00e78423          	sb	a4,8(a5)
80010492:	a031                	j	8001049e <.L17>

80010494 <.L16>:
			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
80010494:	47b2                	lw	a5,12(sp)
80010496:	02000713          	li	a4,32
8001049a:	00e78423          	sb	a4,8(a5)

8001049e <.L17>:
		if (bSdoSegFollows == TRUE)
8001049e:	1921c703          	lbu	a4,402(gp) # 120950a <bSdoSegFollows>
800104a2:	4785                	li	a5,1
800104a4:	00f71963          	bne	a4,a5,800104b6 <.L18>
			nSdoSegBytesToHandle += bytesToSave;
800104a8:	1101a703          	lw	a4,272(gp) # 1209488 <nSdoSegBytesToHandle>
800104ac:	47e2                	lw	a5,24(sp)
800104ae:	973e                	add	a4,a4,a5
800104b0:	10e1a823          	sw	a4,272(gp) # 1209488 <nSdoSegBytesToHandle>
800104b4:	a035                	j	800104e0 <.L19>

800104b6 <.L18>:
			nSdoSegBytesToHandle = 0;
800104b6:	1001a823          	sw	zero,272(gp) # 1209488 <nSdoSegBytesToHandle>
			nSdoSegService = 0;
800104ba:	180184a3          	sb	zero,393(gp) # 1209501 <nSdoSegService>
800104be:	a00d                	j	800104e0 <.L19>

800104c0 <.L15>:
		bSdoSegFollows = FALSE;
800104c0:	18018923          	sb	zero,402(gp) # 120950a <bSdoSegFollows>
		nSdoSegService = 0;
800104c4:	180184a3          	sb	zero,393(gp) # 1209501 <nSdoSegService>
		if (pSdoSegData)
800104c8:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
800104cc:	cb81                	beqz	a5,800104dc <.L20>
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
800104ce:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
800104d2:	853e                	mv	a0,a5
800104d4:	392040ef          	jal	80014866 <free>
			pSdoSegData = NULL;
800104d8:	0c01aa23          	sw	zero,212(gp) # 120944c <pSdoSegData>

800104dc <.L20>:
		nSdoSegBytesToHandle = 0;
800104dc:	1001a823          	sw	zero,272(gp) # 1209488 <nSdoSegBytesToHandle>

800104e0 <.L19>:
	return abort;
800104e0:	01f14783          	lbu	a5,31(sp)

800104e4 <.L14>:
}
800104e4:	853e                	mv	a0,a5
800104e6:	50b2                	lw	ra,44(sp)
800104e8:	6145                	add	sp,sp,48
800104ea:	8082                	ret

Disassembly of section .text.SdoUploadSegmentInd:

800104ec <SdoUploadSegmentInd>:
{
800104ec:	7179                	add	sp,sp,-48
800104ee:	d606                	sw	ra,44(sp)
800104f0:	c62a                	sw	a0,12(sp)
	UINT8 abort = 0;
800104f2:	00010fa3          	sb	zero,31(sp)
	TUPLOADSDOSEGRESMBX MBXMEM * pSdoSegRes = (TUPLOADSDOSEGRESMBX MBXMEM *)pSdoInd;
800104f6:	47b2                	lw	a5,12(sp)
800104f8:	ca3e                	sw	a5,20(sp)
	if (SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
800104fa:	47b2                	lw	a5,12(sp)
800104fc:	0087c783          	lbu	a5,8(a5)
80010500:	8bc1                	and	a5,a5,16
80010502:	1911c703          	lbu	a4,401(gp) # 1209509 <bSdoSegLastToggle>
80010506:	00e79663          	bne	a5,a4,80010512 <.L22>
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
8001050a:	4785                	li	a5,1
8001050c:	00f10fa3          	sb	a5,31(sp)
80010510:	aad1                	j	800106e4 <.L23>

80010512 <.L22>:
		UINT32 size = 0;
80010512:	cc02                	sw	zero,24(sp)
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
80010514:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80010518:	17dd                	add	a5,a5,-9
8001051a:	00f11923          	sh	a5,18(sp)
		bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
8001051e:	47b2                	lw	a5,12(sp)
80010520:	0087c783          	lbu	a5,8(a5)
80010524:	8bc1                	and	a5,a5,16
80010526:	0ff7f713          	zext.b	a4,a5
8001052a:	18e188a3          	sb	a4,401(gp) # 1209509 <bSdoSegLastToggle>
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
8001052e:	01215703          	lhu	a4,18(sp)
80010532:	1101a783          	lw	a5,272(gp) # 1209488 <nSdoSegBytesToHandle>
80010536:	973e                	add	a4,a4,a5
80010538:	10c1a783          	lw	a5,268(gp) # 1209484 <nSdoSegCompleteSize>
8001053c:	00e7fc63          	bgeu	a5,a4,80010554 <.L24>
			size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
80010540:	10c1a703          	lw	a4,268(gp) # 1209484 <nSdoSegCompleteSize>
80010544:	1101a783          	lw	a5,272(gp) # 1209488 <nSdoSegBytesToHandle>
80010548:	40f707b3          	sub	a5,a4,a5
8001054c:	cc3e                	sw	a5,24(sp)
			bSdoSegFollows = FALSE;
8001054e:	18018923          	sb	zero,402(gp) # 120950a <bSdoSegFollows>
80010552:	a039                	j	80010560 <.L25>

80010554 <.L24>:
			size = maxData;
80010554:	01215783          	lhu	a5,18(sp)
80010558:	cc3e                	sw	a5,24(sp)
			bSdoSegFollows = TRUE;
8001055a:	4705                	li	a4,1
8001055c:	18e18923          	sb	a4,402(gp) # 120950a <bSdoSegFollows>

80010560 <.L25>:
		MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &(((UINT8*)pSdoSegData)[nSdoSegBytesToHandle]), size);
80010560:	47d2                	lw	a5,20(sp)
80010562:	00978693          	add	a3,a5,9
80010566:	0d41a703          	lw	a4,212(gp) # 120944c <pSdoSegData>
8001056a:	1101a783          	lw	a5,272(gp) # 1209488 <nSdoSegBytesToHandle>
8001056e:	97ba                	add	a5,a5,a4
80010570:	4662                	lw	a2,24(sp)
80010572:	85be                	mv	a1,a5
80010574:	8536                	mv	a0,a3
80010576:	ee6fd0ef          	jal	8000dc5c <memcpy>
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
8001057a:	47d2                	lw	a5,20(sp)
8001057c:	0067c703          	lbu	a4,6(a5)
80010580:	0077c783          	lbu	a5,7(a5)
80010584:	07a2                	sll	a5,a5,0x8
80010586:	8fd9                	or	a5,a5,a4
80010588:	0807c733          	zext.h	a4,a5
8001058c:	6785                	lui	a5,0x1
8001058e:	17fd                	add	a5,a5,-1 # fff <.L76+0x39>
80010590:	8ff9                	and	a5,a5,a4
80010592:	0807c733          	zext.h	a4,a5
80010596:	47d2                	lw	a5,20(sp)
80010598:	0ff77693          	zext.b	a3,a4
8001059c:	0067c603          	lbu	a2,6(a5)
800105a0:	8a01                	and	a2,a2,0
800105a2:	8ed1                	or	a3,a3,a2
800105a4:	00d78323          	sb	a3,6(a5)
800105a8:	8321                	srl	a4,a4,0x8
800105aa:	08074733          	zext.h	a4,a4
800105ae:	0077c683          	lbu	a3,7(a5)
800105b2:	8a81                	and	a3,a3,0
800105b4:	8f55                	or	a4,a4,a3
800105b6:	00e783a3          	sb	a4,7(a5)
		pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
800105ba:	47d2                	lw	a5,20(sp)
800105bc:	0067c703          	lbu	a4,6(a5)
800105c0:	0077c783          	lbu	a5,7(a5)
800105c4:	07a2                	sll	a5,a5,0x8
800105c6:	8fd9                	or	a5,a5,a4
800105c8:	0807c733          	zext.h	a4,a5
800105cc:	678d                	lui	a5,0x3
800105ce:	8fd9                	or	a5,a5,a4
800105d0:	0807c733          	zext.h	a4,a5
800105d4:	47d2                	lw	a5,20(sp)
800105d6:	0ff77693          	zext.b	a3,a4
800105da:	0067c603          	lbu	a2,6(a5) # 3006 <__BOOT_HEADER_segment_size__+0x1006>
800105de:	8a01                	and	a2,a2,0
800105e0:	8ed1                	or	a3,a3,a2
800105e2:	00d78323          	sb	a3,6(a5)
800105e6:	8321                	srl	a4,a4,0x8
800105e8:	08074733          	zext.h	a4,a4
800105ec:	0077c683          	lbu	a3,7(a5)
800105f0:	8a81                	and	a3,a3,0
800105f2:	8f55                	or	a4,a4,a3
800105f4:	00e783a3          	sb	a4,7(a5)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
800105f8:	47d2                	lw	a5,20(sp)
800105fa:	00078423          	sb	zero,8(a5)
		if (bSdoSegFollows)
800105fe:	1921c783          	lbu	a5,402(gp) # 120950a <bSdoSegFollows>
80010602:	cf89                	beqz	a5,8001061c <.L26>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle);
80010604:	47d2                	lw	a5,20(sp)
80010606:	0087c703          	lbu	a4,8(a5)
8001060a:	1911c783          	lbu	a5,401(gp) # 1209509 <bSdoSegLastToggle>
8001060e:	8fd9                	or	a5,a5,a4
80010610:	0ff7f713          	zext.b	a4,a5
80010614:	47d2                	lw	a5,20(sp)
80010616:	00e78423          	sb	a4,8(a5)
8001061a:	a005                	j	8001063a <.L27>

8001061c <.L26>:
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS);
8001061c:	47d2                	lw	a5,20(sp)
8001061e:	0087c703          	lbu	a4,8(a5)
80010622:	1911c783          	lbu	a5,401(gp) # 1209509 <bSdoSegLastToggle>
80010626:	8fd9                	or	a5,a5,a4
80010628:	0ff7f793          	zext.b	a5,a5
8001062c:	0017e793          	or	a5,a5,1
80010630:	0ff7f713          	zext.b	a4,a5
80010634:	47d2                	lw	a5,20(sp)
80010636:	00e78423          	sb	a4,8(a5)

8001063a <.L27>:
		if (size < MIN_SEGMENTED_DATA)
8001063a:	4762                	lw	a4,24(sp)
8001063c:	4799                	li	a5,6
8001063e:	04e7e463          	bltu	a5,a4,80010686 <.L28>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
80010642:	47d2                	lw	a5,20(sp)
80010644:	0007c703          	lbu	a4,0(a5)
80010648:	8b01                	and	a4,a4,0
8001064a:	00a76713          	or	a4,a4,10
8001064e:	00e78023          	sb	a4,0(a5)
80010652:	0017c703          	lbu	a4,1(a5)
80010656:	8b01                	and	a4,a4,0
80010658:	00e780a3          	sb	a4,1(a5)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
8001065c:	47d2                	lw	a5,20(sp)
8001065e:	0087c703          	lbu	a4,8(a5)
80010662:	47e2                	lw	a5,24(sp)
80010664:	0ff7f793          	zext.b	a5,a5
80010668:	469d                	li	a3,7
8001066a:	40f687b3          	sub	a5,a3,a5
8001066e:	0ff7f793          	zext.b	a5,a5
80010672:	0786                	sll	a5,a5,0x1
80010674:	0ff7f793          	zext.b	a5,a5
80010678:	8fd9                	or	a5,a5,a4
8001067a:	0ff7f713          	zext.b	a4,a5
8001067e:	47d2                	lw	a5,20(sp)
80010680:	00e78423          	sb	a4,8(a5)
80010684:	a80d                	j	800106b6 <.L29>

80010686 <.L28>:
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
80010686:	47e2                	lw	a5,24(sp)
80010688:	0807c7b3          	zext.h	a5,a5
8001068c:	078d                	add	a5,a5,3
8001068e:	0807c733          	zext.h	a4,a5
80010692:	47d2                	lw	a5,20(sp)
80010694:	0ff77693          	zext.b	a3,a4
80010698:	0007c603          	lbu	a2,0(a5)
8001069c:	8a01                	and	a2,a2,0
8001069e:	8ed1                	or	a3,a3,a2
800106a0:	00d78023          	sb	a3,0(a5)
800106a4:	8321                	srl	a4,a4,0x8
800106a6:	08074733          	zext.h	a4,a4
800106aa:	0017c683          	lbu	a3,1(a5)
800106ae:	8a81                	and	a3,a3,0
800106b0:	8f55                	or	a4,a4,a3
800106b2:	00e780a3          	sb	a4,1(a5)

800106b6 <.L29>:
		if (bSdoSegFollows == TRUE)
800106b6:	1921c703          	lbu	a4,402(gp) # 120950a <bSdoSegFollows>
800106ba:	4785                	li	a5,1
800106bc:	00f71963          	bne	a4,a5,800106ce <.L30>
			nSdoSegBytesToHandle += size;
800106c0:	1101a703          	lw	a4,272(gp) # 1209488 <nSdoSegBytesToHandle>
800106c4:	47e2                	lw	a5,24(sp)
800106c6:	973e                	add	a4,a4,a5
800106c8:	10e1a823          	sw	a4,272(gp) # 1209488 <nSdoSegBytesToHandle>
800106cc:	a821                	j	800106e4 <.L23>

800106ce <.L30>:
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
800106ce:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
800106d2:	853e                	mv	a0,a5
800106d4:	192040ef          	jal	80014866 <free>
			pSdoSegData = NULL;
800106d8:	0c01aa23          	sw	zero,212(gp) # 120944c <pSdoSegData>
			nSdoSegBytesToHandle = 0;
800106dc:	1001a823          	sw	zero,272(gp) # 1209488 <nSdoSegBytesToHandle>
			nSdoSegService = 0;
800106e0:	180184a3          	sb	zero,393(gp) # 1209501 <nSdoSegService>

800106e4 <.L23>:
	return abort;
800106e4:	01f14783          	lbu	a5,31(sp)
}
800106e8:	853e                	mv	a0,a5
800106ea:	50b2                	lw	ra,44(sp)
800106ec:	6145                	add	sp,sp,48
800106ee:	8082                	ret

Disassembly of section .text.SDOS_SdoInd:

800106f0 <SDOS_SdoInd>:
{
800106f0:	715d                	add	sp,sp,-80
800106f2:	c686                	sw	ra,76(sp)
800106f4:	c62a                	sw	a0,12(sp)
	UINT8 abort = 0;
800106f6:	02010fa3          	sb	zero,63(sp)
	UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK);
800106fa:	47b2                	lw	a5,12(sp)
800106fc:	0087c783          	lbu	a5,8(a5)
80010700:	02f10523          	sb	a5,42(sp)
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
80010704:	02a14783          	lbu	a5,42(sp)
80010708:	9b81                	and	a5,a5,-32
8001070a:	02f104a3          	sb	a5,41(sp)
	UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
8001070e:	47b2                	lw	a5,12(sp)
80010710:	0007c703          	lbu	a4,0(a5)
80010714:	0017c783          	lbu	a5,1(a5)
80010718:	07a2                	sll	a5,a5,0x8
8001071a:	8fd9                	or	a5,a5,a4
8001071c:	02f11323          	sh	a5,38(sp)
	UINT8 bCompleteAccess = 0;
80010720:	02010f23          	sb	zero,62(sp)
	UINT32 objLength = 0;
80010724:	dc02                	sw	zero,56(sp)
	UINT32 dataSize = 0;
80010726:	da02                	sw	zero,52(sp)
	if (bSdoInWork)
80010728:	1941c783          	lbu	a5,404(gp) # 120950c <bSdoInWork>
8001072c:	c399                	beqz	a5,80010732 <.L45>
		return MBXERR_SERVICEINWORK;
8001072e:	47a5                	li	a5,9
80010730:	abbd                	j	80010cae <.L46>

80010732 <.L45>:
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
80010732:	02a14783          	lbu	a5,42(sp)
80010736:	8bc1                	and	a5,a5,16
80010738:	c781                	beqz	a5,80010740 <.L47>
		bCompleteAccess = 1;
8001073a:	4785                	li	a5,1
8001073c:	02f10f23          	sb	a5,62(sp)

80010740 <.L47>:
	switch (command)
80010740:	02914783          	lbu	a5,41(sp)
80010744:	06000713          	li	a4,96
80010748:	4ee78d63          	beq	a5,a4,80010c42 <.L48>
8001074c:	06000713          	li	a4,96
80010750:	52f74363          	blt	a4,a5,80010c76 <.L49>
80010754:	04000713          	li	a4,64
80010758:	00e78c63          	beq	a5,a4,80010770 <.L50>
8001075c:	04000713          	li	a4,64
80010760:	50f74b63          	blt	a4,a5,80010c76 <.L49>
80010764:	4c078f63          	beqz	a5,80010c42 <.L48>
80010768:	02000713          	li	a4,32
8001076c:	50e79563          	bne	a5,a4,80010c76 <.L49>

80010770 <.L50>:
		index = ((UINT16)(pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK));
80010770:	47b2                	lw	a5,12(sp)
80010772:	00a7c783          	lbu	a5,10(a5)
80010776:	02f11223          	sh	a5,36(sp)
		index <<= 8;
8001077a:	02415783          	lhu	a5,36(sp)
8001077e:	07a2                	sll	a5,a5,0x8
80010780:	02f11223          	sh	a5,36(sp)
		index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET]);
80010784:	47b2                	lw	a5,12(sp)
80010786:	0097c783          	lbu	a5,9(a5)
8001078a:	873e                	mv	a4,a5
8001078c:	02415783          	lhu	a5,36(sp)
80010790:	97ba                	add	a5,a5,a4
80010792:	02f11223          	sh	a5,36(sp)
		subindex = pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET];
80010796:	47b2                	lw	a5,12(sp)
80010798:	00b7c783          	lbu	a5,11(a5)
8001079c:	02f101a3          	sb	a5,35(sp)
		pObjEntry = OBJ_GetObjectHandle(index);
800107a0:	02415783          	lhu	a5,36(sp)
800107a4:	853e                	mv	a0,a5
800107a6:	b56ff0ef          	jal	8000fafc <OBJ_GetObjectHandle>
800107aa:	ce2a                	sw	a0,28(sp)
		if (pObjEntry)
800107ac:	47f2                	lw	a5,28(sp)
800107ae:	48078663          	beqz	a5,80010c3a <.L51>

800107b2 <.LBB5>:
			UINT8 bTransferType = 0;
800107b2:	020109a3          	sb	zero,51(sp)
			UINT16 MBXMEM * pData = NULL;
800107b6:	d602                	sw	zero,44(sp)
			UINT8 segTransfer = 0;
800107b8:	020105a3          	sb	zero,43(sp)

800107bc <.LBB6>:
				UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
800107bc:	47f2                	lw	a5,28(sp)
800107be:	00c7d783          	lhu	a5,12(a5)
800107c2:	00f10da3          	sb	a5,27(sp)
				if (subindex > maxSubindex)
800107c6:	02314703          	lbu	a4,35(sp)
800107ca:	01b14783          	lbu	a5,27(sp)
800107ce:	00e7f663          	bgeu	a5,a4,800107da <.L52>
					abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
800107d2:	47c5                	li	a5,17
800107d4:	02f10fa3          	sb	a5,63(sp)
800107d8:	a015                	j	800107fc <.L53>

800107da <.L52>:
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
800107da:	02a14783          	lbu	a5,42(sp)
800107de:	8bc1                	and	a5,a5,16
800107e0:	0ff7f693          	zext.b	a3,a5
800107e4:	02314703          	lbu	a4,35(sp)
800107e8:	02415783          	lhu	a5,36(sp)
800107ec:	4672                	lw	a2,28(sp)
800107ee:	85ba                	mv	a1,a4
800107f0:	853e                	mv	a0,a5
800107f2:	a1af90ef          	jal	80009a0c <OBJ_GetObjectLength>
800107f6:	dc2a                	sw	a0,56(sp)
800107f8:	57e2                	lw	a5,56(sp)
800107fa:	da3e                	sw	a5,52(sp)

800107fc <.L53>:
				if (abort == 0)
800107fc:	03f14783          	lbu	a5,63(sp)
80010800:	e7bd                	bnez	a5,8001086e <.L54>
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
80010802:	02914703          	lbu	a4,41(sp)
80010806:	04000793          	li	a5,64
8001080a:	04f71d63          	bne	a4,a5,80010864 <.L55>
						if (mbxSize != EXPEDITED_FRAME_SIZE)
8001080e:	02615703          	lhu	a4,38(sp)
80010812:	47a9                	li	a5,10
80010814:	00f70463          	beq	a4,a5,8001081c <.L56>
							return MBXERR_INVALIDSIZE;
80010818:	47a1                	li	a5,8
8001081a:	a951                	j	80010cae <.L46>

8001081c <.L56>:
						if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
8001081c:	5762                	lw	a4,56(sp)
8001081e:	4791                	li	a5,4
80010820:	02e7e263          	bltu	a5,a4,80010844 <.L57>
80010824:	57e2                	lw	a5,56(sp)
80010826:	cf99                	beqz	a5,80010844 <.L57>
							bTransferType = 1;
80010828:	4785                	li	a5,1
8001082a:	02f109a3          	sb	a5,51(sp)
							pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
8001082e:	47b2                	lw	a5,12(sp)
80010830:	07b1                	add	a5,a5,12
80010832:	d63e                	sw	a5,44(sp)
							pData[0] = 0;
80010834:	57b2                	lw	a5,44(sp)
80010836:	00079023          	sh	zero,0(a5)
							pData[1] = 0;
8001083a:	57b2                	lw	a5,44(sp)
8001083c:	0789                	add	a5,a5,2
8001083e:	00079023          	sh	zero,0(a5)
80010842:	a035                	j	8001086e <.L54>

80010844 <.L57>:
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
80010844:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80010848:	17c1                	add	a5,a5,-16
8001084a:	da3e                	sw	a5,52(sp)
							if (dataSize < objLength)
8001084c:	5752                	lw	a4,52(sp)
8001084e:	57e2                	lw	a5,56(sp)
80010850:	00f77663          	bgeu	a4,a5,8001085c <.L59>
								segTransfer = 1;
80010854:	4785                	li	a5,1
80010856:	02f105a3          	sb	a5,43(sp)
8001085a:	a811                	j	8001086e <.L54>

8001085c <.L59>:
								pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
8001085c:	47b2                	lw	a5,12(sp)
8001085e:	07c1                	add	a5,a5,16
80010860:	d63e                	sw	a5,44(sp)
80010862:	a031                	j	8001086e <.L54>

80010864 <.L55>:
						bTransferType = sdoHeader & SDOHEADER_TRANSFERTYPE;
80010864:	02a14783          	lbu	a5,42(sp)
80010868:	8b89                	and	a5,a5,2
8001086a:	02f109a3          	sb	a5,51(sp)

8001086e <.L54>:
			if ((abort == 0) && (command == SDOSERVICE_INITIATEDOWNLOADREQ))
8001086e:	03f14783          	lbu	a5,63(sp)
80010872:	ebcd                	bnez	a5,80010924 <.L60>
80010874:	02914703          	lbu	a4,41(sp)
80010878:	02000793          	li	a5,32
8001087c:	0af71463          	bne	a4,a5,80010924 <.L60>
				if (bTransferType)
80010880:	03314783          	lbu	a5,51(sp)
80010884:	c785                	beqz	a5,800108ac <.L61>
					if (mbxSize != EXPEDITED_FRAME_SIZE)
80010886:	02615703          	lhu	a4,38(sp)
8001088a:	47a9                	li	a5,10
8001088c:	00f70463          	beq	a4,a5,80010894 <.L62>
						return MBXERR_INVALIDSIZE;
80010890:	47a1                	li	a5,8
80010892:	a931                	j	80010cae <.L46>

80010894 <.L62>:
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
80010894:	02a14783          	lbu	a5,42(sp)
80010898:	8789                	sra	a5,a5,0x2
8001089a:	8b8d                	and	a5,a5,3
8001089c:	4711                	li	a4,4
8001089e:	40f707b3          	sub	a5,a4,a5
800108a2:	da3e                	sw	a5,52(sp)
					pData = (UINT16 MBXMEM *) &pSdoInd[1];
800108a4:	47b2                	lw	a5,12(sp)
800108a6:	07b1                	add	a5,a5,12
800108a8:	d63e                	sw	a5,44(sp)
800108aa:	a8ad                	j	80010924 <.L60>

800108ac <.L61>:
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
800108ac:	47b2                	lw	a5,12(sp)
800108ae:	00e7c703          	lbu	a4,14(a5)
800108b2:	00f7c783          	lbu	a5,15(a5)
800108b6:	07a2                	sll	a5,a5,0x8
800108b8:	8fd9                	or	a5,a5,a4
800108ba:	0807c7b3          	zext.h	a5,a5
800108be:	01079713          	sll	a4,a5,0x10
800108c2:	47b2                	lw	a5,12(sp)
800108c4:	00c7c683          	lbu	a3,12(a5)
800108c8:	00d7c783          	lbu	a5,13(a5)
800108cc:	07a2                	sll	a5,a5,0x8
800108ce:	8fd5                	or	a5,a5,a3
800108d0:	0807c7b3          	zext.h	a5,a5
800108d4:	97ba                	add	a5,a5,a4
800108d6:	ca3e                	sw	a5,20(sp)
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
800108d8:	47d2                	lw	a5,20(sp)
800108da:	07c1                	add	a5,a5,16
800108dc:	14a1d703          	lhu	a4,330(gp) # 12094c2 <u16ReceiveMbxSize>
800108e0:	00f77b63          	bgeu	a4,a5,800108f6 <.L63>
						if (mbxSize != (u16ReceiveMbxSize - MBX_HEADER_SIZE))
800108e4:	02615703          	lhu	a4,38(sp)
800108e8:	14a1d783          	lhu	a5,330(gp) # 12094c2 <u16ReceiveMbxSize>
800108ec:	17e9                	add	a5,a5,-6
800108ee:	00f70c63          	beq	a4,a5,80010906 <.L64>
							return MBXERR_INVALIDSIZE;
800108f2:	47a1                	li	a5,8
800108f4:	ae6d                	j	80010cae <.L46>

800108f6 <.L63>:
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
800108f6:	02615703          	lhu	a4,38(sp)
800108fa:	47d2                	lw	a5,20(sp)
800108fc:	07a9                	add	a5,a5,10
800108fe:	00f70463          	beq	a4,a5,80010906 <.L64>
							return MBXERR_INVALIDSIZE;
80010902:	47a1                	li	a5,8
80010904:	a66d                	j	80010cae <.L46>

80010906 <.L64>:
					pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
80010906:	47b2                	lw	a5,12(sp)
80010908:	07c1                	add	a5,a5,16
8001090a:	d63e                	sw	a5,44(sp)
					dataSize = downloadSize;
8001090c:	47d2                	lw	a5,20(sp)
8001090e:	da3e                	sw	a5,52(sp)
					if (dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE))
80010910:	02615783          	lhu	a5,38(sp)
80010914:	17d9                	add	a5,a5,-10
80010916:	873e                	mv	a4,a5
80010918:	57d2                	lw	a5,52(sp)
8001091a:	00f77563          	bgeu	a4,a5,80010924 <.L60>
						segTransfer = 1;
8001091e:	4785                	li	a5,1
80010920:	02f105a3          	sb	a5,43(sp)

80010924 <.L60>:
			if ((abort == 0) && (bCompleteAccess == 1))
80010924:	03f14783          	lbu	a5,63(sp)
80010928:	ef91                	bnez	a5,80010944 <.L65>
8001092a:	03e14703          	lbu	a4,62(sp)
8001092e:	4785                	li	a5,1
80010930:	00f71a63          	bne	a4,a5,80010944 <.L65>
				if (subindex > 1)
80010934:	02314703          	lbu	a4,35(sp)
80010938:	4785                	li	a5,1
8001093a:	00e7f563          	bgeu	a5,a4,80010944 <.L65>
					abort = ABORTIDX_UNSUPPORTED_ACCESS;
8001093e:	4795                	li	a5,5
80010940:	02f10fa3          	sb	a5,63(sp)

80010944 <.L65>:
			if (abort == 0)
80010944:	03f14783          	lbu	a5,63(sp)
80010948:	32079b63          	bnez	a5,80010c7e <.L83>
				if (segTransfer)
8001094c:	02b14783          	lbu	a5,43(sp)
80010950:	18078863          	beqz	a5,80010ae0 <.L67>
					bSdoSegFollows = TRUE;
80010954:	4705                	li	a4,1
80010956:	18e18923          	sb	a4,402(gp) # 120950a <bSdoSegFollows>
					bSdoSegLastToggle = 1;
8001095a:	4705                	li	a4,1
8001095c:	18e188a3          	sb	a4,401(gp) # 1209509 <bSdoSegLastToggle>
					bSdoSegAccess = bCompleteAccess;
80010960:	03e14703          	lbu	a4,62(sp)
80010964:	18e189a3          	sb	a4,403(gp) # 120950b <bSdoSegAccess>
					nSdoSegIndex = index;
80010968:	02415703          	lhu	a4,36(sp)
8001096c:	14e19e23          	sh	a4,348(gp) # 12094d4 <nSdoSegIndex>
					nSdoSegSubindex = subindex;
80010970:	02314703          	lbu	a4,35(sp)
80010974:	18e18423          	sb	a4,392(gp) # 1209500 <nSdoSegSubindex>
					pSdoSegObjEntry = pObjEntry;
80010978:	4772                	lw	a4,28(sp)
8001097a:	0ce1a823          	sw	a4,208(gp) # 1209448 <pSdoSegObjEntry>
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
8001097e:	02914703          	lbu	a4,41(sp)
80010982:	04000793          	li	a5,64
80010986:	00f71663          	bne	a4,a5,80010992 <.L68>
						nSdoSegCompleteSize = objLength;
8001098a:	5762                	lw	a4,56(sp)
8001098c:	10e1a623          	sw	a4,268(gp) # 1209484 <nSdoSegCompleteSize>
80010990:	a021                	j	80010998 <.L69>

80010992 <.L68>:
						nSdoSegCompleteSize = dataSize;
80010992:	5752                	lw	a4,52(sp)
80010994:	10e1a623          	sw	a4,268(gp) # 1209484 <nSdoSegCompleteSize>

80010998 <.L69>:
					if (pSdoSegData != NULL)
80010998:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
8001099c:	cb81                	beqz	a5,800109ac <.L70>
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
8001099e:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
800109a2:	853e                	mv	a0,a5
800109a4:	6c3030ef          	jal	80014866 <free>
						pSdoSegData = NULL;
800109a8:	0c01aa23          	sw	zero,212(gp) # 120944c <pSdoSegData>

800109ac <.L70>:
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
800109ac:	10c1a783          	lw	a5,268(gp) # 1209484 <nSdoSegCompleteSize>
800109b0:	0785                	add	a5,a5,1
800109b2:	9bf9                	and	a5,a5,-2
800109b4:	853e                	mv	a0,a5
800109b6:	c54fd0ef          	jal	8000de0a <malloc>
800109ba:	872a                	mv	a4,a0
800109bc:	0ce1aa23          	sw	a4,212(gp) # 120944c <pSdoSegData>
					if (pSdoSegData == NULL)
800109c0:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
800109c4:	ef81                	bnez	a5,800109dc <.L71>
						if (bCompleteAccess)
800109c6:	03e14783          	lbu	a5,62(sp)
800109ca:	c789                	beqz	a5,800109d4 <.L72>
							abort = ABORTIDX_UNSUPPORTED_ACCESS;
800109cc:	4795                	li	a5,5
800109ce:	02f10fa3          	sb	a5,63(sp)

800109d2 <.LBE5>:
		break;
800109d2:	a475                	j	80010c7e <.L83>

800109d4 <.L72>:
							abort = ABORTIDX_OUT_OF_MEMORY;
800109d4:	4791                	li	a5,4
800109d6:	02f10fa3          	sb	a5,63(sp)

800109da <.LBE8>:
		break;
800109da:	a455                	j	80010c7e <.L83>

800109dc <.L71>:
						if (command == SDOSERVICE_INITIATEUPLOADREQ)
800109dc:	02914703          	lbu	a4,41(sp)
800109e0:	04000793          	li	a5,64
800109e4:	0cf71763          	bne	a4,a5,80010ab2 <.L73>
							abort = OBJ_Read(index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess);
800109e8:	0d41a703          	lw	a4,212(gp) # 120944c <pSdoSegData>
800109ec:	03e14783          	lbu	a5,62(sp)
800109f0:	02314583          	lbu	a1,35(sp)
800109f4:	02415503          	lhu	a0,36(sp)
800109f8:	46f2                	lw	a3,28(sp)
800109fa:	5662                	lw	a2,56(sp)
800109fc:	a9cf90ef          	jal	80009c98 <OBJ_Read>
80010a00:	87aa                	mv	a5,a0
80010a02:	02f10fa3          	sb	a5,63(sp)
							if (abort == 0)
80010a06:	03f14783          	lbu	a5,63(sp)
80010a0a:	e385                	bnez	a5,80010a2a <.L74>
								MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize);
80010a0c:	47b2                	lw	a5,12(sp)
80010a0e:	01078713          	add	a4,a5,16
80010a12:	0d41a783          	lw	a5,212(gp) # 120944c <pSdoSegData>
80010a16:	5652                	lw	a2,52(sp)
80010a18:	85be                	mv	a1,a5
80010a1a:	853a                	mv	a0,a4
80010a1c:	a40fd0ef          	jal	8000dc5c <memcpy>
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
80010a20:	06000713          	li	a4,96
80010a24:	18e184a3          	sb	a4,393(gp) # 1209501 <nSdoSegService>
80010a28:	a845                	j	80010ad8 <.L75>

80010a2a <.L74>:
							else if (abort == ABORTIDX_WORKING)
80010a2a:	03f14703          	lbu	a4,63(sp)
80010a2e:	0ff00793          	li	a5,255
80010a32:	0af71363          	bne	a4,a5,80010ad8 <.L75>
								u8PendingSdo = SDO_PENDING_SEG_READ;
80010a36:	4711                	li	a4,4
80010a38:	36e207a3          	sb	a4,879(tp) # 36f <default_isr_62+0x79>
								bStoreCompleteAccess = bCompleteAccess;
80010a3c:	03e14703          	lbu	a4,62(sp)
80010a40:	18e18723          	sb	a4,398(gp) # 1209506 <bStoreCompleteAccess>
								u8StoreSubindex = subindex;
80010a44:	02314703          	lbu	a4,35(sp)
80010a48:	34e20aa3          	sb	a4,853(tp) # 355 <default_isr_62+0x5f>
								u16StoreIndex = index;
80010a4c:	02415703          	lhu	a4,36(sp)
80010a50:	34e21323          	sh	a4,838(tp) # 346 <default_isr_62+0x50>
								u32StoreDataSize = objLength;
80010a54:	5762                	lw	a4,56(sp)
80010a56:	0ae1a023          	sw	a4,160(gp) # 1209418 <u32StoreDataSize>
								pStoreData = pSdoSegData;
80010a5a:	0d41a703          	lw	a4,212(gp) # 120944c <pSdoSegData>
80010a5e:	0ce1a623          	sw	a4,204(gp) # 1209444 <pStoreData>
								pSdoPendFunc = pObjEntry->Read;
80010a62:	47f2                	lw	a5,28(sp)
80010a64:	4fd8                	lw	a4,28(a5)
80010a66:	0ce1ae23          	sw	a4,220(gp) # 1209454 <pSdoPendFunc>
								bSdoInWork = TRUE;
80010a6a:	4705                	li	a4,1
80010a6c:	18e18a23          	sb	a4,404(gp) # 120950c <bSdoInWork>
								pSdoResStored = pSdoInd;
80010a70:	4732                	lw	a4,12(sp)
80010a72:	0ce1ac23          	sw	a4,216(gp) # 1209450 <pSdoResStored>
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
80010a76:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010a7a:	00078423          	sb	zero,8(a5)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
80010a7e:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010a82:	0087c783          	lbu	a5,8(a5)
80010a86:	60479713          	sext.b	a4,a5
80010a8a:	02a10783          	lb	a5,42(sp)
80010a8e:	9bc1                	and	a5,a5,-16
80010a90:	60479793          	sext.b	a5,a5
80010a94:	8fd9                	or	a5,a5,a4
80010a96:	60479713          	sext.b	a4,a5
80010a9a:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010a9e:	0ff77713          	zext.b	a4,a4
80010aa2:	00e78423          	sb	a4,8(a5)
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
80010aa6:	06000713          	li	a4,96
80010aaa:	18e184a3          	sb	a4,393(gp) # 1209501 <nSdoSegService>
								return 0;
80010aae:	4781                	li	a5,0
80010ab0:	aafd                	j	80010cae <.L46>

80010ab2 <.L73>:
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
80010ab2:	0d41a703          	lw	a4,212(gp) # 120944c <pSdoSegData>
80010ab6:	47b2                	lw	a5,12(sp)
80010ab8:	01078693          	add	a3,a5,16
80010abc:	02615783          	lhu	a5,38(sp)
80010ac0:	17d9                	add	a5,a5,-10
80010ac2:	863e                	mv	a2,a5
80010ac4:	85b6                	mv	a1,a3
80010ac6:	853a                	mv	a0,a4
80010ac8:	994fd0ef          	jal	8000dc5c <memcpy>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
80010acc:	180184a3          	sb	zero,393(gp) # 1209501 <nSdoSegService>
							dataSize = (mbxSize - DOWNLOAD_NORM_REQ_SIZE);
80010ad0:	02615783          	lhu	a5,38(sp)
80010ad4:	17d9                	add	a5,a5,-10
80010ad6:	da3e                	sw	a5,52(sp)

80010ad8 <.L75>:
						nSdoSegBytesToHandle = dataSize;
80010ad8:	5752                	lw	a4,52(sp)
80010ada:	10e1a823          	sw	a4,272(gp) # 1209488 <nSdoSegBytesToHandle>

80010ade <.LBE9>:
		break;
80010ade:	a245                	j	80010c7e <.L83>

80010ae0 <.L67>:
					if (objLength == 0)
80010ae0:	57e2                	lw	a5,56(sp)
80010ae2:	ef81                	bnez	a5,80010afa <.L76>
						nSdoSegIndex = index;
80010ae4:	02415703          	lhu	a4,36(sp)
80010ae8:	14e19e23          	sh	a4,348(gp) # 12094d4 <nSdoSegIndex>
						nSdoSegSubindex = subindex;
80010aec:	02314703          	lbu	a4,35(sp)
80010af0:	18e18423          	sb	a4,392(gp) # 1209500 <nSdoSegSubindex>
						pSdoSegObjEntry = pObjEntry;
80010af4:	4772                	lw	a4,28(sp)
80010af6:	0ce1a823          	sw	a4,208(gp) # 1209448 <pSdoSegObjEntry>

80010afa <.L76>:
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
80010afa:	02914703          	lbu	a4,41(sp)
80010afe:	04000793          	li	a5,64
80010b02:	08f71f63          	bne	a4,a5,80010ba0 <.L77>
						abort = OBJ_Read(index, subindex, objLength, pObjEntry, pData, bCompleteAccess);
80010b06:	03e14783          	lbu	a5,62(sp)
80010b0a:	02314583          	lbu	a1,35(sp)
80010b0e:	02415503          	lhu	a0,36(sp)
80010b12:	5732                	lw	a4,44(sp)
80010b14:	46f2                	lw	a3,28(sp)
80010b16:	5662                	lw	a2,56(sp)
80010b18:	980f90ef          	jal	80009c98 <OBJ_Read>
80010b1c:	87aa                	mv	a5,a0
80010b1e:	02f10fa3          	sb	a5,63(sp)
						if (abort == ABORTIDX_WORKING)
80010b22:	03f14703          	lbu	a4,63(sp)
80010b26:	0ff00793          	li	a5,255
80010b2a:	14f71a63          	bne	a4,a5,80010c7e <.L83>
							u8PendingSdo = SDO_PENDING_READ;
80010b2e:	470d                	li	a4,3
80010b30:	36e207a3          	sb	a4,879(tp) # 36f <default_isr_62+0x79>
							bStoreCompleteAccess = bCompleteAccess;
80010b34:	03e14703          	lbu	a4,62(sp)
80010b38:	18e18723          	sb	a4,398(gp) # 1209506 <bStoreCompleteAccess>
							u8StoreSubindex = subindex;
80010b3c:	02314703          	lbu	a4,35(sp)
80010b40:	34e20aa3          	sb	a4,853(tp) # 355 <default_isr_62+0x5f>
							u16StoreIndex = index;
80010b44:	02415703          	lhu	a4,36(sp)
80010b48:	34e21323          	sh	a4,838(tp) # 346 <default_isr_62+0x50>
							u32StoreDataSize = objLength;
80010b4c:	5762                	lw	a4,56(sp)
80010b4e:	0ae1a023          	sw	a4,160(gp) # 1209418 <u32StoreDataSize>
							pStoreData = pData;
80010b52:	5732                	lw	a4,44(sp)
80010b54:	0ce1a623          	sw	a4,204(gp) # 1209444 <pStoreData>
							pSdoPendFunc = pObjEntry->Read;
80010b58:	47f2                	lw	a5,28(sp)
80010b5a:	4fd8                	lw	a4,28(a5)
80010b5c:	0ce1ae23          	sw	a4,220(gp) # 1209454 <pSdoPendFunc>
							bSdoInWork = TRUE;
80010b60:	4705                	li	a4,1
80010b62:	18e18a23          	sb	a4,404(gp) # 120950c <bSdoInWork>
							pSdoResStored = pSdoInd;
80010b66:	4732                	lw	a4,12(sp)
80010b68:	0ce1ac23          	sw	a4,216(gp) # 1209450 <pSdoResStored>
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
80010b6c:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010b70:	00078423          	sb	zero,8(a5)
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
80010b74:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010b78:	0087c783          	lbu	a5,8(a5)
80010b7c:	60479713          	sext.b	a4,a5
80010b80:	02a10783          	lb	a5,42(sp)
80010b84:	9bc1                	and	a5,a5,-16
80010b86:	60479793          	sext.b	a5,a5
80010b8a:	8fd9                	or	a5,a5,a4
80010b8c:	60479713          	sext.b	a4,a5
80010b90:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010b94:	0ff77713          	zext.b	a4,a4
80010b98:	00e78423          	sb	a4,8(a5)
							return 0;
80010b9c:	4781                	li	a5,0
80010b9e:	aa01                	j	80010cae <.L46>

80010ba0 <.L77>:
						abort = OBJ_Write(index, subindex, dataSize, pObjEntry, pData, bCompleteAccess);
80010ba0:	03e14783          	lbu	a5,62(sp)
80010ba4:	02314583          	lbu	a1,35(sp)
80010ba8:	02415503          	lhu	a0,36(sp)
80010bac:	5732                	lw	a4,44(sp)
80010bae:	46f2                	lw	a3,28(sp)
80010bb0:	5652                	lw	a2,52(sp)
80010bb2:	8fbf90ef          	jal	8000a4ac <OBJ_Write>
80010bb6:	87aa                	mv	a5,a0
80010bb8:	02f10fa3          	sb	a5,63(sp)
						if (abort == ABORTIDX_WORKING)
80010bbc:	03f14703          	lbu	a4,63(sp)
80010bc0:	0ff00793          	li	a5,255
80010bc4:	0af71d63          	bne	a4,a5,80010c7e <.L83>
							u8PendingSdo = SDO_PENDING_WRITE;
80010bc8:	4705                	li	a4,1
80010bca:	36e207a3          	sb	a4,879(tp) # 36f <default_isr_62+0x79>
							bStoreCompleteAccess = bCompleteAccess;
80010bce:	03e14703          	lbu	a4,62(sp)
80010bd2:	18e18723          	sb	a4,398(gp) # 1209506 <bStoreCompleteAccess>
							u8StoreSubindex = subindex;
80010bd6:	02314703          	lbu	a4,35(sp)
80010bda:	34e20aa3          	sb	a4,853(tp) # 355 <default_isr_62+0x5f>
							u16StoreIndex = index;
80010bde:	02415703          	lhu	a4,36(sp)
80010be2:	34e21323          	sh	a4,838(tp) # 346 <default_isr_62+0x50>
							u32StoreDataSize = dataSize;
80010be6:	5752                	lw	a4,52(sp)
80010be8:	0ae1a023          	sw	a4,160(gp) # 1209418 <u32StoreDataSize>
							pStoreData = pData;
80010bec:	5732                	lw	a4,44(sp)
80010bee:	0ce1a623          	sw	a4,204(gp) # 1209444 <pStoreData>
							pSdoPendFunc = pObjEntry->Write;
80010bf2:	47f2                	lw	a5,28(sp)
80010bf4:	5398                	lw	a4,32(a5)
80010bf6:	0ce1ae23          	sw	a4,220(gp) # 1209454 <pSdoPendFunc>
							bSdoInWork = TRUE;
80010bfa:	4705                	li	a4,1
80010bfc:	18e18a23          	sb	a4,404(gp) # 120950c <bSdoInWork>
							pSdoResStored = pSdoInd;
80010c00:	4732                	lw	a4,12(sp)
80010c02:	0ce1ac23          	sw	a4,216(gp) # 1209450 <pSdoResStored>
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
80010c06:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010c0a:	00078423          	sb	zero,8(a5)
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
80010c0e:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010c12:	0087c783          	lbu	a5,8(a5)
80010c16:	60479713          	sext.b	a4,a5
80010c1a:	02a10783          	lb	a5,42(sp)
80010c1e:	9bc1                	and	a5,a5,-16
80010c20:	60479793          	sext.b	a5,a5
80010c24:	8fd9                	or	a5,a5,a4
80010c26:	60479713          	sext.b	a4,a5
80010c2a:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010c2e:	0ff77713          	zext.b	a4,a4
80010c32:	00e78423          	sb	a4,8(a5)
							return 0;
80010c36:	4781                	li	a5,0
80010c38:	a89d                	j	80010cae <.L46>

80010c3a <.L51>:
			abort = ABORTIDX_OBJECT_NOT_EXISTING;
80010c3a:	47a1                	li	a5,8
80010c3c:	02f10fa3          	sb	a5,63(sp)
		break;
80010c40:	a83d                	j	80010c7e <.L83>

80010c42 <.L48>:
		if (command == nSdoSegService)
80010c42:	1891c783          	lbu	a5,393(gp) # 1209501 <nSdoSegService>
80010c46:	02914703          	lbu	a4,41(sp)
80010c4a:	02f71263          	bne	a4,a5,80010c6e <.L79>
			if (command == SDOSERVICE_DOWNLOADSEGMENTREQ)
80010c4e:	02914783          	lbu	a5,41(sp)
80010c52:	eb81                	bnez	a5,80010c62 <.L80>
				abort = SdoDownloadSegmentInd((TDOWNLOADSDOSEGREQMBX MBXMEM *) pSdoInd);
80010c54:	4532                	lw	a0,12(sp)
80010c56:	ddeff0ef          	jal	80010234 <SdoDownloadSegmentInd>
80010c5a:	87aa                	mv	a5,a0
80010c5c:	02f10fa3          	sb	a5,63(sp)
		break;
80010c60:	a005                	j	80010c80 <.L78>

80010c62 <.L80>:
				abort = SdoUploadSegmentInd((TUPLOADSDOSEGREQMBX MBXMEM *) pSdoInd);
80010c62:	4532                	lw	a0,12(sp)
80010c64:	3061                	jal	800104ec <SdoUploadSegmentInd>
80010c66:	87aa                	mv	a5,a0
80010c68:	02f10fa3          	sb	a5,63(sp)
		break;
80010c6c:	a811                	j	80010c80 <.L78>

80010c6e <.L79>:
			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
80010c6e:	478d                	li	a5,3
80010c70:	02f10fa3          	sb	a5,63(sp)
		break;
80010c74:	a031                	j	80010c80 <.L78>

80010c76 <.L49>:
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
80010c76:	478d                	li	a5,3
80010c78:	02f10fa3          	sb	a5,63(sp)
		break;
80010c7c:	a011                	j	80010c80 <.L78>

80010c7e <.L83>:
		break;
80010c7e:	0001                	nop

80010c80 <.L78>:
	if (abort != ABORTIDX_WORKING)
80010c80:	03f14703          	lbu	a4,63(sp)
80010c84:	0ff00793          	li	a5,255
80010c88:	02f70263          	beq	a4,a5,80010cac <.L82>
		SdoRes(abort, command, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16)dataSize, objLength, pSdoInd);
80010c8c:	02a14783          	lbu	a5,42(sp)
80010c90:	8bc1                	and	a5,a5,16
80010c92:	0ff7f613          	zext.b	a2,a5
80010c96:	57d2                	lw	a5,52(sp)
80010c98:	0807c6b3          	zext.h	a3,a5
80010c9c:	02914583          	lbu	a1,41(sp)
80010ca0:	03f14503          	lbu	a0,63(sp)
80010ca4:	47b2                	lw	a5,12(sp)
80010ca6:	5762                	lw	a4,56(sp)
80010ca8:	a56fa0ef          	jal	8000aefe <SdoRes>

80010cac <.L82>:
	return 0;
80010cac:	4781                	li	a5,0

80010cae <.L46>:
}
80010cae:	853e                	mv	a0,a5
80010cb0:	40b6                	lw	ra,76(sp)
80010cb2:	6161                	add	sp,sp,80
80010cb4:	8082                	ret

Disassembly of section .text.SDOS_SdoRes:

80010cb6 <SDOS_SdoRes>:
{
80010cb6:	7179                	add	sp,sp,-48
80010cb8:	d606                	sw	ra,44(sp)
80010cba:	87aa                	mv	a5,a0
80010cbc:	c42e                	sw	a1,8(sp)
80010cbe:	c232                	sw	a2,4(sp)
80010cc0:	00f107a3          	sb	a5,15(sp)
	UINT16 dataSize = 0;
80010cc4:	00011f23          	sh	zero,30(sp)
	if (bSdoInWork)
80010cc8:	1941c783          	lbu	a5,404(gp) # 120950c <bSdoInWork>
80010ccc:	0e078563          	beqz	a5,80010db6 <.L90>

80010cd0 <.LBB11>:
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
80010cd0:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010cd4:	0087c783          	lbu	a5,8(a5)
80010cd8:	9b81                	and	a5,a5,-32
80010cda:	00f10ea3          	sb	a5,29(sp)
		UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
80010cde:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010ce2:	0087c783          	lbu	a5,8(a5)
80010ce6:	8bc1                	and	a5,a5,16
80010ce8:	00f10e23          	sb	a5,28(sp)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
80010cec:	01d14703          	lbu	a4,29(sp)
80010cf0:	04000793          	li	a5,64
80010cf4:	0af71263          	bne	a4,a5,80010d98 <.L86>
			dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
80010cf8:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80010cfc:	17c1                	add	a5,a5,-16
80010cfe:	00f11f23          	sh	a5,30(sp)
			if (dataSize < objLength)
80010d02:	01e15783          	lhu	a5,30(sp)
80010d06:	4722                	lw	a4,8(sp)
80010d08:	04e7f563          	bgeu	a5,a4,80010d52 <.L87>
				bSdoSegFollows = TRUE;
80010d0c:	4705                	li	a4,1
80010d0e:	18e18923          	sb	a4,402(gp) # 120950a <bSdoSegFollows>
				bSdoSegLastToggle = 1;
80010d12:	4705                	li	a4,1
80010d14:	18e188a3          	sb	a4,401(gp) # 1209509 <bSdoSegLastToggle>
				bSdoSegAccess = completeAccess;
80010d18:	01c14703          	lbu	a4,28(sp)
80010d1c:	18e189a3          	sb	a4,403(gp) # 120950b <bSdoSegAccess>
				nSdoSegCompleteSize = objLength;
80010d20:	4722                	lw	a4,8(sp)
80010d22:	10e1a623          	sw	a4,268(gp) # 1209484 <nSdoSegCompleteSize>
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
80010d26:	06000713          	li	a4,96
80010d2a:	18e184a3          	sb	a4,393(gp) # 1209501 <nSdoSegService>
				pSdoSegData = (UINT16 VARMEM *) pData;
80010d2e:	4712                	lw	a4,4(sp)
80010d30:	0ce1aa23          	sw	a4,212(gp) # 120944c <pSdoSegData>
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
80010d34:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010d38:	07c1                	add	a5,a5,16
80010d3a:	01e15703          	lhu	a4,30(sp)
80010d3e:	863a                	mv	a2,a4
80010d40:	4592                	lw	a1,4(sp)
80010d42:	853e                	mv	a0,a5
80010d44:	f19fc0ef          	jal	8000dc5c <memcpy>
				nSdoSegBytesToHandle = dataSize;
80010d48:	01e15703          	lhu	a4,30(sp)
80010d4c:	10e1a823          	sw	a4,272(gp) # 1209488 <nSdoSegBytesToHandle>
80010d50:	a0a1                	j	80010d98 <.L86>

80010d52 <.L87>:
				if ((objLength <= 4) && (objLength > 0))
80010d52:	4722                	lw	a4,8(sp)
80010d54:	4791                	li	a5,4
80010d56:	02e7e363          	bltu	a5,a4,80010d7c <.L88>
80010d5a:	47a2                	lw	a5,8(sp)
80010d5c:	c385                	beqz	a5,80010d7c <.L88>
					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
80010d5e:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010d62:	07b1                	add	a5,a5,12
80010d64:	4712                	lw	a4,4(sp)
80010d66:	02f70963          	beq	a4,a5,80010d98 <.L86>
						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
80010d6a:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010d6e:	07b1                	add	a5,a5,12
80010d70:	4622                	lw	a2,8(sp)
80010d72:	4592                	lw	a1,4(sp)
80010d74:	853e                	mv	a0,a5
80010d76:	ee7fc0ef          	jal	8000dc5c <memcpy>
					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
80010d7a:	a839                	j	80010d98 <.L86>

80010d7c <.L88>:
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
80010d7c:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010d80:	07c1                	add	a5,a5,16
80010d82:	4712                	lw	a4,4(sp)
80010d84:	00f70a63          	beq	a4,a5,80010d98 <.L86>
						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
80010d88:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010d8c:	07c1                	add	a5,a5,16
80010d8e:	4622                	lw	a2,8(sp)
80010d90:	4592                	lw	a1,4(sp)
80010d92:	853e                	mv	a0,a5
80010d94:	ec9fc0ef          	jal	8000dc5c <memcpy>

80010d98 <.L86>:
		bSdoInWork = FALSE;
80010d98:	18018a23          	sb	zero,404(gp) # 120950c <bSdoInWork>
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
80010d9c:	0d81a783          	lw	a5,216(gp) # 1209450 <pSdoResStored>
80010da0:	01e15683          	lhu	a3,30(sp)
80010da4:	01c14603          	lbu	a2,28(sp)
80010da8:	01d14583          	lbu	a1,29(sp)
80010dac:	00f14503          	lbu	a0,15(sp)
80010db0:	4722                	lw	a4,8(sp)
80010db2:	94cfa0ef          	jal	8000aefe <SdoRes>

80010db6 <.L90>:
}
80010db6:	0001                	nop
80010db8:	50b2                	lw	ra,44(sp)
80010dba:	6145                	add	sp,sp,48
80010dbc:	8082                	ret

Disassembly of section .text.SDOS_SdoInfoInd:

80010dbe <SDOS_SdoInfoInd>:
			is received from the master and calls depending from
			the opcode the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd)
{
80010dbe:	715d                	add	sp,sp,-80
80010dc0:	c686                	sw	ra,76(sp)
80010dc2:	c4a2                	sw	s0,72(sp)
80010dc4:	c62a                	sw	a0,12(sp)
	UINT8 abort = 0;
80010dc6:	00010fa3          	sb	zero,31(sp)
	/* the variable opCode contains the requested SDO Information type */
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
80010dca:	47b2                	lw	a5,12(sp)
80010dcc:	0087c703          	lbu	a4,8(a5)
80010dd0:	0097c783          	lbu	a5,9(a5)
80010dd4:	07a2                	sll	a5,a5,0x8
80010dd6:	8fd9                	or	a5,a5,a4
80010dd8:	0807c7b3          	zext.h	a5,a5
80010ddc:	0ff7f793          	zext.b	a5,a5
80010de0:	07f7f793          	and	a5,a5,127
80010de4:	02f108a3          	sb	a5,49(sp)
	OBJCONST TOBJECT OBJMEM * pObjEntry;
	UINT16 index;
	UINT8 flags = COE_SERVICE;
80010de8:	4789                	li	a5,2
80010dea:	02f10fa3          	sb	a5,63(sp)

	/* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
	   great enough for the service header of the requested SDO Information type */
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
80010dee:	03114703          	lbu	a4,49(sp)
80010df2:	4795                	li	a5,5
80010df4:	02f71063          	bne	a4,a5,80010e14 <.L95>
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT)
80010df8:	47b2                	lw	a5,12(sp)
80010dfa:	0007c703          	lbu	a4,0(a5)
80010dfe:	0017c783          	lbu	a5,1(a5)
80010e02:	07a2                	sll	a5,a5,0x8
80010e04:	8fd9                	or	a5,a5,a4
80010e06:	0807c733          	zext.h	a4,a5
80010e0a:	47a5                	li	a5,9
80010e0c:	02e7e263          	bltu	a5,a4,80010e30 <.L96>
		{
			return MBXERR_SIZETOOSHORT;
80010e10:	4799                	li	a5,6
80010e12:	af0d                	j	80011544 <.L123>

80010e14 <.L95>:
		}
	}
	else
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT)
80010e14:	47b2                	lw	a5,12(sp)
80010e16:	0007c703          	lbu	a4,0(a5)
80010e1a:	0017c783          	lbu	a5,1(a5)
80010e1e:	07a2                	sll	a5,a5,0x8
80010e20:	8fd9                	or	a5,a5,a4
80010e22:	0807c733          	zext.h	a4,a5
80010e26:	479d                	li	a5,7
80010e28:	00e7e463          	bltu	a5,a4,80010e30 <.L96>
		{
			return MBXERR_SIZETOOSHORT;
80010e2c:	4799                	li	a5,6
80010e2e:	af19                	j	80011544 <.L123>

80010e30 <.L96>:
		}
	}

	switch (opCode)
80010e30:	03114783          	lbu	a5,49(sp)
80010e34:	4715                	li	a4,5
80010e36:	2ee78963          	beq	a5,a4,80011128 <.L98>
80010e3a:	4715                	li	a4,5
80010e3c:	5cf74663          	blt	a4,a5,80011408 <.L99>
80010e40:	4705                	li	a4,1
80010e42:	00e78663          	beq	a5,a4,80010e4e <.L100>
80010e46:	470d                	li	a4,3
80010e48:	2ee78063          	beq	a5,a4,80011128 <.L98>
80010e4c:	ab75                	j	80011408 <.L99>

80010e4e <.L100>:
	{
	case SDOINFOSERVICE_OBJDICTIONARYLIST_Q:
		/* an object list is requested, check if the list type is supported */
		if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
80010e4e:	47b2                	lw	a5,12(sp)
80010e50:	00c7c703          	lbu	a4,12(a5)
80010e54:	00d7c783          	lbu	a5,13(a5)
80010e58:	07a2                	sll	a5,a5,0x8
80010e5a:	8fd9                	or	a5,a5,a4
80010e5c:	0807c733          	zext.h	a4,a5
80010e60:	4795                	li	a5,5
80010e62:	5ae7e763          	bltu	a5,a4,80011410 <.L124>

80010e66 <.LBB12>:
		{
			UINT16 size = 0;
80010e66:	02011e23          	sh	zero,60(sp)
			/* the variable listType contains the requested listType */
			UINT8 listType = (UINT8)SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType);
80010e6a:	47b2                	lw	a5,12(sp)
80010e6c:	00c7c703          	lbu	a4,12(a5)
80010e70:	00d7c783          	lbu	a5,13(a5)
80010e74:	07a2                	sll	a5,a5,0x8
80010e76:	8fd9                	or	a5,a5,a4
80010e78:	0807c7b3          	zext.h	a5,a5
80010e7c:	02f103a3          	sb	a5,39(sp)

			/* the SDO Information Header has to be stored because this function will be
			   called again if the response could not be sent with one mailbox service, the
			   variable nSdoInfoFragmentsLeft is 0 zero for the first call and unequal 0
			   for the following calls */
			MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
80010e80:	4639                	li	a2,14
80010e82:	45b2                	lw	a1,12(sp)
80010e84:	08018513          	add	a0,gp,128 # 12093f8 <aSdoInfoHeader>
80010e88:	dd5fc0ef          	jal	8000dc5c <memcpy>
			if (listType-- == 0)
80010e8c:	02714783          	lbu	a5,39(sp)
80010e90:	fff78713          	add	a4,a5,-1
80010e94:	02e103a3          	sb	a4,39(sp)
80010e98:	eba1                	bnez	a5,80010ee8 <.L102>

80010e9a <.LBB13>:
				/* List-Type 0: length of the lists */
				UINT8 i;

				/* the needed mailbox size for List-Type 0 response is just 24 bytes, the mailbox has always
				   to be at least 24 bytes to support the SDO Information service */
				nSdoInfoFragmentsLeft = 0;
80010e9a:	16019023          	sh	zero,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
80010e9e:	02010da3          	sb	zero,59(sp)
80010ea2:	a815                	j	80010ed6 <.L103>

80010ea4 <.L104>:
				{
					UINT16 n = OBJ_GetNoOfObjects(i);
80010ea4:	03b14783          	lbu	a5,59(sp)
80010ea8:	853e                	mv	a0,a5
80010eaa:	c8bfe0ef          	jal	8000fb34 <OBJ_GetNoOfObjects>
80010eae:	87aa                	mv	a5,a0
80010eb0:	02f11023          	sh	a5,32(sp)

					/* copy the number of objects of the list type in the SDO Information response */
					((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i] = SWAPWORD(n);
80010eb4:	47b2                	lw	a5,12(sp)
80010eb6:	00678713          	add	a4,a5,6
80010eba:	03b14783          	lbu	a5,59(sp)
80010ebe:	0791                	add	a5,a5,4
80010ec0:	0786                	sll	a5,a5,0x1
80010ec2:	97ba                	add	a5,a5,a4
80010ec4:	02015703          	lhu	a4,32(sp)
80010ec8:	00e79023          	sh	a4,0(a5)

80010ecc <.LBE14>:
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
80010ecc:	03b14783          	lbu	a5,59(sp)
80010ed0:	0785                	add	a5,a5,1
80010ed2:	02f10da3          	sb	a5,59(sp)

80010ed6 <.L103>:
80010ed6:	03b14703          	lbu	a4,59(sp)
80010eda:	4791                	li	a5,4
80010edc:	fce7f4e3          	bgeu	a5,a4,80010ea4 <.L104>
				}

				/* size of the mailbox service response */
				size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
80010ee0:	47c9                	li	a5,18
80010ee2:	02f11e23          	sh	a5,60(sp)

80010ee6 <.LBE13>:
80010ee6:	a0c5                	j	80010fc6 <.L105>

80010ee8 <.L102>:
			}
			else
			{
				/* object list with indexes is requested */
				UINT16 MBXMEM * pData;
				UINT16 n = 0;
80010ee8:	02011223          	sh	zero,36(sp)

				if (nSdoInfoFragmentsLeft)
80010eec:	1601d783          	lhu	a5,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>
80010ef0:	c795                	beqz	a5,80010f1c <.L106>
				{
					/* the next fragment of the SDO Information response shall be sent */
					/* initialize size with the maximum size fits into one mailbox service */
					{
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
80010ef2:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80010ef6:	17d1                	add	a5,a5,-12
80010ef8:	02f11e23          	sh	a5,60(sp)
					}
					/* initialize pData with the pointer where the fragment has to be copied */
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
80010efc:	47b2                	lw	a5,12(sp)
80010efe:	0799                	add	a5,a5,6
80010f00:	0799                	add	a5,a5,6
80010f02:	da3e                	sw	a5,52(sp)
					/* initialize index with the next index to be sent */
					index = nSdoInfoIndex;
80010f04:	15e1d783          	lhu	a5,350(gp) # 12094d6 <nSdoInfoIndex>
80010f08:	00f11e23          	sh	a5,28(sp)
					/* decrement the number of fragments to be sent */
					nSdoInfoFragmentsLeft--;
80010f0c:	1601d783          	lhu	a5,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>
80010f10:	17fd                	add	a5,a5,-1
80010f12:	0807c733          	zext.h	a4,a5
80010f16:	16e19023          	sh	a4,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>
80010f1a:	a885                	j	80010f8a <.L107>

80010f1c <.L106>:
				}
				else
				{
					/* the first fragment of the SDO Information response has to be sent */
					/* get the number of objects of the requested object list */
					n = OBJ_GetNoOfObjects(listType);
80010f1c:	02714783          	lbu	a5,39(sp)
80010f20:	853e                	mv	a0,a5
80010f22:	c13fe0ef          	jal	8000fb34 <OBJ_GetNoOfObjects>
80010f26:	87aa                	mv	a5,a0
80010f28:	02f11223          	sh	a5,36(sp)
					/* we start with index 0x1000 */
					index = 0x1000;
80010f2c:	6785                	lui	a5,0x1
80010f2e:	00f11e23          	sh	a5,28(sp)
					/* initialize size with the maximum size fits into one mailbox service */
					{
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
80010f32:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80010f36:	17c9                	add	a5,a5,-14 # ff2 <.L76+0x2c>
80010f38:	02f11e23          	sh	a5,60(sp)
					}
					/* initialize pData with the pointer where the fragment has to be copied */
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >> 1];
80010f3c:	47b2                	lw	a5,12(sp)
80010f3e:	0799                	add	a5,a5,6
80010f40:	07a1                	add	a5,a5,8
80010f42:	da3e                	sw	a5,52(sp)
					/*Check if List need to be send in fragments*/
					if ((n << 1) > size)
80010f44:	02415783          	lhu	a5,36(sp)
80010f48:	00179713          	sll	a4,a5,0x1
80010f4c:	03c15783          	lhu	a5,60(sp)
80010f50:	02e7db63          	bge	a5,a4,80010f86 <.L108>

80010f54 <.LBB16>:
						/*number of Bytes to transmit don't fit into one mailbox datagram*/

						/*calculate number of fragments which need to be send
						total number of bytes - bytes which will be transmitted with the current response plus the fragment size - 1 (to round up) divided by the size of the following fragments
						*/
						UINT16 Fragsize = size + 2;
80010f54:	03c15783          	lhu	a5,60(sp)
80010f58:	0789                	add	a5,a5,2
80010f5a:	02f11123          	sh	a5,34(sp)

						nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
80010f5e:	02415783          	lhu	a5,36(sp)
80010f62:	00179713          	sll	a4,a5,0x1
80010f66:	03c15783          	lhu	a5,60(sp)
80010f6a:	8f1d                	sub	a4,a4,a5
80010f6c:	02215783          	lhu	a5,34(sp)
80010f70:	17fd                	add	a5,a5,-1
80010f72:	973e                	add	a4,a4,a5
80010f74:	02215783          	lhu	a5,34(sp)
80010f78:	02f747b3          	div	a5,a4,a5
80010f7c:	0807c733          	zext.h	a4,a5
80010f80:	16e19023          	sh	a4,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>

80010f84 <.LBE16>:
80010f84:	a019                	j	80010f8a <.L107>

80010f86 <.L108>:
					}
					else
					{
						nSdoInfoFragmentsLeft = 0;
80010f86:	16019023          	sh	zero,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>

80010f8a <.L107>:
					}
				}

				/* get the next part of the requested object list */
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
80010f8a:	02714783          	lbu	a5,39(sp)
80010f8e:	0807c7b3          	zext.h	a5,a5
80010f92:	01f10713          	add	a4,sp,31
80010f96:	03c15603          	lhu	a2,60(sp)
80010f9a:	086c                	add	a1,sp,28
80010f9c:	56d2                	lw	a3,52(sp)
80010f9e:	853e                	mv	a0,a5
80010fa0:	c5dfe0ef          	jal	8000fbfc <OBJ_GetObjectList>
80010fa4:	87aa                	mv	a5,a0
80010fa6:	02f11e23          	sh	a5,60(sp)

				/* store index for next fragment */
				nSdoInfoIndex = index;
80010faa:	01c15703          	lhu	a4,28(sp)
80010fae:	14e19f23          	sh	a4,350(gp) # 12094d6 <nSdoInfoIndex>
				/* size contains before the instruction the size still available in the mailbox buffer
					and shall contain the size of the mailbox response data after the next instruction */
				{
					size = u16SendMbxSize - size - MBX_HEADER_SIZE;
80010fb2:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
80010fb6:	03c15703          	lhu	a4,60(sp)
80010fba:	8f99                	sub	a5,a5,a4
80010fbc:	0807c7b3          	zext.h	a5,a5
80010fc0:	17e9                	add	a5,a5,-6
80010fc2:	02f11e23          	sh	a5,60(sp)

80010fc6 <.L105>:
				}
			}

			/* size of the mailbox response data */
			pSdoInfoInd->MbxHeader.Length = size;
80010fc6:	47b2                	lw	a5,12(sp)
80010fc8:	5772                	lw	a4,60(sp)
80010fca:	0ff77713          	zext.b	a4,a4
80010fce:	0007c683          	lbu	a3,0(a5)
80010fd2:	8a81                	and	a3,a3,0
80010fd4:	8f55                	or	a4,a4,a3
80010fd6:	00e78023          	sb	a4,0(a5)
80010fda:	5772                	lw	a4,60(sp)
80010fdc:	8321                	srl	a4,a4,0x8
80010fde:	0ff77713          	zext.b	a4,a4
80010fe2:	0017c683          	lbu	a3,1(a5)
80010fe6:	8a81                	and	a3,a3,0
80010fe8:	8f55                	or	a4,a4,a3
80010fea:	00e780a3          	sb	a4,1(a5)

			if (abort == 0)
80010fee:	01f14783          	lbu	a5,31(sp)
80010ff2:	40079f63          	bnez	a5,80011410 <.L124>
			{
				pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
80010ff6:	47b2                	lw	a5,12(sp)
80010ff8:	0087c703          	lbu	a4,8(a5)
80010ffc:	0097c783          	lbu	a5,9(a5)
80011000:	07a2                	sll	a5,a5,0x8
80011002:	8fd9                	or	a5,a5,a4
80011004:	0807c7b3          	zext.h	a5,a5
80011008:	f807f793          	and	a5,a5,-128
8001100c:	0807c733          	zext.h	a4,a5
80011010:	47b2                	lw	a5,12(sp)
80011012:	0ff77693          	zext.b	a3,a4
80011016:	0087c603          	lbu	a2,8(a5)
8001101a:	8a01                	and	a2,a2,0
8001101c:	8ed1                	or	a3,a3,a2
8001101e:	00d78423          	sb	a3,8(a5)
80011022:	8321                	srl	a4,a4,0x8
80011024:	08074733          	zext.h	a4,a4
80011028:	0097c683          	lbu	a3,9(a5)
8001102c:	8a81                	and	a3,a3,0
8001102e:	8f55                	or	a4,a4,a3
80011030:	00e784a3          	sb	a4,9(a5)
				pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
80011034:	47b2                	lw	a5,12(sp)
80011036:	0087c703          	lbu	a4,8(a5)
8001103a:	0097c783          	lbu	a5,9(a5)
8001103e:	07a2                	sll	a5,a5,0x8
80011040:	8fd9                	or	a5,a5,a4
80011042:	0807c7b3          	zext.h	a5,a5
80011046:	0027e793          	or	a5,a5,2
8001104a:	0807c733          	zext.h	a4,a5
8001104e:	47b2                	lw	a5,12(sp)
80011050:	0ff77693          	zext.b	a3,a4
80011054:	0087c603          	lbu	a2,8(a5)
80011058:	8a01                	and	a2,a2,0
8001105a:	8ed1                	or	a3,a3,a2
8001105c:	00d78423          	sb	a3,8(a5)
80011060:	8321                	srl	a4,a4,0x8
80011062:	08074733          	zext.h	a4,a4
80011066:	0097c683          	lbu	a3,9(a5)
8001106a:	8a81                	and	a3,a3,0
8001106c:	8f55                	or	a4,a4,a3
8001106e:	00e784a3          	sb	a4,9(a5)
				/* number of fragments still has to be sent */
				pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
80011072:	1601d703          	lhu	a4,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>
80011076:	47b2                	lw	a5,12(sp)
80011078:	0ff77693          	zext.b	a3,a4
8001107c:	00a7c603          	lbu	a2,10(a5)
80011080:	8a01                	and	a2,a2,0
80011082:	8ed1                	or	a3,a3,a2
80011084:	00d78523          	sb	a3,10(a5)
80011088:	8321                	srl	a4,a4,0x8
8001108a:	08074733          	zext.h	a4,a4
8001108e:	00b7c683          	lbu	a3,11(a5)
80011092:	8a81                	and	a3,a3,0
80011094:	8f55                	or	a4,a4,a3
80011096:	00e785a3          	sb	a4,11(a5)

				if (nSdoInfoFragmentsLeft)
8001109a:	1601d783          	lhu	a5,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>
8001109e:	36078963          	beqz	a5,80011410 <.L124>
				{
					/* there still are fragments to be sent,
					   the InComplete flag in the SDO Information response has to be sent */
					pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEADER_INCOMPLETE_MASK;
800110a2:	47b2                	lw	a5,12(sp)
800110a4:	0087c703          	lbu	a4,8(a5)
800110a8:	0097c783          	lbu	a5,9(a5)
800110ac:	07a2                	sll	a5,a5,0x8
800110ae:	8fd9                	or	a5,a5,a4
800110b0:	0807c7b3          	zext.h	a5,a5
800110b4:	f7f7f793          	and	a5,a5,-129
800110b8:	0807c733          	zext.h	a4,a5
800110bc:	47b2                	lw	a5,12(sp)
800110be:	0ff77693          	zext.b	a3,a4
800110c2:	0087c603          	lbu	a2,8(a5)
800110c6:	8a01                	and	a2,a2,0
800110c8:	8ed1                	or	a3,a3,a2
800110ca:	00d78423          	sb	a3,8(a5)
800110ce:	8321                	srl	a4,a4,0x8
800110d0:	08074733          	zext.h	a4,a4
800110d4:	0097c683          	lbu	a3,9(a5)
800110d8:	8a81                	and	a3,a3,0
800110da:	8f55                	or	a4,a4,a3
800110dc:	00e784a3          	sb	a4,9(a5)
					pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
800110e0:	47b2                	lw	a5,12(sp)
800110e2:	0087c703          	lbu	a4,8(a5)
800110e6:	0097c783          	lbu	a5,9(a5)
800110ea:	07a2                	sll	a5,a5,0x8
800110ec:	8fd9                	or	a5,a5,a4
800110ee:	0807c7b3          	zext.h	a5,a5
800110f2:	0807e793          	or	a5,a5,128
800110f6:	0807c733          	zext.h	a4,a5
800110fa:	47b2                	lw	a5,12(sp)
800110fc:	0ff77693          	zext.b	a3,a4
80011100:	0087c603          	lbu	a2,8(a5)
80011104:	8a01                	and	a2,a2,0
80011106:	8ed1                	or	a3,a3,a2
80011108:	00d78423          	sb	a3,8(a5)
8001110c:	8321                	srl	a4,a4,0x8
8001110e:	08074733          	zext.h	a4,a4
80011112:	0097c683          	lbu	a3,9(a5)
80011116:	8a81                	and	a3,a3,0
80011118:	8f55                	or	a4,a4,a3
8001111a:	00e784a3          	sb	a4,9(a5)
					/* the FRAGMENTS_FOLLOW flag has to be set for the function MBX_MailboxSendReq to
					   indicate the mailbox handler that still fragments has to be sent so that this
						function shall be called again from COE_ContinueInd when the actual mailbox buffer
						was sent */
					flags = FRAGMENTS_FOLLOW | COE_SERVICE;
8001111e:	f8200793          	li	a5,-126
80011122:	02f10fa3          	sb	a5,63(sp)

80011126 <.LBE12>:
				}
			}
		}
		break;
80011126:	a4ed                	j	80011410 <.L124>

80011128 <.L98>:

	case SDOINFOSERVICE_OBJDESCRIPTION_Q:
	case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
		/* get the requested index */
		index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
80011128:	47b2                	lw	a5,12(sp)
8001112a:	00c7c703          	lbu	a4,12(a5)
8001112e:	00d7c783          	lbu	a5,13(a5)
80011132:	07a2                	sll	a5,a5,0x8
80011134:	8fd9                	or	a5,a5,a4
80011136:	0807c7b3          	zext.h	a5,a5
8001113a:	00f11e23          	sh	a5,28(sp)



		if (index < 0x1000)
8001113e:	01c15703          	lhu	a4,28(sp)
80011142:	6785                	lui	a5,0x1
80011144:	00f77663          	bgeu	a4,a5,80011150 <.L110>
		{
			/*SDO Info access is only allowed for objects >= 0x1000*/
			abort = ABORTIDX_UNSUPPORTED_ACCESS;
80011148:	4795                	li	a5,5
8001114a:	00f10fa3          	sb	a5,31(sp)
			else
			{
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
			}
		}
		break;
8001114e:	a4d9                	j	80011414 <.L125>

80011150 <.L110>:
			pObjEntry = OBJ_GetObjectHandle(index);
80011150:	01c15783          	lhu	a5,28(sp)
80011154:	853e                	mv	a0,a5
80011156:	9a7fe0ef          	jal	8000fafc <OBJ_GetObjectHandle>
8001115a:	d62a                	sw	a0,44(sp)
			if (pObjEntry)
8001115c:	57b2                	lw	a5,44(sp)
8001115e:	2a078163          	beqz	a5,80011400 <.L112>

80011162 <.LBB17>:
				UINT16 size = 0;
80011162:	02011923          	sh	zero,50(sp)
				if (opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q)
80011166:	03114703          	lbu	a4,49(sp)
8001116a:	478d                	li	a5,3
8001116c:	06f71663          	bne	a4,a5,800111d8 <.L113>
					OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
80011170:	47b2                	lw	a5,12(sp)
80011172:	00e78413          	add	s0,a5,14 # 100e <.L79+0x8>
80011176:	5532                	lw	a0,44(sp)
80011178:	b13f80ef          	jal	80009c8a <OBJ_GetObjDesc>
8001117c:	87aa                	mv	a5,a0
8001117e:	4611                	li	a2,4
80011180:	85be                	mv	a1,a5
80011182:	8522                	mv	a0,s0
80011184:	ad9fc0ef          	jal	8000dc5c <memcpy>
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
80011188:	01c15783          	lhu	a5,28(sp)
8001118c:	4681                	li	a3,0
8001118e:	5632                	lw	a2,44(sp)
80011190:	4581                	li	a1,0
80011192:	853e                	mv	a0,a5
80011194:	b9dfe0ef          	jal	8000fd30 <OBJ_GetDesc>
80011198:	87aa                	mv	a5,a0
8001119a:	07b1                	add	a5,a5,12
8001119c:	02f11923          	sh	a5,50(sp)
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
800111a0:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
800111a4:	ffb78713          	add	a4,a5,-5
800111a8:	03215783          	lhu	a5,50(sp)
800111ac:	00e7c663          	blt	a5,a4,800111b8 <.L114>
						size = SIZEOF_SDOINFOOBJSTRUCT;
800111b0:	47b1                	li	a5,12
800111b2:	02f11923          	sh	a5,50(sp)
800111b6:	aaa5                	j	8001132e <.L115>

800111b8 <.L114>:
						size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
800111b8:	01c15703          	lhu	a4,28(sp)
800111bc:	47b2                	lw	a5,12(sp)
800111be:	07b9                	add	a5,a5,14
800111c0:	0791                	add	a5,a5,4
800111c2:	86be                	mv	a3,a5
800111c4:	5632                	lw	a2,44(sp)
800111c6:	4581                	li	a1,0
800111c8:	853a                	mv	a0,a4
800111ca:	b67fe0ef          	jal	8000fd30 <OBJ_GetDesc>
800111ce:	87aa                	mv	a5,a0
800111d0:	07b1                	add	a5,a5,12
800111d2:	02f11923          	sh	a5,50(sp)
800111d6:	aaa1                	j	8001132e <.L115>

800111d8 <.L113>:
					UINT8 subindex = (UINT8)((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
800111d8:	47b2                	lw	a5,12(sp)
800111da:	00e7c703          	lbu	a4,14(a5)
800111de:	00f7c783          	lbu	a5,15(a5)
800111e2:	07a2                	sll	a5,a5,0x8
800111e4:	8fd9                	or	a5,a5,a4
800111e6:	0807c7b3          	zext.h	a5,a5
800111ea:	02f105a3          	sb	a5,43(sp)
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
800111ee:	5532                	lw	a0,44(sp)
800111f0:	a9bf80ef          	jal	80009c8a <OBJ_GetObjDesc>
800111f4:	87aa                	mv	a5,a0
800111f6:	0027c703          	lbu	a4,2(a5)
800111fa:	0037c783          	lbu	a5,3(a5)
800111fe:	07a2                	sll	a5,a5,0x8
80011200:	8fd9                	or	a5,a5,a4
80011202:	0807c7b3          	zext.h	a5,a5
80011206:	02f10523          	sb	a5,42(sp)
					if (subindex <= maxSubindex)
8001120a:	02b14703          	lbu	a4,43(sp)
8001120e:	02a14783          	lbu	a5,42(sp)
80011212:	10e7eb63          	bltu	a5,a4,80011328 <.L116>

80011216 <.LBB19>:
						OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
80011216:	47b2                	lw	a5,12(sp)
80011218:	01078413          	add	s0,a5,16
8001121c:	02b14783          	lbu	a5,43(sp)
80011220:	85be                	mv	a1,a5
80011222:	5532                	lw	a0,44(sp)
80011224:	a0df80ef          	jal	80009c30 <OBJ_GetEntryDesc>
80011228:	87aa                	mv	a5,a0
8001122a:	4619                	li	a2,6
8001122c:	85be                	mv	a1,a5
8001122e:	8522                	mv	a0,s0
80011230:	a2dfc0ef          	jal	8000dc5c <memcpy>
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
80011234:	47b2                	lw	a5,12(sp)
80011236:	00e7c703          	lbu	a4,14(a5)
8001123a:	00f7c783          	lbu	a5,15(a5)
8001123e:	07a2                	sll	a5,a5,0x8
80011240:	8fd9                	or	a5,a5,a4
80011242:	0807c7b3          	zext.h	a5,a5
80011246:	0ff7f793          	zext.b	a5,a5
8001124a:	0807c733          	zext.h	a4,a5
8001124e:	47b2                	lw	a5,12(sp)
80011250:	0ff77693          	zext.b	a3,a4
80011254:	00e7c603          	lbu	a2,14(a5)
80011258:	8a01                	and	a2,a2,0
8001125a:	8ed1                	or	a3,a3,a2
8001125c:	00d78723          	sb	a3,14(a5)
80011260:	8321                	srl	a4,a4,0x8
80011262:	08074733          	zext.h	a4,a4
80011266:	00f7c683          	lbu	a3,15(a5)
8001126a:	8a81                	and	a3,a3,0
8001126c:	8f55                	or	a4,a4,a3
8001126e:	00e787a3          	sb	a4,15(a5)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
80011272:	5532                	lw	a0,44(sp)
80011274:	a17f80ef          	jal	80009c8a <OBJ_GetObjDesc>
80011278:	87aa                	mv	a5,a0
8001127a:	0027c703          	lbu	a4,2(a5)
8001127e:	0037c783          	lbu	a5,3(a5)
80011282:	07a2                	sll	a5,a5,0x8
80011284:	8fd9                	or	a5,a5,a4
80011286:	02f11423          	sh	a5,40(sp)
						ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
8001128a:	02815783          	lhu	a5,40(sp)
8001128e:	87a1                	sra	a5,a5,0x8
80011290:	0807c7b3          	zext.h	a5,a5
80011294:	8bbd                	and	a5,a5,15
80011296:	02f11423          	sh	a5,40(sp)
						if (((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0))
8001129a:	02815703          	lhu	a4,40(sp)
8001129e:	47a1                	li	a5,8
800112a0:	00f70763          	beq	a4,a5,800112ae <.L117>
800112a4:	02815703          	lhu	a4,40(sp)
800112a8:	47a5                	li	a5,9
800112aa:	02f71363          	bne	a4,a5,800112d0 <.L118>

800112ae <.L117>:
800112ae:	02b14783          	lbu	a5,43(sp)
800112b2:	ef99                	bnez	a5,800112d0 <.L118>
							OBJTOMBXSTRCPY(((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc));
800112b4:	47b2                	lw	a5,12(sp)
800112b6:	07c1                	add	a5,a5,16
800112b8:	00678713          	add	a4,a5,6
800112bc:	4635                	li	a2,13
800112be:	34820593          	add	a1,tp,840 # 348 <default_isr_62+0x52>
800112c2:	853a                	mv	a0,a4
800112c4:	999fc0ef          	jal	8000dc5c <memcpy>
							size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
800112c8:	47f1                	li	a5,28
800112ca:	02f11923          	sh	a5,50(sp)
800112ce:	a085                	j	8001132e <.L115>

800112d0 <.L118>:
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
800112d0:	01c15783          	lhu	a5,28(sp)
800112d4:	02b14703          	lbu	a4,43(sp)
800112d8:	4681                	li	a3,0
800112da:	5632                	lw	a2,44(sp)
800112dc:	85ba                	mv	a1,a4
800112de:	853e                	mv	a0,a5
800112e0:	a51fe0ef          	jal	8000fd30 <OBJ_GetDesc>
800112e4:	87aa                	mv	a5,a0
800112e6:	07c1                	add	a5,a5,16
800112e8:	02f11923          	sh	a5,50(sp)
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
800112ec:	ffe1d783          	lhu	a5,-2(gp) # 1209376 <u16SendMbxSize>
800112f0:	ffb78713          	add	a4,a5,-5
800112f4:	03215783          	lhu	a5,50(sp)
800112f8:	00e7c663          	blt	a5,a4,80011304 <.L120>
								size = SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
800112fc:	47c1                	li	a5,16
800112fe:	02f11923          	sh	a5,50(sp)
80011302:	a035                	j	8001132e <.L115>

80011304 <.L120>:
								size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
80011304:	01c15703          	lhu	a4,28(sp)
80011308:	47b2                	lw	a5,12(sp)
8001130a:	07c1                	add	a5,a5,16
8001130c:	00678693          	add	a3,a5,6
80011310:	02b14783          	lbu	a5,43(sp)
80011314:	5632                	lw	a2,44(sp)
80011316:	85be                	mv	a1,a5
80011318:	853a                	mv	a0,a4
8001131a:	a17fe0ef          	jal	8000fd30 <OBJ_GetDesc>
8001131e:	87aa                	mv	a5,a0
80011320:	07c1                	add	a5,a5,16
80011322:	02f11923          	sh	a5,50(sp)
80011326:	a021                	j	8001132e <.L115>

80011328 <.L116>:
						abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
80011328:	47c5                	li	a5,17
8001132a:	00f10fa3          	sb	a5,31(sp)

8001132e <.L115>:
				if (abort == 0)
8001132e:	01f14783          	lbu	a5,31(sp)
80011332:	e3ed                	bnez	a5,80011414 <.L125>
						pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
80011334:	47b2                	lw	a5,12(sp)
80011336:	00a7c703          	lbu	a4,10(a5)
8001133a:	8b01                	and	a4,a4,0
8001133c:	00e78523          	sb	a4,10(a5)
80011340:	00b7c703          	lbu	a4,11(a5)
80011344:	8b01                	and	a4,a4,0
80011346:	00e785a3          	sb	a4,11(a5)
						pSdoInfoInd->MbxHeader.Length = size;
8001134a:	47b2                	lw	a5,12(sp)
8001134c:	03215703          	lhu	a4,50(sp)
80011350:	0ff77713          	zext.b	a4,a4
80011354:	0007c683          	lbu	a3,0(a5)
80011358:	8a81                	and	a3,a3,0
8001135a:	8f55                	or	a4,a4,a3
8001135c:	00e78023          	sb	a4,0(a5)
80011360:	03215703          	lhu	a4,50(sp)
80011364:	8321                	srl	a4,a4,0x8
80011366:	08074733          	zext.h	a4,a4
8001136a:	0017c683          	lbu	a3,1(a5)
8001136e:	8a81                	and	a3,a3,0
80011370:	8f55                	or	a4,a4,a3
80011372:	00e780a3          	sb	a4,1(a5)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
80011376:	47b2                	lw	a5,12(sp)
80011378:	0087c703          	lbu	a4,8(a5)
8001137c:	0097c783          	lbu	a5,9(a5)
80011380:	07a2                	sll	a5,a5,0x8
80011382:	8fd9                	or	a5,a5,a4
80011384:	0807c7b3          	zext.h	a5,a5
80011388:	f807f793          	and	a5,a5,-128
8001138c:	0807c733          	zext.h	a4,a5
80011390:	47b2                	lw	a5,12(sp)
80011392:	0ff77693          	zext.b	a3,a4
80011396:	0087c603          	lbu	a2,8(a5)
8001139a:	8a01                	and	a2,a2,0
8001139c:	8ed1                	or	a3,a3,a2
8001139e:	00d78423          	sb	a3,8(a5)
800113a2:	8321                	srl	a4,a4,0x8
800113a4:	08074733          	zext.h	a4,a4
800113a8:	0097c683          	lbu	a3,9(a5)
800113ac:	8a81                	and	a3,a3,0
800113ae:	8f55                	or	a4,a4,a3
800113b0:	00e784a3          	sb	a4,9(a5)
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
800113b4:	47b2                	lw	a5,12(sp)
800113b6:	0087c703          	lbu	a4,8(a5)
800113ba:	0097c783          	lbu	a5,9(a5)
800113be:	07a2                	sll	a5,a5,0x8
800113c0:	8fd9                	or	a5,a5,a4
800113c2:	0807c733          	zext.h	a4,a5
800113c6:	03114783          	lbu	a5,49(sp)
800113ca:	0807c7b3          	zext.h	a5,a5
800113ce:	0785                	add	a5,a5,1
800113d0:	0807c7b3          	zext.h	a5,a5
800113d4:	8fd9                	or	a5,a5,a4
800113d6:	0807c733          	zext.h	a4,a5
800113da:	47b2                	lw	a5,12(sp)
800113dc:	0ff77693          	zext.b	a3,a4
800113e0:	0087c603          	lbu	a2,8(a5)
800113e4:	8a01                	and	a2,a2,0
800113e6:	8ed1                	or	a3,a3,a2
800113e8:	00d78423          	sb	a3,8(a5)
800113ec:	8321                	srl	a4,a4,0x8
800113ee:	08074733          	zext.h	a4,a4
800113f2:	0097c683          	lbu	a3,9(a5)
800113f6:	8a81                	and	a3,a3,0
800113f8:	8f55                	or	a4,a4,a3
800113fa:	00e784a3          	sb	a4,9(a5)

800113fe <.LBE17>:
		break;
800113fe:	a819                	j	80011414 <.L125>

80011400 <.L112>:
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
80011400:	47a1                	li	a5,8
80011402:	00f10fa3          	sb	a5,31(sp)
		break;
80011406:	a039                	j	80011414 <.L125>

80011408 <.L99>:
	default:
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
80011408:	478d                	li	a5,3
8001140a:	00f10fa3          	sb	a5,31(sp)
8001140e:	a021                	j	80011416 <.L109>

80011410 <.L124>:
		break;
80011410:	0001                	nop
80011412:	a011                	j	80011416 <.L109>

80011414 <.L125>:
		break;
80011414:	0001                	nop

80011416 <.L109>:
	}

	if (abort)
80011416:	01f14783          	lbu	a5,31(sp)
8001141a:	10078963          	beqz	a5,8001152c <.L121>
	{
		/* send a SDO Information Error response */
		pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
8001141e:	47b2                	lw	a5,12(sp)
80011420:	0007c703          	lbu	a4,0(a5)
80011424:	8b01                	and	a4,a4,0
80011426:	00a76713          	or	a4,a4,10
8001142a:	00e78023          	sb	a4,0(a5)
8001142e:	0017c703          	lbu	a4,1(a5)
80011432:	8b01                	and	a4,a4,0
80011434:	00e780a3          	sb	a4,1(a5)

		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
80011438:	47b2                	lw	a5,12(sp)
8001143a:	0087c703          	lbu	a4,8(a5)
8001143e:	0097c783          	lbu	a5,9(a5)
80011442:	07a2                	sll	a5,a5,0x8
80011444:	8fd9                	or	a5,a5,a4
80011446:	0807c7b3          	zext.h	a5,a5
8001144a:	f807f793          	and	a5,a5,-128
8001144e:	0807c733          	zext.h	a4,a5
80011452:	47b2                	lw	a5,12(sp)
80011454:	0ff77693          	zext.b	a3,a4
80011458:	0087c603          	lbu	a2,8(a5)
8001145c:	8a01                	and	a2,a2,0
8001145e:	8ed1                	or	a3,a3,a2
80011460:	00d78423          	sb	a3,8(a5)
80011464:	8321                	srl	a4,a4,0x8
80011466:	08074733          	zext.h	a4,a4
8001146a:	0097c683          	lbu	a3,9(a5)
8001146e:	8a81                	and	a3,a3,0
80011470:	8f55                	or	a4,a4,a3
80011472:	00e784a3          	sb	a4,9(a5)
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
80011476:	47b2                	lw	a5,12(sp)
80011478:	0087c703          	lbu	a4,8(a5)
8001147c:	0097c783          	lbu	a5,9(a5)
80011480:	07a2                	sll	a5,a5,0x8
80011482:	8fd9                	or	a5,a5,a4
80011484:	0807c7b3          	zext.h	a5,a5
80011488:	0077e793          	or	a5,a5,7
8001148c:	0807c733          	zext.h	a4,a5
80011490:	47b2                	lw	a5,12(sp)
80011492:	0ff77693          	zext.b	a3,a4
80011496:	0087c603          	lbu	a2,8(a5)
8001149a:	8a01                	and	a2,a2,0
8001149c:	8ed1                	or	a3,a3,a2
8001149e:	00d78423          	sb	a3,8(a5)
800114a2:	8321                	srl	a4,a4,0x8
800114a4:	08074733          	zext.h	a4,a4
800114a8:	0097c683          	lbu	a3,9(a5)
800114ac:	8a81                	and	a3,a3,0
800114ae:	8f55                	or	a4,a4,a3
800114b0:	00e784a3          	sb	a4,9(a5)

		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
800114b4:	47b2                	lw	a5,12(sp)
800114b6:	00a7c703          	lbu	a4,10(a5)
800114ba:	8b01                	and	a4,a4,0
800114bc:	00e78523          	sb	a4,10(a5)
800114c0:	00b7c703          	lbu	a4,11(a5)
800114c4:	8b01                	and	a4,a4,0
800114c6:	00e785a3          	sb	a4,11(a5)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
800114ca:	01f14783          	lbu	a5,31(sp)
800114ce:	86be                	mv	a3,a5
800114d0:	800057b7          	lui	a5,0x80005
800114d4:	08478713          	add	a4,a5,132 # 80005084 <cAbortCode>
800114d8:	00269793          	sll	a5,a3,0x2
800114dc:	97ba                	add	a5,a5,a4
800114de:	4398                	lw	a4,0(a5)
800114e0:	47b2                	lw	a5,12(sp)
800114e2:	0ff77693          	zext.b	a3,a4
800114e6:	00c7c603          	lbu	a2,12(a5)
800114ea:	8a01                	and	a2,a2,0
800114ec:	8ed1                	or	a3,a3,a2
800114ee:	00d78623          	sb	a3,12(a5)
800114f2:	00875693          	srl	a3,a4,0x8
800114f6:	0ff6f693          	zext.b	a3,a3
800114fa:	00d7c603          	lbu	a2,13(a5)
800114fe:	8a01                	and	a2,a2,0
80011500:	8ed1                	or	a3,a3,a2
80011502:	00d786a3          	sb	a3,13(a5)
80011506:	01075693          	srl	a3,a4,0x10
8001150a:	0ff6f693          	zext.b	a3,a3
8001150e:	00e7c603          	lbu	a2,14(a5)
80011512:	8a01                	and	a2,a2,0
80011514:	8ed1                	or	a3,a3,a2
80011516:	00d78723          	sb	a3,14(a5)
8001151a:	8361                	srl	a4,a4,0x18
8001151c:	00f7c683          	lbu	a3,15(a5)
80011520:	8a81                	and	a3,a3,0
80011522:	8f55                	or	a4,a4,a3
80011524:	00e787a3          	sb	a4,15(a5)

		nSdoInfoFragmentsLeft = 0;
80011528:	16019023          	sh	zero,352(gp) # 12094d8 <nSdoInfoFragmentsLeft>

8001152c <.L121>:
	}

	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
8001152c:	03f14783          	lbu	a5,63(sp)
80011530:	85be                	mv	a1,a5
80011532:	4532                	lw	a0,12(sp)
80011534:	9acf80ef          	jal	800096e0 <MBX_MailboxSendReq>
80011538:	87aa                	mv	a5,a0
8001153a:	c781                	beqz	a5,80011542 <.L122>
	{
		/* if the mailbox response could not be sent (or stored), the response will be
		   stored in the variable pCoeSendStored and will be sent automatically
			from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
			the next time from the master */
		pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
8001153c:	4732                	lw	a4,12(sp)
8001153e:	0ee1a623          	sw	a4,236(gp) # 1209464 <pCoeSendStored>

80011542 <.L122>:
	}

	return 0;
80011542:	4781                	li	a5,0

80011544 <.L123>:
}
80011544:	853e                	mv	a0,a5
80011546:	40b6                	lw	ra,76(sp)
80011548:	4426                	lw	s0,72(sp)
8001154a:	6161                	add	sp,sp,80
8001154c:	8082                	ret

Disassembly of section .text.gpio_read_pin:

8001154e <gpio_read_pin>:
{
8001154e:	1141                	add	sp,sp,-16
80011550:	c62a                	sw	a0,12(sp)
80011552:	c42e                	sw	a1,8(sp)
80011554:	87b2                	mv	a5,a2
80011556:	00f103a3          	sb	a5,7(sp)
    return (ptr->DI[port].VALUE & (1 << pin)) >> pin;
8001155a:	4732                	lw	a4,12(sp)
8001155c:	47a2                	lw	a5,8(sp)
8001155e:	0792                	sll	a5,a5,0x4
80011560:	97ba                	add	a5,a5,a4
80011562:	439c                	lw	a5,0(a5)
80011564:	00714703          	lbu	a4,7(sp)
80011568:	4685                	li	a3,1
8001156a:	00e69733          	sll	a4,a3,a4
8001156e:	8f7d                	and	a4,a4,a5
80011570:	00714783          	lbu	a5,7(sp)
80011574:	00f757b3          	srl	a5,a4,a5
80011578:	0ff7f793          	zext.b	a5,a5
}
8001157c:	853e                	mv	a0,a5
8001157e:	0141                	add	sp,sp,16
80011580:	8082                	ret

Disassembly of section .text.APPL_StartInputHandler:

80011582 <APPL_StartInputHandler>:
{
80011582:	1141                	add	sp,sp,-16
80011584:	c62a                	sw	a0,12(sp)
    return ALSTATUSCODE_NOERROR;
80011586:	4781                	li	a5,0
}
80011588:	853e                	mv	a0,a5
8001158a:	0141                	add	sp,sp,16
8001158c:	8082                	ret

Disassembly of section .text.APPL_Application:

8001158e <APPL_Application>:
{
8001158e:	1141                	add	sp,sp,-16
80011590:	c606                	sw	ra,12(sp)
    InputCounter0x6000 = APPL_GetDipSw();
80011592:	2891                	jal	800115e6 <APPL_GetDipSw>
80011594:	872a                	mv	a4,a0
80011596:	12e1ac23          	sw	a4,312(gp) # 12094b0 <InputCounter0x6000>
    APPL_SetLed((UINT32)OutputCounter0x7010);
8001159a:	1301a783          	lw	a5,304(gp) # 12094a8 <OutputCounter0x7010>
8001159e:	853e                	mv	a0,a5
800115a0:	2029                	jal	800115aa <.LFE261>
}
800115a2:	0001                	nop
800115a4:	40b2                	lw	ra,12(sp)
800115a6:	0141                	add	sp,sp,16
800115a8:	8082                	ret

Disassembly of section .text.APPL_SetLed:

800115aa <APPL_SetLed>:

extern void OLED_ShowNum(uint8_t x, uint8_t y, uint32_t num, uint8_t len, uint8_t size1, uint8_t mode);
extern void OLED_Refresh(void);

void APPL_SetLed(UINT32 value)
{
800115aa:	7179                	add	sp,sp,-48
800115ac:	d606                	sw	ra,44(sp)
800115ae:	c62a                	sw	a0,12(sp)
    UINT8 led0 = ((value > 0) ?  BOARD_LED_ON_LEVEL : BOARD_LED_OFF_LEVEL);
800115b0:	47b2                	lw	a5,12(sp)
800115b2:	0017b793          	seqz	a5,a5
800115b6:	0ff7f793          	zext.b	a5,a5
800115ba:	00f10fa3          	sb	a5,31(sp)
    OLED_ShowNum(0, 32, value, 10, 16, 1);
800115be:	4785                	li	a5,1
800115c0:	4741                	li	a4,16
800115c2:	46a9                	li	a3,10
800115c4:	4632                	lw	a2,12(sp)
800115c6:	02000593          	li	a1,32
800115ca:	4501                	li	a0,0
800115cc:	a2bf40ef          	jal	80005ff6 <OLED_ShowNum>
    OLED_Refresh();
800115d0:	909fc0ef          	jal	8000ded8 <OLED_Refresh>
    board_led_write(led0);
800115d4:	01f14783          	lbu	a5,31(sp)
800115d8:	853e                	mv	a0,a5
800115da:	455000ef          	jal	8001222e <board_led_write>
}
800115de:	0001                	nop
800115e0:	50b2                	lw	ra,44(sp)
800115e2:	6145                	add	sp,sp,48
800115e4:	8082                	ret

Disassembly of section .text.APPL_GetDipSw:

800115e6 <APPL_GetDipSw>:

UINT32 APPL_GetDipSw(void)
{
800115e6:	1101                	add	sp,sp,-32
800115e8:	ce06                	sw	ra,28(sp)
    UINT8 pin0_level = gpio_read_pin(BOARD_ECAT_IN1_GPIO, BOARD_ECAT_IN1_GPIO_PORT_INDEX, BOARD_ECAT_IN1_GPIO_PIN_INDEX);
800115ea:	4619                	li	a2,6
800115ec:	458d                	li	a1,3
800115ee:	f00d0537          	lui	a0,0xf00d0
800115f2:	3fb1                	jal	8001154e <gpio_read_pin>
800115f4:	87aa                	mv	a5,a0
800115f6:	00f107a3          	sb	a5,15(sp)
    UINT8 pin1_level = gpio_read_pin(BOARD_ECAT_IN2_GPIO, BOARD_ECAT_IN2_GPIO_PORT_INDEX, BOARD_ECAT_IN2_GPIO_PIN_INDEX);
800115fa:	4631                	li	a2,12
800115fc:	458d                	li	a1,3
800115fe:	f00d0537          	lui	a0,0xf00d0
80011602:	37b1                	jal	8001154e <gpio_read_pin>
80011604:	87aa                	mv	a5,a0
80011606:	00f10723          	sb	a5,14(sp)

    UINT32 val = pin0_level << 0 | pin1_level << 1;
8001160a:	00f14703          	lbu	a4,15(sp)
8001160e:	00e14783          	lbu	a5,14(sp)
80011612:	0786                	sll	a5,a5,0x1
80011614:	8fd9                	or	a5,a5,a4
80011616:	c43e                	sw	a5,8(sp)

    return val;
80011618:	47a2                	lw	a5,8(sp)
}
8001161a:	853e                	mv	a0,a5
8001161c:	40f2                	lw	ra,28(sp)
8001161e:	6105                	add	sp,sp,32
80011620:	8082                	ret

Disassembly of section .text.gptmr_enable_irq:

80011622 <gptmr_enable_irq>:
{
80011622:	1141                	add	sp,sp,-16
80011624:	c62a                	sw	a0,12(sp)
80011626:	c42e                	sw	a1,8(sp)
    ptr->IRQEN |= irq_mask;
80011628:	47b2                	lw	a5,12(sp)
8001162a:	2047a703          	lw	a4,516(a5)
8001162e:	47a2                	lw	a5,8(sp)
80011630:	8f5d                	or	a4,a4,a5
80011632:	47b2                	lw	a5,12(sp)
80011634:	20e7a223          	sw	a4,516(a5)
}
80011638:	0001                	nop
8001163a:	0141                	add	sp,sp,16
8001163c:	8082                	ret

Disassembly of section .text.gptmr_check_status:

8001163e <gptmr_check_status>:
{
8001163e:	1141                	add	sp,sp,-16
80011640:	c62a                	sw	a0,12(sp)
80011642:	c42e                	sw	a1,8(sp)
    return (ptr->SR & mask) == mask;
80011644:	47b2                	lw	a5,12(sp)
80011646:	2007a703          	lw	a4,512(a5)
8001164a:	47a2                	lw	a5,8(sp)
8001164c:	8ff9                	and	a5,a5,a4
8001164e:	4722                	lw	a4,8(sp)
80011650:	40f707b3          	sub	a5,a4,a5
80011654:	0017b793          	seqz	a5,a5
80011658:	0ff7f793          	zext.b	a5,a5
}
8001165c:	853e                	mv	a0,a5
8001165e:	0141                	add	sp,sp,16
80011660:	8082                	ret

Disassembly of section .text.gptmr_clear_status:

80011662 <gptmr_clear_status>:
{
80011662:	1141                	add	sp,sp,-16
80011664:	c62a                	sw	a0,12(sp)
80011666:	c42e                	sw	a1,8(sp)
    ptr->SR = mask;
80011668:	47b2                	lw	a5,12(sp)
8001166a:	4722                	lw	a4,8(sp)
8001166c:	20e7a023          	sw	a4,512(a5)
}
80011670:	0001                	nop
80011672:	0141                	add	sp,sp,16
80011674:	8082                	ret

Disassembly of section .text.gptmr_start_counter:

80011676 <gptmr_start_counter>:
 *
 * @param [in] ptr GPTMR base address
 * @param [in] ch_index channel index
 */
static inline void gptmr_start_counter(GPTMR_Type *ptr, uint8_t ch_index)
{
80011676:	1101                	add	sp,sp,-32
80011678:	ce06                	sw	ra,28(sp)
8001167a:	c62a                	sw	a0,12(sp)
8001167c:	87ae                	mv	a5,a1
8001167e:	00f105a3          	sb	a5,11(sp)
#if defined(HPM_IP_FEATURE_GPTMR_OP_MODE) && (HPM_IP_FEATURE_GPTMR_OP_MODE  == 1)
    /* if support opmode, should clear CEN and set CEN */
     if (gptmr_channel_is_opmode(ptr, ch_index) == true) {
80011682:	00b14783          	lbu	a5,11(sp)
80011686:	85be                	mv	a1,a5
80011688:	4532                	lw	a0,12(sp)
8001168a:	ec1f90ef          	jal	8000b54a <gptmr_channel_is_opmode>
8001168e:	87aa                	mv	a5,a0
80011690:	cf99                	beqz	a5,800116ae <.L8>
        ptr->CHANNEL[ch_index].CR &= ~GPTMR_CHANNEL_CR_CEN_MASK;
80011692:	00b14783          	lbu	a5,11(sp)
80011696:	4732                	lw	a4,12(sp)
80011698:	079a                	sll	a5,a5,0x6
8001169a:	97ba                	add	a5,a5,a4
8001169c:	4398                	lw	a4,0(a5)
8001169e:	00b14783          	lbu	a5,11(sp)
800116a2:	bff77713          	and	a4,a4,-1025
800116a6:	46b2                	lw	a3,12(sp)
800116a8:	079a                	sll	a5,a5,0x6
800116aa:	97b6                	add	a5,a5,a3
800116ac:	c398                	sw	a4,0(a5)

800116ae <.L8>:
     }
#endif
    ptr->CHANNEL[ch_index].CR |= GPTMR_CHANNEL_CR_CEN_MASK;
800116ae:	00b14783          	lbu	a5,11(sp)
800116b2:	4732                	lw	a4,12(sp)
800116b4:	079a                	sll	a5,a5,0x6
800116b6:	97ba                	add	a5,a5,a4
800116b8:	4398                	lw	a4,0(a5)
800116ba:	00b14783          	lbu	a5,11(sp)
800116be:	40076713          	or	a4,a4,1024
800116c2:	46b2                	lw	a3,12(sp)
800116c4:	079a                	sll	a5,a5,0x6
800116c6:	97b6                	add	a5,a5,a3
800116c8:	c398                	sw	a4,0(a5)
}
800116ca:	0001                	nop
800116cc:	40f2                	lw	ra,28(sp)
800116ce:	6105                	add	sp,sp,32
800116d0:	8082                	ret

Disassembly of section .text.esc_phy_enable_clock:

800116d2 <esc_phy_enable_clock>:
{
800116d2:	1141                	add	sp,sp,-16
800116d4:	c62a                	sw	a0,12(sp)
800116d6:	87ae                	mv	a5,a1
800116d8:	00f105a3          	sb	a5,11(sp)
    if (enable) {
800116dc:	00b14783          	lbu	a5,11(sp)
800116e0:	cf81                	beqz	a5,800116f8 <.L14>
        ptr->PHY_CFG1 |= ESC_PHY_CFG1_REFCK_25M_OE_MASK;   /*!< enable PHY 25M refck */
800116e2:	4732                	lw	a4,12(sp)
800116e4:	67fd                	lui	a5,0x1f
800116e6:	97ba                	add	a5,a5,a4
800116e8:	4bdc                	lw	a5,20(a5)
800116ea:	0087e713          	or	a4,a5,8
800116ee:	46b2                	lw	a3,12(sp)
800116f0:	67fd                	lui	a5,0x1f
800116f2:	97b6                	add	a5,a5,a3
800116f4:	cbd8                	sw	a4,20(a5)
}
800116f6:	a819                	j	8001170c <.L16>

800116f8 <.L14>:
        ptr->PHY_CFG1 &= ~ESC_PHY_CFG1_REFCK_25M_OE_MASK;   /*!< disable PHY 25M refck */
800116f8:	4732                	lw	a4,12(sp)
800116fa:	67fd                	lui	a5,0x1f
800116fc:	97ba                	add	a5,a5,a4
800116fe:	4bdc                	lw	a5,20(a5)
80011700:	ff77f713          	and	a4,a5,-9
80011704:	46b2                	lw	a3,12(sp)
80011706:	67fd                	lui	a5,0x1f
80011708:	97b6                	add	a5,a5,a3
8001170a:	cbd8                	sw	a4,20(a5)

8001170c <.L16>:
}
8001170c:	0001                	nop
8001170e:	0141                	add	sp,sp,16
80011710:	8082                	ret

Disassembly of section .text.esc_config_eeprom_and_clock:

80011712 <esc_config_eeprom_and_clock>:
{
80011712:	7179                	add	sp,sp,-48
80011714:	d606                	sw	ra,44(sp)
80011716:	c62a                	sw	a0,12(sp)
80011718:	c42e                	sw	a1,8(sp)
    uint32_t gpr_cfg0 = ptr->GPR_CFG0;
8001171a:	4732                	lw	a4,12(sp)
8001171c:	67fd                	lui	a5,0x1f
8001171e:	97ba                	add	a5,a5,a4
80011720:	439c                	lw	a5,0(a5)
80011722:	ce3e                	sw	a5,28(sp)
    if (config->eeprom_emulation) {
80011724:	47a2                	lw	a5,8(sp)
80011726:	0007c783          	lbu	a5,0(a5) # 1f000 <__FLASH_segment_used_size__+0xb370>
8001172a:	cb91                	beqz	a5,8001173e <.L18>
        gpr_cfg0 |= ESC_GPR_CFG0_EEPROM_EMU_MASK;
8001172c:	4772                	lw	a4,28(sp)
8001172e:	6785                	lui	a5,0x1
80011730:	8fd9                	or	a5,a5,a4
80011732:	ce3e                	sw	a5,28(sp)
        gpr_cfg0 &= ~(ESC_GPR_CFG0_PROM_SIZE_MASK | ESC_GPR_CFG0_I2C_SCLK_EN_MASK);
80011734:	47f2                	lw	a5,28(sp)
80011736:	9bf9                	and	a5,a5,-2
80011738:	9bdd                	and	a5,a5,-9
8001173a:	ce3e                	sw	a5,28(sp)
8001173c:	a035                	j	80011768 <.L19>

8001173e <.L18>:
        gpr_cfg0 &= ~ESC_GPR_CFG0_EEPROM_EMU_MASK;
8001173e:	4772                	lw	a4,28(sp)
80011740:	77fd                	lui	a5,0xfffff
80011742:	17fd                	add	a5,a5,-1 # ffffefff <__AHB_SRAM_segment_end__+0xfdf6fff>
80011744:	8ff9                	and	a5,a5,a4
80011746:	ce3e                	sw	a5,28(sp)
        gpr_cfg0 |= ESC_GPR_CFG0_I2C_SCLK_EN_MASK;
80011748:	47f2                	lw	a5,28(sp)
8001174a:	0087e793          	or	a5,a5,8
8001174e:	ce3e                	sw	a5,28(sp)
        if (config->eeprom_size_over_16kbit) {
80011750:	47a2                	lw	a5,8(sp)
80011752:	0017c783          	lbu	a5,1(a5)
80011756:	c791                	beqz	a5,80011762 <.L20>
            gpr_cfg0 |= ESC_GPR_CFG0_PROM_SIZE_MASK;
80011758:	47f2                	lw	a5,28(sp)
8001175a:	0017e793          	or	a5,a5,1
8001175e:	ce3e                	sw	a5,28(sp)
80011760:	a021                	j	80011768 <.L19>

80011762 <.L20>:
            gpr_cfg0 &= ~ESC_GPR_CFG0_PROM_SIZE_MASK;
80011762:	47f2                	lw	a5,28(sp)
80011764:	9bf9                	and	a5,a5,-2
80011766:	ce3e                	sw	a5,28(sp)

80011768 <.L19>:
    ptr->GPR_CFG0 = gpr_cfg0;
80011768:	4732                	lw	a4,12(sp)
8001176a:	67fd                	lui	a5,0x1f
8001176c:	97ba                	add	a5,a5,a4
8001176e:	4772                	lw	a4,28(sp)
80011770:	c398                	sw	a4,0(a5)
    esc_core_enable_clock(ptr, config->core_clock_en);
80011772:	47a2                	lw	a5,8(sp)
80011774:	0027c783          	lbu	a5,2(a5) # 1f002 <__FLASH_segment_used_size__+0xb372>
80011778:	85be                	mv	a1,a5
8001177a:	4532                	lw	a0,12(sp)
8001177c:	dfdf90ef          	jal	8000b578 <esc_core_enable_clock>
    esc_phy_enable_clock(ptr, config->phy_refclk_en);
80011780:	47a2                	lw	a5,8(sp)
80011782:	0037c783          	lbu	a5,3(a5)
80011786:	85be                	mv	a1,a5
80011788:	4532                	lw	a0,12(sp)
8001178a:	37a1                	jal	800116d2 <esc_phy_enable_clock>
}
8001178c:	0001                	nop
8001178e:	50b2                	lw	ra,44(sp)
80011790:	6145                	add	sp,sp,48
80011792:	8082                	ret

Disassembly of section .text.esc_config_ctrl_signal_function:

80011794 <esc_config_ctrl_signal_function>:
{
80011794:	1141                	add	sp,sp,-16
80011796:	c62a                	sw	a0,12(sp)
80011798:	87ae                	mv	a5,a1
8001179a:	8736                	mv	a4,a3
8001179c:	00f105a3          	sb	a5,11(sp)
800117a0:	87b2                	mv	a5,a2
800117a2:	00f10523          	sb	a5,10(sp)
800117a6:	87ba                	mv	a5,a4
800117a8:	00f104a3          	sb	a5,9(sp)
    ptr->IO_CFG[index] = ESC_IO_CFG_FUNC_ALT_SET(func) | ESC_IO_CFG_INVERT_SET(invert);
800117ac:	00a14783          	lbu	a5,10(sp)
800117b0:	00f7f713          	and	a4,a5,15
800117b4:	00914783          	lbu	a5,9(sp)
800117b8:	0792                	sll	a5,a5,0x4
800117ba:	8bc1                	and	a5,a5,16
800117bc:	00b14603          	lbu	a2,11(sp)
800117c0:	8f5d                	or	a4,a4,a5
800117c2:	46b2                	lw	a3,12(sp)
800117c4:	67a1                	lui	a5,0x8
800117c6:	c2078793          	add	a5,a5,-992 # 7c20 <__HEAPSIZE__+0x3c20>
800117ca:	97b2                	add	a5,a5,a2
800117cc:	078a                	sll	a5,a5,0x2
800117ce:	97b6                	add	a5,a5,a3
800117d0:	c398                	sw	a4,0(a5)
}
800117d2:	0001                	nop
800117d4:	0141                	add	sp,sp,16
800117d6:	8082                	ret

Disassembly of section .text.esc_set_phy_offset:

800117d8 <esc_set_phy_offset>:
{
800117d8:	1141                	add	sp,sp,-16
800117da:	c62a                	sw	a0,12(sp)
800117dc:	87ae                	mv	a5,a1
800117de:	00f105a3          	sb	a5,11(sp)
    ptr->PHY_CFG0 = (ptr->PHY_CFG0 & ~ESC_PHY_CFG0_PHY_OFFSET_VAL_MASK) | (offset << ESC_PHY_CFG0_PHY_OFFSET_VAL_SHIFT);
800117e2:	4732                	lw	a4,12(sp)
800117e4:	67fd                	lui	a5,0x1f
800117e6:	97ba                	add	a5,a5,a4
800117e8:	4b98                	lw	a4,16(a5)
800117ea:	e10007b7          	lui	a5,0xe1000
800117ee:	17fd                	add	a5,a5,-1 # e0ffffff <__FLASH_segment_end__+0x60efffff>
800117f0:	8f7d                	and	a4,a4,a5
800117f2:	00b14783          	lbu	a5,11(sp)
800117f6:	07e2                	sll	a5,a5,0x18
800117f8:	8f5d                	or	a4,a4,a5
800117fa:	46b2                	lw	a3,12(sp)
800117fc:	67fd                	lui	a5,0x1f
800117fe:	97b6                	add	a5,a5,a3
80011800:	cb98                	sw	a4,16(a5)
}
80011802:	0001                	nop
80011804:	0141                	add	sp,sp,16
80011806:	8082                	ret

Disassembly of section .text.esc_get_eeprom_cmd:

80011808 <esc_get_eeprom_cmd>:
{
80011808:	1141                	add	sp,sp,-16
8001180a:	c62a                	sw	a0,12(sp)
    return ESC_EEPROM_CTRL_STAT_CMD_GET(ptr->EEPROM_CTRL_STAT);
8001180c:	47b2                	lw	a5,12(sp)
8001180e:	5027d783          	lhu	a5,1282(a5) # 1f502 <__FLASH_segment_used_size__+0xb872>
80011812:	0807c7b3          	zext.h	a5,a5
80011816:	83a1                	srl	a5,a5,0x8
80011818:	0ff7f793          	zext.b	a5,a5
8001181c:	8b9d                	and	a5,a5,7
8001181e:	0ff7f793          	zext.b	a5,a5
}
80011822:	853e                	mv	a0,a5
80011824:	0141                	add	sp,sp,16
80011826:	8082                	ret

Disassembly of section .text.esc_eeprom_emulation_ack:

80011828 <esc_eeprom_emulation_ack>:
{
80011828:	1101                	add	sp,sp,-32
8001182a:	c62a                	sw	a0,12(sp)
8001182c:	87ae                	mv	a5,a1
8001182e:	8736                	mv	a4,a3
80011830:	00f105a3          	sb	a5,11(sp)
80011834:	87b2                	mv	a5,a2
80011836:	00f10523          	sb	a5,10(sp)
8001183a:	87ba                	mv	a5,a4
8001183c:	00f104a3          	sb	a5,9(sp)
    uint16_t temp = ESC_EEPROM_CTRL_STAT_CMD_SET(cmd);
80011840:	00b14783          	lbu	a5,11(sp)
80011844:	0807c7b3          	zext.h	a5,a5
80011848:	07a2                	sll	a5,a5,0x8
8001184a:	0807c7b3          	zext.h	a5,a5
8001184e:	7007f793          	and	a5,a5,1792
80011852:	00f11f23          	sh	a5,30(sp)
    if (ack_err) {
80011856:	00a14783          	lbu	a5,10(sp)
8001185a:	cb81                	beqz	a5,8001186a <.L34>
        temp |= ESC_EEPROM_CTRL_STAT_ERR_ACK_CMD_MASK;
8001185c:	01e15783          	lhu	a5,30(sp)
80011860:	873e                	mv	a4,a5
80011862:	6789                	lui	a5,0x2
80011864:	8fd9                	or	a5,a5,a4
80011866:	00f11f23          	sh	a5,30(sp)

8001186a <.L34>:
    if (crc_err) {
8001186a:	00914783          	lbu	a5,9(sp)
8001186e:	cb89                	beqz	a5,80011880 <.L35>
        temp |= ESC_EEPROM_CTRL_STAT_CKSM_ERR_MASK;
80011870:	01e15783          	lhu	a5,30(sp)
80011874:	873e                	mv	a4,a5
80011876:	28b01793          	bset	a5,zero,0xb
8001187a:	8fd9                	or	a5,a5,a4
8001187c:	00f11f23          	sh	a5,30(sp)

80011880 <.L35>:
    ptr->EEPROM_CTRL_STAT = temp;
80011880:	47b2                	lw	a5,12(sp)
80011882:	01e15703          	lhu	a4,30(sp)
80011886:	50e79123          	sh	a4,1282(a5) # 2502 <__BOOT_HEADER_segment_size__+0x502>
}
8001188a:	0001                	nop
8001188c:	6105                	add	sp,sp,32
8001188e:	8082                	ret

Disassembly of section .text.esc_write_eeprom_data:

80011890 <esc_write_eeprom_data>:
 *
 * @param[in] ptr ESC base address
 * @param[in] data eeprom data
 */
static inline void esc_write_eeprom_data(ESC_Type *ptr, uint64_t data)
{
80011890:	1141                	add	sp,sp,-16
80011892:	c62a                	sw	a0,12(sp)
80011894:	c02e                	sw	a1,0(sp)
80011896:	c232                	sw	a2,4(sp)
    ptr->EEPROM_DATA = data;
80011898:	46b2                	lw	a3,12(sp)
8001189a:	4702                	lw	a4,0(sp)
8001189c:	4792                	lw	a5,4(sp)
8001189e:	50e6a423          	sw	a4,1288(a3)
800118a2:	50f6a623          	sw	a5,1292(a3)
}
800118a6:	0001                	nop
800118a8:	0141                	add	sp,sp,16
800118aa:	8082                	ret

Disassembly of section .text.ecat_hardware_init:

800118ac <ecat_hardware_init>:
{
800118ac:	7179                	add	sp,sp,-48
800118ae:	d606                	sw	ra,44(sp)
800118b0:	c62a                	sw	a0,12(sp)
    esc_config.core_clock_en = true;
800118b2:	4785                	li	a5,1
800118b4:	00f10d23          	sb	a5,26(sp)
    esc_config.phy_refclk_en = true;
800118b8:	4785                	li	a5,1
800118ba:	00f10da3          	sb	a5,27(sp)
    stat = ecat_flash_eeprom_init();
800118be:	a84fa0ef          	jal	8000bb42 <ecat_flash_eeprom_init>
800118c2:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
800118c4:	47f2                	lw	a5,28(sp)
800118c6:	cb89                	beqz	a5,800118d8 <.L41>
        printf("Flash simulation EEPROM initialization failed.\n");
800118c8:	800077b7          	lui	a5,0x80007
800118cc:	0a478513          	add	a0,a5,164 # 800070a4 <.LC0>
800118d0:	cf0fc0ef          	jal	8000ddc0 <printf>
        return stat;
800118d4:	47f2                	lw	a5,28(sp)
800118d6:	a87d                	j	80011994 <.L48>

800118d8 <.L41>:
    esc_config.eeprom_emulation = true;
800118d8:	4785                	li	a5,1
800118da:	00f10c23          	sb	a5,24(sp)
    esc_config.eeprom_size_over_16kbit = false; /* eeprom emulation not use this */
800118de:	00010ca3          	sb	zero,25(sp)
    esc_config_eeprom_and_clock(esc_ptr, &esc_config);
800118e2:	083c                	add	a5,sp,24
800118e4:	85be                	mv	a1,a5
800118e6:	4532                	lw	a0,12(sp)
800118e8:	352d                	jal	80011712 <esc_config_eeprom_and_clock>
    ecat_eeprom_emulation_reload_response();
800118ea:	7fff0097          	auipc	ra,0x7fff0
800118ee:	fe8080e7          	jalr	-24(ra) # 18d2 <ecat_eeprom_emulation_reload_response>
    stat = esc_check_eeprom_loading(esc_ptr);
800118f2:	4532                	lw	a0,12(sp)
800118f4:	66a010ef          	jal	80012f5e <esc_check_eeprom_loading>
800118f8:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
800118fa:	47f2                	lw	a5,28(sp)
800118fc:	cf85                	beqz	a5,80011934 <.L43>
        if (stat == status_esc_eeprom_checksum_error) {
800118fe:	4772                	lw	a4,28(sp)
80011900:	679d                	lui	a5,0x7
80011902:	d6178793          	add	a5,a5,-671 # 6d61 <__HEAPSIZE__+0x2d61>
80011906:	00f71f63          	bne	a4,a5,80011924 <.L44>
            printf("EEPROM loading with checksum error.\n");
8001190a:	800077b7          	lui	a5,0x80007
8001190e:	0d478513          	add	a0,a5,212 # 800070d4 <.LC1>
80011912:	caefc0ef          	jal	8000ddc0 <printf>
            printf("EtherCAT communication is possible even if the EEPROM is blank(checksum error), please update eeprom context.\n");
80011916:	800077b7          	lui	a5,0x80007
8001191a:	0fc78513          	add	a0,a5,252 # 800070fc <.LC2>
8001191e:	ca2fc0ef          	jal	8000ddc0 <printf>
80011922:	a839                	j	80011940 <.L45>

80011924 <.L44>:
            printf("EEPROM loading failed, please check EEPROM setting.\n");
80011924:	800077b7          	lui	a5,0x80007
80011928:	16c78513          	add	a0,a5,364 # 8000716c <.LC3>
8001192c:	c94fc0ef          	jal	8000ddc0 <printf>
            return status_fail;
80011930:	4785                	li	a5,1
80011932:	a08d                	j	80011994 <.L48>

80011934 <.L43>:
        printf("EEPROM loading successful, no checksum error.\n");
80011934:	800077b7          	lui	a5,0x80007
80011938:	1a478513          	add	a0,a5,420 # 800071a4 <.LC4>
8001193c:	c84fc0ef          	jal	8000ddc0 <printf>

80011940 <.L45>:
    ecat_phy_reset();
80011940:	22d5                	jal	80011b24 <ecat_phy_reset>
    esc_set_phy_offset(esc_ptr, BOARD_ECAT_PHY_ADDR_OFFSET);
80011942:	4585                	li	a1,1
80011944:	4532                	lw	a0,12(sp)
80011946:	3d49                	jal	800117d8 <esc_set_phy_offset>
    stat = ecat_phy_config(esc_ptr);
80011948:	4532                	lw	a0,12(sp)
8001194a:	262d                	jal	80011c74 <ecat_phy_config>
8001194c:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
8001194e:	47f2                	lw	a5,28(sp)
80011950:	cb89                	beqz	a5,80011962 <.L46>
        printf("PHY configuration failed.\n");
80011952:	800077b7          	lui	a5,0x80007
80011956:	1d478513          	add	a0,a5,468 # 800071d4 <.LC5>
8001195a:	c66fc0ef          	jal	8000ddc0 <printf>
        return stat;
8001195e:	47f2                	lw	a5,28(sp)
80011960:	a815                	j	80011994 <.L48>

80011962 <.L46>:
    esc_config_ctrl_signal_function(esc_ptr, BOARD_ECAT_NMII_LINK0_CTRL_INDEX, esc_ctrl_signal_func_alt_nmii_link0, BOARD_ECAT_PORT0_LINK_INVERT); /* NMII_LINK0 */
80011962:	4685                	li	a3,1
80011964:	4601                	li	a2,0
80011966:	459d                	li	a1,7
80011968:	4532                	lw	a0,12(sp)
8001196a:	352d                	jal	80011794 <esc_config_ctrl_signal_function>
    esc_config_ctrl_signal_function(esc_ptr, BOARD_ECAT_NMII_LINK1_CTRL_INDEX, esc_ctrl_signal_func_alt_nmii_link1, BOARD_ECAT_PORT1_LINK_INVERT); /* NMII_LINK1 */
8001196c:	4681                	li	a3,0
8001196e:	4605                	li	a2,1
80011970:	45a1                	li	a1,8
80011972:	4532                	lw	a0,12(sp)
80011974:	3505                	jal	80011794 <esc_config_ctrl_signal_function>
    esc_config_nmii_link_source(esc_ptr, true, BOARD_ECAT_SUPPORT_PORT1, BOARD_ECAT_SUPPORT_PORT2); /* configure nmii_link source */
80011976:	4681                	li	a3,0
80011978:	4605                	li	a2,1
8001197a:	4585                	li	a1,1
8001197c:	4532                	lw	a0,12(sp)
8001197e:	c3df90ef          	jal	8000b5ba <esc_config_nmii_link_source>
    if (status_success == stat) {
80011982:	47f2                	lw	a5,28(sp)
80011984:	e799                	bnez	a5,80011992 <.L47>
        ecat_timer_ms_enable();
80011986:	d5ff90ef          	jal	8000b6e4 <ecat_timer_ms_enable>
        HW_Init();
8001198a:	e3df90ef          	jal	8000b7c6 <HW_Init>
        ENABLE_ESC_INT();
8001198e:	e47f90ef          	jal	8000b7d4 <ENABLE_ESC_INT>

80011992 <.L47>:
    return stat;
80011992:	47f2                	lw	a5,28(sp)

80011994 <.L48>:
}
80011994:	853e                	mv	a0,a5
80011996:	50b2                	lw	ra,44(sp)
80011998:	6145                	add	sp,sp,48
8001199a:	8082                	ret

Disassembly of section .text.HW_GetTimer:

8001199c <HW_GetTimer>:
    return ecat_time_ms;
8001199c:	11c1a783          	lw	a5,284(gp) # 1209494 <ecat_time_ms>
}
800119a0:	853e                	mv	a0,a5
800119a2:	8082                	ret

Disassembly of section .text.HW_ClearTimer:

800119a4 <HW_ClearTimer>:
    ecat_time_ms = 0;
800119a4:	1001ae23          	sw	zero,284(gp) # 1209494 <ecat_time_ms>
}
800119a8:	0001                	nop
800119aa:	8082                	ret

Disassembly of section .text.DISABLE_ESC_INT:

800119ac <DISABLE_ESC_INT>:
{
800119ac:	7159                	add	sp,sp,-112
    HPM_ESC->GPR_CFG1 &= ~(ESC_GPR_CFG1_SYNC0_IRQ_EN_MASK | ESC_GPR_CFG1_SYNC1_IRQ_EN_MASK | ESC_GPR_CFG1_RSTO_IRQ_EN_MASK);
800119ae:	f1700737          	lui	a4,0xf1700
800119b2:	67fd                	lui	a5,0x1f
800119b4:	97ba                	add	a5,a5,a4
800119b6:	43d8                	lw	a4,4(a5)
800119b8:	f17006b7          	lui	a3,0xf1700
800119bc:	200007b7          	lui	a5,0x20000
800119c0:	17fd                	add	a5,a5,-1 # 1fffffff <__AXI_SRAM_segment_end__+0x1edbffff>
800119c2:	8f7d                	and	a4,a4,a5
800119c4:	67fd                	lui	a5,0x1f
800119c6:	97b6                	add	a5,a5,a3
800119c8:	c3d8                	sw	a4,4(a5)
800119ca:	cc02                	sw	zero,24(sp)
800119cc:	03e00793          	li	a5,62
800119d0:	ca3e                	sw	a5,20(sp)
800119d2:	e40007b7          	lui	a5,0xe4000
800119d6:	c83e                	sw	a5,16(sp)
800119d8:	47e2                	lw	a5,24(sp)
800119da:	c63e                	sw	a5,12(sp)
800119dc:	47d2                	lw	a5,20(sp)
800119de:	c43e                	sw	a5,8(sp)

800119e0 <.LBB72>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
800119e0:	47b2                	lw	a5,12(sp)
800119e2:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
800119e6:	47c2                	lw	a5,16(sp)
800119e8:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
800119ea:	47a2                	lw	a5,8(sp)
800119ec:	8395                	srl	a5,a5,0x5
800119ee:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
800119f0:	973e                	add	a4,a4,a5
800119f2:	6789                	lui	a5,0x2
800119f4:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
800119f6:	c23e                	sw	a5,4(sp)
    uint32_t current = *current_ptr;
800119f8:	4792                	lw	a5,4(sp)
800119fa:	439c                	lw	a5,0(a5)
800119fc:	c03e                	sw	a5,0(sp)
    current = current & ~((1 << (irq & 0x1F)));
800119fe:	47a2                	lw	a5,8(sp)
80011a00:	8bfd                	and	a5,a5,31
80011a02:	4705                	li	a4,1
80011a04:	00f717b3          	sll	a5,a4,a5
80011a08:	fff7c793          	not	a5,a5
80011a0c:	873e                	mv	a4,a5
80011a0e:	4782                	lw	a5,0(sp)
80011a10:	8ff9                	and	a5,a5,a4
80011a12:	c03e                	sw	a5,0(sp)
    *current_ptr = current;
80011a14:	4792                	lw	a5,4(sp)
80011a16:	4702                	lw	a4,0(sp)
80011a18:	c398                	sw	a4,0(a5)
}
80011a1a:	0001                	nop

80011a1c <.LBE74>:
}
80011a1c:	0001                	nop
80011a1e:	da02                	sw	zero,52(sp)
80011a20:	03f00793          	li	a5,63
80011a24:	d83e                	sw	a5,48(sp)
80011a26:	e40007b7          	lui	a5,0xe4000
80011a2a:	d63e                	sw	a5,44(sp)
80011a2c:	57d2                	lw	a5,52(sp)
80011a2e:	d43e                	sw	a5,40(sp)
80011a30:	57c2                	lw	a5,48(sp)
80011a32:	d23e                	sw	a5,36(sp)

80011a34 <.LBB76>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
80011a34:	57a2                	lw	a5,40(sp)
80011a36:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
80011a3a:	57b2                	lw	a5,44(sp)
80011a3c:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
80011a3e:	5792                	lw	a5,36(sp)
80011a40:	8395                	srl	a5,a5,0x5
80011a42:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
80011a44:	973e                	add	a4,a4,a5
80011a46:	6789                	lui	a5,0x2
80011a48:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
80011a4a:	d03e                	sw	a5,32(sp)
    uint32_t current = *current_ptr;
80011a4c:	5782                	lw	a5,32(sp)
80011a4e:	439c                	lw	a5,0(a5)
80011a50:	ce3e                	sw	a5,28(sp)
    current = current & ~((1 << (irq & 0x1F)));
80011a52:	5792                	lw	a5,36(sp)
80011a54:	8bfd                	and	a5,a5,31
80011a56:	4705                	li	a4,1
80011a58:	00f717b3          	sll	a5,a4,a5
80011a5c:	fff7c793          	not	a5,a5
80011a60:	873e                	mv	a4,a5
80011a62:	47f2                	lw	a5,28(sp)
80011a64:	8ff9                	and	a5,a5,a4
80011a66:	ce3e                	sw	a5,28(sp)
    *current_ptr = current;
80011a68:	5782                	lw	a5,32(sp)
80011a6a:	4772                	lw	a4,28(sp)
80011a6c:	c398                	sw	a4,0(a5)
}
80011a6e:	0001                	nop

80011a70 <.LBE78>:
80011a70:	0001                	nop
80011a72:	c882                	sw	zero,80(sp)
80011a74:	03d00793          	li	a5,61
80011a78:	c6be                	sw	a5,76(sp)
80011a7a:	e40007b7          	lui	a5,0xe4000
80011a7e:	c4be                	sw	a5,72(sp)
80011a80:	47c6                	lw	a5,80(sp)
80011a82:	c2be                	sw	a5,68(sp)
80011a84:	47b6                	lw	a5,76(sp)
80011a86:	c0be                	sw	a5,64(sp)

80011a88 <.LBB80>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
80011a88:	4796                	lw	a5,68(sp)
80011a8a:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
80011a8e:	47a6                	lw	a5,72(sp)
80011a90:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
80011a92:	4786                	lw	a5,64(sp)
80011a94:	8395                	srl	a5,a5,0x5
80011a96:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
80011a98:	973e                	add	a4,a4,a5
80011a9a:	6789                	lui	a5,0x2
80011a9c:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
80011a9e:	de3e                	sw	a5,60(sp)
    uint32_t current = *current_ptr;
80011aa0:	57f2                	lw	a5,60(sp)
80011aa2:	439c                	lw	a5,0(a5)
80011aa4:	dc3e                	sw	a5,56(sp)
    current = current & ~((1 << (irq & 0x1F)));
80011aa6:	4786                	lw	a5,64(sp)
80011aa8:	8bfd                	and	a5,a5,31
80011aaa:	4705                	li	a4,1
80011aac:	00f717b3          	sll	a5,a4,a5
80011ab0:	fff7c793          	not	a5,a5
80011ab4:	873e                	mv	a4,a5
80011ab6:	57e2                	lw	a5,56(sp)
80011ab8:	8ff9                	and	a5,a5,a4
80011aba:	dc3e                	sw	a5,56(sp)
    *current_ptr = current;
80011abc:	57f2                	lw	a5,60(sp)
80011abe:	5762                	lw	a4,56(sp)
80011ac0:	c398                	sw	a4,0(a5)
}
80011ac2:	0001                	nop

80011ac4 <.LBE82>:
80011ac4:	0001                	nop
80011ac6:	d682                	sw	zero,108(sp)
80011ac8:	04000793          	li	a5,64
80011acc:	d4be                	sw	a5,104(sp)
80011ace:	e40007b7          	lui	a5,0xe4000
80011ad2:	d2be                	sw	a5,100(sp)
80011ad4:	57b6                	lw	a5,108(sp)
80011ad6:	d0be                	sw	a5,96(sp)
80011ad8:	57a6                	lw	a5,104(sp)
80011ada:	cebe                	sw	a5,92(sp)

80011adc <.LBB84>:
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
80011adc:	5786                	lw	a5,96(sp)
80011ade:	00779713          	sll	a4,a5,0x7
            HPM_PLIC_ENABLE_OFFSET +
80011ae2:	5796                	lw	a5,100(sp)
80011ae4:	973e                	add	a4,a4,a5
            ((irq >> 5) << 2));
80011ae6:	47f6                	lw	a5,92(sp)
80011ae8:	8395                	srl	a5,a5,0x5
80011aea:	078a                	sll	a5,a5,0x2
            (target << HPM_PLIC_ENABLE_SHIFT_PER_TARGET) +
80011aec:	973e                	add	a4,a4,a5
80011aee:	6789                	lui	a5,0x2
80011af0:	97ba                	add	a5,a5,a4
    volatile uint32_t *current_ptr = (volatile uint32_t *)(base +
80011af2:	ccbe                	sw	a5,88(sp)
    uint32_t current = *current_ptr;
80011af4:	47e6                	lw	a5,88(sp)
80011af6:	439c                	lw	a5,0(a5)
80011af8:	cabe                	sw	a5,84(sp)
    current = current & ~((1 << (irq & 0x1F)));
80011afa:	47f6                	lw	a5,92(sp)
80011afc:	8bfd                	and	a5,a5,31
80011afe:	4705                	li	a4,1
80011b00:	00f717b3          	sll	a5,a4,a5
80011b04:	fff7c793          	not	a5,a5
80011b08:	873e                	mv	a4,a5
80011b0a:	47d6                	lw	a5,84(sp)
80011b0c:	8ff9                	and	a5,a5,a4
80011b0e:	cabe                	sw	a5,84(sp)
    *current_ptr = current;
80011b10:	47e6                	lw	a5,88(sp)
80011b12:	4756                	lw	a4,84(sp)
80011b14:	c398                	sw	a4,0(a5)
}
80011b16:	0001                	nop

80011b18 <.LBE86>:
80011b18:	0001                	nop

80011b1a <.LBE84>:
}
80011b1a:	0001                	nop
80011b1c:	6165                	add	sp,sp,112
80011b1e:	8082                	ret

Disassembly of section .text.ecat_eeprom_emulation_store:

80011b20 <ecat_eeprom_emulation_store>:
}
80011b20:	0001                	nop
80011b22:	8082                	ret

Disassembly of section .text.ecat_phy_reset:

80011b24 <ecat_phy_reset>:
{
80011b24:	1141                	add	sp,sp,-16
80011b26:	c606                	sw	ra,12(sp)
    gpio_write_pin(BOARD_ECAT_PHY0_RESET_GPIO, BOARD_ECAT_PHY0_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY0_RESET_PIN_INDEX, JL11X1_RESET_LEVEL);
80011b28:	4681                	li	a3,0
80011b2a:	4669                	li	a2,26
80011b2c:	4585                	li	a1,1
80011b2e:	f00d0537          	lui	a0,0xf00d0
80011b32:	ed3f90ef          	jal	8000ba04 <gpio_write_pin>
    gpio_write_pin(BOARD_ECAT_PHY1_RESET_GPIO, BOARD_ECAT_PHY1_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY1_RESET_PIN_INDEX, JL11X1_RESET_LEVEL);
80011b36:	4681                	li	a3,0
80011b38:	4669                	li	a2,26
80011b3a:	4585                	li	a1,1
80011b3c:	f00d0537          	lui	a0,0xf00d0
80011b40:	ec5f90ef          	jal	8000ba04 <gpio_write_pin>
    board_delay_ms(JL11X1_RESET_HOLD_TIME_MS);
80011b44:	4505                	li	a0,1
80011b46:	2d4d                	jal	800121f8 <board_delay_ms>
    gpio_write_pin(BOARD_ECAT_PHY0_RESET_GPIO, BOARD_ECAT_PHY0_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY0_RESET_PIN_INDEX, !JL11X1_RESET_LEVEL);
80011b48:	4685                	li	a3,1
80011b4a:	4669                	li	a2,26
80011b4c:	4585                	li	a1,1
80011b4e:	f00d0537          	lui	a0,0xf00d0
80011b52:	eb3f90ef          	jal	8000ba04 <gpio_write_pin>
    gpio_write_pin(BOARD_ECAT_PHY1_RESET_GPIO, BOARD_ECAT_PHY1_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY1_RESET_PIN_INDEX, !JL11X1_RESET_LEVEL);
80011b56:	4685                	li	a3,1
80011b58:	4669                	li	a2,26
80011b5a:	4585                	li	a1,1
80011b5c:	f00d0537          	lui	a0,0xf00d0
80011b60:	ea5f90ef          	jal	8000ba04 <gpio_write_pin>
    board_delay_ms(JL11X1_RESET_WAIT_TIME_MS);
80011b64:	4515                	li	a0,5
80011b66:	2d49                	jal	800121f8 <board_delay_ms>
}
80011b68:	0001                	nop
80011b6a:	40b2                	lw	ra,12(sp)
80011b6c:	0141                	add	sp,sp,16
80011b6e:	8082                	ret

Disassembly of section .text.ecat_jl1111_phy_config_led_mode:

80011b70 <ecat_jl1111_phy_config_led_mode>:

/* config PHY LED mode (JL1111 Page 7 Register 19, bits[5:4] to 0) */
static hpm_stat_t ecat_jl1111_phy_config_led_mode(ESC_Type *ptr, uint8_t phy_addr)
{
80011b70:	7179                	add	sp,sp,-48
80011b72:	d606                	sw	ra,44(sp)
80011b74:	c62a                	sw	a0,12(sp)
80011b76:	87ae                	mv	a5,a1
80011b78:	00f105a3          	sb	a5,11(sp)
    hpm_stat_t stat;

    /* config LED mode to 00 */
    stat = esc_mdio_write(ptr, phy_addr, JL11X1_PAGESEL_REG_OFFSET, JL11X1_WOLEN_REG_OFFSET / 32);
80011b7c:	00b14783          	lbu	a5,11(sp)
80011b80:	469d                	li	a3,7
80011b82:	467d                	li	a2,31
80011b84:	85be                	mv	a1,a5
80011b86:	4532                	lw	a0,12(sp)
80011b88:	2ea010ef          	jal	80012e72 <esc_mdio_write>
80011b8c:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
80011b8e:	47f2                	lw	a5,28(sp)
80011b90:	c399                	beqz	a5,80011b96 <.L8>
        return stat;
80011b92:	47f2                	lw	a5,28(sp)
80011b94:	a825                	j	80011bcc <.L9>

80011b96 <.L8>:
    }

    stat = esc_mdio_write(ptr, phy_addr, JL11X1_WOLEN_REG_OFFSET % 32, JL11X1_WOLEN_REG_VALUE);
80011b96:	00b14783          	lbu	a5,11(sp)
80011b9a:	4681                	li	a3,0
80011b9c:	464d                	li	a2,19
80011b9e:	85be                	mv	a1,a5
80011ba0:	4532                	lw	a0,12(sp)
80011ba2:	2d0010ef          	jal	80012e72 <esc_mdio_write>
80011ba6:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
80011ba8:	47f2                	lw	a5,28(sp)
80011baa:	c399                	beqz	a5,80011bb0 <.L10>
        return stat;
80011bac:	47f2                	lw	a5,28(sp)
80011bae:	a839                	j	80011bcc <.L9>

80011bb0 <.L10>:
    }

    stat = esc_mdio_write(ptr, phy_addr, JL11X1_PAGESEL_REG_OFFSET, 0);
80011bb0:	00b14783          	lbu	a5,11(sp)
80011bb4:	4681                	li	a3,0
80011bb6:	467d                	li	a2,31
80011bb8:	85be                	mv	a1,a5
80011bba:	4532                	lw	a0,12(sp)
80011bbc:	2b6010ef          	jal	80012e72 <esc_mdio_write>
80011bc0:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
80011bc2:	47f2                	lw	a5,28(sp)
80011bc4:	c399                	beqz	a5,80011bca <.L11>
        return stat;
80011bc6:	47f2                	lw	a5,28(sp)
80011bc8:	a011                	j	80011bcc <.L9>

80011bca <.L11>:
    }

    return status_success;
80011bca:	4781                	li	a5,0

80011bcc <.L9>:
}
80011bcc:	853e                	mv	a0,a5
80011bce:	50b2                	lw	ra,44(sp)
80011bd0:	6145                	add	sp,sp,48
80011bd2:	8082                	ret

Disassembly of section .text.ecat_jl1111_phy_disable_broadcast_response:

80011bd4 <ecat_jl1111_phy_disable_broadcast_response>:

static hpm_stat_t ecat_jl1111_phy_disable_broadcast_response(ESC_Type *ptr, uint8_t phy_addr, uint8_t phy_offset)
{
80011bd4:	7179                	add	sp,sp,-48
80011bd6:	d606                	sw	ra,44(sp)
80011bd8:	c62a                	sw	a0,12(sp)
80011bda:	87ae                	mv	a5,a1
80011bdc:	8732                	mv	a4,a2
80011bde:	00f105a3          	sb	a5,11(sp)
80011be2:	87ba                	mv	a5,a4
80011be4:	00f10523          	sb	a5,10(sp)
    hpm_stat_t stat;

    /* foreach phyid which is not broadcast, disable broadcast */
    if (phy_addr + phy_offset > 0) {
80011be8:	00b14703          	lbu	a4,11(sp)
80011bec:	00a14783          	lbu	a5,10(sp)
80011bf0:	97ba                	add	a5,a5,a4
80011bf2:	06f05c63          	blez	a5,80011c6a <.L13>

80011bf6 <.LBB2>:
        stat = esc_mdio_write(ptr, phy_addr, JL11X1_PAGESEL_REG_OFFSET, 128);
80011bf6:	00b14783          	lbu	a5,11(sp)
80011bfa:	08000693          	li	a3,128
80011bfe:	467d                	li	a2,31
80011c00:	85be                	mv	a1,a5
80011c02:	4532                	lw	a0,12(sp)
80011c04:	26e010ef          	jal	80012e72 <esc_mdio_write>
80011c08:	ce2a                	sw	a0,28(sp)
        if (stat != status_success) {
80011c0a:	47f2                	lw	a5,28(sp)
80011c0c:	c399                	beqz	a5,80011c12 <.L14>
            return stat;
80011c0e:	47f2                	lw	a5,28(sp)
80011c10:	a8b1                	j	80011c6c <.L15>

80011c12 <.L14>:
        }

        uint16_t value = (phy_addr + phy_offset) << 5 | 0x1F;
80011c12:	00b14703          	lbu	a4,11(sp)
80011c16:	00a14783          	lbu	a5,10(sp)
80011c1a:	97ba                	add	a5,a5,a4
80011c1c:	60579793          	sext.h	a5,a5
80011c20:	0796                	sll	a5,a5,0x5
80011c22:	60579793          	sext.h	a5,a5
80011c26:	01f7e793          	or	a5,a5,31
80011c2a:	60579793          	sext.h	a5,a5
80011c2e:	00f11d23          	sh	a5,26(sp)
        stat = esc_mdio_write(ptr, phy_addr, 19, value);
80011c32:	01a15703          	lhu	a4,26(sp)
80011c36:	00b14783          	lbu	a5,11(sp)
80011c3a:	86ba                	mv	a3,a4
80011c3c:	464d                	li	a2,19
80011c3e:	85be                	mv	a1,a5
80011c40:	4532                	lw	a0,12(sp)
80011c42:	230010ef          	jal	80012e72 <esc_mdio_write>
80011c46:	ce2a                	sw	a0,28(sp)
        if (stat != status_success) {
80011c48:	47f2                	lw	a5,28(sp)
80011c4a:	c399                	beqz	a5,80011c50 <.L16>
            return stat;
80011c4c:	47f2                	lw	a5,28(sp)
80011c4e:	a839                	j	80011c6c <.L15>

80011c50 <.L16>:
        }

        stat = esc_mdio_write(ptr, phy_addr, JL11X1_PAGESEL_REG_OFFSET, 0);
80011c50:	00b14783          	lbu	a5,11(sp)
80011c54:	4681                	li	a3,0
80011c56:	467d                	li	a2,31
80011c58:	85be                	mv	a1,a5
80011c5a:	4532                	lw	a0,12(sp)
80011c5c:	216010ef          	jal	80012e72 <esc_mdio_write>
80011c60:	ce2a                	sw	a0,28(sp)
        if (stat != status_success) {
80011c62:	47f2                	lw	a5,28(sp)
80011c64:	c399                	beqz	a5,80011c6a <.L13>
            return stat;
80011c66:	47f2                	lw	a5,28(sp)
80011c68:	a011                	j	80011c6c <.L15>

80011c6a <.L13>:
        }
    }

    return status_success;
80011c6a:	4781                	li	a5,0

80011c6c <.L15>:
}
80011c6c:	853e                	mv	a0,a5
80011c6e:	50b2                	lw	ra,44(sp)
80011c70:	6145                	add	sp,sp,48
80011c72:	8082                	ret

Disassembly of section .text.ecat_phy_config:

80011c74 <ecat_phy_config>:

hpm_stat_t ecat_phy_config(ESC_Type *ptr)
{
80011c74:	7179                	add	sp,sp,-48
80011c76:	d606                	sw	ra,44(sp)
80011c78:	c62a                	sw	a0,12(sp)
    hpm_stat_t stat;
    stat = ecat_jl1111_phy_config_led_mode(ptr, BOARD_ECAT_PORT0_PHY_ADDR); /* config Port0 PHY LED mode  */
80011c7a:	4581                	li	a1,0
80011c7c:	4532                	lw	a0,12(sp)
80011c7e:	3dcd                	jal	80011b70 <ecat_jl1111_phy_config_led_mode>
80011c80:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
80011c82:	47f2                	lw	a5,28(sp)
80011c84:	c399                	beqz	a5,80011c8a <.L18>
        return stat;
80011c86:	47f2                	lw	a5,28(sp)
80011c88:	a825                	j	80011cc0 <.L19>

80011c8a <.L18>:
    }

    stat = ecat_jl1111_phy_disable_broadcast_response(ptr, BOARD_ECAT_PORT0_PHY_ADDR, BOARD_ECAT_PHY_ADDR_OFFSET); /* disable broadcast if phyid is not broadcast */
80011c8a:	4605                	li	a2,1
80011c8c:	4581                	li	a1,0
80011c8e:	4532                	lw	a0,12(sp)
80011c90:	3791                	jal	80011bd4 <ecat_jl1111_phy_disable_broadcast_response>
80011c92:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
80011c94:	47f2                	lw	a5,28(sp)
80011c96:	c399                	beqz	a5,80011c9c <.L20>
        return stat;
80011c98:	47f2                	lw	a5,28(sp)
80011c9a:	a01d                	j	80011cc0 <.L19>

80011c9c <.L20>:
    }

#if defined(BOARD_ECAT_SUPPORT_PORT1) && BOARD_ECAT_SUPPORT_PORT1
    stat = ecat_jl1111_phy_config_led_mode(ptr, BOARD_ECAT_PORT1_PHY_ADDR); /* config Port1 PHY LED mode */
80011c9c:	4585                	li	a1,1
80011c9e:	4532                	lw	a0,12(sp)
80011ca0:	3dc1                	jal	80011b70 <ecat_jl1111_phy_config_led_mode>
80011ca2:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
80011ca4:	47f2                	lw	a5,28(sp)
80011ca6:	c399                	beqz	a5,80011cac <.L21>
        return stat;
80011ca8:	47f2                	lw	a5,28(sp)
80011caa:	a819                	j	80011cc0 <.L19>

80011cac <.L21>:
    }

    stat = ecat_jl1111_phy_disable_broadcast_response(ptr, BOARD_ECAT_PORT1_PHY_ADDR, BOARD_ECAT_PHY_ADDR_OFFSET); /* disable broadcast if phyid is not broadcast */
80011cac:	4605                	li	a2,1
80011cae:	4585                	li	a1,1
80011cb0:	4532                	lw	a0,12(sp)
80011cb2:	370d                	jal	80011bd4 <ecat_jl1111_phy_disable_broadcast_response>
80011cb4:	ce2a                	sw	a0,28(sp)
    if (stat != status_success) {
80011cb6:	47f2                	lw	a5,28(sp)
80011cb8:	c399                	beqz	a5,80011cbe <.L22>
        return stat;
80011cba:	47f2                	lw	a5,28(sp)
80011cbc:	a011                	j	80011cc0 <.L19>

80011cbe <.L22>:
    stat = ecat_jl1111_phy_disable_broadcast_response(ptr, BOARD_ECAT_PORT2_PHY_ADDR, BOARD_ECAT_PHY_ADDR_OFFSET); /* disable broadcast if phyid is not broadcast */
    if (stat != status_success) {
        return stat;
    }
#endif
    return status_success;
80011cbe:	4781                	li	a5,0

80011cc0 <.L19>:
80011cc0:	853e                	mv	a0,a5
80011cc2:	50b2                	lw	ra,44(sp)
80011cc4:	6145                	add	sp,sp,48
80011cc6:	8082                	ret

Disassembly of section .text.flash_erase:

80011cc8 <flash_erase>:
{
80011cc8:	1101                	add	sp,sp,-32
80011cca:	ce06                	sw	ra,28(sp)
80011ccc:	c62a                	sw	a0,12(sp)
80011cce:	c42e                	sw	a1,8(sp)
    nor_flash_erase(&ecat_e2p_emulation.nor_config, start_addr, size);
80011cd0:	4622                	lw	a2,8(sp)
80011cd2:	45b2                	lw	a1,12(sp)
80011cd4:	c9c18513          	add	a0,gp,-868 # 1209014 <ecat_e2p_emulation+0x1c>
80011cd8:	7fff0097          	auipc	ra,0x7fff0
80011cdc:	e8a080e7          	jalr	-374(ra) # 1b62 <nor_flash_erase>
}
80011ce0:	0001                	nop
80011ce2:	40f2                	lw	ra,28(sp)
80011ce4:	6105                	add	sp,sp,32
80011ce6:	8082                	ret

Disassembly of section .text.ecat_flash_eeprom_write:

80011ce8 <ecat_flash_eeprom_write>:
{
80011ce8:	7179                	add	sp,sp,-48
80011cea:	d606                	sw	ra,44(sp)
80011cec:	c62a                	sw	a0,12(sp)
80011cee:	c42e                	sw	a1,8(sp)
80011cf0:	47a1                	li	a5,8
80011cf2:	ca3e                	sw	a5,20(sp)

80011cf4 <.LBB66>:
    return read_clear_csr(CSR_MSTATUS, mask);
80011cf4:	c802                	sw	zero,16(sp)
80011cf6:	47d2                	lw	a5,20(sp)
80011cf8:	3007b7f3          	csrrc	a5,mstatus,a5
80011cfc:	c83e                	sw	a5,16(sp)
80011cfe:	47c2                	lw	a5,16(sp)

80011d00 <.LBE68>:
80011d00:	0001                	nop

80011d02 <.LBE66>:
    stat = e2p_write(addr, EEPROM_WRITE_SIZE, data);
80011d02:	4622                	lw	a2,8(sp)
80011d04:	4589                	li	a1,2
80011d06:	4532                	lw	a0,12(sp)
80011d08:	7ffef097          	auipc	ra,0x7ffef
80011d0c:	6c2080e7          	jalr	1730(ra) # 13ca <e2p_write>
80011d10:	ce2a                	sw	a0,28(sp)
80011d12:	47a1                	li	a5,8
80011d14:	cc3e                	sw	a5,24(sp)

80011d16 <.LBB69>:
    set_csr(CSR_MSTATUS, mask);
80011d16:	47e2                	lw	a5,24(sp)
80011d18:	3007a073          	csrs	mstatus,a5
}
80011d1c:	0001                	nop

80011d1e <.LBE69>:
    return stat;
80011d1e:	47f2                	lw	a5,28(sp)
}
80011d20:	853e                	mv	a0,a5
80011d22:	50b2                	lw	ra,44(sp)
80011d24:	6145                	add	sp,sp,48
80011d26:	8082                	ret

Disassembly of section .text.reset_handler:

80011d28 <reset_handler>:
        ;
    }
}

__attribute__((weak)) void reset_handler(void)
{
80011d28:	1141                	add	sp,sp,-16
80011d2a:	c606                	sw	ra,12(sp)
    fencei();
80011d2c:	0000100f          	fence.i

    /* Call platform specific hardware initialization */
    system_init();
80011d30:	a28fa0ef          	jal	8000bf58 <system_init>

    /* Entry function */
    MAIN_ENTRY();
80011d34:	d2ef40ef          	jal	80006262 <main>
}
80011d38:	0001                	nop
80011d3a:	40b2                	lw	ra,12(sp)
80011d3c:	0141                	add	sp,sp,16
80011d3e:	8082                	ret

Disassembly of section .text._init:

80011d40 <_init>:
void *__dso_handle = (void *) &__dso_handle;
#endif

__attribute__((weak)) void _init(void)
{
}
80011d40:	0001                	nop
80011d42:	8082                	ret

Disassembly of section .text.mchtmr_isr:

80011d44 <mchtmr_isr>:
}
80011d44:	0001                	nop
80011d46:	8082                	ret

Disassembly of section .text.swi_isr:

80011d48 <swi_isr>:
}
80011d48:	0001                	nop
80011d4a:	8082                	ret

Disassembly of section .text.exception_handler:

80011d4c <exception_handler>:

__attribute__((weak)) long exception_handler(long cause, long epc)
{
80011d4c:	1141                	add	sp,sp,-16
80011d4e:	c62a                	sw	a0,12(sp)
80011d50:	c42e                	sw	a1,8(sp)
    switch (cause) {
80011d52:	4732                	lw	a4,12(sp)
80011d54:	47bd                	li	a5,15
80011d56:	00e7ec63          	bltu	a5,a4,80011d6e <.L23>
80011d5a:	47b2                	lw	a5,12(sp)
80011d5c:	00279713          	sll	a4,a5,0x2
80011d60:	800057b7          	lui	a5,0x80005
80011d64:	0fc78793          	add	a5,a5,252 # 800050fc <.L7>
80011d68:	97ba                	add	a5,a5,a4
80011d6a:	439c                	lw	a5,0(a5)
80011d6c:	8782                	jr	a5

80011d6e <.L23>:
    case MCAUSE_LOAD_PAGE_FAULT:
        break;
    case MCAUSE_STORE_AMO_PAGE_FAULT:
        break;
    default:
        break;
80011d6e:	0001                	nop
    }
    /* Unhandled Trap */
    return epc;
80011d70:	47a2                	lw	a5,8(sp)
}
80011d72:	853e                	mv	a0,a5
80011d74:	0141                	add	sp,sp,16
80011d76:	8082                	ret

Disassembly of section .text.enable_plic_feature:

80011d78 <enable_plic_feature>:
{
80011d78:	1141                	add	sp,sp,-16
    uint32_t plic_feature = 0;
80011d7a:	c602                	sw	zero,12(sp)
    plic_feature |= HPM_PLIC_FEATURE_VECTORED_MODE;
80011d7c:	47b2                	lw	a5,12(sp)
80011d7e:	0027e793          	or	a5,a5,2
80011d82:	c63e                	sw	a5,12(sp)
    plic_feature |= HPM_PLIC_FEATURE_PREEMPTIVE_PRIORITY_IRQ;
80011d84:	47b2                	lw	a5,12(sp)
80011d86:	0017e793          	or	a5,a5,1
80011d8a:	c63e                	sw	a5,12(sp)
80011d8c:	e40007b7          	lui	a5,0xe4000
80011d90:	c43e                	sw	a5,8(sp)
80011d92:	47b2                	lw	a5,12(sp)
80011d94:	c23e                	sw	a5,4(sp)

80011d96 <.LBB14>:
    *(volatile uint32_t *)(base + HPM_PLIC_FEATURE_OFFSET) = feature;
80011d96:	47a2                	lw	a5,8(sp)
80011d98:	4712                	lw	a4,4(sp)
80011d9a:	c398                	sw	a4,0(a5)
}
80011d9c:	0001                	nop

80011d9e <.LBE14>:
}
80011d9e:	0001                	nop
80011da0:	0141                	add	sp,sp,16
80011da2:	8082                	ret

Disassembly of section .text.sysctl_clock_target_is_busy:

80011da4 <sysctl_clock_target_is_busy>:
{
80011da4:	1141                	add	sp,sp,-16
80011da6:	c62a                	sw	a0,12(sp)
80011da8:	c42e                	sw	a1,8(sp)
    return ptr->CLOCK[clock] & SYSCTL_CLOCK_LOC_BUSY_MASK;
80011daa:	4732                	lw	a4,12(sp)
80011dac:	47a2                	lw	a5,8(sp)
80011dae:	60078793          	add	a5,a5,1536 # e4000600 <__FLASH_segment_end__+0x63f00600>
80011db2:	078a                	sll	a5,a5,0x2
80011db4:	97ba                	add	a5,a5,a4
80011db6:	4398                	lw	a4,0(a5)
80011db8:	400007b7          	lui	a5,0x40000
80011dbc:	8ff9                	and	a5,a5,a4
80011dbe:	00f037b3          	snez	a5,a5
80011dc2:	0ff7f793          	zext.b	a5,a5
}
80011dc6:	853e                	mv	a0,a5
80011dc8:	0141                	add	sp,sp,16
80011dca:	8082                	ret

Disassembly of section .text.sysctl_enable_group_resource:

80011dcc <sysctl_enable_group_resource>:
{
80011dcc:	7179                	add	sp,sp,-48
80011dce:	d606                	sw	ra,44(sp)
80011dd0:	c62a                	sw	a0,12(sp)
80011dd2:	87ae                	mv	a5,a1
80011dd4:	8736                	mv	a4,a3
80011dd6:	00f105a3          	sb	a5,11(sp)
80011dda:	87b2                	mv	a5,a2
80011ddc:	00f11423          	sh	a5,8(sp)
80011de0:	87ba                	mv	a5,a4
80011de2:	00f10523          	sb	a5,10(sp)
    if (linkable_resource < sysctl_resource_linkable_start) {
80011de6:	00815703          	lhu	a4,8(sp)
80011dea:	0ff00793          	li	a5,255
80011dee:	00e7e463          	bltu	a5,a4,80011df6 <.L50>
        return status_invalid_argument;
80011df2:	4789                	li	a5,2
80011df4:	a851                	j	80011e88 <.L51>

80011df6 <.L50>:
    index = (linkable_resource - sysctl_resource_linkable_start) / 32;
80011df6:	00815783          	lhu	a5,8(sp)
80011dfa:	f0078793          	add	a5,a5,-256 # 3fffff00 <__AXI_SRAM_segment_end__+0x3edbff00>
80011dfe:	41f7d713          	sra	a4,a5,0x1f
80011e02:	8b7d                	and	a4,a4,31
80011e04:	97ba                	add	a5,a5,a4
80011e06:	8795                	sra	a5,a5,0x5
80011e08:	ce3e                	sw	a5,28(sp)
    offset = (linkable_resource - sysctl_resource_linkable_start) % 32;
80011e0a:	00815783          	lhu	a5,8(sp)
80011e0e:	f0078713          	add	a4,a5,-256
80011e12:	41f75793          	sra	a5,a4,0x1f
80011e16:	83ed                	srl	a5,a5,0x1b
80011e18:	973e                	add	a4,a4,a5
80011e1a:	8b7d                	and	a4,a4,31
80011e1c:	40f707b3          	sub	a5,a4,a5
80011e20:	cc3e                	sw	a5,24(sp)
    switch (group) {
80011e22:	00b14783          	lbu	a5,11(sp)
80011e26:	efa9                	bnez	a5,80011e80 <.L52>
        ptr->GROUP0[index].VALUE = (ptr->GROUP0[index].VALUE & ~(1UL << offset)) | (enable ? (1UL << offset) : 0);
80011e28:	4732                	lw	a4,12(sp)
80011e2a:	47f2                	lw	a5,28(sp)
80011e2c:	08078793          	add	a5,a5,128
80011e30:	0792                	sll	a5,a5,0x4
80011e32:	97ba                	add	a5,a5,a4
80011e34:	4398                	lw	a4,0(a5)
80011e36:	47e2                	lw	a5,24(sp)
80011e38:	4685                	li	a3,1
80011e3a:	00f697b3          	sll	a5,a3,a5
80011e3e:	fff7c793          	not	a5,a5
80011e42:	8f7d                	and	a4,a4,a5
80011e44:	00a14783          	lbu	a5,10(sp)
80011e48:	c791                	beqz	a5,80011e54 <.L53>
80011e4a:	47e2                	lw	a5,24(sp)
80011e4c:	4685                	li	a3,1
80011e4e:	00f697b3          	sll	a5,a3,a5
80011e52:	a011                	j	80011e56 <.L54>

80011e54 <.L53>:
80011e54:	4781                	li	a5,0

80011e56 <.L54>:
80011e56:	8f5d                	or	a4,a4,a5
80011e58:	46b2                	lw	a3,12(sp)
80011e5a:	47f2                	lw	a5,28(sp)
80011e5c:	08078793          	add	a5,a5,128
80011e60:	0792                	sll	a5,a5,0x4
80011e62:	97b6                	add	a5,a5,a3
80011e64:	c398                	sw	a4,0(a5)
        if (enable) {
80011e66:	00a14783          	lbu	a5,10(sp)
80011e6a:	cf89                	beqz	a5,80011e84 <.L58>
            while (sysctl_resource_target_is_busy(ptr, linkable_resource)) {
80011e6c:	0001                	nop

80011e6e <.L56>:
80011e6e:	00815783          	lhu	a5,8(sp)
80011e72:	85be                	mv	a1,a5
80011e74:	4532                	lw	a0,12(sp)
80011e76:	938fa0ef          	jal	8000bfae <sysctl_resource_target_is_busy>
80011e7a:	87aa                	mv	a5,a0
80011e7c:	fbed                	bnez	a5,80011e6e <.L56>
        break;
80011e7e:	a019                	j	80011e84 <.L58>

80011e80 <.L52>:
        return status_invalid_argument;
80011e80:	4789                	li	a5,2
80011e82:	a019                	j	80011e88 <.L51>

80011e84 <.L58>:
        break;
80011e84:	0001                	nop
    return status_success;
80011e86:	4781                	li	a5,0

80011e88 <.L51>:
}
80011e88:	853e                	mv	a0,a5
80011e8a:	50b2                	lw	ra,44(sp)
80011e8c:	6145                	add	sp,sp,48
80011e8e:	8082                	ret

Disassembly of section .text.get_frequency_for_adc:

80011e90 <get_frequency_for_adc>:
{
80011e90:	7179                	add	sp,sp,-48
80011e92:	d606                	sw	ra,44(sp)
80011e94:	c62a                	sw	a0,12(sp)
    uint32_t clk_freq = 0UL;
80011e96:	ce02                	sw	zero,28(sp)
    bool is_mux_valid = false;
80011e98:	00010da3          	sb	zero,27(sp)
    clock_node_t node = clock_node_end;
80011e9c:	02b00793          	li	a5,43
80011ea0:	00f10d23          	sb	a5,26(sp)
    if (instance < ADC_INSTANCE_NUM) {
80011ea4:	4732                	lw	a4,12(sp)
80011ea6:	4785                	li	a5,1
80011ea8:	02e7ee63          	bltu	a5,a4,80011ee4 <.L48>

80011eac <.LBB7>:
        uint32_t mux_in_reg = SYSCTL_ADCCLK_MUX_GET(HPM_SYSCTL->ADCCLK[instance]);
80011eac:	f4000737          	lui	a4,0xf4000
80011eb0:	47b2                	lw	a5,12(sp)
80011eb2:	70078793          	add	a5,a5,1792
80011eb6:	078a                	sll	a5,a5,0x2
80011eb8:	97ba                	add	a5,a5,a4
80011eba:	439c                	lw	a5,0(a5)
80011ebc:	83a1                	srl	a5,a5,0x8
80011ebe:	8b85                	and	a5,a5,1
80011ec0:	ca3e                	sw	a5,20(sp)
        if (mux_in_reg < ARRAY_SIZE(s_adc_clk_mux_node)) {
80011ec2:	4752                	lw	a4,20(sp)
80011ec4:	4785                	li	a5,1
80011ec6:	00e7ef63          	bltu	a5,a4,80011ee4 <.L48>
            node = s_adc_clk_mux_node[mux_in_reg];
80011eca:	800067b7          	lui	a5,0x80006
80011ece:	6e478713          	add	a4,a5,1764 # 800066e4 <s_adc_clk_mux_node>
80011ed2:	47d2                	lw	a5,20(sp)
80011ed4:	97ba                	add	a5,a5,a4
80011ed6:	0007c783          	lbu	a5,0(a5)
80011eda:	00f10d23          	sb	a5,26(sp)
            is_mux_valid = true;
80011ede:	4785                	li	a5,1
80011ee0:	00f10da3          	sb	a5,27(sp)

80011ee4 <.L48>:
    if (is_mux_valid) {
80011ee4:	01b14783          	lbu	a5,27(sp)
80011ee8:	cb8d                	beqz	a5,80011f1a <.L49>
        if (node == clock_node_ahb0) {
80011eea:	01a14703          	lbu	a4,26(sp)
80011eee:	4789                	li	a5,2
80011ef0:	00f71763          	bne	a4,a5,80011efe <.L50>
            clk_freq = get_frequency_for_ip_in_common_group(clock_node_ahb0);
80011ef4:	4509                	li	a0,2
80011ef6:	b4cfa0ef          	jal	8000c242 <get_frequency_for_ip_in_common_group>
80011efa:	ce2a                	sw	a0,28(sp)
80011efc:	a839                	j	80011f1a <.L49>

80011efe <.L50>:
            node += instance;
80011efe:	47b2                	lw	a5,12(sp)
80011f00:	0ff7f793          	zext.b	a5,a5
80011f04:	01a14703          	lbu	a4,26(sp)
80011f08:	97ba                	add	a5,a5,a4
80011f0a:	00f10d23          	sb	a5,26(sp)
            clk_freq = get_frequency_for_ip_in_common_group(node);
80011f0e:	01a14783          	lbu	a5,26(sp)
80011f12:	853e                	mv	a0,a5
80011f14:	b2efa0ef          	jal	8000c242 <get_frequency_for_ip_in_common_group>
80011f18:	ce2a                	sw	a0,28(sp)

80011f1a <.L49>:
    return clk_freq;
80011f1a:	47f2                	lw	a5,28(sp)
}
80011f1c:	853e                	mv	a0,a5
80011f1e:	50b2                	lw	ra,44(sp)
80011f20:	6145                	add	sp,sp,48
80011f22:	8082                	ret

Disassembly of section .text.get_frequency_for_ewdg:

80011f24 <get_frequency_for_ewdg>:
{
80011f24:	7179                	add	sp,sp,-48
80011f26:	d606                	sw	ra,44(sp)
80011f28:	c62a                	sw	a0,12(sp)
    if (EWDG_CTRL0_CLK_SEL_GET(s_wdgs[instance]->CTRL0) == 0) {
80011f2a:	800057b7          	lui	a5,0x80005
80011f2e:	13c78713          	add	a4,a5,316 # 8000513c <s_wdgs>
80011f32:	47b2                	lw	a5,12(sp)
80011f34:	078a                	sll	a5,a5,0x2
80011f36:	97ba                	add	a5,a5,a4
80011f38:	439c                	lw	a5,0(a5)
80011f3a:	4398                	lw	a4,0(a5)
80011f3c:	200007b7          	lui	a5,0x20000
80011f40:	8ff9                	and	a5,a5,a4
80011f42:	e791                	bnez	a5,80011f4e <.L53>
        freq_in_hz = get_frequency_for_ip_in_common_group(clock_node_ahb0);
80011f44:	4509                	li	a0,2
80011f46:	afcfa0ef          	jal	8000c242 <get_frequency_for_ip_in_common_group>
80011f4a:	ce2a                	sw	a0,28(sp)
80011f4c:	a019                	j	80011f52 <.L54>

80011f4e <.L53>:
        freq_in_hz = FREQ_32KHz;
80011f4e:	67a1                	lui	a5,0x8
80011f50:	ce3e                	sw	a5,28(sp)

80011f52 <.L54>:
    return freq_in_hz;
80011f52:	47f2                	lw	a5,28(sp)
}
80011f54:	853e                	mv	a0,a5
80011f56:	50b2                	lw	ra,44(sp)
80011f58:	6145                	add	sp,sp,48
80011f5a:	8082                	ret

Disassembly of section .text.get_frequency_for_pewdg:

80011f5c <get_frequency_for_pewdg>:
{
80011f5c:	1141                	add	sp,sp,-16
    if (EWDG_CTRL0_CLK_SEL_GET(HPM_PEWDG->CTRL0) == 0) {
80011f5e:	f41287b7          	lui	a5,0xf4128
80011f62:	4398                	lw	a4,0(a5)
80011f64:	200007b7          	lui	a5,0x20000
80011f68:	8ff9                	and	a5,a5,a4
80011f6a:	e799                	bnez	a5,80011f78 <.L57>
        freq_in_hz = FREQ_PRESET1_OSC0_CLK0;
80011f6c:	016e37b7          	lui	a5,0x16e3
80011f70:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
80011f74:	c63e                	sw	a5,12(sp)
80011f76:	a019                	j	80011f7c <.L58>

80011f78 <.L57>:
        freq_in_hz = FREQ_32KHz;
80011f78:	67a1                	lui	a5,0x8
80011f7a:	c63e                	sw	a5,12(sp)

80011f7c <.L58>:
    return freq_in_hz;
80011f7c:	47b2                	lw	a5,12(sp)
}
80011f7e:	853e                	mv	a0,a5
80011f80:	0141                	add	sp,sp,16
80011f82:	8082                	ret

Disassembly of section .text.clock_connect_group_to_cpu:

80011f84 <clock_connect_group_to_cpu>:
{
80011f84:	1141                	add	sp,sp,-16
80011f86:	c62a                	sw	a0,12(sp)
80011f88:	c42e                	sw	a1,8(sp)
    if (cpu < 2U) {
80011f8a:	4722                	lw	a4,8(sp)
80011f8c:	4785                	li	a5,1
80011f8e:	00e7ee63          	bltu	a5,a4,80011faa <.L143>
        HPM_SYSCTL->AFFILIATE[cpu].SET = (1UL << group);
80011f92:	f40006b7          	lui	a3,0xf4000
80011f96:	47b2                	lw	a5,12(sp)
80011f98:	4705                	li	a4,1
80011f9a:	00f71733          	sll	a4,a4,a5
80011f9e:	47a2                	lw	a5,8(sp)
80011fa0:	09078793          	add	a5,a5,144 # 8090 <__AHB_SRAM_segment_size__+0x90>
80011fa4:	0792                	sll	a5,a5,0x4
80011fa6:	97b6                	add	a5,a5,a3
80011fa8:	c3d8                	sw	a4,4(a5)

80011faa <.L143>:
}
80011faa:	0001                	nop
80011fac:	0141                	add	sp,sp,16
80011fae:	8082                	ret

Disassembly of section .text.clock_get_core_clock_ticks_per_ms:

80011fb0 <clock_get_core_clock_ticks_per_ms>:
{
80011fb0:	1141                	add	sp,sp,-16
80011fb2:	c606                	sw	ra,12(sp)
    if (hpm_core_clock == 0U) {
80011fb4:	1141a783          	lw	a5,276(gp) # 120948c <hpm_core_clock>
80011fb8:	e391                	bnez	a5,80011fbc <.L151>
        clock_update_core_clock();
80011fba:	2005                	jal	80011fda <.LFE149>

80011fbc <.L151>:
    return (hpm_core_clock + FREQ_1MHz - 1U) / 1000;
80011fbc:	1141a703          	lw	a4,276(gp) # 120948c <hpm_core_clock>
80011fc0:	000f47b7          	lui	a5,0xf4
80011fc4:	23f78793          	add	a5,a5,575 # f423f <__AXI_SRAM_segment_size__+0xb423f>
80011fc8:	973e                	add	a4,a4,a5
80011fca:	3e800793          	li	a5,1000
80011fce:	02f757b3          	divu	a5,a4,a5
}
80011fd2:	853e                	mv	a0,a5
80011fd4:	40b2                	lw	ra,12(sp)
80011fd6:	0141                	add	sp,sp,16
80011fd8:	8082                	ret

Disassembly of section .text.clock_update_core_clock:

80011fda <clock_update_core_clock>:

void clock_update_core_clock(void)
{
80011fda:	1141                	add	sp,sp,-16
80011fdc:	c606                	sw	ra,12(sp)
    hpm_core_clock = clock_get_frequency(clock_cpu0);
80011fde:	4501                	li	a0,0
80011fe0:	900fa0ef          	jal	8000c0e0 <clock_get_frequency>
80011fe4:	872a                	mv	a4,a0
80011fe6:	10e1aa23          	sw	a4,276(gp) # 120948c <hpm_core_clock>
}
80011fea:	0001                	nop
80011fec:	40b2                	lw	ra,12(sp)
80011fee:	0141                	add	sp,sp,16
80011ff0:	8082                	ret

Disassembly of section .text.l1c_dc_invalidate_all:

80011ff2 <l1c_dc_invalidate_all>:
{
80011ff2:	1141                	add	sp,sp,-16
80011ff4:	47dd                	li	a5,23
80011ff6:	00f107a3          	sb	a5,15(sp)

80011ffa <.LBB68>:
    write_csr(CSR_MCCTLCOMMAND, cmd);
80011ffa:	00f14783          	lbu	a5,15(sp)
80011ffe:	7cc79073          	csrw	0x7cc,a5
}
80012002:	0001                	nop

80012004 <.LBE68>:
}
80012004:	0001                	nop
80012006:	0141                	add	sp,sp,16
80012008:	8082                	ret

Disassembly of section .text.init_uart_pins:

8001200a <init_uart_pins>:
{
8001200a:	1141                	add	sp,sp,-16
8001200c:	c62a                	sw	a0,12(sp)
    if (ptr == HPM_UART0) {
8001200e:	4732                	lw	a4,12(sp)
80012010:	f00407b7          	lui	a5,0xf0040
80012014:	00f71b63          	bne	a4,a5,8001202a <.L4>
        HPM_IOC->PAD[IOC_PAD_PA00].FUNC_CTL = IOC_PA00_FUNC_CTL_UART0_TXD;
80012018:	f40407b7          	lui	a5,0xf4040
8001201c:	4709                	li	a4,2
8001201e:	c398                	sw	a4,0(a5)
        HPM_IOC->PAD[IOC_PAD_PA01].FUNC_CTL = IOC_PA01_FUNC_CTL_UART0_RXD;
80012020:	f40407b7          	lui	a5,0xf4040
80012024:	4709                	li	a4,2
80012026:	c798                	sw	a4,8(a5)
}
80012028:	a005                	j	80012048 <.L6>

8001202a <.L4>:
    } else if (ptr == HPM_UART4) {
8001202a:	4732                	lw	a4,12(sp)
8001202c:	f00507b7          	lui	a5,0xf0050
80012030:	00f71c63          	bne	a4,a5,80012048 <.L6>
        HPM_IOC->PAD[IOC_PAD_PC16].FUNC_CTL = IOC_PC16_FUNC_CTL_UART4_TXD;
80012034:	f40407b7          	lui	a5,0xf4040
80012038:	4709                	li	a4,2
8001203a:	28e7a023          	sw	a4,640(a5) # f4040280 <__AHB_SRAM_segment_end__+0x3e38280>
        HPM_IOC->PAD[IOC_PAD_PC17].FUNC_CTL = IOC_PC17_FUNC_CTL_UART4_RXD;
8001203e:	f40407b7          	lui	a5,0xf4040
80012042:	4709                	li	a4,2
80012044:	28e7a423          	sw	a4,648(a5) # f4040288 <__AHB_SRAM_segment_end__+0x3e38288>

80012048 <.L6>:
}
80012048:	0001                	nop
8001204a:	0141                	add	sp,sp,16
8001204c:	8082                	ret

Disassembly of section .text.init_led_pins:

8001204e <init_led_pins>:
    HPM_IOC->PAD[IOC_PAD_PA22].FUNC_CTL = IOC_PA22_FUNC_CTL_GPIO_A_22;
8001204e:	f40407b7          	lui	a5,0xf4040
80012052:	0a07a823          	sw	zero,176(a5) # f40400b0 <__AHB_SRAM_segment_end__+0x3e380b0>
}
80012056:	0001                	nop
80012058:	8082                	ret

Disassembly of section .text.gptmr_check_status:

8001205a <gptmr_check_status>:
{
8001205a:	1141                	add	sp,sp,-16
8001205c:	c62a                	sw	a0,12(sp)
8001205e:	c42e                	sw	a1,8(sp)
    return (ptr->SR & mask) == mask;
80012060:	47b2                	lw	a5,12(sp)
80012062:	2007a703          	lw	a4,512(a5)
80012066:	47a2                	lw	a5,8(sp)
80012068:	8ff9                	and	a5,a5,a4
8001206a:	4722                	lw	a4,8(sp)
8001206c:	40f707b3          	sub	a5,a4,a5
80012070:	0017b793          	seqz	a5,a5
80012074:	0ff7f793          	zext.b	a5,a5
}
80012078:	853e                	mv	a0,a5
8001207a:	0141                	add	sp,sp,16
8001207c:	8082                	ret

Disassembly of section .text.gptmr_clear_status:

8001207e <gptmr_clear_status>:
{
8001207e:	1141                	add	sp,sp,-16
80012080:	c62a                	sw	a0,12(sp)
80012082:	c42e                	sw	a1,8(sp)
    ptr->SR = mask;
80012084:	47b2                	lw	a5,12(sp)
80012086:	4722                	lw	a4,8(sp)
80012088:	20e7a023          	sw	a4,512(a5)
}
8001208c:	0001                	nop
8001208e:	0141                	add	sp,sp,16
80012090:	8082                	ret

Disassembly of section .text.board_init_console:

80012092 <board_init_console>:
{
80012092:	1101                	add	sp,sp,-32
80012094:	ce06                	sw	ra,28(sp)
    init_uart_pins((UART_Type *) BOARD_CONSOLE_UART_BASE);
80012096:	f0040537          	lui	a0,0xf0040
8001209a:	3f85                	jal	8001200a <init_uart_pins>
    clock_add_to_group(BOARD_CONSOLE_UART_CLK_NAME, 0);
8001209c:	4581                	li	a1,0
8001209e:	011607b7          	lui	a5,0x1160
800120a2:	01478513          	add	a0,a5,20 # 1160014 <__DLM_segment_end__+0xf40014>
800120a6:	ad0fa0ef          	jal	8000c376 <clock_add_to_group>
    cfg.type = BOARD_CONSOLE_TYPE;
800120aa:	c002                	sw	zero,0(sp)
    cfg.base = (uint32_t) BOARD_CONSOLE_UART_BASE;
800120ac:	f00407b7          	lui	a5,0xf0040
800120b0:	c23e                	sw	a5,4(sp)
    cfg.src_freq_in_hz = clock_get_frequency(BOARD_CONSOLE_UART_CLK_NAME);
800120b2:	011607b7          	lui	a5,0x1160
800120b6:	01478513          	add	a0,a5,20 # 1160014 <__DLM_segment_end__+0xf40014>
800120ba:	826fa0ef          	jal	8000c0e0 <clock_get_frequency>
800120be:	87aa                	mv	a5,a0
800120c0:	c43e                	sw	a5,8(sp)
    cfg.baudrate = BOARD_CONSOLE_UART_BAUDRATE;
800120c2:	67f1                	lui	a5,0x1c
800120c4:	20078793          	add	a5,a5,512 # 1c200 <__FLASH_segment_used_size__+0x8570>
800120c8:	c63e                	sw	a5,12(sp)
    if (status_success != console_init(&cfg)) {
800120ca:	878a                	mv	a5,sp
800120cc:	853e                	mv	a0,a5
800120ce:	785000ef          	jal	80013052 <console_init>
800120d2:	87aa                	mv	a5,a0
800120d4:	c391                	beqz	a5,800120d8 <.L39>

800120d6 <.L38>:
        while (1) {
800120d6:	a001                	j	800120d6 <.L38>

800120d8 <.L39>:
}
800120d8:	0001                	nop
800120da:	40f2                	lw	ra,28(sp)
800120dc:	6105                	add	sp,sp,32
800120de:	8082                	ret

Disassembly of section .text.board_print_clock_freq:

800120e0 <board_print_clock_freq>:
{
800120e0:	1141                	add	sp,sp,-16
800120e2:	c606                	sw	ra,12(sp)
    printf("==============================\n");
800120e4:	800057b7          	lui	a5,0x80005
800120e8:	1bc78513          	add	a0,a5,444 # 800051bc <.LC0>
800120ec:	cd5fb0ef          	jal	8000ddc0 <printf>
    printf(" %s clock summary\n", BOARD_NAME);
800120f0:	800057b7          	lui	a5,0x80005
800120f4:	1dc78593          	add	a1,a5,476 # 800051dc <.LC1>
800120f8:	800057b7          	lui	a5,0x80005
800120fc:	1f078513          	add	a0,a5,496 # 800051f0 <.LC2>
80012100:	cc1fb0ef          	jal	8000ddc0 <printf>
    printf("==============================\n");
80012104:	800057b7          	lui	a5,0x80005
80012108:	1bc78513          	add	a0,a5,444 # 800051bc <.LC0>
8001210c:	cb5fb0ef          	jal	8000ddc0 <printf>
    printf("cpu0:\t\t %dHz\n", clock_get_frequency(clock_cpu0));
80012110:	4501                	li	a0,0
80012112:	fcff90ef          	jal	8000c0e0 <clock_get_frequency>
80012116:	87aa                	mv	a5,a0
80012118:	85be                	mv	a1,a5
8001211a:	800057b7          	lui	a5,0x80005
8001211e:	20478513          	add	a0,a5,516 # 80005204 <.LC3>
80012122:	c9ffb0ef          	jal	8000ddc0 <printf>
    printf("ahb:\t\t %luHz\n", clock_get_frequency(clock_ahb0));
80012126:	010007b7          	lui	a5,0x1000
8001212a:	00278513          	add	a0,a5,2 # 1000002 <__DLM_segment_end__+0xde0002>
8001212e:	fb3f90ef          	jal	8000c0e0 <clock_get_frequency>
80012132:	87aa                	mv	a5,a0
80012134:	85be                	mv	a1,a5
80012136:	800057b7          	lui	a5,0x80005
8001213a:	21478513          	add	a0,a5,532 # 80005214 <.LC4>
8001213e:	c83fb0ef          	jal	8000ddc0 <printf>
    printf("axif:\t\t %dHz\n", clock_get_frequency(clock_axif));
80012142:	77c1                	lui	a5,0xffff0
80012144:	00378513          	add	a0,a5,3 # ffff0003 <__AHB_SRAM_segment_end__+0xfde8003>
80012148:	f99f90ef          	jal	8000c0e0 <clock_get_frequency>
8001214c:	87aa                	mv	a5,a0
8001214e:	85be                	mv	a1,a5
80012150:	800057b7          	lui	a5,0x80005
80012154:	22478513          	add	a0,a5,548 # 80005224 <.LC5>
80012158:	c69fb0ef          	jal	8000ddc0 <printf>
    printf("axis:\t\t %dHz\n", clock_get_frequency(clock_axis));
8001215c:	010107b7          	lui	a5,0x1010
80012160:	00478513          	add	a0,a5,4 # 1010004 <__DLM_segment_end__+0xdf0004>
80012164:	f7df90ef          	jal	8000c0e0 <clock_get_frequency>
80012168:	87aa                	mv	a5,a0
8001216a:	85be                	mv	a1,a5
8001216c:	800057b7          	lui	a5,0x80005
80012170:	23478513          	add	a0,a5,564 # 80005234 <.LC6>
80012174:	c4dfb0ef          	jal	8000ddc0 <printf>
    printf("axic:\t\t %dHz\n", clock_get_frequency(clock_axic));
80012178:	010207b7          	lui	a5,0x1020
8001217c:	00578513          	add	a0,a5,5 # 1020005 <__DLM_segment_end__+0xe00005>
80012180:	f61f90ef          	jal	8000c0e0 <clock_get_frequency>
80012184:	87aa                	mv	a5,a0
80012186:	85be                	mv	a1,a5
80012188:	800057b7          	lui	a5,0x80005
8001218c:	24478513          	add	a0,a5,580 # 80005244 <.LC7>
80012190:	c31fb0ef          	jal	8000ddc0 <printf>
    printf("xpi0:\t\t %dHz\n", clock_get_frequency(clock_xpi0));
80012194:	013807b7          	lui	a5,0x1380
80012198:	02078513          	add	a0,a5,32 # 1380020 <__AXI_SRAM_segment_end__+0x140020>
8001219c:	f45f90ef          	jal	8000c0e0 <clock_get_frequency>
800121a0:	87aa                	mv	a5,a0
800121a2:	85be                	mv	a1,a5
800121a4:	800057b7          	lui	a5,0x80005
800121a8:	25478513          	add	a0,a5,596 # 80005254 <.LC8>
800121ac:	c15fb0ef          	jal	8000ddc0 <printf>
    printf("mchtmr0:\t %dHz\n", clock_get_frequency(clock_mchtmr0));
800121b0:	010507b7          	lui	a5,0x1050
800121b4:	00178513          	add	a0,a5,1 # 1050001 <__DLM_segment_end__+0xe30001>
800121b8:	f29f90ef          	jal	8000c0e0 <clock_get_frequency>
800121bc:	87aa                	mv	a5,a0
800121be:	85be                	mv	a1,a5
800121c0:	800057b7          	lui	a5,0x80005
800121c4:	26478513          	add	a0,a5,612 # 80005264 <.LC9>
800121c8:	bf9fb0ef          	jal	8000ddc0 <printf>
    printf("==============================\n");
800121cc:	800057b7          	lui	a5,0x80005
800121d0:	1bc78513          	add	a0,a5,444 # 800051bc <.LC0>
800121d4:	bedfb0ef          	jal	8000ddc0 <printf>
}
800121d8:	0001                	nop
800121da:	40b2                	lw	ra,12(sp)
800121dc:	0141                	add	sp,sp,16
800121de:	8082                	ret

Disassembly of section .text.board_init:

800121e0 <board_init>:
    /* Keep cpu clock on wfi, so that mchtmr irq can still work after wfi */
    sysctl_set_cpu_lp_mode(HPM_SYSCTL, BOARD_RUNNING_CORE, cpu_lp_mode_ungate_cpu_clock);
}

void board_init(void)
{
800121e0:	1141                	add	sp,sp,-16
800121e2:	c606                	sw	ra,12(sp)
    board_init_clock();
800121e4:	288d                	jal	80012256 <board_init_clock>
    board_init_console();
800121e6:	3575                	jal	80012092 <board_init_console>
    board_init_pmp();
800121e8:	20ad                	jal	80012252 <board_init_pmp>
#if BOARD_SHOW_CLOCK
    board_print_clock_freq();
800121ea:	3ddd                	jal	800120e0 <board_print_clock_freq>
#endif
#if BOARD_SHOW_BANNER
    board_print_banner();
800121ec:	de8fa0ef          	jal	8000c7d4 <board_print_banner>
#endif
}
800121f0:	0001                	nop
800121f2:	40b2                	lw	ra,12(sp)
800121f4:	0141                	add	sp,sp,16
800121f6:	8082                	ret

Disassembly of section .text.board_delay_ms:

800121f8 <board_delay_ms>:
{
    clock_cpu_delay_us(us);
}

void board_delay_ms(uint32_t ms)
{
800121f8:	1101                	add	sp,sp,-32
800121fa:	ce06                	sw	ra,28(sp)
800121fc:	c62a                	sw	a0,12(sp)
    clock_cpu_delay_ms(ms);
800121fe:	4532                	lw	a0,12(sp)
80012200:	9b0fa0ef          	jal	8000c3b0 <clock_cpu_delay_ms>
}
80012204:	0001                	nop
80012206:	40f2                	lw	ra,28(sp)
80012208:	6105                	add	sp,sp,32
8001220a:	8082                	ret

Disassembly of section .text.board_init_led_pins:

8001220c <board_init_led_pins>:
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void board_init_led_pins(void)
{
8001220c:	1141                	add	sp,sp,-16
8001220e:	c606                	sw	ra,12(sp)
    init_led_pins();
80012210:	3d3d                	jal	8001204e <init_led_pins>
    gpio_set_pin_output_with_initial(BOARD_LED_GPIO_CTRL, BOARD_LED_GPIO_INDEX, BOARD_LED_GPIO_PIN, board_get_led_gpio_off_level());
80012212:	e00fa0ef          	jal	8000c812 <board_get_led_gpio_off_level>
80012216:	87aa                	mv	a5,a0
80012218:	86be                	mv	a3,a5
8001221a:	4659                	li	a2,22
8001221c:	4581                	li	a1,0
8001221e:	f00d0537          	lui	a0,0xf00d0
80012222:	88bfa0ef          	jal	8000caac <gpio_set_pin_output_with_initial>
}
80012226:	0001                	nop
80012228:	40b2                	lw	ra,12(sp)
8001222a:	0141                	add	sp,sp,16
8001222c:	8082                	ret

Disassembly of section .text.board_led_write:

8001222e <board_led_write>:
*	形    参: state: 设置的状态
*	返 回 值: 无
*********************************************************************************************************
*/
void board_led_write(uint8_t state)
{
8001222e:	1101                	add	sp,sp,-32
80012230:	ce06                	sw	ra,28(sp)
80012232:	87aa                	mv	a5,a0
80012234:	00f107a3          	sb	a5,15(sp)
    gpio_write_pin(BOARD_LED_GPIO_CTRL, BOARD_LED_GPIO_INDEX, BOARD_LED_GPIO_PIN, state);
80012238:	00f14783          	lbu	a5,15(sp)
8001223c:	86be                	mv	a3,a5
8001223e:	4659                	li	a2,22
80012240:	4581                	li	a1,0
80012242:	f00d0537          	lui	a0,0xf00d0
80012246:	d16fa0ef          	jal	8000c75c <gpio_write_pin>
}
8001224a:	0001                	nop
8001224c:	40f2                	lw	ra,28(sp)
8001224e:	6105                	add	sp,sp,32
80012250:	8082                	ret

Disassembly of section .text.board_init_pmp:

80012252 <board_init_pmp>:

void board_init_pmp(void)
{
}
80012252:	0001                	nop
80012254:	8082                	ret

Disassembly of section .text.board_init_clock:

80012256 <board_init_clock>:
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void board_init_clock(void)
{
80012256:	1101                	add	sp,sp,-32
80012258:	ce06                	sw	ra,28(sp)
    uint32_t cpu0_freq = clock_get_frequency(clock_cpu0);
8001225a:	4501                	li	a0,0
8001225c:	e85f90ef          	jal	8000c0e0 <clock_get_frequency>
80012260:	c62a                	sw	a0,12(sp)
    if (cpu0_freq == PLLCTL_SOC_PLL_REFCLK_FREQ) {
80012262:	4732                	lw	a4,12(sp)
80012264:	016e37b7          	lui	a5,0x16e3
80012268:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
8001226c:	00f71f63          	bne	a4,a5,8001228a <.L83>
        /* Configure the External OSC ramp-up time: ~9ms */
        pllctlv2_xtal_set_rampup_time(HPM_PLLCTLV2, 32ul * 1000ul * 9u);
80012270:	000467b7          	lui	a5,0x46
80012274:	50078593          	add	a1,a5,1280 # 46500 <__AXI_SRAM_segment_size__+0x6500>
80012278:	f40c0537          	lui	a0,0xf40c0
8001227c:	d32fa0ef          	jal	8000c7ae <pllctlv2_xtal_set_rampup_time>

        /* select clock setting preset1 */
        sysctl_clock_set_preset(HPM_SYSCTL, 2);
80012280:	4589                	li	a1,2
80012282:	f4000537          	lui	a0,0xf4000
80012286:	cacfa0ef          	jal	8000c732 <sysctl_clock_set_preset>

8001228a <.L83>:
    }
    /* Add Clocks to group 0 */
    clock_add_to_group(clock_cpu0, 0);
8001228a:	4581                	li	a1,0
8001228c:	4501                	li	a0,0
8001228e:	8e8fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_mchtmr0, 0);
80012292:	4581                	li	a1,0
80012294:	010507b7          	lui	a5,0x1050
80012298:	00178513          	add	a0,a5,1 # 1050001 <__DLM_segment_end__+0xe30001>
8001229c:	8dafa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_ahb0, 0);
800122a0:	4581                	li	a1,0
800122a2:	010007b7          	lui	a5,0x1000
800122a6:	00278513          	add	a0,a5,2 # 1000002 <__DLM_segment_end__+0xde0002>
800122aa:	8ccfa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_axif, 0);
800122ae:	4581                	li	a1,0
800122b0:	77c1                	lui	a5,0xffff0
800122b2:	00378513          	add	a0,a5,3 # ffff0003 <__AHB_SRAM_segment_end__+0xfde8003>
800122b6:	8c0fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_axis, 0);
800122ba:	4581                	li	a1,0
800122bc:	010107b7          	lui	a5,0x1010
800122c0:	00478513          	add	a0,a5,4 # 1010004 <__DLM_segment_end__+0xdf0004>
800122c4:	8b2fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_axic, 0);
800122c8:	4581                	li	a1,0
800122ca:	010207b7          	lui	a5,0x1020
800122ce:	00578513          	add	a0,a5,5 # 1020005 <__DLM_segment_end__+0xe00005>
800122d2:	8a4fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_rom0, 0);
800122d6:	4581                	li	a1,0
800122d8:	010307b7          	lui	a5,0x1030
800122dc:	50678513          	add	a0,a5,1286 # 1030506 <__DLM_segment_end__+0xe10506>
800122e0:	896fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_xpi0, 0);
800122e4:	4581                	li	a1,0
800122e6:	013807b7          	lui	a5,0x1380
800122ea:	02078513          	add	a0,a5,32 # 1380020 <__AXI_SRAM_segment_end__+0x140020>
800122ee:	888fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_lmm0, 0);
800122f2:	4581                	li	a1,0
800122f4:	010417b7          	lui	a5,0x1041
800122f8:	90078513          	add	a0,a5,-1792 # 1040900 <__DLM_segment_end__+0xe20900>
800122fc:	87afa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_ram0, 0);
80012300:	4581                	li	a1,0
80012302:	013907b7          	lui	a5,0x1390
80012306:	40078513          	add	a0,a5,1024 # 1390400 <__AXI_SRAM_segment_end__+0x150400>
8001230a:	86cfa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_hdma, 0);
8001230e:	4581                	li	a1,0
80012310:	012507b7          	lui	a5,0x1250
80012314:	30078513          	add	a0,a5,768 # 1250300 <__AXI_SRAM_segment_end__+0x10300>
80012318:	85efa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_xdma, 0);
8001231c:	4581                	li	a1,0
8001231e:	013a07b7          	lui	a5,0x13a0
80012322:	50478513          	add	a0,a5,1284 # 13a0504 <__AXI_SRAM_segment_end__+0x160504>
80012326:	850fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_gpio, 0);
8001232a:	4581                	li	a1,0
8001232c:	012307b7          	lui	a5,0x1230
80012330:	30078513          	add	a0,a5,768 # 1230300 <__AXI_SRAM_segment_used_end__+0x26da4>
80012334:	842fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_ptpc, 0);
80012338:	4581                	li	a1,0
8001233a:	012e07b7          	lui	a5,0x12e0
8001233e:	30078513          	add	a0,a5,768 # 12e0300 <__AXI_SRAM_segment_end__+0xa0300>
80012342:	834fa0ef          	jal	8000c376 <clock_add_to_group>
    /* Motor Related */
    clock_add_to_group(clock_qei0, 0);
80012346:	4581                	li	a1,0
80012348:	012f07b7          	lui	a5,0x12f0
8001234c:	30078513          	add	a0,a5,768 # 12f0300 <__AXI_SRAM_segment_end__+0xb0300>
80012350:	826fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_plb0, 0);
80012354:	4581                	li	a1,0
80012356:	013407b7          	lui	a5,0x1340
8001235a:	30078513          	add	a0,a5,768 # 1340300 <__AXI_SRAM_segment_end__+0x100300>
8001235e:	818fa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_qei1, 0);
80012362:	4581                	li	a1,0
80012364:	013007b7          	lui	a5,0x1300
80012368:	30078513          	add	a0,a5,768 # 1300300 <__AXI_SRAM_segment_end__+0xc0300>
8001236c:	80afa0ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_qeo0, 0);
80012370:	4581                	li	a1,0
80012372:	013107b7          	lui	a5,0x1310
80012376:	30078513          	add	a0,a5,768 # 1310300 <__AXI_SRAM_segment_end__+0xd0300>
8001237a:	ffdf90ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_qeo1, 0);
8001237e:	4581                	li	a1,0
80012380:	013207b7          	lui	a5,0x1320
80012384:	30078513          	add	a0,a5,768 # 1320300 <__AXI_SRAM_segment_end__+0xe0300>
80012388:	feff90ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_pwm0, 0);
8001238c:	4581                	li	a1,0
8001238e:	013507b7          	lui	a5,0x1350
80012392:	30078513          	add	a0,a5,768 # 1350300 <__AXI_SRAM_segment_end__+0x110300>
80012396:	fe1f90ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_pwm1, 0);
8001239a:	4581                	li	a1,0
8001239c:	013607b7          	lui	a5,0x1360
800123a0:	30078513          	add	a0,a5,768 # 1360300 <__AXI_SRAM_segment_end__+0x120300>
800123a4:	fd3f90ef          	jal	8000c376 <clock_add_to_group>
    clock_add_to_group(clock_emds, 0);
800123a8:	4581                	li	a1,0
800123aa:	013707b7          	lui	a5,0x1370
800123ae:	30078513          	add	a0,a5,768 # 1370300 <__AXI_SRAM_segment_end__+0x130300>
800123b2:	fc5f90ef          	jal	8000c376 <clock_add_to_group>
    /* Connect Group0 to CPU0 */
    clock_connect_group_to_cpu(0, 0);
800123b6:	4581                	li	a1,0
800123b8:	4501                	li	a0,0
800123ba:	36e9                	jal	80011f84 <clock_connect_group_to_cpu>

    /* Bump up DCDC voltage to 1275mv */
    pcfg_dcdc_set_voltage(HPM_PCFG, 1275);
800123bc:	4fb00593          	li	a1,1275
800123c0:	f4104537          	lui	a0,0xf4104
800123c4:	267000ef          	jal	80012e2a <pcfg_dcdc_set_voltage>

    /* Configure PLL0 Post Divider */
    pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk0, pllctlv2_div_1p0);    /* PLL0CLK0: 480MHz */
800123c8:	4681                	li	a3,0
800123ca:	4601                	li	a2,0
800123cc:	4581                	li	a1,0
800123ce:	f40c0537          	lui	a0,0xf40c0
800123d2:	13f000ef          	jal	80012d10 <pllctlv2_set_postdiv>
    pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk1, pllctlv2_div_1p2);    /* PLL0CLK1: 400MHz */
800123d6:	4685                	li	a3,1
800123d8:	4605                	li	a2,1
800123da:	4581                	li	a1,0
800123dc:	f40c0537          	lui	a0,0xf40c0
800123e0:	131000ef          	jal	80012d10 <pllctlv2_set_postdiv>
    /* Configure PLL0 Frequency to 480MHz */
    pllctlv2_init_pll_with_freq(HPM_PLLCTLV2, pllctlv2_pll0, BOARD_CPU_FREQ);
800123e4:	1c9c47b7          	lui	a5,0x1c9c4
800123e8:	80078613          	add	a2,a5,-2048 # 1c9c3800 <__AXI_SRAM_segment_end__+0x1b783800>
800123ec:	4581                	li	a1,0
800123ee:	f40c0537          	lui	a0,0xf40c0
800123f2:	047000ef          	jal	80012c38 <pllctlv2_init_pll_with_freq>
    /* CPU clock use clk_src_pll0_clk0 */
    clock_set_source_divider(clock_cpu0, clk_src_pll0_clk0, 1);
800123f6:	4605                	li	a2,1
800123f8:	4585                	li	a1,1
800123fa:	4501                	li	a0,0
800123fc:	eb3f90ef          	jal	8000c2ae <clock_set_source_divider>
    clock_update_core_clock();
80012400:	3ee9                	jal	80011fda <clock_update_core_clock>

    /* Configure mchtmr to 24MHz */
    clock_set_source_divider(clock_mchtmr0, clk_src_osc24m, 1);
80012402:	4605                	li	a2,1
80012404:	4581                	li	a1,0
80012406:	010507b7          	lui	a5,0x1050
8001240a:	00178513          	add	a0,a5,1 # 1050001 <__DLM_segment_end__+0xe30001>
8001240e:	ea1f90ef          	jal	8000c2ae <clock_set_source_divider>
}
80012412:	0001                	nop
80012414:	40f2                	lw	ra,28(sp)
80012416:	6105                	add	sp,sp,32
80012418:	8082                	ret

Disassembly of section .text.board_init_ethercat:

8001241a <board_init_ethercat>:
{
    init_owr_pins(ptr);
}

void board_init_ethercat(ESC_Type *ptr)
{
8001241a:	1101                	add	sp,sp,-32
8001241c:	ce06                	sw	ra,28(sp)
8001241e:	c62a                	sw	a0,12(sp)
    (void)ptr;

    clock_add_to_group(clock_esc0, 0);
80012420:	4581                	li	a1,0
80012422:	013b07b7          	lui	a5,0x13b0
80012426:	02178513          	add	a0,a5,33 # 13b0021 <__AXI_SRAM_segment_end__+0x170021>
8001242a:	f4df90ef          	jal	8000c376 <clock_add_to_group>

    init_esc_pins();
8001242e:	92afa0ef          	jal	8000c558 <init_esc_pins>
    /* PHY reset pin */
    gpio_set_pin_output_with_initial(HPM_GPIO0, BOARD_ECAT_PHY0_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY0_RESET_PIN_INDEX, 0);
80012432:	4681                	li	a3,0
80012434:	4669                	li	a2,26
80012436:	4585                	li	a1,1
80012438:	f00d0537          	lui	a0,0xf00d0
8001243c:	e70fa0ef          	jal	8000caac <gpio_set_pin_output_with_initial>
#if BOARD_ECAT_SUPPORT_PORT1
    gpio_set_pin_output_with_initial(HPM_GPIO0, BOARD_ECAT_PHY1_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY1_RESET_PIN_INDEX, 0);
80012440:	4681                	li	a3,0
80012442:	4669                	li	a2,26
80012444:	4585                	li	a1,1
80012446:	f00d0537          	lui	a0,0xf00d0
8001244a:	e62fa0ef          	jal	8000caac <gpio_set_pin_output_with_initial>
#endif
#if BOARD_ECAT_SUPPORT_PORT2
    gpio_set_pin_output_with_initial(HPM_GPIO0, BOARD_ECAT_PHY2_RESET_GPIO_PORT_INDEX, BOARD_ECAT_PHY2_RESET_PIN_INDEX, 0);
#endif
}
8001244e:	0001                	nop
80012450:	40f2                	lw	ra,28(sp)
80012452:	6105                	add	sp,sp,32
80012454:	8082                	ret

Disassembly of section .text.uart_modem_config:

80012456 <uart_modem_config>:
 *
 * @param [in] ptr UART base address
 * @param config Pointer to modem config struct
 */
static inline void uart_modem_config(UART_Type *ptr, uart_modem_config_t *config)
{
80012456:	1141                	add	sp,sp,-16
80012458:	c62a                	sw	a0,12(sp)
8001245a:	c42e                	sw	a1,8(sp)
    ptr->MCR = UART_MCR_AFE_SET(config->auto_flow_ctrl_en)
8001245c:	47a2                	lw	a5,8(sp)
8001245e:	0007c783          	lbu	a5,0(a5)
80012462:	0796                	sll	a5,a5,0x5
80012464:	0207f713          	and	a4,a5,32
        | UART_MCR_LOOP_SET(config->loop_back_en)
80012468:	47a2                	lw	a5,8(sp)
8001246a:	0017c783          	lbu	a5,1(a5)
8001246e:	0792                	sll	a5,a5,0x4
80012470:	8bc1                	and	a5,a5,16
80012472:	8f5d                	or	a4,a4,a5
        | UART_MCR_RTS_SET(!config->set_rts_high);
80012474:	47a2                	lw	a5,8(sp)
80012476:	0027c783          	lbu	a5,2(a5)
8001247a:	0017c793          	xor	a5,a5,1
8001247e:	0ff7f793          	zext.b	a5,a5
80012482:	0786                	sll	a5,a5,0x1
80012484:	8b89                	and	a5,a5,2
80012486:	8f5d                	or	a4,a4,a5
    ptr->MCR = UART_MCR_AFE_SET(config->auto_flow_ctrl_en)
80012488:	47b2                	lw	a5,12(sp)
8001248a:	db98                	sw	a4,48(a5)
}
8001248c:	0001                	nop
8001248e:	0141                	add	sp,sp,16
80012490:	8082                	ret

Disassembly of section .text.uart_disable_irq:

80012492 <uart_disable_irq>:
 *
 * @param [in] ptr UART base address
 * @param irq_mask IRQ mask value to be disabled
 */
static inline void uart_disable_irq(UART_Type *ptr, uint32_t irq_mask)
{
80012492:	1141                	add	sp,sp,-16
80012494:	c62a                	sw	a0,12(sp)
80012496:	c42e                	sw	a1,8(sp)
    ptr->IER &= ~irq_mask;
80012498:	47b2                	lw	a5,12(sp)
8001249a:	53d8                	lw	a4,36(a5)
8001249c:	47a2                	lw	a5,8(sp)
8001249e:	fff7c793          	not	a5,a5
800124a2:	8f7d                	and	a4,a4,a5
800124a4:	47b2                	lw	a5,12(sp)
800124a6:	d3d8                	sw	a4,36(a5)
}
800124a8:	0001                	nop
800124aa:	0141                	add	sp,sp,16
800124ac:	8082                	ret

Disassembly of section .text.uart_enable_irq:

800124ae <uart_enable_irq>:
 *
 * @param [in] ptr UART base address
 * @param irq_mask IRQ mask value to be enabled
 */
static inline void uart_enable_irq(UART_Type *ptr, uint32_t irq_mask)
{
800124ae:	1141                	add	sp,sp,-16
800124b0:	c62a                	sw	a0,12(sp)
800124b2:	c42e                	sw	a1,8(sp)
    ptr->IER |= irq_mask;
800124b4:	47b2                	lw	a5,12(sp)
800124b6:	53d8                	lw	a4,36(a5)
800124b8:	47a2                	lw	a5,8(sp)
800124ba:	8f5d                	or	a4,a4,a5
800124bc:	47b2                	lw	a5,12(sp)
800124be:	d3d8                	sw	a4,36(a5)
}
800124c0:	0001                	nop
800124c2:	0141                	add	sp,sp,16
800124c4:	8082                	ret

Disassembly of section .text.uart_default_config:

800124c6 <uart_default_config>:
{
800124c6:	1141                	add	sp,sp,-16
800124c8:	c62a                	sw	a0,12(sp)
800124ca:	c42e                	sw	a1,8(sp)
    config->baudrate = 115200;
800124cc:	47a2                	lw	a5,8(sp)
800124ce:	6771                	lui	a4,0x1c
800124d0:	20070713          	add	a4,a4,512 # 1c200 <__FLASH_segment_used_size__+0x8570>
800124d4:	c3d8                	sw	a4,4(a5)
    config->word_length = word_length_8_bits;
800124d6:	47a2                	lw	a5,8(sp)
800124d8:	470d                	li	a4,3
800124da:	00e784a3          	sb	a4,9(a5)
    config->parity = parity_none;
800124de:	47a2                	lw	a5,8(sp)
800124e0:	00078523          	sb	zero,10(a5)
    config->num_of_stop_bits = stop_bits_1;
800124e4:	47a2                	lw	a5,8(sp)
800124e6:	00078423          	sb	zero,8(a5)
    config->fifo_enable = true;
800124ea:	47a2                	lw	a5,8(sp)
800124ec:	4705                	li	a4,1
800124ee:	00e78723          	sb	a4,14(a5)
    config->rx_fifo_level = uart_rx_fifo_trg_not_empty;
800124f2:	47a2                	lw	a5,8(sp)
800124f4:	00078623          	sb	zero,12(a5)
    config->tx_fifo_level = uart_tx_fifo_trg_not_full;
800124f8:	47a2                	lw	a5,8(sp)
800124fa:	477d                	li	a4,31
800124fc:	00e785a3          	sb	a4,11(a5)
    config->dma_enable = false;
80012500:	47a2                	lw	a5,8(sp)
80012502:	000786a3          	sb	zero,13(a5)
    config->modem_config.auto_flow_ctrl_en = false;
80012506:	47a2                	lw	a5,8(sp)
80012508:	000787a3          	sb	zero,15(a5)
    config->modem_config.loop_back_en = false;
8001250c:	47a2                	lw	a5,8(sp)
8001250e:	00078823          	sb	zero,16(a5)
    config->modem_config.set_rts_high = false;
80012512:	47a2                	lw	a5,8(sp)
80012514:	000788a3          	sb	zero,17(a5)
    config->rxidle_config.detect_enable = false;
80012518:	47a2                	lw	a5,8(sp)
8001251a:	00078923          	sb	zero,18(a5)
    config->rxidle_config.detect_irq_enable = false;
8001251e:	47a2                	lw	a5,8(sp)
80012520:	000789a3          	sb	zero,19(a5)
    config->rxidle_config.idle_cond = uart_rxline_idle_cond_rxline_logic_one;
80012524:	47a2                	lw	a5,8(sp)
80012526:	00078a23          	sb	zero,20(a5)
    config->rxidle_config.threshold = 10; /* 10-bit for typical UART configuration (8-N-1) */
8001252a:	47a2                	lw	a5,8(sp)
8001252c:	4729                	li	a4,10
8001252e:	00e78aa3          	sb	a4,21(a5)
    config->txidle_config.detect_enable = false;
80012532:	47a2                	lw	a5,8(sp)
80012534:	00078b23          	sb	zero,22(a5)
    config->txidle_config.detect_irq_enable = false;
80012538:	47a2                	lw	a5,8(sp)
8001253a:	00078ba3          	sb	zero,23(a5)
    config->txidle_config.idle_cond = uart_rxline_idle_cond_rxline_logic_one;
8001253e:	47a2                	lw	a5,8(sp)
80012540:	00078c23          	sb	zero,24(a5)
    config->txidle_config.threshold = 10; /* 10-bit for typical UART configuration (8-N-1) */
80012544:	47a2                	lw	a5,8(sp)
80012546:	4729                	li	a4,10
80012548:	00e78ca3          	sb	a4,25(a5)
    config->rx_enable = true;
8001254c:	47a2                	lw	a5,8(sp)
8001254e:	4705                	li	a4,1
80012550:	00e78d23          	sb	a4,26(a5)
}
80012554:	0001                	nop
80012556:	0141                	add	sp,sp,16
80012558:	8082                	ret

Disassembly of section .text.uart_calculate_baudrate:

8001255a <uart_calculate_baudrate>:
{
8001255a:	7119                	add	sp,sp,-128
8001255c:	de86                	sw	ra,124(sp)
8001255e:	dca2                	sw	s0,120(sp)
80012560:	daa6                	sw	s1,116(sp)
80012562:	d8ca                	sw	s2,112(sp)
80012564:	d6ce                	sw	s3,108(sp)
80012566:	d4d2                	sw	s4,104(sp)
80012568:	d2d6                	sw	s5,100(sp)
8001256a:	d0da                	sw	s6,96(sp)
8001256c:	cede                	sw	s7,92(sp)
8001256e:	cce2                	sw	s8,88(sp)
80012570:	cae6                	sw	s9,84(sp)
80012572:	c8ea                	sw	s10,80(sp)
80012574:	c6ee                	sw	s11,76(sp)
80012576:	ce2a                	sw	a0,28(sp)
80012578:	cc2e                	sw	a1,24(sp)
8001257a:	ca32                	sw	a2,20(sp)
8001257c:	c836                	sw	a3,16(sp)
    if ((div_out == NULL) || (!freq) || (!baudrate)
8001257e:	46d2                	lw	a3,20(sp)
80012580:	ca85                	beqz	a3,800125b0 <.L6>
80012582:	46f2                	lw	a3,28(sp)
80012584:	c695                	beqz	a3,800125b0 <.L6>
80012586:	46e2                	lw	a3,24(sp)
80012588:	c685                	beqz	a3,800125b0 <.L6>
            || (baudrate < HPM_UART_MINIMUM_BAUDRATE)
8001258a:	4662                	lw	a2,24(sp)
8001258c:	0c700693          	li	a3,199
80012590:	02c6f063          	bgeu	a3,a2,800125b0 <.L6>
            || (freq / HPM_UART_BAUDRATE_DIV_MIN < baudrate * HPM_UART_OSC_MIN)
80012594:	46e2                	lw	a3,24(sp)
80012596:	068e                	sll	a3,a3,0x3
80012598:	4672                	lw	a2,28(sp)
8001259a:	00d66b63          	bltu	a2,a3,800125b0 <.L6>
            || (freq / HPM_UART_BAUDRATE_DIV_MAX > (baudrate * HPM_UART_OSC_MAX))) {
8001259e:	4672                	lw	a2,28(sp)
800125a0:	66c1                	lui	a3,0x10
800125a2:	16fd                	add	a3,a3,-1 # ffff <__AXI_SRAM_segment_used_size__+0x6aa3>
800125a4:	02d65633          	divu	a2,a2,a3
800125a8:	46e2                	lw	a3,24(sp)
800125aa:	0696                	sll	a3,a3,0x5
800125ac:	00c6f463          	bgeu	a3,a2,800125b4 <.L7>

800125b0 <.L6>:
        return 0;
800125b0:	4781                	li	a5,0
800125b2:	ac91                	j	80012806 <.L8>

800125b4 <.L7>:
    tmp = ((uint64_t)freq * HPM_UART_BAUDRATE_SCALE) / baudrate;
800125b4:	46f2                	lw	a3,28(sp)
800125b6:	8736                	mv	a4,a3
800125b8:	4781                	li	a5,0
800125ba:	3e800693          	li	a3,1000
800125be:	02d78633          	mul	a2,a5,a3
800125c2:	4681                	li	a3,0
800125c4:	02d706b3          	mul	a3,a4,a3
800125c8:	9636                	add	a2,a2,a3
800125ca:	3e800693          	li	a3,1000
800125ce:	02d705b3          	mul	a1,a4,a3
800125d2:	02d738b3          	mulhu	a7,a4,a3
800125d6:	882e                	mv	a6,a1
800125d8:	011607b3          	add	a5,a2,a7
800125dc:	88be                	mv	a7,a5
800125de:	47e2                	lw	a5,24(sp)
800125e0:	833e                	mv	t1,a5
800125e2:	4381                	li	t2,0
800125e4:	861a                	mv	a2,t1
800125e6:	869e                	mv	a3,t2
800125e8:	8542                	mv	a0,a6
800125ea:	85c6                	mv	a1,a7
800125ec:	e0bfa0ef          	jal	8000d3f6 <__udivdi3>
800125f0:	872a                	mv	a4,a0
800125f2:	87ae                	mv	a5,a1
800125f4:	d83a                	sw	a4,48(sp)
800125f6:	da3e                	sw	a5,52(sp)
    for (osc = HPM_UART_OSC_MIN; osc <= UART_SOC_OVERSAMPLE_MAX; osc += 2) {
800125f8:	47a1                	li	a5,8
800125fa:	02f11f23          	sh	a5,62(sp)
800125fe:	aaed                	j	800127f8 <.L9>

80012600 <.L20>:
        delta = 0;
80012600:	02011e23          	sh	zero,60(sp)
        div = (uint16_t)((tmp + osc * (HPM_UART_BAUDRATE_SCALE / 2)) / (osc * HPM_UART_BAUDRATE_SCALE));
80012604:	03e15703          	lhu	a4,62(sp)
80012608:	87ba                	mv	a5,a4
8001260a:	078a                	sll	a5,a5,0x2
8001260c:	97ba                	add	a5,a5,a4
8001260e:	00279713          	sll	a4,a5,0x2
80012612:	97ba                	add	a5,a5,a4
80012614:	00279713          	sll	a4,a5,0x2
80012618:	97ba                	add	a5,a5,a4
8001261a:	078a                	sll	a5,a5,0x2
8001261c:	843e                	mv	s0,a5
8001261e:	4481                	li	s1,0
80012620:	5642                	lw	a2,48(sp)
80012622:	56d2                	lw	a3,52(sp)
80012624:	00c40733          	add	a4,s0,a2
80012628:	85ba                	mv	a1,a4
8001262a:	0085b5b3          	sltu	a1,a1,s0
8001262e:	00d487b3          	add	a5,s1,a3
80012632:	00f586b3          	add	a3,a1,a5
80012636:	87b6                	mv	a5,a3
80012638:	853a                	mv	a0,a4
8001263a:	85be                	mv	a1,a5
8001263c:	03e15703          	lhu	a4,62(sp)
80012640:	87ba                	mv	a5,a4
80012642:	078a                	sll	a5,a5,0x2
80012644:	97ba                	add	a5,a5,a4
80012646:	00279713          	sll	a4,a5,0x2
8001264a:	97ba                	add	a5,a5,a4
8001264c:	00279713          	sll	a4,a5,0x2
80012650:	97ba                	add	a5,a5,a4
80012652:	078e                	sll	a5,a5,0x3
80012654:	8d3e                	mv	s10,a5
80012656:	4d81                	li	s11,0
80012658:	866a                	mv	a2,s10
8001265a:	86ee                	mv	a3,s11
8001265c:	d9bfa0ef          	jal	8000d3f6 <__udivdi3>
80012660:	872a                	mv	a4,a0
80012662:	87ae                	mv	a5,a1
80012664:	02e11723          	sh	a4,46(sp)
        if (div < HPM_UART_BAUDRATE_DIV_MIN) {
80012668:	02e15783          	lhu	a5,46(sp)
8001266c:	16078e63          	beqz	a5,800127e8 <.L23>
        if ((div * osc * HPM_UART_BAUDRATE_SCALE) > tmp) {
80012670:	02e15703          	lhu	a4,46(sp)
80012674:	03e15783          	lhu	a5,62(sp)
80012678:	02f707b3          	mul	a5,a4,a5
8001267c:	873e                	mv	a4,a5
8001267e:	87ba                	mv	a5,a4
80012680:	078a                	sll	a5,a5,0x2
80012682:	97ba                	add	a5,a5,a4
80012684:	00279713          	sll	a4,a5,0x2
80012688:	97ba                	add	a5,a5,a4
8001268a:	00279713          	sll	a4,a5,0x2
8001268e:	97ba                	add	a5,a5,a4
80012690:	078e                	sll	a5,a5,0x3
80012692:	8b3e                	mv	s6,a5
80012694:	4b81                	li	s7,0
80012696:	57d2                	lw	a5,52(sp)
80012698:	875e                	mv	a4,s7
8001269a:	00e7ea63          	bltu	a5,a4,800126ae <.L21>
8001269e:	57d2                	lw	a5,52(sp)
800126a0:	875e                	mv	a4,s7
800126a2:	06e79163          	bne	a5,a4,80012704 <.L12>
800126a6:	57c2                	lw	a5,48(sp)
800126a8:	875a                	mv	a4,s6
800126aa:	04e7fd63          	bgeu	a5,a4,80012704 <.L12>

800126ae <.L21>:
            delta = (uint16_t)(((div * osc * HPM_UART_BAUDRATE_SCALE) - tmp) / HPM_UART_BAUDRATE_SCALE);
800126ae:	02e15703          	lhu	a4,46(sp)
800126b2:	03e15783          	lhu	a5,62(sp)
800126b6:	02f707b3          	mul	a5,a4,a5
800126ba:	873e                	mv	a4,a5
800126bc:	87ba                	mv	a5,a4
800126be:	078a                	sll	a5,a5,0x2
800126c0:	97ba                	add	a5,a5,a4
800126c2:	00279713          	sll	a4,a5,0x2
800126c6:	97ba                	add	a5,a5,a4
800126c8:	00279713          	sll	a4,a5,0x2
800126cc:	97ba                	add	a5,a5,a4
800126ce:	078e                	sll	a5,a5,0x3
800126d0:	893e                	mv	s2,a5
800126d2:	4981                	li	s3,0
800126d4:	5642                	lw	a2,48(sp)
800126d6:	56d2                	lw	a3,52(sp)
800126d8:	40c90733          	sub	a4,s2,a2
800126dc:	85ba                	mv	a1,a4
800126de:	00b935b3          	sltu	a1,s2,a1
800126e2:	40d987b3          	sub	a5,s3,a3
800126e6:	40b786b3          	sub	a3,a5,a1
800126ea:	87b6                	mv	a5,a3
800126ec:	3e800613          	li	a2,1000
800126f0:	4681                	li	a3,0
800126f2:	853a                	mv	a0,a4
800126f4:	85be                	mv	a1,a5
800126f6:	d01fa0ef          	jal	8000d3f6 <__udivdi3>
800126fa:	872a                	mv	a4,a0
800126fc:	87ae                	mv	a5,a1
800126fe:	02e11e23          	sh	a4,60(sp)
80012702:	a051                	j	80012786 <.L14>

80012704 <.L12>:
        } else if (div * osc < tmp) {
80012704:	02e15703          	lhu	a4,46(sp)
80012708:	03e15783          	lhu	a5,62(sp)
8001270c:	02f707b3          	mul	a5,a4,a5
80012710:	8c3e                	mv	s8,a5
80012712:	87fd                	sra	a5,a5,0x1f
80012714:	8cbe                	mv	s9,a5
80012716:	57d2                	lw	a5,52(sp)
80012718:	8766                	mv	a4,s9
8001271a:	00f76a63          	bltu	a4,a5,8001272e <.L22>
8001271e:	57d2                	lw	a5,52(sp)
80012720:	8766                	mv	a4,s9
80012722:	06e79263          	bne	a5,a4,80012786 <.L14>
80012726:	57c2                	lw	a5,48(sp)
80012728:	8762                	mv	a4,s8
8001272a:	04f77e63          	bgeu	a4,a5,80012786 <.L14>

8001272e <.L22>:
            delta = (uint16_t)((tmp - (div * osc * HPM_UART_BAUDRATE_SCALE)) / HPM_UART_BAUDRATE_SCALE);
8001272e:	02e15703          	lhu	a4,46(sp)
80012732:	03e15783          	lhu	a5,62(sp)
80012736:	02f707b3          	mul	a5,a4,a5
8001273a:	873e                	mv	a4,a5
8001273c:	87ba                	mv	a5,a4
8001273e:	078a                	sll	a5,a5,0x2
80012740:	97ba                	add	a5,a5,a4
80012742:	00279713          	sll	a4,a5,0x2
80012746:	97ba                	add	a5,a5,a4
80012748:	00279713          	sll	a4,a5,0x2
8001274c:	97ba                	add	a5,a5,a4
8001274e:	078e                	sll	a5,a5,0x3
80012750:	8a3e                	mv	s4,a5
80012752:	4a81                	li	s5,0
80012754:	5742                	lw	a4,48(sp)
80012756:	57d2                	lw	a5,52(sp)
80012758:	41470633          	sub	a2,a4,s4
8001275c:	85b2                	mv	a1,a2
8001275e:	00b735b3          	sltu	a1,a4,a1
80012762:	415786b3          	sub	a3,a5,s5
80012766:	40b687b3          	sub	a5,a3,a1
8001276a:	86be                	mv	a3,a5
8001276c:	8732                	mv	a4,a2
8001276e:	87b6                	mv	a5,a3
80012770:	3e800613          	li	a2,1000
80012774:	4681                	li	a3,0
80012776:	853a                	mv	a0,a4
80012778:	85be                	mv	a1,a5
8001277a:	c7dfa0ef          	jal	8000d3f6 <__udivdi3>
8001277e:	872a                	mv	a4,a0
80012780:	87ae                	mv	a5,a1
80012782:	02e11e23          	sh	a4,60(sp)

80012786 <.L14>:
        if (delta && (((delta * 100 * HPM_UART_BAUDRATE_SCALE) / tmp) > HPM_UART_BAUDRATE_TOLERANCE)) {
80012786:	03c15783          	lhu	a5,60(sp)
8001278a:	cb8d                	beqz	a5,800127bc <.L16>
8001278c:	03c15703          	lhu	a4,60(sp)
80012790:	67e1                	lui	a5,0x18
80012792:	6a078793          	add	a5,a5,1696 # 186a0 <__FLASH_segment_used_size__+0x4a10>
80012796:	02f707b3          	mul	a5,a4,a5
8001279a:	c43e                	sw	a5,8(sp)
8001279c:	c602                	sw	zero,12(sp)
8001279e:	5642                	lw	a2,48(sp)
800127a0:	56d2                	lw	a3,52(sp)
800127a2:	4522                	lw	a0,8(sp)
800127a4:	45b2                	lw	a1,12(sp)
800127a6:	c51fa0ef          	jal	8000d3f6 <__udivdi3>
800127aa:	872a                	mv	a4,a0
800127ac:	87ae                	mv	a5,a1
800127ae:	86be                	mv	a3,a5
800127b0:	ee95                	bnez	a3,800127ec <.L24>
800127b2:	86be                	mv	a3,a5
800127b4:	e681                	bnez	a3,800127bc <.L16>
800127b6:	478d                	li	a5,3
800127b8:	02e7ea63          	bltu	a5,a4,800127ec <.L24>

800127bc <.L16>:
            *div_out = div;
800127bc:	47d2                	lw	a5,20(sp)
800127be:	02e15703          	lhu	a4,46(sp)
800127c2:	00e79023          	sh	a4,0(a5)
            *osc_out = (osc == HPM_UART_OSC_MAX) ? 0 : osc; /* osc == 0 in bitfield, oversample rate is 32 */
800127c6:	03e15703          	lhu	a4,62(sp)
800127ca:	02000793          	li	a5,32
800127ce:	00f70763          	beq	a4,a5,800127dc <.L18>
800127d2:	03e15783          	lhu	a5,62(sp)
800127d6:	0ff7f793          	zext.b	a5,a5
800127da:	a011                	j	800127de <.L19>

800127dc <.L18>:
800127dc:	4781                	li	a5,0

800127de <.L19>:
800127de:	4742                	lw	a4,16(sp)
800127e0:	00f70023          	sb	a5,0(a4)
            return true;
800127e4:	4785                	li	a5,1
800127e6:	a005                	j	80012806 <.L8>

800127e8 <.L23>:
            continue;
800127e8:	0001                	nop
800127ea:	a011                	j	800127ee <.L11>

800127ec <.L24>:
            continue;
800127ec:	0001                	nop

800127ee <.L11>:
    for (osc = HPM_UART_OSC_MIN; osc <= UART_SOC_OVERSAMPLE_MAX; osc += 2) {
800127ee:	03e15783          	lhu	a5,62(sp)
800127f2:	0789                	add	a5,a5,2
800127f4:	02f11f23          	sh	a5,62(sp)

800127f8 <.L9>:
800127f8:	03e15703          	lhu	a4,62(sp)
800127fc:	02000793          	li	a5,32
80012800:	e0e7f0e3          	bgeu	a5,a4,80012600 <.L20>
    return false;
80012804:	4781                	li	a5,0

80012806 <.L8>:
}
80012806:	853e                	mv	a0,a5
80012808:	50f6                	lw	ra,124(sp)
8001280a:	5466                	lw	s0,120(sp)
8001280c:	54d6                	lw	s1,116(sp)
8001280e:	5946                	lw	s2,112(sp)
80012810:	59b6                	lw	s3,108(sp)
80012812:	5a26                	lw	s4,104(sp)
80012814:	5a96                	lw	s5,100(sp)
80012816:	5b06                	lw	s6,96(sp)
80012818:	4bf6                	lw	s7,92(sp)
8001281a:	4c66                	lw	s8,88(sp)
8001281c:	4cd6                	lw	s9,84(sp)
8001281e:	4d46                	lw	s10,80(sp)
80012820:	4db6                	lw	s11,76(sp)
80012822:	6109                	add	sp,sp,128
80012824:	8082                	ret

Disassembly of section .text.uart_flush:

80012826 <uart_flush>:
{
80012826:	1101                	add	sp,sp,-32
80012828:	c62a                	sw	a0,12(sp)
    uint32_t retry = 0;
8001282a:	ce02                	sw	zero,28(sp)
    while (!(ptr->LSR & UART_LSR_TEMT_MASK)) {
8001282c:	a811                	j	80012840 <.L59>

8001282e <.L62>:
        if (retry > HPM_UART_DRV_RETRY_COUNT) {
8001282e:	4772                	lw	a4,28(sp)
80012830:	6785                	lui	a5,0x1
80012832:	38878793          	add	a5,a5,904 # 1388 <.LBE11+0x4c>
80012836:	00e7eb63          	bltu	a5,a4,8001284c <.L65>
        retry++;
8001283a:	47f2                	lw	a5,28(sp)
8001283c:	0785                	add	a5,a5,1
8001283e:	ce3e                	sw	a5,28(sp)

80012840 <.L59>:
    while (!(ptr->LSR & UART_LSR_TEMT_MASK)) {
80012840:	47b2                	lw	a5,12(sp)
80012842:	5bdc                	lw	a5,52(a5)
80012844:	0407f793          	and	a5,a5,64
80012848:	d3fd                	beqz	a5,8001282e <.L62>
8001284a:	a011                	j	8001284e <.L61>

8001284c <.L65>:
            break;
8001284c:	0001                	nop

8001284e <.L61>:
    if (retry > HPM_UART_DRV_RETRY_COUNT) {
8001284e:	4772                	lw	a4,28(sp)
80012850:	6785                	lui	a5,0x1
80012852:	38878793          	add	a5,a5,904 # 1388 <.LBE11+0x4c>
80012856:	00e7f463          	bgeu	a5,a4,8001285e <.L63>
        return status_timeout;
8001285a:	478d                	li	a5,3
8001285c:	a011                	j	80012860 <.L64>

8001285e <.L63>:
    return status_success;
8001285e:	4781                	li	a5,0

80012860 <.L64>:
}
80012860:	853e                	mv	a0,a5
80012862:	6105                	add	sp,sp,32
80012864:	8082                	ret

Disassembly of section .text.uart_init_rxline_idle_detection:

80012866 <uart_init_rxline_idle_detection>:
{
80012866:	1101                	add	sp,sp,-32
80012868:	ce06                	sw	ra,28(sp)
8001286a:	c62a                	sw	a0,12(sp)
8001286c:	c42e                	sw	a1,8(sp)
    ptr->IDLE_CFG &= ~(UART_IDLE_CFG_RX_IDLE_EN_MASK
8001286e:	47b2                	lw	a5,12(sp)
80012870:	43dc                	lw	a5,4(a5)
80012872:	c007f713          	and	a4,a5,-1024
80012876:	47b2                	lw	a5,12(sp)
80012878:	c3d8                	sw	a4,4(a5)
    ptr->IDLE_CFG |= UART_IDLE_CFG_RX_IDLE_EN_SET(rxidle_config.detect_enable)
8001287a:	47b2                	lw	a5,12(sp)
8001287c:	43d8                	lw	a4,4(a5)
8001287e:	00814783          	lbu	a5,8(sp)
80012882:	07a2                	sll	a5,a5,0x8
80012884:	1007f793          	and	a5,a5,256
                    | UART_IDLE_CFG_RX_IDLE_THR_SET(rxidle_config.threshold)
80012888:	00b14683          	lbu	a3,11(sp)
8001288c:	8edd                	or	a3,a3,a5
                    | UART_IDLE_CFG_RX_IDLE_COND_SET(rxidle_config.idle_cond);
8001288e:	00a14783          	lbu	a5,10(sp)
80012892:	07a6                	sll	a5,a5,0x9
80012894:	2007f793          	and	a5,a5,512
80012898:	8fd5                	or	a5,a5,a3
    ptr->IDLE_CFG |= UART_IDLE_CFG_RX_IDLE_EN_SET(rxidle_config.detect_enable)
8001289a:	8f5d                	or	a4,a4,a5
8001289c:	47b2                	lw	a5,12(sp)
8001289e:	c3d8                	sw	a4,4(a5)
    if (rxidle_config.detect_irq_enable) {
800128a0:	00914783          	lbu	a5,9(sp)
800128a4:	c791                	beqz	a5,800128b0 <.L92>
        uart_enable_irq(ptr, uart_intr_rx_line_idle);
800128a6:	800005b7          	lui	a1,0x80000
800128aa:	4532                	lw	a0,12(sp)
800128ac:	3109                	jal	800124ae <uart_enable_irq>
800128ae:	a029                	j	800128b8 <.L93>

800128b0 <.L92>:
        uart_disable_irq(ptr, uart_intr_rx_line_idle);
800128b0:	800005b7          	lui	a1,0x80000
800128b4:	4532                	lw	a0,12(sp)
800128b6:	3ef1                	jal	80012492 <uart_disable_irq>

800128b8 <.L93>:
    return status_success;
800128b8:	4781                	li	a5,0
}
800128ba:	853e                	mv	a0,a5
800128bc:	40f2                	lw	ra,28(sp)
800128be:	6105                	add	sp,sp,32
800128c0:	8082                	ret

Disassembly of section .text.gptmr_channel_enable_monitor:

800128c2 <gptmr_channel_enable_monitor>:
{
800128c2:	1141                	add	sp,sp,-16
800128c4:	c62a                	sw	a0,12(sp)
800128c6:	87ae                	mv	a5,a1
800128c8:	00f105a3          	sb	a5,11(sp)
    ptr->CHANNEL[ch_index].CR |= GPTMR_CHANNEL_CR_MONITOR_EN_MASK;
800128cc:	00b14783          	lbu	a5,11(sp)
800128d0:	4732                	lw	a4,12(sp)
800128d2:	079a                	sll	a5,a5,0x6
800128d4:	97ba                	add	a5,a5,a4
800128d6:	4394                	lw	a3,0(a5)
800128d8:	00b14783          	lbu	a5,11(sp)
800128dc:	6721                	lui	a4,0x8
800128de:	8f55                	or	a4,a4,a3
800128e0:	46b2                	lw	a3,12(sp)
800128e2:	079a                	sll	a5,a5,0x6
800128e4:	97b6                	add	a5,a5,a3
800128e6:	c398                	sw	a4,0(a5)
}
800128e8:	0001                	nop
800128ea:	0141                	add	sp,sp,16
800128ec:	8082                	ret

Disassembly of section .text.gptmr_channel_get_default_config:

800128ee <gptmr_channel_get_default_config>:
 */

#include "hpm_gptmr_drv.h"

void gptmr_channel_get_default_config(GPTMR_Type *ptr, gptmr_channel_config_t *config)
{
800128ee:	7179                	add	sp,sp,-48
800128f0:	d606                	sw	ra,44(sp)
800128f2:	c62a                	sw	a0,12(sp)
800128f4:	c42e                	sw	a1,8(sp)
    (void) ptr;
    config->mode = gptmr_work_mode_no_capture;
800128f6:	47a2                	lw	a5,8(sp)
800128f8:	00078023          	sb	zero,0(a5)
    config->dma_request_event = gptmr_dma_request_disabled;
800128fc:	47a2                	lw	a5,8(sp)
800128fe:	577d                	li	a4,-1
80012900:	00e780a3          	sb	a4,1(a5)
    config->synci_edge = gptmr_synci_edge_none;
80012904:	47a2                	lw	a5,8(sp)
80012906:	00079123          	sh	zero,2(a5)

8001290a <.LBB2>:
    for (uint8_t i = 0; i < GPTMR_CH_CMP_COUNT; i++) {
8001290a:	00010fa3          	sb	zero,31(sp)
8001290e:	a829                	j	80012928 <.L32>

80012910 <.L33>:
        config->cmp[i] = 0xFFFFFFFEUL;
80012910:	01f14783          	lbu	a5,31(sp)
80012914:	4722                	lw	a4,8(sp)
80012916:	078a                	sll	a5,a5,0x2
80012918:	97ba                	add	a5,a5,a4
8001291a:	5779                	li	a4,-2
8001291c:	c3d8                	sw	a4,4(a5)
    for (uint8_t i = 0; i < GPTMR_CH_CMP_COUNT; i++) {
8001291e:	01f14783          	lbu	a5,31(sp)
80012922:	0785                	add	a5,a5,1
80012924:	00f10fa3          	sb	a5,31(sp)

80012928 <.L32>:
80012928:	01f14703          	lbu	a4,31(sp)
8001292c:	4785                	li	a5,1
8001292e:	fee7f1e3          	bgeu	a5,a4,80012910 <.L33>

80012932 <.LBE2>:
    }
    config->reload = 0xFFFFFFFEUL;
80012932:	47a2                	lw	a5,8(sp)
80012934:	5779                	li	a4,-2
80012936:	c7d8                	sw	a4,12(a5)
    config->cmp_initial_polarity_high = true;
80012938:	47a2                	lw	a5,8(sp)
8001293a:	4705                	li	a4,1
8001293c:	00e78823          	sb	a4,16(a5)
    config->enable_cmp_output = true;
80012940:	47a2                	lw	a5,8(sp)
80012942:	4705                	li	a4,1
80012944:	00e788a3          	sb	a4,17(a5)
    config->enable_sync_follow_previous_channel = false;
80012948:	47a2                	lw	a5,8(sp)
8001294a:	00078923          	sb	zero,18(a5)
    config->enable_software_sync = false;
8001294e:	47a2                	lw	a5,8(sp)
80012950:	000789a3          	sb	zero,19(a5)
    config->debug_mode = true;
80012954:	47a2                	lw	a5,8(sp)
80012956:	4705                	li	a4,1
80012958:	00e78a23          	sb	a4,20(a5)

#if defined(HPM_IP_FEATURE_GPTMR_CNT_MODE) && (HPM_IP_FEATURE_GPTMR_CNT_MODE  == 1)
    config->counter_mode = gptmr_counter_mode_internal;
8001295c:	47a2                	lw	a5,8(sp)
8001295e:	02078223          	sb	zero,36(a5)
#endif

#if defined(HPM_IP_FEATURE_GPTMR_OP_MODE) && (HPM_IP_FEATURE_GPTMR_OP_MODE  == 1)
    config->enable_opmode = false;
80012962:	47a2                	lw	a5,8(sp)
80012964:	020782a3          	sb	zero,37(a5)
#endif

#if defined(HPM_IP_FEATURE_GPTMR_MONITOR) && (HPM_IP_FEATURE_GPTMR_MONITOR  == 1)
    config->enable_monitor = false;
80012968:	47a2                	lw	a5,8(sp)
8001296a:	00078aa3          	sb	zero,21(a5)
    gptmr_channel_get_default_monitor_config(ptr, &config->monitor_config);
8001296e:	47a2                	lw	a5,8(sp)
80012970:	07e1                	add	a5,a5,24
80012972:	85be                	mv	a1,a5
80012974:	4532                	lw	a0,12(sp)
80012976:	2a51                	jal	80012b0a <gptmr_channel_get_default_monitor_config>
#endif
}
80012978:	0001                	nop
8001297a:	50b2                	lw	ra,44(sp)
8001297c:	6145                	add	sp,sp,48
8001297e:	8082                	ret

Disassembly of section .text.gptmr_channel_config:

80012980 <gptmr_channel_config>:

hpm_stat_t gptmr_channel_config(GPTMR_Type *ptr,
                         uint8_t ch_index,
                         gptmr_channel_config_t *config,
                         bool enable)
{
80012980:	7179                	add	sp,sp,-48
80012982:	d606                	sw	ra,44(sp)
80012984:	c62a                	sw	a0,12(sp)
80012986:	87ae                	mv	a5,a1
80012988:	c232                	sw	a2,4(sp)
8001298a:	8736                	mv	a4,a3
8001298c:	00f105a3          	sb	a5,11(sp)
80012990:	87ba                	mv	a5,a4
80012992:	00f10523          	sb	a5,10(sp)
    uint32_t v = 0;
80012996:	ce02                	sw	zero,28(sp)
    uint32_t tmp_value;

    if (config->enable_sync_follow_previous_channel && !ch_index) {
80012998:	4792                	lw	a5,4(sp)
8001299a:	0127c783          	lbu	a5,18(a5)
8001299e:	c791                	beqz	a5,800129aa <.L35>
800129a0:	00b14783          	lbu	a5,11(sp)
800129a4:	e399                	bnez	a5,800129aa <.L35>
        return status_invalid_argument;
800129a6:	4789                	li	a5,2
800129a8:	aaa9                	j	80012b02 <.L36>

800129aa <.L35>:
    }

    if (config->dma_request_event != gptmr_dma_request_disabled) {
800129aa:	4792                	lw	a5,4(sp)
800129ac:	0017c703          	lbu	a4,1(a5)
800129b0:	0ff00793          	li	a5,255
800129b4:	00f70d63          	beq	a4,a5,800129ce <.L37>
        v |= GPTMR_CHANNEL_CR_DMAEN_MASK
            | GPTMR_CHANNEL_CR_DMASEL_SET(config->dma_request_event);
800129b8:	4792                	lw	a5,4(sp)
800129ba:	0017c783          	lbu	a5,1(a5)
800129be:	079a                	sll	a5,a5,0x6
800129c0:	0ff7f713          	zext.b	a4,a5
        v |= GPTMR_CHANNEL_CR_DMAEN_MASK
800129c4:	47f2                	lw	a5,28(sp)
800129c6:	8fd9                	or	a5,a5,a4
800129c8:	0207e793          	or	a5,a5,32
800129cc:	ce3e                	sw	a5,28(sp)

800129ce <.L37>:
    }
    v |= GPTMR_CHANNEL_CR_CAPMODE_SET(config->mode)
800129ce:	4792                	lw	a5,4(sp)
800129d0:	0007c783          	lbu	a5,0(a5)
800129d4:	0077f713          	and	a4,a5,7
        | GPTMR_CHANNEL_CR_DBGPAUSE_SET(config->debug_mode)
800129d8:	4792                	lw	a5,4(sp)
800129da:	0147c783          	lbu	a5,20(a5)
800129de:	078e                	sll	a5,a5,0x3
800129e0:	8ba1                	and	a5,a5,8
800129e2:	8f5d                	or	a4,a4,a5
        | GPTMR_CHANNEL_CR_SWSYNCIEN_SET(config->enable_software_sync)
800129e4:	4792                	lw	a5,4(sp)
800129e6:	0137c783          	lbu	a5,19(a5)
800129ea:	0792                	sll	a5,a5,0x4
800129ec:	8bc1                	and	a5,a5,16
800129ee:	8f5d                	or	a4,a4,a5
        | GPTMR_CHANNEL_CR_CMPINIT_SET(config->cmp_initial_polarity_high)
800129f0:	4792                	lw	a5,4(sp)
800129f2:	0107c783          	lbu	a5,16(a5)
800129f6:	07a6                	sll	a5,a5,0x9
800129f8:	2007f793          	and	a5,a5,512
800129fc:	8f5d                	or	a4,a4,a5
        | GPTMR_CHANNEL_CR_SYNCFLW_SET(config->enable_sync_follow_previous_channel)
800129fe:	4792                	lw	a5,4(sp)
80012a00:	0127c783          	lbu	a5,18(a5)
80012a04:	00d79693          	sll	a3,a5,0xd
80012a08:	6789                	lui	a5,0x2
80012a0a:	8ff5                	and	a5,a5,a3
80012a0c:	8f5d                	or	a4,a4,a5
        | GPTMR_CHANNEL_CR_CMPEN_SET(config->enable_cmp_output)
80012a0e:	4792                	lw	a5,4(sp)
80012a10:	0117c783          	lbu	a5,17(a5) # 2011 <__BOOT_HEADER_segment_size__+0x11>
80012a14:	07a2                	sll	a5,a5,0x8
80012a16:	1007f793          	and	a5,a5,256
80012a1a:	8f5d                	or	a4,a4,a5
        | GPTMR_CHANNEL_CR_CEN_SET(enable)
80012a1c:	00a14783          	lbu	a5,10(sp)
80012a20:	07aa                	sll	a5,a5,0xa
80012a22:	4007f793          	and	a5,a5,1024
80012a26:	8fd9                	or	a5,a5,a4
        | config->synci_edge;
80012a28:	4712                	lw	a4,4(sp)
80012a2a:	00275703          	lhu	a4,2(a4) # 8002 <__AHB_SRAM_segment_size__+0x2>
80012a2e:	8fd9                	or	a5,a5,a4
    v |= GPTMR_CHANNEL_CR_CAPMODE_SET(config->mode)
80012a30:	4772                	lw	a4,28(sp)
80012a32:	8fd9                	or	a5,a5,a4
80012a34:	ce3e                	sw	a5,28(sp)
#if defined(HPM_IP_FEATURE_GPTMR_CNT_MODE) && (HPM_IP_FEATURE_GPTMR_CNT_MODE  == 1)
    v |= GPTMR_CHANNEL_CR_CNT_MODE_SET(config->counter_mode);
80012a36:	4792                	lw	a5,4(sp)
80012a38:	0247c783          	lbu	a5,36(a5)
80012a3c:	01279713          	sll	a4,a5,0x12
80012a40:	000407b7          	lui	a5,0x40
80012a44:	8ff9                	and	a5,a5,a4
80012a46:	4772                	lw	a4,28(sp)
80012a48:	8fd9                	or	a5,a5,a4
80012a4a:	ce3e                	sw	a5,28(sp)
#endif
#if defined(HPM_IP_FEATURE_GPTMR_OP_MODE) && (HPM_IP_FEATURE_GPTMR_OP_MODE  == 1)
    v |= GPTMR_CHANNEL_CR_OPMODE_SET(config->enable_opmode);
80012a4c:	4792                	lw	a5,4(sp)
80012a4e:	0257c783          	lbu	a5,37(a5) # 40025 <__AXI_SRAM_segment_size__+0x25>
80012a52:	01179713          	sll	a4,a5,0x11
80012a56:	000207b7          	lui	a5,0x20
80012a5a:	8ff9                	and	a5,a5,a4
80012a5c:	4772                	lw	a4,28(sp)
80012a5e:	8fd9                	or	a5,a5,a4
80012a60:	ce3e                	sw	a5,28(sp)

80012a62 <.LBB3>:
#endif
    for (uint8_t i = GPTMR_CH_CMP_COUNT; i > 0; i--) {
80012a62:	4789                	li	a5,2
80012a64:	00f10ba3          	sb	a5,23(sp)
80012a68:	a099                	j	80012aae <.L38>

80012a6a <.L40>:
        tmp_value = config->cmp[i - 1];
80012a6a:	01714783          	lbu	a5,23(sp)
80012a6e:	17fd                	add	a5,a5,-1 # 1ffff <__FLASH_segment_used_size__+0xc36f>
80012a70:	4712                	lw	a4,4(sp)
80012a72:	078a                	sll	a5,a5,0x2
80012a74:	97ba                	add	a5,a5,a4
80012a76:	43dc                	lw	a5,4(a5)
80012a78:	cc3e                	sw	a5,24(sp)
        if ((tmp_value > 0)  && (tmp_value != 0xFFFFFFFFu)) {
80012a7a:	47e2                	lw	a5,24(sp)
80012a7c:	cb81                	beqz	a5,80012a8c <.L39>
80012a7e:	4762                	lw	a4,24(sp)
80012a80:	57fd                	li	a5,-1
80012a82:	00f70563          	beq	a4,a5,80012a8c <.L39>
            tmp_value--;
80012a86:	47e2                	lw	a5,24(sp)
80012a88:	17fd                	add	a5,a5,-1
80012a8a:	cc3e                	sw	a5,24(sp)

80012a8c <.L39>:
        }
        ptr->CHANNEL[ch_index].CMP[i - 1] = GPTMR_CHANNEL_CMP_CMP_SET(tmp_value);
80012a8c:	00b14683          	lbu	a3,11(sp)
80012a90:	01714783          	lbu	a5,23(sp)
80012a94:	17fd                	add	a5,a5,-1
80012a96:	4732                	lw	a4,12(sp)
80012a98:	0692                	sll	a3,a3,0x4
80012a9a:	97b6                	add	a5,a5,a3
80012a9c:	078a                	sll	a5,a5,0x2
80012a9e:	97ba                	add	a5,a5,a4
80012aa0:	4762                	lw	a4,24(sp)
80012aa2:	c3d8                	sw	a4,4(a5)
    for (uint8_t i = GPTMR_CH_CMP_COUNT; i > 0; i--) {
80012aa4:	01714783          	lbu	a5,23(sp)
80012aa8:	17fd                	add	a5,a5,-1
80012aaa:	00f10ba3          	sb	a5,23(sp)

80012aae <.L38>:
80012aae:	01714783          	lbu	a5,23(sp)
80012ab2:	ffc5                	bnez	a5,80012a6a <.L40>

80012ab4 <.LBE3>:
    }
    tmp_value = config->reload;
80012ab4:	4792                	lw	a5,4(sp)
80012ab6:	47dc                	lw	a5,12(a5)
80012ab8:	cc3e                	sw	a5,24(sp)
    if ((tmp_value > 0) && (tmp_value != 0xFFFFFFFFu)) {
80012aba:	47e2                	lw	a5,24(sp)
80012abc:	cb81                	beqz	a5,80012acc <.L41>
80012abe:	4762                	lw	a4,24(sp)
80012ac0:	57fd                	li	a5,-1
80012ac2:	00f70563          	beq	a4,a5,80012acc <.L41>
        tmp_value--;
80012ac6:	47e2                	lw	a5,24(sp)
80012ac8:	17fd                	add	a5,a5,-1
80012aca:	cc3e                	sw	a5,24(sp)

80012acc <.L41>:
    }
    ptr->CHANNEL[ch_index].RLD = GPTMR_CHANNEL_RLD_RLD_SET(tmp_value);
80012acc:	00b14783          	lbu	a5,11(sp)
80012ad0:	4732                	lw	a4,12(sp)
80012ad2:	079a                	sll	a5,a5,0x6
80012ad4:	97ba                	add	a5,a5,a4
80012ad6:	4762                	lw	a4,24(sp)
80012ad8:	c7d8                	sw	a4,12(a5)
    ptr->CHANNEL[ch_index].CR = v;
80012ada:	00b14783          	lbu	a5,11(sp)
80012ade:	4732                	lw	a4,12(sp)
80012ae0:	079a                	sll	a5,a5,0x6
80012ae2:	97ba                	add	a5,a5,a4
80012ae4:	4772                	lw	a4,28(sp)
80012ae6:	c398                	sw	a4,0(a5)
#if defined(HPM_IP_FEATURE_GPTMR_MONITOR) && (HPM_IP_FEATURE_GPTMR_MONITOR  == 1)
    gptmr_channel_monitor_config(ptr, ch_index, &config->monitor_config, config->enable_monitor);
80012ae8:	4792                	lw	a5,4(sp)
80012aea:	01878713          	add	a4,a5,24
80012aee:	4792                	lw	a5,4(sp)
80012af0:	0157c683          	lbu	a3,21(a5)
80012af4:	00b14783          	lbu	a5,11(sp)
80012af8:	863a                	mv	a2,a4
80012afa:	85be                	mv	a1,a5
80012afc:	4532                	lw	a0,12(sp)
80012afe:	2035                	jal	80012b2a <gptmr_channel_monitor_config>
#endif

    return status_success;
80012b00:	4781                	li	a5,0

80012b02 <.L36>:
}
80012b02:	853e                	mv	a0,a5
80012b04:	50b2                	lw	ra,44(sp)
80012b06:	6145                	add	sp,sp,48
80012b08:	8082                	ret

Disassembly of section .text.gptmr_channel_get_default_monitor_config:

80012b0a <gptmr_channel_get_default_monitor_config>:

#if defined(HPM_IP_FEATURE_GPTMR_MONITOR) && (HPM_IP_FEATURE_GPTMR_MONITOR  == 1)
void gptmr_channel_get_default_monitor_config(GPTMR_Type *ptr, gptmr_channel_monitor_config_t *config)
{
80012b0a:	1141                	add	sp,sp,-16
80012b0c:	c62a                	sw	a0,12(sp)
80012b0e:	c42e                	sw	a1,8(sp)
    (void) ptr;
    config->max_value = 0;
80012b10:	47a2                	lw	a5,8(sp)
80012b12:	0007a223          	sw	zero,4(a5)
    config->min_value = 0;
80012b16:	47a2                	lw	a5,8(sp)
80012b18:	0007a423          	sw	zero,8(a5)
    config->monitor_type = monitor_signal_high_level_time;
80012b1c:	47a2                	lw	a5,8(sp)
80012b1e:	4705                	li	a4,1
80012b20:	00e78023          	sb	a4,0(a5)
}
80012b24:	0001                	nop
80012b26:	0141                	add	sp,sp,16
80012b28:	8082                	ret

Disassembly of section .text.gptmr_channel_monitor_config:

80012b2a <gptmr_channel_monitor_config>:

hpm_stat_t gptmr_channel_monitor_config(GPTMR_Type *ptr, uint8_t ch_index, gptmr_channel_monitor_config_t *config, bool enable)
{
80012b2a:	1101                	add	sp,sp,-32
80012b2c:	ce06                	sw	ra,28(sp)
80012b2e:	c62a                	sw	a0,12(sp)
80012b30:	87ae                	mv	a5,a1
80012b32:	c232                	sw	a2,4(sp)
80012b34:	8736                	mv	a4,a3
80012b36:	00f105a3          	sb	a5,11(sp)
80012b3a:	87ba                	mv	a5,a4
80012b3c:	00f10523          	sb	a5,10(sp)
    if ((ptr == NULL) || (config->max_value < config->min_value)) {
80012b40:	47b2                	lw	a5,12(sp)
80012b42:	c799                	beqz	a5,80012b50 <.L44>
80012b44:	4792                	lw	a5,4(sp)
80012b46:	43d8                	lw	a4,4(a5)
80012b48:	4792                	lw	a5,4(sp)
80012b4a:	479c                	lw	a5,8(a5)
80012b4c:	00f77463          	bgeu	a4,a5,80012b54 <.L45>

80012b50 <.L44>:
        return status_invalid_argument;
80012b50:	4789                	li	a5,2
80012b52:	a059                	j	80012bd8 <.L46>

80012b54 <.L45>:
    }
    if (enable == true) {
80012b54:	00a14783          	lbu	a5,10(sp)
80012b58:	cbad                	beqz	a5,80012bca <.L47>
        gptmr_channel_set_monitor_type(ptr, ch_index, config->monitor_type);
80012b5a:	4792                	lw	a5,4(sp)
80012b5c:	0007c703          	lbu	a4,0(a5)
80012b60:	00b14783          	lbu	a5,11(sp)
80012b64:	863a                	mv	a2,a4
80012b66:	85be                	mv	a1,a5
80012b68:	4532                	lw	a0,12(sp)
80012b6a:	8dafa0ef          	jal	8000cc44 <gptmr_channel_set_monitor_type>
        gptmr_update_cmp(ptr, ch_index, 0, config->min_value);
80012b6e:	4792                	lw	a5,4(sp)
80012b70:	4798                	lw	a4,8(a5)
80012b72:	00b14783          	lbu	a5,11(sp)
80012b76:	86ba                	mv	a3,a4
80012b78:	4601                	li	a2,0
80012b7a:	85be                	mv	a1,a5
80012b7c:	4532                	lw	a0,12(sp)
80012b7e:	824fa0ef          	jal	8000cba2 <gptmr_update_cmp>
        gptmr_update_cmp(ptr, ch_index, 1, config->max_value);
80012b82:	4792                	lw	a5,4(sp)
80012b84:	43d8                	lw	a4,4(a5)
80012b86:	00b14783          	lbu	a5,11(sp)
80012b8a:	86ba                	mv	a3,a4
80012b8c:	4605                	li	a2,1
80012b8e:	85be                	mv	a1,a5
80012b90:	4532                	lw	a0,12(sp)
80012b92:	810fa0ef          	jal	8000cba2 <gptmr_update_cmp>
        gptmr_channel_config_update_reload(ptr, ch_index, 0xFFFFFFFF);
80012b96:	00b14783          	lbu	a5,11(sp)
80012b9a:	567d                	li	a2,-1
80012b9c:	85be                	mv	a1,a5
80012b9e:	4532                	lw	a0,12(sp)
80012ba0:	844fa0ef          	jal	8000cbe4 <gptmr_channel_config_update_reload>
        gptmr_channel_set_capmode(ptr, ch_index, gptmr_work_mode_measure_width);
80012ba4:	00b14783          	lbu	a5,11(sp)
80012ba8:	4611                	li	a2,4
80012baa:	85be                	mv	a1,a5
80012bac:	4532                	lw	a0,12(sp)
80012bae:	fb7f90ef          	jal	8000cb64 <gptmr_channel_set_capmode>
        gptmr_channel_reset_count(ptr, ch_index);
80012bb2:	00b14783          	lbu	a5,11(sp)
80012bb6:	85be                	mv	a1,a5
80012bb8:	4532                	lw	a0,12(sp)
80012bba:	f61f90ef          	jal	8000cb1a <gptmr_channel_reset_count>
        gptmr_channel_enable_monitor(ptr, ch_index);
80012bbe:	00b14783          	lbu	a5,11(sp)
80012bc2:	85be                	mv	a1,a5
80012bc4:	4532                	lw	a0,12(sp)
80012bc6:	39f5                	jal	800128c2 <gptmr_channel_enable_monitor>
80012bc8:	a039                	j	80012bd6 <.L48>

80012bca <.L47>:
    } else {
        gptmr_channel_disable_monitor(ptr, ch_index);
80012bca:	00b14783          	lbu	a5,11(sp)
80012bce:	85be                	mv	a1,a5
80012bd0:	4532                	lw	a0,12(sp)
80012bd2:	844fa0ef          	jal	8000cc16 <gptmr_channel_disable_monitor>

80012bd6 <.L48>:
    }
    return status_success;
80012bd6:	4781                	li	a5,0

80012bd8 <.L46>:
}
80012bd8:	853e                	mv	a0,a5
80012bda:	40f2                	lw	ra,28(sp)
80012bdc:	6105                	add	sp,sp,32
80012bde:	8082                	ret

Disassembly of section .text.pllctlv2_pll_clk_is_stable:

80012be0 <pllctlv2_pll_clk_is_stable>:
 * @param [in] pll Index of the PLL to check (pllctlv2_pll0 through pllctlv2_pll6)
 * @param [in] clk Post-divider output index (pllctlv2_clk0 through pllctlv2_clk3)
 * @return true if the PLL CLK is stable and locked, false otherwise
 */
static inline bool pllctlv2_pll_clk_is_stable(PLLCTLV2_Type *ptr, pllctlv2_pll_t pll, pllctlv2_clk_t clk)
{
80012be0:	1101                	add	sp,sp,-32
80012be2:	c62a                	sw	a0,12(sp)
80012be4:	87ae                	mv	a5,a1
80012be6:	8732                	mv	a4,a2
80012be8:	00f105a3          	sb	a5,11(sp)
80012bec:	87ba                	mv	a5,a4
80012bee:	00f10523          	sb	a5,10(sp)
    uint32_t status = ptr->PLL[pll].DIV[clk];
80012bf2:	00b14683          	lbu	a3,11(sp)
80012bf6:	00a14783          	lbu	a5,10(sp)
80012bfa:	4732                	lw	a4,12(sp)
80012bfc:	0696                	sll	a3,a3,0x5
80012bfe:	97b6                	add	a5,a5,a3
80012c00:	03078793          	add	a5,a5,48
80012c04:	078a                	sll	a5,a5,0x2
80012c06:	97ba                	add	a5,a5,a4
80012c08:	439c                	lw	a5,0(a5)
80012c0a:	ce3e                	sw	a5,28(sp)
    return (IS_HPM_BITMASK_CLR(status, PLLCTLV2_PLL_DIV_ENABLE_MASK)
80012c0c:	4772                	lw	a4,28(sp)
80012c0e:	100007b7          	lui	a5,0x10000
80012c12:	8ff9                	and	a5,a5,a4
         || (IS_HPM_BITMASK_CLR(status, PLLCTLV2_PLL_DIV_BUSY_MASK) && IS_HPM_BITMASK_SET(status, PLLCTLV2_PLL_DIV_RESPONSE_MASK)));
80012c14:	cb89                	beqz	a5,80012c26 <.L7>
80012c16:	47f2                	lw	a5,28(sp)
80012c18:	0007c963          	bltz	a5,80012c2a <.L8>
80012c1c:	4772                	lw	a4,28(sp)
80012c1e:	200007b7          	lui	a5,0x20000
80012c22:	8ff9                	and	a5,a5,a4
80012c24:	c399                	beqz	a5,80012c2a <.L8>

80012c26 <.L7>:
80012c26:	4785                	li	a5,1
80012c28:	a011                	j	80012c2c <.L9>

80012c2a <.L8>:
80012c2a:	4781                	li	a5,0

80012c2c <.L9>:
80012c2c:	8b85                	and	a5,a5,1
80012c2e:	0ff7f793          	zext.b	a5,a5
}
80012c32:	853e                	mv	a0,a5
80012c34:	6105                	add	sp,sp,32
80012c36:	8082                	ret

Disassembly of section .text.pllctlv2_init_pll_with_freq:

80012c38 <pllctlv2_init_pll_with_freq>:
{
80012c38:	7179                	add	sp,sp,-48
80012c3a:	d606                	sw	ra,44(sp)
80012c3c:	c62a                	sw	a0,12(sp)
80012c3e:	87ae                	mv	a5,a1
80012c40:	c232                	sw	a2,4(sp)
80012c42:	00f105a3          	sb	a5,11(sp)
    if ((ptr == NULL) || (freq_in_hz < PLLCTLV2_PLL_FREQ_MIN) || (freq_in_hz > PLLCTLV2_PLL_FREQ_MAX) ||
80012c46:	47b2                	lw	a5,12(sp)
80012c48:	c395                	beqz	a5,80012c6c <.L20>
80012c4a:	4712                	lw	a4,4(sp)
80012c4c:	16e367b7          	lui	a5,0x16e36
80012c50:	00f76e63          	bltu	a4,a5,80012c6c <.L20>
80012c54:	4712                	lw	a4,4(sp)
80012c56:	3d8317b7          	lui	a5,0x3d831
80012c5a:	20078793          	add	a5,a5,512 # 3d831200 <__AXI_SRAM_segment_end__+0x3c5f1200>
80012c5e:	00e7e763          	bltu	a5,a4,80012c6c <.L20>
80012c62:	00b14703          	lbu	a4,11(sp)
80012c66:	4789                	li	a5,2
80012c68:	00e7f563          	bgeu	a5,a4,80012c72 <.L21>

80012c6c <.L20>:
        status = status_invalid_argument;
80012c6c:	4789                	li	a5,2
80012c6e:	ce3e                	sw	a5,28(sp)
80012c70:	a859                	j	80012d06 <.L22>

80012c72 <.L21>:
        uint32_t mfn = freq_in_hz % PLLCTLV2_PLL_XTAL_FREQ;
80012c72:	4712                	lw	a4,4(sp)
80012c74:	016e37b7          	lui	a5,0x16e3
80012c78:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
80012c7c:	02f777b3          	remu	a5,a4,a5
80012c80:	cc3e                	sw	a5,24(sp)
        uint32_t mfi = freq_in_hz / PLLCTLV2_PLL_XTAL_FREQ;
80012c82:	4712                	lw	a4,4(sp)
80012c84:	016e37b7          	lui	a5,0x16e3
80012c88:	60078793          	add	a5,a5,1536 # 16e3600 <__AXI_SRAM_segment_end__+0x4a3600>
80012c8c:	02f757b3          	divu	a5,a4,a5
80012c90:	ca3e                	sw	a5,20(sp)
        if (PLLCTLV2_PLL_MFI_MFI_GET(ptr->PLL[pll].MFI) == mfi) {
80012c92:	00b14783          	lbu	a5,11(sp)
80012c96:	4732                	lw	a4,12(sp)
80012c98:	0785                	add	a5,a5,1
80012c9a:	079e                	sll	a5,a5,0x7
80012c9c:	97ba                	add	a5,a5,a4
80012c9e:	439c                	lw	a5,0(a5)
80012ca0:	07f7f793          	and	a5,a5,127
80012ca4:	4752                	lw	a4,20(sp)
80012ca6:	00f71b63          	bne	a4,a5,80012cbc <.L23>
            ptr->PLL[pll].MFI = mfi - 1U;
80012caa:	00b14783          	lbu	a5,11(sp)
80012cae:	4752                	lw	a4,20(sp)
80012cb0:	177d                	add	a4,a4,-1
80012cb2:	46b2                	lw	a3,12(sp)
80012cb4:	0785                	add	a5,a5,1
80012cb6:	079e                	sll	a5,a5,0x7
80012cb8:	97b6                	add	a5,a5,a3
80012cba:	c398                	sw	a4,0(a5)

80012cbc <.L23>:
        ptr->PLL[pll].MFI = mfi;
80012cbc:	00b14783          	lbu	a5,11(sp)
80012cc0:	4732                	lw	a4,12(sp)
80012cc2:	0785                	add	a5,a5,1
80012cc4:	079e                	sll	a5,a5,0x7
80012cc6:	97ba                	add	a5,a5,a4
80012cc8:	4752                	lw	a4,20(sp)
80012cca:	c398                	sw	a4,0(a5)
        ptr->PLL[pll].MFN = mfn * PLLCTLV2_PLL_MFN_FACTOR;
80012ccc:	00b14683          	lbu	a3,11(sp)
80012cd0:	4762                	lw	a4,24(sp)
80012cd2:	87ba                	mv	a5,a4
80012cd4:	078a                	sll	a5,a5,0x2
80012cd6:	97ba                	add	a5,a5,a4
80012cd8:	0786                	sll	a5,a5,0x1
80012cda:	863e                	mv	a2,a5
80012cdc:	4732                	lw	a4,12(sp)
80012cde:	00168793          	add	a5,a3,1
80012ce2:	079e                	sll	a5,a5,0x7
80012ce4:	97ba                	add	a5,a5,a4
80012ce6:	c3d0                	sw	a2,4(a5)
        while (!pllctlv2_pll_is_stable(ptr, pll)) {
80012ce8:	a011                	j	80012cec <.L24>

80012cea <.L25>:
            NOP();
80012cea:	0001                	nop

80012cec <.L24>:
        while (!pllctlv2_pll_is_stable(ptr, pll)) {
80012cec:	00b14783          	lbu	a5,11(sp)
80012cf0:	85be                	mv	a1,a5
80012cf2:	4532                	lw	a0,12(sp)
80012cf4:	f97f90ef          	jal	8000cc8a <pllctlv2_pll_is_stable>
80012cf8:	87aa                	mv	a5,a0
80012cfa:	0017c793          	xor	a5,a5,1
80012cfe:	0ff7f793          	zext.b	a5,a5
80012d02:	f7e5                	bnez	a5,80012cea <.L25>
        status = status_success;
80012d04:	ce02                	sw	zero,28(sp)

80012d06 <.L22>:
    return status;
80012d06:	47f2                	lw	a5,28(sp)
}
80012d08:	853e                	mv	a0,a5
80012d0a:	50b2                	lw	ra,44(sp)
80012d0c:	6145                	add	sp,sp,48
80012d0e:	8082                	ret

Disassembly of section .text.pllctlv2_set_postdiv:

80012d10 <pllctlv2_set_postdiv>:
{
80012d10:	1101                	add	sp,sp,-32
80012d12:	ce06                	sw	ra,28(sp)
80012d14:	c62a                	sw	a0,12(sp)
80012d16:	87ae                	mv	a5,a1
80012d18:	8736                	mv	a4,a3
80012d1a:	00f105a3          	sb	a5,11(sp)
80012d1e:	87b2                	mv	a5,a2
80012d20:	00f10523          	sb	a5,10(sp)
80012d24:	87ba                	mv	a5,a4
80012d26:	00f104a3          	sb	a5,9(sp)
    if ((ptr != NULL) && (pll < PLLCTL_SOC_PLL_MAX_COUNT)) {
80012d2a:	47b2                	lw	a5,12(sp)
80012d2c:	c7ad                	beqz	a5,80012d96 <.L34>
80012d2e:	00b14703          	lbu	a4,11(sp)
80012d32:	4789                	li	a5,2
80012d34:	06e7e163          	bltu	a5,a4,80012d96 <.L34>
            (ptr->PLL[pll].DIV[clk] & ~PLLCTLV2_PLL_DIV_DIV_MASK) | PLLCTLV2_PLL_DIV_DIV_SET(div_value);
80012d38:	00b14683          	lbu	a3,11(sp)
80012d3c:	00a14783          	lbu	a5,10(sp)
80012d40:	4732                	lw	a4,12(sp)
80012d42:	0696                	sll	a3,a3,0x5
80012d44:	97b6                	add	a5,a5,a3
80012d46:	03078793          	add	a5,a5,48
80012d4a:	078a                	sll	a5,a5,0x2
80012d4c:	97ba                	add	a5,a5,a4
80012d4e:	439c                	lw	a5,0(a5)
80012d50:	fc07f693          	and	a3,a5,-64
80012d54:	00914783          	lbu	a5,9(sp)
80012d58:	03f7f713          	and	a4,a5,63
        ptr->PLL[pll].DIV[clk] =
80012d5c:	00b14603          	lbu	a2,11(sp)
80012d60:	00a14783          	lbu	a5,10(sp)
            (ptr->PLL[pll].DIV[clk] & ~PLLCTLV2_PLL_DIV_DIV_MASK) | PLLCTLV2_PLL_DIV_DIV_SET(div_value);
80012d64:	8f55                	or	a4,a4,a3
        ptr->PLL[pll].DIV[clk] =
80012d66:	46b2                	lw	a3,12(sp)
80012d68:	0616                	sll	a2,a2,0x5
80012d6a:	97b2                	add	a5,a5,a2
80012d6c:	03078793          	add	a5,a5,48
80012d70:	078a                	sll	a5,a5,0x2
80012d72:	97b6                	add	a5,a5,a3
80012d74:	c398                	sw	a4,0(a5)
        while (!pllctlv2_pll_clk_is_stable(ptr, pll, clk)) {
80012d76:	a011                	j	80012d7a <.L32>

80012d78 <.L33>:
            NOP();
80012d78:	0001                	nop

80012d7a <.L32>:
        while (!pllctlv2_pll_clk_is_stable(ptr, pll, clk)) {
80012d7a:	00a14703          	lbu	a4,10(sp)
80012d7e:	00b14783          	lbu	a5,11(sp)
80012d82:	863a                	mv	a2,a4
80012d84:	85be                	mv	a1,a5
80012d86:	4532                	lw	a0,12(sp)
80012d88:	3da1                	jal	80012be0 <pllctlv2_pll_clk_is_stable>
80012d8a:	87aa                	mv	a5,a0
80012d8c:	0017c793          	xor	a5,a5,1
80012d90:	0ff7f793          	zext.b	a5,a5
80012d94:	f3f5                	bnez	a5,80012d78 <.L33>

80012d96 <.L34>:
}
80012d96:	0001                	nop
80012d98:	40f2                	lw	ra,28(sp)
80012d9a:	6105                	add	sp,sp,32
80012d9c:	8082                	ret

Disassembly of section .text.pllctlv2_get_pll_postdiv_freq_in_hz:

80012d9e <pllctlv2_get_pll_postdiv_freq_in_hz>:

uint32_t pllctlv2_get_pll_postdiv_freq_in_hz(PLLCTLV2_Type *ptr, pllctlv2_pll_t pll, pllctlv2_clk_t clk)
{
80012d9e:	7179                	add	sp,sp,-48
80012da0:	d606                	sw	ra,44(sp)
80012da2:	c62a                	sw	a0,12(sp)
80012da4:	87ae                	mv	a5,a1
80012da6:	8732                	mv	a4,a2
80012da8:	00f105a3          	sb	a5,11(sp)
80012dac:	87ba                	mv	a5,a4
80012dae:	00f10523          	sb	a5,10(sp)
    uint32_t postdiv_freq = 0;
80012db2:	ce02                	sw	zero,28(sp)
    if ((ptr != NULL) && (pll < PLLCTL_SOC_PLL_MAX_COUNT)) {
80012db4:	47b2                	lw	a5,12(sp)
80012db6:	c7ad                	beqz	a5,80012e20 <.L43>
80012db8:	00b14703          	lbu	a4,11(sp)
80012dbc:	4789                	li	a5,2
80012dbe:	06e7e163          	bltu	a5,a4,80012e20 <.L43>

80012dc2 <.LBB4>:
        uint32_t postdiv = PLLCTLV2_PLL_DIV_DIV_GET(ptr->PLL[pll].DIV[clk]);
80012dc2:	00b14683          	lbu	a3,11(sp)
80012dc6:	00a14783          	lbu	a5,10(sp)
80012dca:	4732                	lw	a4,12(sp)
80012dcc:	0696                	sll	a3,a3,0x5
80012dce:	97b6                	add	a5,a5,a3
80012dd0:	03078793          	add	a5,a5,48
80012dd4:	078a                	sll	a5,a5,0x2
80012dd6:	97ba                	add	a5,a5,a4
80012dd8:	439c                	lw	a5,0(a5)
80012dda:	03f7f793          	and	a5,a5,63
80012dde:	cc3e                	sw	a5,24(sp)
        uint32_t pll_freq = pllctlv2_get_pll_freq_in_hz(ptr, pll);
80012de0:	00b14783          	lbu	a5,11(sp)
80012de4:	85be                	mv	a1,a5
80012de6:	4532                	lw	a0,12(sp)
80012de8:	ee9f90ef          	jal	8000ccd0 <pllctlv2_get_pll_freq_in_hz>
80012dec:	ca2a                	sw	a0,20(sp)
        postdiv_freq = (uint32_t) (pll_freq / (100 + postdiv * 100 / 5U) * 100);
80012dee:	4762                	lw	a4,24(sp)
80012df0:	87ba                	mv	a5,a4
80012df2:	078a                	sll	a5,a5,0x2
80012df4:	97ba                	add	a5,a5,a4
80012df6:	00279713          	sll	a4,a5,0x2
80012dfa:	97ba                	add	a5,a5,a4
80012dfc:	078a                	sll	a5,a5,0x2
80012dfe:	873e                	mv	a4,a5
80012e00:	4795                	li	a5,5
80012e02:	02f757b3          	divu	a5,a4,a5
80012e06:	06478793          	add	a5,a5,100
80012e0a:	4752                	lw	a4,20(sp)
80012e0c:	02f75733          	divu	a4,a4,a5
80012e10:	87ba                	mv	a5,a4
80012e12:	078a                	sll	a5,a5,0x2
80012e14:	97ba                	add	a5,a5,a4
80012e16:	00279713          	sll	a4,a5,0x2
80012e1a:	97ba                	add	a5,a5,a4
80012e1c:	078a                	sll	a5,a5,0x2
80012e1e:	ce3e                	sw	a5,28(sp)

80012e20 <.L43>:
    }

    return postdiv_freq;
80012e20:	47f2                	lw	a5,28(sp)
}
80012e22:	853e                	mv	a0,a5
80012e24:	50b2                	lw	ra,44(sp)
80012e26:	6145                	add	sp,sp,48
80012e28:	8082                	ret

Disassembly of section .text.pcfg_dcdc_set_voltage:

80012e2a <pcfg_dcdc_set_voltage>:

    return PCFG_DCDC_CURRENT_LEVEL_GET(ptr->DCDC_CURRENT) * PCFG_CURRENT_MEASUREMENT_STEP;
}

hpm_stat_t pcfg_dcdc_set_voltage(PCFG_Type *ptr, uint16_t mv)
{
80012e2a:	1101                	add	sp,sp,-32
80012e2c:	c62a                	sw	a0,12(sp)
80012e2e:	87ae                	mv	a5,a1
80012e30:	00f11523          	sh	a5,10(sp)
    hpm_stat_t stat = status_success;
80012e34:	ce02                	sw	zero,28(sp)
    if ((mv < PCFG_SOC_DCDC_MIN_VOLTAGE_IN_MV) || (mv > PCFG_SOC_DCDC_MAX_VOLTAGE_IN_MV)) {
80012e36:	00a15703          	lhu	a4,10(sp)
80012e3a:	25700793          	li	a5,599
80012e3e:	00e7f863          	bgeu	a5,a4,80012e4e <.L26>
80012e42:	00a15703          	lhu	a4,10(sp)
80012e46:	55f00793          	li	a5,1375
80012e4a:	00e7f463          	bgeu	a5,a4,80012e52 <.L27>

80012e4e <.L26>:
        return status_invalid_argument;
80012e4e:	4789                	li	a5,2
80012e50:	a831                	j	80012e6c <.L28>

80012e52 <.L27>:
    }
    ptr->DCDC_MODE = (ptr->DCDC_MODE & ~PCFG_DCDC_MODE_VOLT_MASK) | PCFG_DCDC_MODE_VOLT_SET(mv);
80012e52:	47b2                	lw	a5,12(sp)
80012e54:	4b98                	lw	a4,16(a5)
80012e56:	77fd                	lui	a5,0xfffff
80012e58:	8f7d                	and	a4,a4,a5
80012e5a:	00a15683          	lhu	a3,10(sp)
80012e5e:	6785                	lui	a5,0x1
80012e60:	17fd                	add	a5,a5,-1 # fff <.L76+0x39>
80012e62:	8ff5                	and	a5,a5,a3
80012e64:	8f5d                	or	a4,a4,a5
80012e66:	47b2                	lw	a5,12(sp)
80012e68:	cb98                	sw	a4,16(a5)
    return stat;
80012e6a:	47f2                	lw	a5,28(sp)

80012e6c <.L28>:
}
80012e6c:	853e                	mv	a0,a5
80012e6e:	6105                	add	sp,sp,32
80012e70:	8082                	ret

Disassembly of section .text.esc_mdio_write:

80012e72 <esc_mdio_write>:

    return status_success;
}

hpm_stat_t esc_mdio_write(ESC_Type *ptr, uint8_t phy_addr, uint8_t reg_addr, uint16_t data)
{
80012e72:	1101                	add	sp,sp,-32
80012e74:	c62a                	sw	a0,12(sp)
80012e76:	87ae                	mv	a5,a1
80012e78:	8736                	mv	a4,a3
80012e7a:	00f105a3          	sb	a5,11(sp)
80012e7e:	87b2                	mv	a5,a2
80012e80:	00f10523          	sb	a5,10(sp)
80012e84:	87ba                	mv	a5,a4
80012e86:	00f11423          	sh	a5,8(sp)
    uint32_t retry;

    ptr->MIIM_PDI_ACC_STAT = 1; /* PDI access MII management interface */
80012e8a:	47b2                	lw	a5,12(sp)
80012e8c:	4705                	li	a4,1
80012e8e:	50e78ba3          	sb	a4,1303(a5)

    /* wait for MII idle */
    retry = 0;
80012e92:	ce02                	sw	zero,28(sp)
    while ((ptr->MII_MNG_CS & ESC_MII_MNG_CS_BUSY_MASK) != 0) {
80012e94:	a809                	j	80012ea6 <.L18>

80012e96 <.L21>:
        if (retry > HPM_ESC_DRV_DEFAULT_RETRY_COUNT) {
80012e96:	4772                	lw	a4,28(sp)
80012e98:	a00007b7          	lui	a5,0xa0000
80012e9c:	00e7ef63          	bltu	a5,a4,80012eba <.L30>
            break;
        }
        retry++;
80012ea0:	47f2                	lw	a5,28(sp)
80012ea2:	0785                	add	a5,a5,1 # a0000001 <__FLASH_segment_end__+0x1ff00001>
80012ea4:	ce3e                	sw	a5,28(sp)

80012ea6 <.L18>:
    while ((ptr->MII_MNG_CS & ESC_MII_MNG_CS_BUSY_MASK) != 0) {
80012ea6:	47b2                	lw	a5,12(sp)
80012ea8:	5107d783          	lhu	a5,1296(a5)
80012eac:	0807c7b3          	zext.h	a5,a5
80012eb0:	60579793          	sext.h	a5,a5
80012eb4:	fe07c1e3          	bltz	a5,80012e96 <.L21>
80012eb8:	a011                	j	80012ebc <.L20>

80012eba <.L30>:
            break;
80012eba:	0001                	nop

80012ebc <.L20>:
    }
    if (retry > HPM_ESC_DRV_DEFAULT_RETRY_COUNT) {
80012ebc:	4772                	lw	a4,28(sp)
80012ebe:	a00007b7          	lui	a5,0xa0000
80012ec2:	00e7f463          	bgeu	a5,a4,80012eca <.L22>
        return status_timeout;
80012ec6:	478d                	li	a5,3
80012ec8:	a841                	j	80012f58 <.L23>

80012eca <.L22>:
    }


    /* set PHY address, register address and register value */
    ptr->PHY_ADDR = phy_addr;
80012eca:	47b2                	lw	a5,12(sp)
80012ecc:	00b14703          	lbu	a4,11(sp)
80012ed0:	50e78923          	sb	a4,1298(a5) # a0000512 <__FLASH_segment_end__+0x1ff00512>
    ptr->PHY_REG_ADDR = reg_addr;
80012ed4:	47b2                	lw	a5,12(sp)
80012ed6:	00a14703          	lbu	a4,10(sp)
80012eda:	50e789a3          	sb	a4,1299(a5)
    ptr->PHY_DATA = data;
80012ede:	47b2                	lw	a5,12(sp)
80012ee0:	00815703          	lhu	a4,8(sp)
80012ee4:	50e79a23          	sh	a4,1300(a5)

    /* write command */
    ptr->MII_MNG_CS = (ptr->MII_MNG_CS & ~ESC_MII_MNG_CS_CMD_MASK) | ESC_MII_MNG_CS_WEN_MASK | ESC_MII_MNG_CS_CMD_SET(2);
80012ee8:	47b2                	lw	a5,12(sp)
80012eea:	5107d783          	lhu	a5,1296(a5)
80012eee:	0807c7b3          	zext.h	a5,a5
80012ef2:	cfe7f793          	and	a5,a5,-770
80012ef6:	0807c7b3          	zext.h	a5,a5
80012efa:	2017e793          	or	a5,a5,513
80012efe:	0807c733          	zext.h	a4,a5
80012f02:	47b2                	lw	a5,12(sp)
80012f04:	50e79823          	sh	a4,1296(a5)

    /* wait command done */
    retry = 0;
80012f08:	ce02                	sw	zero,28(sp)
    while ((ptr->MII_MNG_CS & ESC_MII_MNG_CS_BUSY_MASK) != 0) {
80012f0a:	a809                	j	80012f1c <.L24>

80012f0c <.L27>:
        if (retry > HPM_ESC_DRV_DEFAULT_RETRY_COUNT) {
80012f0c:	4772                	lw	a4,28(sp)
80012f0e:	a00007b7          	lui	a5,0xa0000
80012f12:	00e7ef63          	bltu	a5,a4,80012f30 <.L31>
            break;
        }
        retry++;
80012f16:	47f2                	lw	a5,28(sp)
80012f18:	0785                	add	a5,a5,1 # a0000001 <__FLASH_segment_end__+0x1ff00001>
80012f1a:	ce3e                	sw	a5,28(sp)

80012f1c <.L24>:
    while ((ptr->MII_MNG_CS & ESC_MII_MNG_CS_BUSY_MASK) != 0) {
80012f1c:	47b2                	lw	a5,12(sp)
80012f1e:	5107d783          	lhu	a5,1296(a5)
80012f22:	0807c7b3          	zext.h	a5,a5
80012f26:	60579793          	sext.h	a5,a5
80012f2a:	fe07c1e3          	bltz	a5,80012f0c <.L27>
80012f2e:	a011                	j	80012f32 <.L26>

80012f30 <.L31>:
            break;
80012f30:	0001                	nop

80012f32 <.L26>:
    }
    if (retry > HPM_ESC_DRV_DEFAULT_RETRY_COUNT) {
80012f32:	4772                	lw	a4,28(sp)
80012f34:	a00007b7          	lui	a5,0xa0000
80012f38:	00e7f463          	bgeu	a5,a4,80012f40 <.L28>
        return status_timeout;
80012f3c:	478d                	li	a5,3
80012f3e:	a829                	j	80012f58 <.L23>

80012f40 <.L28>:
    }

    /* check command status */
    if ((ptr->MII_MNG_CS & ESC_MII_MNG_CS_CMD_ERR_MASK) != 0) {
80012f40:	47b2                	lw	a5,12(sp)
80012f42:	5107d783          	lhu	a5,1296(a5) # a0000510 <__FLASH_segment_end__+0x1ff00510>
80012f46:	0807c7b3          	zext.h	a5,a5
80012f4a:	873e                	mv	a4,a5
80012f4c:	6791                	lui	a5,0x4
80012f4e:	8ff9                	and	a5,a5,a4
80012f50:	c399                	beqz	a5,80012f56 <.L29>
        return status_fail;
80012f52:	4785                	li	a5,1
80012f54:	a011                	j	80012f58 <.L23>

80012f56 <.L29>:
    }

    return status_success;
80012f56:	4781                	li	a5,0

80012f58 <.L23>:
}
80012f58:	853e                	mv	a0,a5
80012f5a:	6105                	add	sp,sp,32
80012f5c:	8082                	ret

Disassembly of section .text.esc_check_eeprom_loading:

80012f5e <esc_check_eeprom_loading>:

/* Loding ESC EEPROM, EtherCAT communication is possible even if the EEPROM is blank */
hpm_stat_t esc_check_eeprom_loading(ESC_Type *ptr)
{
80012f5e:	1101                	add	sp,sp,-32
80012f60:	c62a                	sw	a0,12(sp)
    hpm_stat_t stat = status_success;
80012f62:	ce02                	sw	zero,28(sp)
    uint32_t retry = 0;
80012f64:	cc02                	sw	zero,24(sp)

80012f66 <.L38>:

    while (1) {
        /* 0x110 bit0 eeprom load correctly */
        if ((ptr->ESC_DL_STAT & ESC_ESC_DL_STAT_EPLC_MASK) == ESC_ESC_DL_STAT_EPLC_MASK) {
80012f66:	47b2                	lw	a5,12(sp)
80012f68:	1107d783          	lhu	a5,272(a5) # 4110 <__HEAPSIZE__+0x110>
80012f6c:	0807c7b3          	zext.h	a5,a5
80012f70:	0017f713          	and	a4,a5,1
80012f74:	4785                	li	a5,1
80012f76:	00f71463          	bne	a4,a5,80012f7e <.L33>
            stat = status_success; /* Loading successful, PDI operations */
80012f7a:	ce02                	sw	zero,28(sp)
            break;
80012f7c:	a8b9                	j	80012fda <.L34>

80012f7e <.L33>:
        }

        /* 0x502 bit13 ack or cmd error */
        if ((ptr->EEPROM_CTRL_STAT & ESC_EEPROM_CTRL_STAT_ERR_ACK_CMD_MASK) == ESC_EEPROM_CTRL_STAT_ERR_ACK_CMD_MASK) { /* ACMDERR = 1 */
80012f7e:	47b2                	lw	a5,12(sp)
80012f80:	5027d783          	lhu	a5,1282(a5)
80012f84:	0807c7b3          	zext.h	a5,a5
80012f88:	873e                	mv	a4,a5
80012f8a:	6789                	lui	a5,0x2
80012f8c:	8f7d                	and	a4,a4,a5
80012f8e:	6789                	lui	a5,0x2
80012f90:	00f71763          	bne	a4,a5,80012f9e <.L35>
            stat = status_esc_eeprom_ack_error; /* I2C bus error */
80012f94:	679d                	lui	a5,0x7
80012f96:	d6078793          	add	a5,a5,-672 # 6d60 <__HEAPSIZE__+0x2d60>
80012f9a:	ce3e                	sw	a5,28(sp)
            break;
80012f9c:	a83d                	j	80012fda <.L34>

80012f9e <.L35>:
        } else {
            if ((ptr->EEPROM_CTRL_STAT & ESC_EEPROM_CTRL_STAT_CKSM_ERR_MASK) == ESC_EEPROM_CTRL_STAT_CKSM_ERR_MASK) {   /* ACMDERR,CKSUMERR = 01 */
80012f9e:	47b2                	lw	a5,12(sp)
80012fa0:	5027d783          	lhu	a5,1282(a5)
80012fa4:	0807c7b3          	zext.h	a5,a5
80012fa8:	873e                	mv	a4,a5
80012faa:	28b01793          	bset	a5,zero,0xb
80012fae:	8f7d                	and	a4,a4,a5
80012fb0:	28b01793          	bset	a5,zero,0xb
80012fb4:	00f71763          	bne	a4,a5,80012fc2 <.L36>
                stat = status_esc_eeprom_checksum_error; /* EEPROM is loaded, but it is blank and cause checksum error  */
80012fb8:	679d                	lui	a5,0x7
80012fba:	d6178793          	add	a5,a5,-671 # 6d61 <__HEAPSIZE__+0x2d61>
80012fbe:	ce3e                	sw	a5,28(sp)
                break;
80012fc0:	a829                	j	80012fda <.L34>

80012fc2 <.L36>:
            }
        }

        if (retry > HPM_ESC_DRV_DEFAULT_RETRY_COUNT) {
80012fc2:	4762                	lw	a4,24(sp)
80012fc4:	a00007b7          	lui	a5,0xa0000
80012fc8:	00e7f563          	bgeu	a5,a4,80012fd2 <.L37>
            stat = status_timeout;
80012fcc:	478d                	li	a5,3
80012fce:	ce3e                	sw	a5,28(sp)
            break;
80012fd0:	a029                	j	80012fda <.L34>

80012fd2 <.L37>:
        }
        retry++;
80012fd2:	47e2                	lw	a5,24(sp)
80012fd4:	0785                	add	a5,a5,1 # a0000001 <__FLASH_segment_end__+0x1ff00001>
80012fd6:	cc3e                	sw	a5,24(sp)
        if ((ptr->ESC_DL_STAT & ESC_ESC_DL_STAT_EPLC_MASK) == ESC_ESC_DL_STAT_EPLC_MASK) {
80012fd8:	b779                	j	80012f66 <.L38>

80012fda <.L34>:
    }

    return stat;
80012fda:	47f2                	lw	a5,28(sp)
}
80012fdc:	853e                	mv	a0,a5
80012fde:	6105                	add	sp,sp,32
80012fe0:	8082                	ret

Disassembly of section .text.crc32:

80012fe2 <crc32>:

#include "hpm_crc32.h"


uint32_t crc32(const uint8_t *buf, uint32_t len)
{
80012fe2:	1101                	add	sp,sp,-32
80012fe4:	c62a                	sw	a0,12(sp)
80012fe6:	c42e                	sw	a1,8(sp)
    uint8_t i;
    uint32_t crc = 0xFFFFFFFF;
80012fe8:	57fd                	li	a5,-1
80012fea:	cc3e                	sw	a5,24(sp)
    while (len--) {
80012fec:	a881                	j	8001303c <.L2>

80012fee <.L7>:
        crc ^= *buf++;
80012fee:	47b2                	lw	a5,12(sp)
80012ff0:	00178713          	add	a4,a5,1
80012ff4:	c63a                	sw	a4,12(sp)
80012ff6:	0007c783          	lbu	a5,0(a5)
80012ffa:	873e                	mv	a4,a5
80012ffc:	47e2                	lw	a5,24(sp)
80012ffe:	8fb9                	xor	a5,a5,a4
80013000:	cc3e                	sw	a5,24(sp)
        for (i = 0; i < 8; ++i) {
80013002:	00010fa3          	sb	zero,31(sp)
80013006:	a035                	j	80013032 <.L3>

80013008 <.L6>:
            if (crc & 1)
80013008:	47e2                	lw	a5,24(sp)
8001300a:	8b85                	and	a5,a5,1
8001300c:	cb99                	beqz	a5,80013022 <.L4>
                crc = (crc >> 1) ^ 0xEDB88320;
8001300e:	47e2                	lw	a5,24(sp)
80013010:	0017d713          	srl	a4,a5,0x1
80013014:	edb887b7          	lui	a5,0xedb88
80013018:	32078793          	add	a5,a5,800 # edb88320 <__FLASH_segment_end__+0x6da88320>
8001301c:	8fb9                	xor	a5,a5,a4
8001301e:	cc3e                	sw	a5,24(sp)
80013020:	a021                	j	80013028 <.L5>

80013022 <.L4>:
            else
                crc = (crc >> 1);
80013022:	47e2                	lw	a5,24(sp)
80013024:	8385                	srl	a5,a5,0x1
80013026:	cc3e                	sw	a5,24(sp)

80013028 <.L5>:
        for (i = 0; i < 8; ++i) {
80013028:	01f14783          	lbu	a5,31(sp)
8001302c:	0785                	add	a5,a5,1
8001302e:	00f10fa3          	sb	a5,31(sp)

80013032 <.L3>:
80013032:	01f14703          	lbu	a4,31(sp)
80013036:	479d                	li	a5,7
80013038:	fce7f8e3          	bgeu	a5,a4,80013008 <.L6>

8001303c <.L2>:
    while (len--) {
8001303c:	47a2                	lw	a5,8(sp)
8001303e:	fff78713          	add	a4,a5,-1
80013042:	c43a                	sw	a4,8(sp)
80013044:	f7cd                	bnez	a5,80012fee <.L7>
        }
    }

    return ~crc;
80013046:	47e2                	lw	a5,24(sp)
80013048:	fff7c793          	not	a5,a5
}
8001304c:	853e                	mv	a0,a5
8001304e:	6105                	add	sp,sp,32
80013050:	8082                	ret

Disassembly of section .text.console_init:

80013052 <console_init>:
#include "hpm_uart_drv.h"

static UART_Type* g_console_uart = NULL;

hpm_stat_t console_init(console_config_t *cfg)
{
80013052:	7139                	add	sp,sp,-64
80013054:	de06                	sw	ra,60(sp)
80013056:	c62a                	sw	a0,12(sp)
    hpm_stat_t stat = status_fail;
80013058:	4785                	li	a5,1
8001305a:	d63e                	sw	a5,44(sp)

    if (cfg->type == CONSOLE_TYPE_UART) {
8001305c:	47b2                	lw	a5,12(sp)
8001305e:	439c                	lw	a5,0(a5)
80013060:	e7b1                	bnez	a5,800130ac <.L2>

80013062 <.LBB2>:
        uart_config_t config = {0};
80013062:	c802                	sw	zero,16(sp)
80013064:	ca02                	sw	zero,20(sp)
80013066:	cc02                	sw	zero,24(sp)
80013068:	ce02                	sw	zero,28(sp)
8001306a:	d002                	sw	zero,32(sp)
8001306c:	d202                	sw	zero,36(sp)
8001306e:	d402                	sw	zero,40(sp)
        uart_default_config((UART_Type *)cfg->base, &config);
80013070:	47b2                	lw	a5,12(sp)
80013072:	43dc                	lw	a5,4(a5)
80013074:	873e                	mv	a4,a5
80013076:	081c                	add	a5,sp,16
80013078:	85be                	mv	a1,a5
8001307a:	853a                	mv	a0,a4
8001307c:	c4aff0ef          	jal	800124c6 <uart_default_config>
        config.src_freq_in_hz = cfg->src_freq_in_hz;
80013080:	47b2                	lw	a5,12(sp)
80013082:	479c                	lw	a5,8(a5)
80013084:	c83e                	sw	a5,16(sp)
        config.baudrate = cfg->baudrate;
80013086:	47b2                	lw	a5,12(sp)
80013088:	47dc                	lw	a5,12(a5)
8001308a:	ca3e                	sw	a5,20(sp)
        stat = uart_init((UART_Type *)cfg->base, &config);
8001308c:	47b2                	lw	a5,12(sp)
8001308e:	43dc                	lw	a5,4(a5)
80013090:	873e                	mv	a4,a5
80013092:	081c                	add	a5,sp,16
80013094:	85be                	mv	a1,a5
80013096:	853a                	mv	a0,a4
80013098:	f80f90ef          	jal	8000c818 <uart_init>
8001309c:	d62a                	sw	a0,44(sp)
        if (status_success == stat) {
8001309e:	57b2                	lw	a5,44(sp)
800130a0:	e791                	bnez	a5,800130ac <.L2>
            g_console_uart = (UART_Type *)cfg->base;
800130a2:	47b2                	lw	a5,12(sp)
800130a4:	43dc                	lw	a5,4(a5)
800130a6:	873e                	mv	a4,a5
800130a8:	10e1ac23          	sw	a4,280(gp) # 1209490 <g_console_uart>

800130ac <.L2>:
        }
    }

    return stat;
800130ac:	57b2                	lw	a5,44(sp)
}
800130ae:	853e                	mv	a0,a5
800130b0:	50f2                	lw	ra,60(sp)
800130b2:	6121                	add	sp,sp,64
800130b4:	8082                	ret

Disassembly of section .text.__SEGGER_RTL_X_file_write:

800130b6 <__SEGGER_RTL_X_file_write>:
__attribute__((used)) FILE *stdin  = &__SEGGER_RTL_stdin_file;  /* NOTE: Provide implementation of stdin for RTL. */
__attribute__((used)) FILE *stdout = &__SEGGER_RTL_stdout_file; /* NOTE: Provide implementation of stdout for RTL. */
__attribute__((used)) FILE *stderr = &__SEGGER_RTL_stderr_file; /* NOTE: Provide implementation of stderr for RTL. */

__attribute__((used)) int __SEGGER_RTL_X_file_write(__SEGGER_RTL_FILE *file, const char *data, unsigned int size)
{
800130b6:	7179                	add	sp,sp,-48
800130b8:	d606                	sw	ra,44(sp)
800130ba:	c62a                	sw	a0,12(sp)
800130bc:	c42e                	sw	a1,8(sp)
800130be:	c232                	sw	a2,4(sp)
    unsigned int count;
    (void)file;
    for (count = 0; count < size; count++) {
800130c0:	ce02                	sw	zero,28(sp)
800130c2:	a099                	j	80013108 <.L13>

800130c4 <.L17>:
        if (data[count] == '\n') {
800130c4:	4722                	lw	a4,8(sp)
800130c6:	47f2                	lw	a5,28(sp)
800130c8:	97ba                	add	a5,a5,a4
800130ca:	0007c703          	lbu	a4,0(a5)
800130ce:	47a9                	li	a5,10
800130d0:	00f71b63          	bne	a4,a5,800130e6 <.L20>
            while (status_success != uart_send_byte(g_console_uart, '\r')) {
800130d4:	0001                	nop

800130d6 <.L15>:
800130d6:	1181a783          	lw	a5,280(gp) # 1209490 <g_console_uart>
800130da:	45b5                	li	a1,13
800130dc:	853e                	mv	a0,a5
800130de:	90bf90ef          	jal	8000c9e8 <uart_send_byte>
800130e2:	87aa                	mv	a5,a0
800130e4:	fbed                	bnez	a5,800130d6 <.L15>

800130e6 <.L20>:
            }
        }
        while (status_success != uart_send_byte(g_console_uart, data[count])) {
800130e6:	0001                	nop

800130e8 <.L16>:
800130e8:	1181a683          	lw	a3,280(gp) # 1209490 <g_console_uart>
800130ec:	4722                	lw	a4,8(sp)
800130ee:	47f2                	lw	a5,28(sp)
800130f0:	97ba                	add	a5,a5,a4
800130f2:	0007c783          	lbu	a5,0(a5)
800130f6:	85be                	mv	a1,a5
800130f8:	8536                	mv	a0,a3
800130fa:	8eff90ef          	jal	8000c9e8 <uart_send_byte>
800130fe:	87aa                	mv	a5,a0
80013100:	f7e5                	bnez	a5,800130e8 <.L16>
    for (count = 0; count < size; count++) {
80013102:	47f2                	lw	a5,28(sp)
80013104:	0785                	add	a5,a5,1
80013106:	ce3e                	sw	a5,28(sp)

80013108 <.L13>:
80013108:	4772                	lw	a4,28(sp)
8001310a:	4792                	lw	a5,4(sp)
8001310c:	faf76ce3          	bltu	a4,a5,800130c4 <.L17>
        }
    }
    while (status_success != uart_flush(g_console_uart)) {
80013110:	0001                	nop

80013112 <.L18>:
80013112:	1181a783          	lw	a5,280(gp) # 1209490 <g_console_uart>
80013116:	853e                	mv	a0,a5
80013118:	f0eff0ef          	jal	80012826 <uart_flush>
8001311c:	87aa                	mv	a5,a0
8001311e:	fbf5                	bnez	a5,80013112 <.L18>
    }
    return count;
80013120:	47f2                	lw	a5,28(sp)

}
80013122:	853e                	mv	a0,a5
80013124:	50b2                	lw	ra,44(sp)
80013126:	6145                	add	sp,sp,48
80013128:	8082                	ret

Disassembly of section .text.__SEGGER_RTL_X_file_stat:

8001312a <__SEGGER_RTL_X_file_stat>:
    }
    return 1;
}

__attribute__((used)) int __SEGGER_RTL_X_file_stat(__SEGGER_RTL_FILE *stream)
{
8001312a:	1141                	add	sp,sp,-16
8001312c:	c62a                	sw	a0,12(sp)
    (void) stream;
    return 0;
8001312e:	4781                	li	a5,0
}
80013130:	853e                	mv	a0,a5
80013132:	0141                	add	sp,sp,16
80013134:	8082                	ret

Disassembly of section .text.__SEGGER_RTL_X_file_bufsize:

80013136 <__SEGGER_RTL_X_file_bufsize>:

__attribute__((used)) int __SEGGER_RTL_X_file_bufsize(__SEGGER_RTL_FILE *stream)
{
80013136:	1141                	add	sp,sp,-16
80013138:	c62a                	sw	a0,12(sp)
    (void) stream;
    return 1;
8001313a:	4785                	li	a5,1
}
8001313c:	853e                	mv	a0,a5
8001313e:	0141                	add	sp,sp,16
80013140:	8082                	ret

Disassembly of section .text.rom_xpi_nor_get_property:

80013142 <rom_xpi_nor_get_property>:
 */
static inline hpm_stat_t rom_xpi_nor_get_property(XPI_Type *base,
                                                  xpi_nor_config_t *nor_cfg,
                                                  uint32_t property_id,
                                                  uint32_t *value)
{
80013142:	1101                	add	sp,sp,-32
80013144:	ce06                	sw	ra,28(sp)
80013146:	c62a                	sw	a0,12(sp)
80013148:	c42e                	sw	a1,8(sp)
8001314a:	c232                	sw	a2,4(sp)
8001314c:	c036                	sw	a3,0(sp)
    return ROM_API_TABLE_ROOT->xpi_nor_driver_if->get_property(base, nor_cfg, property_id, value);
8001314e:	200207b7          	lui	a5,0x20020
80013152:	f0078793          	add	a5,a5,-256 # 2001ff00 <__AXI_SRAM_segment_end__+0x1eddff00>
80013156:	4bdc                	lw	a5,20(a5)
80013158:	4bbc                	lw	a5,80(a5)
8001315a:	4682                	lw	a3,0(sp)
8001315c:	4612                	lw	a2,4(sp)
8001315e:	45a2                	lw	a1,8(sp)
80013160:	4532                	lw	a0,12(sp)
80013162:	9782                	jalr	a5
80013164:	87aa                	mv	a5,a0
}
80013166:	853e                	mv	a0,a5
80013168:	40f2                	lw	ra,28(sp)
8001316a:	6105                	add	sp,sp,32
8001316c:	8082                	ret

Disassembly of section .text.e2p_exit_critical:

8001316e <e2p_exit_critical>:

void e2p_exit_critical(void)
{
8001316e:	1141                	add	sp,sp,-16
80013170:	47a1                	li	a5,8
80013172:	c63e                	sw	a5,12(sp)

80013174 <.LBB10>:
    set_csr(CSR_MSTATUS, mask);
80013174:	47b2                	lw	a5,12(sp)
80013176:	3007a073          	csrs	mstatus,a5
}
8001317a:	0001                	nop

8001317c <.LBE10>:
    enable_global_irq(CSR_MSTATUS_MIE_MASK);
}
8001317c:	0001                	nop
8001317e:	0141                	add	sp,sp,16
80013180:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_puts_no_nl:

80013182 <__SEGGER_RTL_puts_no_nl>:
80013182:	1101                	add	sp,sp,-32
80013184:	cc22                	sw	s0,24(sp)
80013186:	1d41a403          	lw	s0,468(gp) # 120954c <stdout>
8001318a:	ce06                	sw	ra,28(sp)
8001318c:	c62a                	sw	a0,12(sp)
8001318e:	2335                	jal	800136ba <strlen>
80013190:	862a                	mv	a2,a0
80013192:	8522                	mv	a0,s0
80013194:	4462                	lw	s0,24(sp)
80013196:	45b2                	lw	a1,12(sp)
80013198:	40f2                	lw	ra,28(sp)
8001319a:	6105                	add	sp,sp,32
8001319c:	bf29                	j	800130b6 <__SEGGER_RTL_X_file_write>

Disassembly of section .text.libc.signal:

8001319e <signal>:
8001319e:	4795                	li	a5,5
800131a0:	02a7e263          	bltu	a5,a0,800131c4 <.L18>
800131a4:	06818693          	add	a3,gp,104 # 12093e0 <__SEGGER_RTL_aSigTab>
800131a8:	00251793          	sll	a5,a0,0x2
800131ac:	96be                	add	a3,a3,a5
800131ae:	4288                	lw	a0,0(a3)
800131b0:	06818713          	add	a4,gp,104 # 12093e0 <__SEGGER_RTL_aSigTab>
800131b4:	e509                	bnez	a0,800131be <.L17>
800131b6:	80003537          	lui	a0,0x80003
800131ba:	06650513          	add	a0,a0,102 # 80003066 <__SEGGER_RTL_SIGNAL_SIG_DFL>

800131be <.L17>:
800131be:	973e                	add	a4,a4,a5
800131c0:	c30c                	sw	a1,0(a4)
800131c2:	8082                	ret

800131c4 <.L18>:
800131c4:	80006537          	lui	a0,0x80006
800131c8:	e7650513          	add	a0,a0,-394 # 80005e76 <__SEGGER_RTL_SIGNAL_SIG_ERR>
800131cc:	8082                	ret

Disassembly of section .text.libc.raise:

800131ce <raise>:
800131ce:	1141                	add	sp,sp,-16
800131d0:	c04a                	sw	s2,0(sp)
800131d2:	80006937          	lui	s2,0x80006
800131d6:	e3290593          	add	a1,s2,-462 # 80005e32 <__SEGGER_RTL_SIGNAL_SIG_IGN>
800131da:	c226                	sw	s1,4(sp)
800131dc:	c606                	sw	ra,12(sp)
800131de:	c422                	sw	s0,8(sp)
800131e0:	84aa                	mv	s1,a0
800131e2:	3f75                	jal	8001319e <signal>
800131e4:	800067b7          	lui	a5,0x80006
800131e8:	e7678793          	add	a5,a5,-394 # 80005e76 <__SEGGER_RTL_SIGNAL_SIG_ERR>
800131ec:	02f50d63          	beq	a0,a5,80013226 <.L24>
800131f0:	e3290913          	add	s2,s2,-462
800131f4:	842a                	mv	s0,a0
800131f6:	03250163          	beq	a0,s2,80013218 <.L22>
800131fa:	800035b7          	lui	a1,0x80003
800131fe:	06658793          	add	a5,a1,102 # 80003066 <__SEGGER_RTL_SIGNAL_SIG_DFL>
80013202:	00f51563          	bne	a0,a5,8001320c <.L23>
80013206:	4505                	li	a0,1
80013208:	e53ef0ef          	jal	8000305a <exit>

8001320c <.L23>:
8001320c:	06658593          	add	a1,a1,102
80013210:	8526                	mv	a0,s1
80013212:	3771                	jal	8001319e <signal>
80013214:	8526                	mv	a0,s1
80013216:	9402                	jalr	s0

80013218 <.L22>:
80013218:	4501                	li	a0,0

8001321a <.L20>:
8001321a:	40b2                	lw	ra,12(sp)
8001321c:	4422                	lw	s0,8(sp)
8001321e:	4492                	lw	s1,4(sp)
80013220:	4902                	lw	s2,0(sp)
80013222:	0141                	add	sp,sp,16
80013224:	8082                	ret

80013226 <.L24>:
80013226:	557d                	li	a0,-1
80013228:	bfcd                	j	8001321a <.L20>

Disassembly of section .text.libc.abort:

8001322a <abort>:
8001322a:	1141                	add	sp,sp,-16
8001322c:	c606                	sw	ra,12(sp)

8001322e <.L27>:
8001322e:	4501                	li	a0,0
80013230:	3f79                	jal	800131ce <raise>
80013232:	bff5                	j	8001322e <.L27>

Disassembly of section .text.libc.__SEGGER_RTL_X_assert:

80013234 <__SEGGER_RTL_X_assert>:
80013234:	1101                	add	sp,sp,-32
80013236:	cc22                	sw	s0,24(sp)
80013238:	ca26                	sw	s1,20(sp)
8001323a:	842a                	mv	s0,a0
8001323c:	84ae                	mv	s1,a1
8001323e:	8532                	mv	a0,a2
80013240:	858a                	mv	a1,sp
80013242:	4629                	li	a2,10
80013244:	ce06                	sw	ra,28(sp)
80013246:	c4df90ef          	jal	8000ce92 <itoa>
8001324a:	8526                	mv	a0,s1
8001324c:	3f1d                	jal	80013182 <__SEGGER_RTL_puts_no_nl>
8001324e:	80007537          	lui	a0,0x80007
80013252:	8a050513          	add	a0,a0,-1888 # 800068a0 <.LC0>
80013256:	3735                	jal	80013182 <__SEGGER_RTL_puts_no_nl>
80013258:	850a                	mv	a0,sp
8001325a:	3725                	jal	80013182 <__SEGGER_RTL_puts_no_nl>
8001325c:	80007537          	lui	a0,0x80007
80013260:	8a450513          	add	a0,a0,-1884 # 800068a4 <.LC1>
80013264:	3f39                	jal	80013182 <__SEGGER_RTL_puts_no_nl>
80013266:	8522                	mv	a0,s0
80013268:	3f29                	jal	80013182 <__SEGGER_RTL_puts_no_nl>
8001326a:	80007537          	lui	a0,0x80007
8001326e:	8bc50513          	add	a0,a0,-1860 # 800068bc <.LC2>
80013272:	3f01                	jal	80013182 <__SEGGER_RTL_puts_no_nl>
80013274:	3f5d                	jal	8001322a <abort>

Disassembly of section .text.libc.__mulsf3:

80013276 <__mulsf3>:
80013276:	80000737          	lui	a4,0x80000
8001327a:	0ff00293          	li	t0,255
8001327e:	00b547b3          	xor	a5,a0,a1
80013282:	8ff9                	and	a5,a5,a4
80013284:	00151613          	sll	a2,a0,0x1
80013288:	8261                	srl	a2,a2,0x18
8001328a:	00159693          	sll	a3,a1,0x1
8001328e:	82e1                	srl	a3,a3,0x18
80013290:	ce29                	beqz	a2,800132ea <.L__mulsf3_lhs_zero_or_subnormal>
80013292:	c6bd                	beqz	a3,80013300 <.L__mulsf3_rhs_zero_or_subnormal>
80013294:	04560f63          	beq	a2,t0,800132f2 <.L__mulsf3_lhs_inf_or_nan>
80013298:	06568963          	beq	a3,t0,8001330a <.L__mulsf3_rhs_inf_or_nan>
8001329c:	9636                	add	a2,a2,a3
8001329e:	0522                	sll	a0,a0,0x8
800132a0:	8d59                	or	a0,a0,a4
800132a2:	05a2                	sll	a1,a1,0x8
800132a4:	8dd9                	or	a1,a1,a4
800132a6:	02b506b3          	mul	a3,a0,a1
800132aa:	02b53533          	mulhu	a0,a0,a1
800132ae:	00d036b3          	snez	a3,a3
800132b2:	8d55                	or	a0,a0,a3
800132b4:	00054463          	bltz	a0,800132bc <.L__mulsf3_normalized>
800132b8:	0506                	sll	a0,a0,0x1
800132ba:	167d                	add	a2,a2,-1

800132bc <.L__mulsf3_normalized>:
800132bc:	f8160613          	add	a2,a2,-127
800132c0:	04064863          	bltz	a2,80013310 <.L__mulsf3_zero_or_underflow>
800132c4:	12fd                	add	t0,t0,-1 # ffffffff <__AHB_SRAM_segment_end__+0xfdf7fff>
800132c6:	00565f63          	bge	a2,t0,800132e4 <.L__mulsf3_inf>
800132ca:	01851693          	sll	a3,a0,0x18
800132ce:	8121                	srl	a0,a0,0x8
800132d0:	065e                	sll	a2,a2,0x17
800132d2:	9532                	add	a0,a0,a2
800132d4:	0006d663          	bgez	a3,800132e0 <.L__mulsf3_apply_sign>
800132d8:	0505                	add	a0,a0,1
800132da:	0686                	sll	a3,a3,0x1
800132dc:	e291                	bnez	a3,800132e0 <.L__mulsf3_apply_sign>
800132de:	9979                	and	a0,a0,-2

800132e0 <.L__mulsf3_apply_sign>:
800132e0:	8d5d                	or	a0,a0,a5
800132e2:	8082                	ret

800132e4 <.L__mulsf3_inf>:
800132e4:	7f800537          	lui	a0,0x7f800
800132e8:	bfe5                	j	800132e0 <.L__mulsf3_apply_sign>

800132ea <.L__mulsf3_lhs_zero_or_subnormal>:
800132ea:	00568d63          	beq	a3,t0,80013304 <.L__mulsf3_nan>

800132ee <.L__mulsf3_signed_zero>:
800132ee:	853e                	mv	a0,a5
800132f0:	8082                	ret

800132f2 <.L__mulsf3_lhs_inf_or_nan>:
800132f2:	0526                	sll	a0,a0,0x9
800132f4:	e901                	bnez	a0,80013304 <.L__mulsf3_nan>
800132f6:	fe5697e3          	bne	a3,t0,800132e4 <.L__mulsf3_inf>
800132fa:	05a6                	sll	a1,a1,0x9
800132fc:	e581                	bnez	a1,80013304 <.L__mulsf3_nan>
800132fe:	b7dd                	j	800132e4 <.L__mulsf3_inf>

80013300 <.L__mulsf3_rhs_zero_or_subnormal>:
80013300:	fe5617e3          	bne	a2,t0,800132ee <.L__mulsf3_signed_zero>

80013304 <.L__mulsf3_nan>:
80013304:	7fc00537          	lui	a0,0x7fc00
80013308:	8082                	ret

8001330a <.L__mulsf3_rhs_inf_or_nan>:
8001330a:	05a6                	sll	a1,a1,0x9
8001330c:	fde5                	bnez	a1,80013304 <.L__mulsf3_nan>
8001330e:	bfd9                	j	800132e4 <.L__mulsf3_inf>

80013310 <.L__mulsf3_zero_or_underflow>:
80013310:	0605                	add	a2,a2,1
80013312:	fe71                	bnez	a2,800132ee <.L__mulsf3_signed_zero>
80013314:	8521                	sra	a0,a0,0x8
80013316:	00150293          	add	t0,a0,1 # 7fc00001 <__AXI_SRAM_segment_end__+0x7e9c0001>
8001331a:	0509                	add	a0,a0,2
8001331c:	fc0299e3          	bnez	t0,800132ee <.L__mulsf3_signed_zero>
80013320:	00800537          	lui	a0,0x800
80013324:	bf75                	j	800132e0 <.L__mulsf3_apply_sign>

Disassembly of section .text.libc.__divsf3:

80013326 <__divsf3>:
80013326:	0ff00293          	li	t0,255
8001332a:	00151713          	sll	a4,a0,0x1
8001332e:	8361                	srl	a4,a4,0x18
80013330:	00159793          	sll	a5,a1,0x1
80013334:	83e1                	srl	a5,a5,0x18
80013336:	00b54333          	xor	t1,a0,a1
8001333a:	01f35313          	srl	t1,t1,0x1f
8001333e:	037e                	sll	t1,t1,0x1f
80013340:	cf5d                	beqz	a4,800133fe <.L__divsf3_lhs_zero_or_subnormal>
80013342:	cbf9                	beqz	a5,80013418 <.L__divsf3_rhs_zero_or_subnormal>
80013344:	0c570563          	beq	a4,t0,8001340e <.L__divsf3_lhs_inf_or_nan>
80013348:	0c578d63          	beq	a5,t0,80013422 <.L__divsf3_rhs_inf_or_nan>
8001334c:	8f1d                	sub	a4,a4,a5
8001334e:	800052b7          	lui	t0,0x80005
80013352:	59828293          	add	t0,t0,1432 # 80005598 <__SEGGER_RTL_fdiv_reciprocal_table>
80013356:	00f5d693          	srl	a3,a1,0xf
8001335a:	0fc6f693          	and	a3,a3,252
8001335e:	9696                	add	a3,a3,t0
80013360:	429c                	lw	a5,0(a3)
80013362:	4187d613          	sra	a2,a5,0x18
80013366:	00f59693          	sll	a3,a1,0xf
8001336a:	82e1                	srl	a3,a3,0x18
8001336c:	0016f293          	and	t0,a3,1
80013370:	8285                	srl	a3,a3,0x1
80013372:	fc068693          	add	a3,a3,-64
80013376:	9696                	add	a3,a3,t0
80013378:	02d60633          	mul	a2,a2,a3
8001337c:	07a2                	sll	a5,a5,0x8
8001337e:	83a1                	srl	a5,a5,0x8
80013380:	963e                	add	a2,a2,a5
80013382:	05a2                	sll	a1,a1,0x8
80013384:	81a1                	srl	a1,a1,0x8
80013386:	008007b7          	lui	a5,0x800
8001338a:	8ddd                	or	a1,a1,a5
8001338c:	02c586b3          	mul	a3,a1,a2
80013390:	0522                	sll	a0,a0,0x8
80013392:	8121                	srl	a0,a0,0x8
80013394:	8d5d                	or	a0,a0,a5
80013396:	02c697b3          	mulh	a5,a3,a2
8001339a:	00b532b3          	sltu	t0,a0,a1
8001339e:	00551533          	sll	a0,a0,t0
800133a2:	40570733          	sub	a4,a4,t0
800133a6:	01465693          	srl	a3,a2,0x14
800133aa:	8a85                	and	a3,a3,1
800133ac:	0016c693          	xor	a3,a3,1
800133b0:	062e                	sll	a2,a2,0xb
800133b2:	8e1d                	sub	a2,a2,a5
800133b4:	8e15                	sub	a2,a2,a3
800133b6:	050a                	sll	a0,a0,0x2
800133b8:	02a617b3          	mulh	a5,a2,a0
800133bc:	07e70613          	add	a2,a4,126 # 8000007e <__AXI_SRAM_segment_end__+0x7edc007e>
800133c0:	055a                	sll	a0,a0,0x16
800133c2:	8d0d                	sub	a0,a0,a1
800133c4:	02b786b3          	mul	a3,a5,a1
800133c8:	0fe00293          	li	t0,254
800133cc:	00567f63          	bgeu	a2,t0,800133ea <.L__divsf3_underflow_or_overflow>
800133d0:	40a68533          	sub	a0,a3,a0
800133d4:	000522b3          	sltz	t0,a0
800133d8:	9796                	add	a5,a5,t0
800133da:	0017f513          	and	a0,a5,1
800133de:	8385                	srl	a5,a5,0x1
800133e0:	953e                	add	a0,a0,a5
800133e2:	065e                	sll	a2,a2,0x17
800133e4:	9532                	add	a0,a0,a2
800133e6:	951a                	add	a0,a0,t1
800133e8:	8082                	ret

800133ea <.L__divsf3_underflow_or_overflow>:
800133ea:	851a                	mv	a0,t1
800133ec:	00564563          	blt	a2,t0,800133f6 <.L__divsf3_done>
800133f0:	7f800337          	lui	t1,0x7f800

800133f4 <.L__divsf3_apply_sign>:
800133f4:	951a                	add	a0,a0,t1

800133f6 <.L__divsf3_done>:
800133f6:	8082                	ret

800133f8 <.L__divsf3_inf>:
800133f8:	7f800537          	lui	a0,0x7f800
800133fc:	bfe5                	j	800133f4 <.L__divsf3_apply_sign>

800133fe <.L__divsf3_lhs_zero_or_subnormal>:
800133fe:	c789                	beqz	a5,80013408 <.L__divsf3_nan>
80013400:	02579363          	bne	a5,t0,80013426 <.L__divsf3_signed_zero>
80013404:	05a6                	sll	a1,a1,0x9
80013406:	c185                	beqz	a1,80013426 <.L__divsf3_signed_zero>

80013408 <.L__divsf3_nan>:
80013408:	7fc00537          	lui	a0,0x7fc00
8001340c:	8082                	ret

8001340e <.L__divsf3_lhs_inf_or_nan>:
8001340e:	0526                	sll	a0,a0,0x9
80013410:	fd65                	bnez	a0,80013408 <.L__divsf3_nan>
80013412:	fe5793e3          	bne	a5,t0,800133f8 <.L__divsf3_inf>
80013416:	bfcd                	j	80013408 <.L__divsf3_nan>

80013418 <.L__divsf3_rhs_zero_or_subnormal>:
80013418:	fe5710e3          	bne	a4,t0,800133f8 <.L__divsf3_inf>
8001341c:	0526                	sll	a0,a0,0x9
8001341e:	f56d                	bnez	a0,80013408 <.L__divsf3_nan>
80013420:	bfe1                	j	800133f8 <.L__divsf3_inf>

80013422 <.L__divsf3_rhs_inf_or_nan>:
80013422:	05a6                	sll	a1,a1,0x9
80013424:	f1f5                	bnez	a1,80013408 <.L__divsf3_nan>

80013426 <.L__divsf3_signed_zero>:
80013426:	851a                	mv	a0,t1
80013428:	8082                	ret

Disassembly of section .text.libc.__eqsf2:

8001342a <__eqsf2>:
8001342a:	ff000637          	lui	a2,0xff000
8001342e:	00151693          	sll	a3,a0,0x1
80013432:	02d66063          	bltu	a2,a3,80013452 <.L__eqsf2_one>
80013436:	00159693          	sll	a3,a1,0x1
8001343a:	00d66c63          	bltu	a2,a3,80013452 <.L__eqsf2_one>
8001343e:	00b56633          	or	a2,a0,a1
80013442:	0606                	sll	a2,a2,0x1
80013444:	c609                	beqz	a2,8001344e <.L__eqsf2_zero>
80013446:	8d0d                	sub	a0,a0,a1
80013448:	00a03533          	snez	a0,a0
8001344c:	8082                	ret

8001344e <.L__eqsf2_zero>:
8001344e:	4501                	li	a0,0
80013450:	8082                	ret

80013452 <.L__eqsf2_one>:
80013452:	4505                	li	a0,1
80013454:	8082                	ret

Disassembly of section .text.libc.__fixunssfdi:

80013456 <__fixunssfdi>:
80013456:	04054a63          	bltz	a0,800134aa <.L__fixunssfdi_zero_result>
8001345a:	00151613          	sll	a2,a0,0x1
8001345e:	8261                	srl	a2,a2,0x18
80013460:	f8160613          	add	a2,a2,-127 # feffff81 <__AHB_SRAM_segment_end__+0xedf7f81>
80013464:	04064363          	bltz	a2,800134aa <.L__fixunssfdi_zero_result>
80013468:	800006b7          	lui	a3,0x80000
8001346c:	02000293          	li	t0,32
80013470:	00565b63          	bge	a2,t0,80013486 <.L__fixunssfdi_long_shift>
80013474:	40c00633          	neg	a2,a2
80013478:	067d                	add	a2,a2,31
8001347a:	0522                	sll	a0,a0,0x8
8001347c:	8d55                	or	a0,a0,a3
8001347e:	00c55533          	srl	a0,a0,a2
80013482:	4581                	li	a1,0
80013484:	8082                	ret

80013486 <.L__fixunssfdi_long_shift>:
80013486:	40c00633          	neg	a2,a2
8001348a:	03f60613          	add	a2,a2,63
8001348e:	02064163          	bltz	a2,800134b0 <.L__fixunssfdi_overflow_result>
80013492:	00851593          	sll	a1,a0,0x8
80013496:	8dd5                	or	a1,a1,a3
80013498:	4501                	li	a0,0
8001349a:	c619                	beqz	a2,800134a8 <.L__fixunssfdi_shift_32>
8001349c:	40c006b3          	neg	a3,a2
800134a0:	00d59533          	sll	a0,a1,a3
800134a4:	00c5d5b3          	srl	a1,a1,a2

800134a8 <.L__fixunssfdi_shift_32>:
800134a8:	8082                	ret

800134aa <.L__fixunssfdi_zero_result>:
800134aa:	4501                	li	a0,0
800134ac:	4581                	li	a1,0
800134ae:	8082                	ret

800134b0 <.L__fixunssfdi_overflow_result>:
800134b0:	557d                	li	a0,-1
800134b2:	55fd                	li	a1,-1
800134b4:	8082                	ret

Disassembly of section .text.libc.__trunctfsf2:

800134b6 <__trunctfsf2>:
800134b6:	4110                	lw	a2,0(a0)
800134b8:	4154                	lw	a3,4(a0)
800134ba:	4518                	lw	a4,8(a0)
800134bc:	455c                	lw	a5,12(a0)
800134be:	1101                	add	sp,sp,-32
800134c0:	850a                	mv	a0,sp
800134c2:	ce06                	sw	ra,28(sp)
800134c4:	c032                	sw	a2,0(sp)
800134c6:	c236                	sw	a3,4(sp)
800134c8:	c43a                	sw	a4,8(sp)
800134ca:	c63e                	sw	a5,12(sp)
800134cc:	deff90ef          	jal	8000d2ba <__SEGGER_RTL_ldouble_to_double>
800134d0:	d65f90ef          	jal	8000d234 <__truncdfsf2>
800134d4:	40f2                	lw	ra,28(sp)
800134d6:	6105                	add	sp,sp,32
800134d8:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_float32_signbit:

800134da <__SEGGER_RTL_float32_signbit>:
800134da:	817d                	srl	a0,a0,0x1f
800134dc:	8082                	ret

Disassembly of section .text.libc.ldexpf:

800134de <ldexpf>:
800134de:	01755713          	srl	a4,a0,0x17
800134e2:	0ff77713          	zext.b	a4,a4
800134e6:	fff70613          	add	a2,a4,-1
800134ea:	0fd00693          	li	a3,253
800134ee:	87aa                	mv	a5,a0
800134f0:	02c6e863          	bltu	a3,a2,80013520 <.L780>
800134f4:	95ba                	add	a1,a1,a4
800134f6:	fff58713          	add	a4,a1,-1
800134fa:	00e6eb63          	bltu	a3,a4,80013510 <.L781>
800134fe:	80800737          	lui	a4,0x80800
80013502:	177d                	add	a4,a4,-1 # 807fffff <__FLASH_segment_end__+0x6fffff>
80013504:	00e577b3          	and	a5,a0,a4
80013508:	05de                	sll	a1,a1,0x17
8001350a:	00f5e533          	or	a0,a1,a5
8001350e:	8082                	ret

80013510 <.L781>:
80013510:	80000537          	lui	a0,0x80000
80013514:	8d7d                	and	a0,a0,a5
80013516:	00b05563          	blez	a1,80013520 <.L780>
8001351a:	7f8007b7          	lui	a5,0x7f800
8001351e:	8d5d                	or	a0,a0,a5

80013520 <.L780>:
80013520:	8082                	ret

Disassembly of section .text.libc.frexpf:

80013522 <frexpf>:
80013522:	01755793          	srl	a5,a0,0x17
80013526:	0ff7f793          	zext.b	a5,a5
8001352a:	4701                	li	a4,0
8001352c:	cf99                	beqz	a5,8001354a <.L959>
8001352e:	0ff00613          	li	a2,255
80013532:	00c78c63          	beq	a5,a2,8001354a <.L959>
80013536:	f8278713          	add	a4,a5,-126 # 7f7fff82 <__AXI_SRAM_segment_end__+0x7e5bff82>
8001353a:	808007b7          	lui	a5,0x80800
8001353e:	17fd                	add	a5,a5,-1 # 807fffff <__FLASH_segment_end__+0x6fffff>
80013540:	00f576b3          	and	a3,a0,a5
80013544:	3f000537          	lui	a0,0x3f000
80013548:	8d55                	or	a0,a0,a3

8001354a <.L959>:
8001354a:	c198                	sw	a4,0(a1)
8001354c:	8082                	ret

Disassembly of section .text.libc.fmodf:

8001354e <fmodf>:
8001354e:	01755793          	srl	a5,a0,0x17
80013552:	80000837          	lui	a6,0x80000
80013556:	17fd                	add	a5,a5,-1
80013558:	0fd00713          	li	a4,253
8001355c:	86aa                	mv	a3,a0
8001355e:	862e                	mv	a2,a1
80013560:	00a87833          	and	a6,a6,a0
80013564:	02f76663          	bltu	a4,a5,80013590 <.L991>
80013568:	0175d793          	srl	a5,a1,0x17
8001356c:	17fd                	add	a5,a5,-1
8001356e:	04f77063          	bgeu	a4,a5,800135ae <.L992>
80013572:	00151713          	sll	a4,a0,0x1

80013576 <.L993>:
80013576:	00159793          	sll	a5,a1,0x1
8001357a:	ff000637          	lui	a2,0xff000
8001357e:	0cf66863          	bltu	a2,a5,8001364e <.L1009>
80013582:	ef11                	bnez	a4,8001359e <.L995>
80013584:	ef81                	bnez	a5,8001359c <.L994>

80013586 <.L1011>:
80013586:	800067b7          	lui	a5,0x80006
8001358a:	ce07a503          	lw	a0,-800(a5) # 80005ce0 <.Lmerged_single+0x14>
8001358e:	8082                	ret

80013590 <.L991>:
80013590:	00151713          	sll	a4,a0,0x1
80013594:	ff0007b7          	lui	a5,0xff000
80013598:	fce7ffe3          	bgeu	a5,a4,80013576 <.L993>

8001359c <.L994>:
8001359c:	8082                	ret

8001359e <.L995>:
8001359e:	fec704e3          	beq	a4,a2,80013586 <.L1011>
800135a2:	fec78de3          	beq	a5,a2,8001359c <.L994>
800135a6:	d3e5                	beqz	a5,80013586 <.L1011>
800135a8:	0586                	sll	a1,a1,0x1
800135aa:	0015d613          	srl	a2,a1,0x1

800135ae <.L992>:
800135ae:	00169793          	sll	a5,a3,0x1
800135b2:	8385                	srl	a5,a5,0x1
800135b4:	00f66663          	bltu	a2,a5,800135c0 <.L996>
800135b8:	fec792e3          	bne	a5,a2,8001359c <.L994>

800135bc <.L1018>:
800135bc:	8542                	mv	a0,a6
800135be:	8082                	ret

800135c0 <.L996>:
800135c0:	0177d713          	srl	a4,a5,0x17
800135c4:	cb0d                	beqz	a4,800135f6 <.L1012>
800135c6:	008007b7          	lui	a5,0x800
800135ca:	fff78593          	add	a1,a5,-1 # 7fffff <__DLM_segment_end__+0x5dffff>
800135ce:	8eed                	and	a3,a3,a1
800135d0:	8fd5                	or	a5,a5,a3

800135d2 <.L998>:
800135d2:	01765593          	srl	a1,a2,0x17
800135d6:	c985                	beqz	a1,80013606 <.L1013>
800135d8:	008006b7          	lui	a3,0x800
800135dc:	fff68513          	add	a0,a3,-1 # 7fffff <__DLM_segment_end__+0x5dffff>
800135e0:	8e69                	and	a2,a2,a0
800135e2:	8e55                	or	a2,a2,a3

800135e4 <.L1002>:
800135e4:	40c786b3          	sub	a3,a5,a2
800135e8:	02e5c763          	blt	a1,a4,80013616 <.L1003>
800135ec:	0206cc63          	bltz	a3,80013624 <.L1015>
800135f0:	8542                	mv	a0,a6
800135f2:	ea95                	bnez	a3,80013626 <.L1004>
800135f4:	8082                	ret

800135f6 <.L1012>:
800135f6:	4701                	li	a4,0
800135f8:	008006b7          	lui	a3,0x800

800135fc <.L997>:
800135fc:	0786                	sll	a5,a5,0x1
800135fe:	177d                	add	a4,a4,-1
80013600:	fed7eee3          	bltu	a5,a3,800135fc <.L997>
80013604:	b7f9                	j	800135d2 <.L998>

80013606 <.L1013>:
80013606:	4581                	li	a1,0
80013608:	008006b7          	lui	a3,0x800

8001360c <.L999>:
8001360c:	0606                	sll	a2,a2,0x1
8001360e:	15fd                	add	a1,a1,-1
80013610:	fed66ee3          	bltu	a2,a3,8001360c <.L999>
80013614:	bfc1                	j	800135e4 <.L1002>

80013616 <.L1003>:
80013616:	0006c463          	bltz	a3,8001361e <.L1001>
8001361a:	d2cd                	beqz	a3,800135bc <.L1018>
8001361c:	87b6                	mv	a5,a3

8001361e <.L1001>:
8001361e:	0786                	sll	a5,a5,0x1
80013620:	177d                	add	a4,a4,-1
80013622:	b7c9                	j	800135e4 <.L1002>

80013624 <.L1015>:
80013624:	86be                	mv	a3,a5

80013626 <.L1004>:
80013626:	008007b7          	lui	a5,0x800

8001362a <.L1006>:
8001362a:	fff70513          	add	a0,a4,-1
8001362e:	00f6ed63          	bltu	a3,a5,80013648 <.L1007>
80013632:	00e04763          	bgtz	a4,80013640 <.L1008>
80013636:	4785                	li	a5,1
80013638:	8f99                	sub	a5,a5,a4
8001363a:	00f6d6b3          	srl	a3,a3,a5
8001363e:	4501                	li	a0,0

80013640 <.L1008>:
80013640:	9836                	add	a6,a6,a3
80013642:	055e                	sll	a0,a0,0x17
80013644:	9542                	add	a0,a0,a6
80013646:	8082                	ret

80013648 <.L1007>:
80013648:	0686                	sll	a3,a3,0x1
8001364a:	872a                	mv	a4,a0
8001364c:	bff9                	j	8001362a <.L1006>

8001364e <.L1009>:
8001364e:	852e                	mv	a0,a1
80013650:	8082                	ret

Disassembly of section .text.libc.memset:

80013652 <memset>:
80013652:	872a                	mv	a4,a0
80013654:	c22d                	beqz	a2,800136b6 <.Lmemset_memset_end>

80013656 <.Lmemset_unaligned_byte_set_loop>:
80013656:	01e51693          	sll	a3,a0,0x1e
8001365a:	c699                	beqz	a3,80013668 <.Lmemset_fast_set>
8001365c:	00b50023          	sb	a1,0(a0) # 3f000000 <__AXI_SRAM_segment_end__+0x3ddc0000>
80013660:	0505                	add	a0,a0,1
80013662:	167d                	add	a2,a2,-1 # feffffff <__AHB_SRAM_segment_end__+0xedf7fff>
80013664:	fa6d                	bnez	a2,80013656 <.Lmemset_unaligned_byte_set_loop>
80013666:	a881                	j	800136b6 <.Lmemset_memset_end>

80013668 <.Lmemset_fast_set>:
80013668:	0ff5f593          	zext.b	a1,a1
8001366c:	00859693          	sll	a3,a1,0x8
80013670:	8dd5                	or	a1,a1,a3
80013672:	01059693          	sll	a3,a1,0x10
80013676:	8dd5                	or	a1,a1,a3
80013678:	02000693          	li	a3,32
8001367c:	00d66f63          	bltu	a2,a3,8001369a <.Lmemset_word_set>

80013680 <.Lmemset_fast_set_loop>:
80013680:	c10c                	sw	a1,0(a0)
80013682:	c14c                	sw	a1,4(a0)
80013684:	c50c                	sw	a1,8(a0)
80013686:	c54c                	sw	a1,12(a0)
80013688:	c90c                	sw	a1,16(a0)
8001368a:	c94c                	sw	a1,20(a0)
8001368c:	cd0c                	sw	a1,24(a0)
8001368e:	cd4c                	sw	a1,28(a0)
80013690:	9536                	add	a0,a0,a3
80013692:	8e15                	sub	a2,a2,a3
80013694:	fed676e3          	bgeu	a2,a3,80013680 <.Lmemset_fast_set_loop>
80013698:	ce19                	beqz	a2,800136b6 <.Lmemset_memset_end>

8001369a <.Lmemset_word_set>:
8001369a:	4691                	li	a3,4
8001369c:	00d66863          	bltu	a2,a3,800136ac <.Lmemset_byte_set_loop>

800136a0 <.Lmemset_word_set_loop>:
800136a0:	c10c                	sw	a1,0(a0)
800136a2:	9536                	add	a0,a0,a3
800136a4:	8e15                	sub	a2,a2,a3
800136a6:	fed67de3          	bgeu	a2,a3,800136a0 <.Lmemset_word_set_loop>
800136aa:	c611                	beqz	a2,800136b6 <.Lmemset_memset_end>

800136ac <.Lmemset_byte_set_loop>:
800136ac:	00b50023          	sb	a1,0(a0)
800136b0:	0505                	add	a0,a0,1
800136b2:	167d                	add	a2,a2,-1
800136b4:	fe65                	bnez	a2,800136ac <.Lmemset_byte_set_loop>

800136b6 <.Lmemset_memset_end>:
800136b6:	853a                	mv	a0,a4
800136b8:	8082                	ret

Disassembly of section .text.libc.strlen:

800136ba <strlen>:
800136ba:	85aa                	mv	a1,a0
800136bc:	00357693          	and	a3,a0,3
800136c0:	c29d                	beqz	a3,800136e6 <.Lstrlen_aligned>
800136c2:	00054603          	lbu	a2,0(a0)
800136c6:	ce21                	beqz	a2,8001371e <.Lstrlen_done>
800136c8:	0505                	add	a0,a0,1
800136ca:	00357693          	and	a3,a0,3
800136ce:	ce81                	beqz	a3,800136e6 <.Lstrlen_aligned>
800136d0:	00054603          	lbu	a2,0(a0)
800136d4:	c629                	beqz	a2,8001371e <.Lstrlen_done>
800136d6:	0505                	add	a0,a0,1
800136d8:	00357693          	and	a3,a0,3
800136dc:	c689                	beqz	a3,800136e6 <.Lstrlen_aligned>
800136de:	00054603          	lbu	a2,0(a0)
800136e2:	ce15                	beqz	a2,8001371e <.Lstrlen_done>
800136e4:	0505                	add	a0,a0,1

800136e6 <.Lstrlen_aligned>:
800136e6:	01010637          	lui	a2,0x1010
800136ea:	10160613          	add	a2,a2,257 # 1010101 <__DLM_segment_end__+0xdf0101>
800136ee:	00761693          	sll	a3,a2,0x7

800136f2 <.Lstrlen_wordstrlen>:
800136f2:	4118                	lw	a4,0(a0)
800136f4:	0511                	add	a0,a0,4
800136f6:	40c707b3          	sub	a5,a4,a2
800136fa:	fff74713          	not	a4,a4
800136fe:	8ff9                	and	a5,a5,a4
80013700:	8ff5                	and	a5,a5,a3
80013702:	dbe5                	beqz	a5,800136f2 <.Lstrlen_wordstrlen>
80013704:	1571                	add	a0,a0,-4
80013706:	01879713          	sll	a4,a5,0x18
8001370a:	eb11                	bnez	a4,8001371e <.Lstrlen_done>
8001370c:	0505                	add	a0,a0,1
8001370e:	01079713          	sll	a4,a5,0x10
80013712:	e711                	bnez	a4,8001371e <.Lstrlen_done>
80013714:	0505                	add	a0,a0,1
80013716:	00879713          	sll	a4,a5,0x8
8001371a:	e311                	bnez	a4,8001371e <.Lstrlen_done>
8001371c:	0505                	add	a0,a0,1

8001371e <.Lstrlen_done>:
8001371e:	8d0d                	sub	a0,a0,a1
80013720:	8082                	ret

Disassembly of section .text.libc.memmove:

80013722 <memmove>:
80013722:	0cb57b63          	bgeu	a0,a1,800137f8 <.L2>
80013726:	00b547b3          	xor	a5,a0,a1
8001372a:	8b8d                	and	a5,a5,3
8001372c:	872a                	mv	a4,a0
8001372e:	c395                	beqz	a5,80013752 <.L3>

80013730 <.L4>:
80013730:	c601                	beqz	a2,80013738 <.L11>
80013732:	0035f793          	and	a5,a1,3
80013736:	e3b5                	bnez	a5,8001379a <.L12>

80013738 <.L11>:
80013738:	882e                	mv	a6,a1
8001373a:	87ba                	mv	a5,a4
8001373c:	00c70333          	add	t1,a4,a2
80013740:	488d                	li	a7,3
80013742:	a069                	j	800137cc <.L13>

80013744 <.L6>:
80013744:	0005c683          	lbu	a3,0(a1)
80013748:	0585                	add	a1,a1,1
8001374a:	0705                	add	a4,a4,1
8001374c:	167d                	add	a2,a2,-1
8001374e:	fed70fa3          	sb	a3,-1(a4)

80013752 <.L3>:
80013752:	00377693          	and	a3,a4,3
80013756:	e285                	bnez	a3,80013776 <.L46>
80013758:	480d                	li	a6,3

8001375a <.L5>:
8001375a:	40d608b3          	sub	a7,a2,a3
8001375e:	01187d63          	bgeu	a6,a7,80013778 <.L7>
80013762:	00d588b3          	add	a7,a1,a3
80013766:	0008a303          	lw	t1,0(a7)
8001376a:	00d708b3          	add	a7,a4,a3
8001376e:	0691                	add	a3,a3,4 # 800004 <__DLM_segment_end__+0x5e0004>
80013770:	0068a023          	sw	t1,0(a7)
80013774:	b7dd                	j	8001375a <.L5>

80013776 <.L46>:
80013776:	f679                	bnez	a2,80013744 <.L6>

80013778 <.L7>:
80013778:	ffc67813          	and	a6,a2,-4
8001377c:	8a0d                	and	a2,a2,3

8001377e <.L9>:
8001377e:	00f61363          	bne	a2,a5,80013784 <.L10>
80013782:	8082                	ret

80013784 <.L10>:
80013784:	00f806b3          	add	a3,a6,a5
80013788:	00d588b3          	add	a7,a1,a3
8001378c:	0008c883          	lbu	a7,0(a7)
80013790:	96ba                	add	a3,a3,a4
80013792:	0785                	add	a5,a5,1 # 800001 <__DLM_segment_end__+0x5e0001>
80013794:	01168023          	sb	a7,0(a3)
80013798:	b7dd                	j	8001377e <.L9>

8001379a <.L12>:
8001379a:	0005c783          	lbu	a5,0(a1)
8001379e:	0585                	add	a1,a1,1
800137a0:	0705                	add	a4,a4,1
800137a2:	167d                	add	a2,a2,-1
800137a4:	fef70fa3          	sb	a5,-1(a4)
800137a8:	b761                	j	80013730 <.L4>

800137aa <.L14>:
800137aa:	00082683          	lw	a3,0(a6) # 80000000 <__AXI_SRAM_segment_end__+0x7edc0000>
800137ae:	0791                	add	a5,a5,4
800137b0:	0811                	add	a6,a6,4
800137b2:	0086de13          	srl	t3,a3,0x8
800137b6:	fed78e23          	sb	a3,-4(a5)
800137ba:	ffc78ea3          	sb	t3,-3(a5)
800137be:	0106de13          	srl	t3,a3,0x10
800137c2:	82e1                	srl	a3,a3,0x18
800137c4:	ffc78f23          	sb	t3,-2(a5)
800137c8:	fed78fa3          	sb	a3,-1(a5)

800137cc <.L13>:
800137cc:	40f306b3          	sub	a3,t1,a5
800137d0:	fcd8ede3          	bltu	a7,a3,800137aa <.L14>
800137d4:	ffc67813          	and	a6,a2,-4
800137d8:	4781                	li	a5,0
800137da:	8a0d                	and	a2,a2,3

800137dc <.L15>:
800137dc:	00f61363          	bne	a2,a5,800137e2 <.L16>
800137e0:	8082                	ret

800137e2 <.L16>:
800137e2:	00f806b3          	add	a3,a6,a5
800137e6:	00d588b3          	add	a7,a1,a3
800137ea:	0008c883          	lbu	a7,0(a7)
800137ee:	96ba                	add	a3,a3,a4
800137f0:	0785                	add	a5,a5,1
800137f2:	01168023          	sb	a7,0(a3)
800137f6:	b7dd                	j	800137dc <.L15>

800137f8 <.L2>:
800137f8:	04a5f263          	bgeu	a1,a0,8001383c <.L38>
800137fc:	00c50833          	add	a6,a0,a2
80013800:	95b2                	add	a1,a1,a2
80013802:	00b847b3          	xor	a5,a6,a1
80013806:	8b8d                	and	a5,a5,3
80013808:	c3b1                	beqz	a5,8001384c <.L18>

8001380a <.L19>:
8001380a:	c601                	beqz	a2,80013812 <.L26>
8001380c:	0035f793          	and	a5,a1,3
80013810:	ebc1                	bnez	a5,800138a0 <.L27>

80013812 <.L26>:
80013812:	86ae                	mv	a3,a1
80013814:	87c2                	mv	a5,a6
80013816:	40b60333          	sub	t1,a2,a1
8001381a:	488d                	li	a7,3

8001381c <.L28>:
8001381c:	00668733          	add	a4,a3,t1
80013820:	08e8e863          	bltu	a7,a4,800138b0 <.L29>
80013824:	00265713          	srl	a4,a2,0x2
80013828:	57f1                	li	a5,-4
8001382a:	02f70733          	mul	a4,a4,a5
8001382e:	4781                	li	a5,0
80013830:	963a                	add	a2,a2,a4
80013832:	fff64613          	not	a2,a2

80013836 <.L30>:
80013836:	17fd                	add	a5,a5,-1
80013838:	08c79d63          	bne	a5,a2,800138d2 <.L31>

8001383c <.L38>:
8001383c:	8082                	ret

8001383e <.L21>:
8001383e:	fff5c703          	lbu	a4,-1(a1)
80013842:	15fd                	add	a1,a1,-1
80013844:	187d                	add	a6,a6,-1
80013846:	167d                	add	a2,a2,-1
80013848:	00e80023          	sb	a4,0(a6)

8001384c <.L18>:
8001384c:	00387713          	and	a4,a6,3
80013850:	c311                	beqz	a4,80013854 <.L20>
80013852:	f675                	bnez	a2,8001383e <.L21>

80013854 <.L20>:
80013854:	872e                	mv	a4,a1
80013856:	86c2                	mv	a3,a6
80013858:	40b60e33          	sub	t3,a2,a1
8001385c:	488d                	li	a7,3

8001385e <.L22>:
8001385e:	01c70333          	add	t1,a4,t3
80013862:	0068ee63          	bltu	a7,t1,8001387e <.L23>
80013866:	00265713          	srl	a4,a2,0x2
8001386a:	56f1                	li	a3,-4
8001386c:	02d70733          	mul	a4,a4,a3
80013870:	963a                	add	a2,a2,a4
80013872:	fff64613          	not	a2,a2

80013876 <.L24>:
80013876:	17fd                	add	a5,a5,-1
80013878:	00c79a63          	bne	a5,a2,8001388c <.L25>
8001387c:	8082                	ret

8001387e <.L23>:
8001387e:	1771                	add	a4,a4,-4
80013880:	00072303          	lw	t1,0(a4)
80013884:	16f1                	add	a3,a3,-4
80013886:	0066a023          	sw	t1,0(a3)
8001388a:	bfd1                	j	8001385e <.L22>

8001388c <.L25>:
8001388c:	00f706b3          	add	a3,a4,a5
80013890:	00d588b3          	add	a7,a1,a3
80013894:	0008c883          	lbu	a7,0(a7)
80013898:	96c2                	add	a3,a3,a6
8001389a:	01168023          	sb	a7,0(a3)
8001389e:	bfe1                	j	80013876 <.L24>

800138a0 <.L27>:
800138a0:	fff5c783          	lbu	a5,-1(a1)
800138a4:	15fd                	add	a1,a1,-1
800138a6:	187d                	add	a6,a6,-1
800138a8:	167d                	add	a2,a2,-1
800138aa:	00f80023          	sb	a5,0(a6)
800138ae:	bfb1                	j	8001380a <.L19>

800138b0 <.L29>:
800138b0:	16f1                	add	a3,a3,-4
800138b2:	4298                	lw	a4,0(a3)
800138b4:	17f1                	add	a5,a5,-4
800138b6:	00875e13          	srl	t3,a4,0x8
800138ba:	01c780a3          	sb	t3,1(a5)
800138be:	00e78023          	sb	a4,0(a5)
800138c2:	01075e13          	srl	t3,a4,0x10
800138c6:	8361                	srl	a4,a4,0x18
800138c8:	01c78123          	sb	t3,2(a5)
800138cc:	00e781a3          	sb	a4,3(a5)
800138d0:	b7b1                	j	8001381c <.L28>

800138d2 <.L31>:
800138d2:	00f706b3          	add	a3,a4,a5
800138d6:	00d588b3          	add	a7,a1,a3
800138da:	0008c883          	lbu	a7,0(a7)
800138de:	96c2                	add	a3,a3,a6
800138e0:	01168023          	sb	a7,0(a3)
800138e4:	bf89                	j	80013836 <.L30>

Disassembly of section .text.libc.strnlen:

800138e6 <strnlen>:
800138e6:	862a                	mv	a2,a0
800138e8:	852e                	mv	a0,a1
800138ea:	c9c9                	beqz	a1,8001397c <.L528>
800138ec:	00064783          	lbu	a5,0(a2)
800138f0:	c7c9                	beqz	a5,8001397a <.L534>
800138f2:	00367793          	and	a5,a2,3
800138f6:	00379693          	sll	a3,a5,0x3
800138fa:	00f58533          	add	a0,a1,a5
800138fe:	ffc67713          	and	a4,a2,-4
80013902:	57fd                	li	a5,-1
80013904:	00d797b3          	sll	a5,a5,a3
80013908:	4314                	lw	a3,0(a4)
8001390a:	fff7c793          	not	a5,a5
8001390e:	feff05b7          	lui	a1,0xfeff0
80013912:	80808837          	lui	a6,0x80808
80013916:	8fd5                	or	a5,a5,a3
80013918:	488d                	li	a7,3
8001391a:	eff58593          	add	a1,a1,-257 # fefefeff <__AHB_SRAM_segment_end__+0xede7eff>
8001391e:	08080813          	add	a6,a6,128 # 80808080 <__FLASH_segment_end__+0x708080>

80013922 <.L530>:
80013922:	00a8ff63          	bgeu	a7,a0,80013940 <.L529>
80013926:	00b786b3          	add	a3,a5,a1
8001392a:	fff7c313          	not	t1,a5
8001392e:	0066f6b3          	and	a3,a3,t1
80013932:	0106f6b3          	and	a3,a3,a6
80013936:	e689                	bnez	a3,80013940 <.L529>
80013938:	0711                	add	a4,a4,4
8001393a:	1571                	add	a0,a0,-4
8001393c:	431c                	lw	a5,0(a4)
8001393e:	b7d5                	j	80013922 <.L530>

80013940 <.L529>:
80013940:	0ff7f593          	zext.b	a1,a5
80013944:	c59d                	beqz	a1,80013972 <.L531>
80013946:	0087d593          	srl	a1,a5,0x8
8001394a:	0ff5f593          	zext.b	a1,a1
8001394e:	4685                	li	a3,1
80013950:	cd89                	beqz	a1,8001396a <.L532>
80013952:	0107d593          	srl	a1,a5,0x10
80013956:	0ff5f593          	zext.b	a1,a1
8001395a:	4689                	li	a3,2
8001395c:	c599                	beqz	a1,8001396a <.L532>
8001395e:	010005b7          	lui	a1,0x1000
80013962:	468d                	li	a3,3
80013964:	00b7e363          	bltu	a5,a1,8001396a <.L532>
80013968:	4691                	li	a3,4

8001396a <.L532>:
8001396a:	85aa                	mv	a1,a0
8001396c:	00a6f363          	bgeu	a3,a0,80013972 <.L531>
80013970:	85b6                	mv	a1,a3

80013972 <.L531>:
80013972:	8f11                	sub	a4,a4,a2
80013974:	00b70533          	add	a0,a4,a1
80013978:	8082                	ret

8001397a <.L534>:
8001397a:	4501                	li	a0,0

8001397c <.L528>:
8001397c:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_stream_write:

8001397e <__SEGGER_RTL_stream_write>:
8001397e:	5154                	lw	a3,36(a0)
80013980:	87ae                	mv	a5,a1
80013982:	853e                	mv	a0,a5
80013984:	4585                	li	a1,1
80013986:	d28f906f          	j	8000ceae <fwrite>

Disassembly of section .text.libc.__SEGGER_RTL_putc:

8001398a <__SEGGER_RTL_putc>:
8001398a:	4918                	lw	a4,16(a0)
8001398c:	1101                	add	sp,sp,-32
8001398e:	0ff5f593          	zext.b	a1,a1
80013992:	cc22                	sw	s0,24(sp)
80013994:	ce06                	sw	ra,28(sp)
80013996:	00b107a3          	sb	a1,15(sp)
8001399a:	411c                	lw	a5,0(a0)
8001399c:	842a                	mv	s0,a0
8001399e:	cb05                	beqz	a4,800139ce <.L24>
800139a0:	4154                	lw	a3,4(a0)
800139a2:	00d7ff63          	bgeu	a5,a3,800139c0 <.L26>
800139a6:	495c                	lw	a5,20(a0)
800139a8:	00178693          	add	a3,a5,1
800139ac:	973e                	add	a4,a4,a5
800139ae:	c954                	sw	a3,20(a0)
800139b0:	00b70023          	sb	a1,0(a4)
800139b4:	4958                	lw	a4,20(a0)
800139b6:	4d1c                	lw	a5,24(a0)
800139b8:	00f71463          	bne	a4,a5,800139c0 <.L26>
800139bc:	b80fa0ef          	jal	8000dd3c <__SEGGER_RTL_prin_flush>

800139c0 <.L26>:
800139c0:	401c                	lw	a5,0(s0)
800139c2:	40f2                	lw	ra,28(sp)
800139c4:	0785                	add	a5,a5,1
800139c6:	c01c                	sw	a5,0(s0)
800139c8:	4462                	lw	s0,24(sp)
800139ca:	6105                	add	sp,sp,32
800139cc:	8082                	ret

800139ce <.L24>:
800139ce:	4558                	lw	a4,12(a0)
800139d0:	c305                	beqz	a4,800139f0 <.L28>
800139d2:	4154                	lw	a3,4(a0)
800139d4:	00178613          	add	a2,a5,1
800139d8:	00d61463          	bne	a2,a3,800139e0 <.L29>
800139dc:	000107a3          	sb	zero,15(sp)

800139e0 <.L29>:
800139e0:	fed7f0e3          	bgeu	a5,a3,800139c0 <.L26>
800139e4:	00f14683          	lbu	a3,15(sp)
800139e8:	973e                	add	a4,a4,a5
800139ea:	00d70023          	sb	a3,0(a4)
800139ee:	bfc9                	j	800139c0 <.L26>

800139f0 <.L28>:
800139f0:	4518                	lw	a4,8(a0)
800139f2:	c305                	beqz	a4,80013a12 <.L30>
800139f4:	4154                	lw	a3,4(a0)
800139f6:	00178613          	add	a2,a5,1
800139fa:	00d61463          	bne	a2,a3,80013a02 <.L31>
800139fe:	000107a3          	sb	zero,15(sp)

80013a02 <.L31>:
80013a02:	fad7ffe3          	bgeu	a5,a3,800139c0 <.L26>
80013a06:	078a                	sll	a5,a5,0x2
80013a08:	973e                	add	a4,a4,a5
80013a0a:	00f14783          	lbu	a5,15(sp)
80013a0e:	c31c                	sw	a5,0(a4)
80013a10:	bf45                	j	800139c0 <.L26>

80013a12 <.L30>:
80013a12:	5118                	lw	a4,32(a0)
80013a14:	d755                	beqz	a4,800139c0 <.L26>
80013a16:	4154                	lw	a3,4(a0)
80013a18:	fad7f4e3          	bgeu	a5,a3,800139c0 <.L26>
80013a1c:	4605                	li	a2,1
80013a1e:	00f10593          	add	a1,sp,15
80013a22:	9702                	jalr	a4
80013a24:	bf71                	j	800139c0 <.L26>

Disassembly of section .text.libc.__SEGGER_RTL_print_padding:

80013a26 <__SEGGER_RTL_print_padding>:
80013a26:	1141                	add	sp,sp,-16
80013a28:	c422                	sw	s0,8(sp)
80013a2a:	c226                	sw	s1,4(sp)
80013a2c:	c04a                	sw	s2,0(sp)
80013a2e:	c606                	sw	ra,12(sp)
80013a30:	84aa                	mv	s1,a0
80013a32:	892e                	mv	s2,a1
80013a34:	8432                	mv	s0,a2

80013a36 <.L37>:
80013a36:	147d                	add	s0,s0,-1
80013a38:	00045863          	bgez	s0,80013a48 <.L38>
80013a3c:	40b2                	lw	ra,12(sp)
80013a3e:	4422                	lw	s0,8(sp)
80013a40:	4492                	lw	s1,4(sp)
80013a42:	4902                	lw	s2,0(sp)
80013a44:	0141                	add	sp,sp,16
80013a46:	8082                	ret

80013a48 <.L38>:
80013a48:	85ca                	mv	a1,s2
80013a4a:	8526                	mv	a0,s1
80013a4c:	3f3d                	jal	8001398a <__SEGGER_RTL_putc>
80013a4e:	b7e5                	j	80013a36 <.L37>

Disassembly of section .text.libc.vfprintf_l:

80013a50 <vfprintf_l>:
80013a50:	711d                	add	sp,sp,-96
80013a52:	ce86                	sw	ra,92(sp)
80013a54:	cca2                	sw	s0,88(sp)
80013a56:	caa6                	sw	s1,84(sp)
80013a58:	1080                	add	s0,sp,96
80013a5a:	c8ca                	sw	s2,80(sp)
80013a5c:	c6ce                	sw	s3,76(sp)
80013a5e:	8932                	mv	s2,a2
80013a60:	fad42623          	sw	a3,-84(s0)
80013a64:	89aa                	mv	s3,a0
80013a66:	fab42423          	sw	a1,-88(s0)
80013a6a:	eccff0ef          	jal	80013136 <__SEGGER_RTL_X_file_bufsize>
80013a6e:	fa842583          	lw	a1,-88(s0)
80013a72:	00f50793          	add	a5,a0,15
80013a76:	9bc1                	and	a5,a5,-16
80013a78:	40f10133          	sub	sp,sp,a5
80013a7c:	84aa                	mv	s1,a0
80013a7e:	fb840513          	add	a0,s0,-72
80013a82:	af6fa0ef          	jal	8000dd78 <__SEGGER_RTL_init_prin_l>
80013a86:	800007b7          	lui	a5,0x80000
80013a8a:	fac42603          	lw	a2,-84(s0)
80013a8e:	17fd                	add	a5,a5,-1 # 7fffffff <__AXI_SRAM_segment_end__+0x7edbffff>
80013a90:	faf42e23          	sw	a5,-68(s0)
80013a94:	800147b7          	lui	a5,0x80014
80013a98:	97e78793          	add	a5,a5,-1666 # 8001397e <__SEGGER_RTL_stream_write>
80013a9c:	85ca                	mv	a1,s2
80013a9e:	fb840513          	add	a0,s0,-72
80013aa2:	fc242423          	sw	sp,-56(s0)
80013aa6:	fc942823          	sw	s1,-48(s0)
80013aaa:	fd342e23          	sw	s3,-36(s0)
80013aae:	fcf42c23          	sw	a5,-40(s0)
80013ab2:	2811                	jal	80013ac6 <__SEGGER_RTL_vfprintf>
80013ab4:	fa040113          	add	sp,s0,-96
80013ab8:	40f6                	lw	ra,92(sp)
80013aba:	4466                	lw	s0,88(sp)
80013abc:	44d6                	lw	s1,84(sp)
80013abe:	4946                	lw	s2,80(sp)
80013ac0:	49b6                	lw	s3,76(sp)
80013ac2:	6125                	add	sp,sp,96
80013ac4:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_vfprintf_short_float_long:

80013ac6 <__SEGGER_RTL_vfprintf>:
80013ac6:	800067b7          	lui	a5,0x80006
80013aca:	7175                	add	sp,sp,-144
80013acc:	b0078793          	add	a5,a5,-1280 # 80005b00 <.L9>
80013ad0:	c83e                	sw	a5,16(sp)
80013ad2:	800067b7          	lui	a5,0x80006
80013ad6:	dece                	sw	s3,124(sp)
80013ad8:	dad6                	sw	s5,116(sp)
80013ada:	ceee                	sw	s11,92(sp)
80013adc:	c706                	sw	ra,140(sp)
80013ade:	c522                	sw	s0,136(sp)
80013ae0:	c326                	sw	s1,132(sp)
80013ae2:	c14a                	sw	s2,128(sp)
80013ae4:	dcd2                	sw	s4,120(sp)
80013ae6:	d8da                	sw	s6,112(sp)
80013ae8:	d6de                	sw	s7,108(sp)
80013aea:	d4e2                	sw	s8,104(sp)
80013aec:	d2e6                	sw	s9,100(sp)
80013aee:	d0ea                	sw	s10,96(sp)
80013af0:	b4478793          	add	a5,a5,-1212 # 80005b44 <.L45>
80013af4:	00020db7          	lui	s11,0x20
80013af8:	89aa                	mv	s3,a0
80013afa:	8ab2                	mv	s5,a2
80013afc:	00052023          	sw	zero,0(a0)
80013b00:	ca3e                	sw	a5,20(sp)
80013b02:	021d8d93          	add	s11,s11,33 # 20021 <__DLM_segment_size__+0x21>

80013b06 <.L2>:
80013b06:	00158a13          	add	s4,a1,1 # 1000001 <__DLM_segment_end__+0xde0001>
80013b0a:	0005c583          	lbu	a1,0(a1)
80013b0e:	e19d                	bnez	a1,80013b34 <.L229>
80013b10:	00c9a783          	lw	a5,12(s3)
80013b14:	cb91                	beqz	a5,80013b28 <.L230>
80013b16:	0009a703          	lw	a4,0(s3)
80013b1a:	0049a683          	lw	a3,4(s3)
80013b1e:	00d77563          	bgeu	a4,a3,80013b28 <.L230>
80013b22:	97ba                	add	a5,a5,a4
80013b24:	00078023          	sb	zero,0(a5)

80013b28 <.L230>:
80013b28:	854e                	mv	a0,s3
80013b2a:	a12fa0ef          	jal	8000dd3c <__SEGGER_RTL_prin_flush>
80013b2e:	0009a503          	lw	a0,0(s3)
80013b32:	a2f9                	j	80013d00 <.L338>

80013b34 <.L229>:
80013b34:	02500793          	li	a5,37
80013b38:	00f58563          	beq	a1,a5,80013b42 <.L231>

80013b3c <.L362>:
80013b3c:	854e                	mv	a0,s3
80013b3e:	35b1                	jal	8001398a <__SEGGER_RTL_putc>
80013b40:	aab9                	j	80013c9e <.L4>

80013b42 <.L231>:
80013b42:	4b81                	li	s7,0
80013b44:	03000613          	li	a2,48
80013b48:	05e00593          	li	a1,94
80013b4c:	6505                	lui	a0,0x1
80013b4e:	487d                	li	a6,31
80013b50:	48c1                	li	a7,16
80013b52:	6321                	lui	t1,0x8
80013b54:	a03d                	j	80013b82 <.L3>

80013b56 <.L5>:
80013b56:	04b78f63          	beq	a5,a1,80013bb4 <.L15>

80013b5a <.L232>:
80013b5a:	8a36                	mv	s4,a3
80013b5c:	4b01                	li	s6,0
80013b5e:	46a5                	li	a3,9
80013b60:	45a9                	li	a1,10

80013b62 <.L18>:
80013b62:	fd078713          	add	a4,a5,-48
80013b66:	0ff77613          	zext.b	a2,a4
80013b6a:	08c6e363          	bltu	a3,a2,80013bf0 <.L20>
80013b6e:	02bb0b33          	mul	s6,s6,a1
80013b72:	0a05                	add	s4,s4,1
80013b74:	fffa4783          	lbu	a5,-1(s4)
80013b78:	9b3a                	add	s6,s6,a4
80013b7a:	b7e5                	j	80013b62 <.L18>

80013b7c <.L14>:
80013b7c:	040beb93          	or	s7,s7,64

80013b80 <.L16>:
80013b80:	8a36                	mv	s4,a3

80013b82 <.L3>:
80013b82:	000a4783          	lbu	a5,0(s4)
80013b86:	001a0693          	add	a3,s4,1
80013b8a:	fcf666e3          	bltu	a2,a5,80013b56 <.L5>
80013b8e:	fcf876e3          	bgeu	a6,a5,80013b5a <.L232>
80013b92:	fe078713          	add	a4,a5,-32
80013b96:	0ff77713          	zext.b	a4,a4
80013b9a:	02e8e963          	bltu	a7,a4,80013bcc <.L7>
80013b9e:	4442                	lw	s0,16(sp)
80013ba0:	070a                	sll	a4,a4,0x2
80013ba2:	9722                	add	a4,a4,s0
80013ba4:	4318                	lw	a4,0(a4)
80013ba6:	8702                	jr	a4

80013ba8 <.L13>:
80013ba8:	080beb93          	or	s7,s7,128
80013bac:	bfd1                	j	80013b80 <.L16>

80013bae <.L12>:
80013bae:	006bebb3          	or	s7,s7,t1
80013bb2:	b7f9                	j	80013b80 <.L16>

80013bb4 <.L15>:
80013bb4:	00abebb3          	or	s7,s7,a0
80013bb8:	b7e1                	j	80013b80 <.L16>

80013bba <.L11>:
80013bba:	020beb93          	or	s7,s7,32
80013bbe:	b7c9                	j	80013b80 <.L16>

80013bc0 <.L10>:
80013bc0:	010beb93          	or	s7,s7,16
80013bc4:	bf75                	j	80013b80 <.L16>

80013bc6 <.L8>:
80013bc6:	200beb93          	or	s7,s7,512
80013bca:	bf5d                	j	80013b80 <.L16>

80013bcc <.L7>:
80013bcc:	02a00713          	li	a4,42
80013bd0:	f8e795e3          	bne	a5,a4,80013b5a <.L232>
80013bd4:	000aab03          	lw	s6,0(s5)
80013bd8:	004a8713          	add	a4,s5,4
80013bdc:	000b5663          	bgez	s6,80013be8 <.L19>
80013be0:	41600b33          	neg	s6,s6
80013be4:	010beb93          	or	s7,s7,16

80013be8 <.L19>:
80013be8:	0006c783          	lbu	a5,0(a3)
80013bec:	0a09                	add	s4,s4,2
80013bee:	8aba                	mv	s5,a4

80013bf0 <.L20>:
80013bf0:	000b5363          	bgez	s6,80013bf6 <.L22>
80013bf4:	4b01                	li	s6,0

80013bf6 <.L22>:
80013bf6:	02e00713          	li	a4,46
80013bfa:	4481                	li	s1,0
80013bfc:	04e79263          	bne	a5,a4,80013c40 <.L23>
80013c00:	000a4783          	lbu	a5,0(s4)
80013c04:	02a00713          	li	a4,42
80013c08:	02e78263          	beq	a5,a4,80013c2c <.L24>
80013c0c:	0a05                	add	s4,s4,1
80013c0e:	46a5                	li	a3,9
80013c10:	45a9                	li	a1,10

80013c12 <.L25>:
80013c12:	fd078713          	add	a4,a5,-48
80013c16:	0ff77613          	zext.b	a2,a4
80013c1a:	00c6ef63          	bltu	a3,a2,80013c38 <.L26>
80013c1e:	02b484b3          	mul	s1,s1,a1
80013c22:	0a05                	add	s4,s4,1
80013c24:	fffa4783          	lbu	a5,-1(s4)
80013c28:	94ba                	add	s1,s1,a4
80013c2a:	b7e5                	j	80013c12 <.L25>

80013c2c <.L24>:
80013c2c:	000aa483          	lw	s1,0(s5)
80013c30:	001a4783          	lbu	a5,1(s4)
80013c34:	0a91                	add	s5,s5,4
80013c36:	0a09                	add	s4,s4,2

80013c38 <.L26>:
80013c38:	0004c463          	bltz	s1,80013c40 <.L23>
80013c3c:	100beb93          	or	s7,s7,256

80013c40 <.L23>:
80013c40:	06c00713          	li	a4,108
80013c44:	06e78263          	beq	a5,a4,80013ca8 <.L28>
80013c48:	02f76c63          	bltu	a4,a5,80013c80 <.L29>
80013c4c:	06800713          	li	a4,104
80013c50:	06e78a63          	beq	a5,a4,80013cc4 <.L30>
80013c54:	06a00713          	li	a4,106
80013c58:	04e78563          	beq	a5,a4,80013ca2 <.L31>

80013c5c <.L32>:
80013c5c:	05700713          	li	a4,87
80013c60:	2ef764e3          	bltu	a4,a5,80014748 <.L38>
80013c64:	04500713          	li	a4,69
80013c68:	2ce78763          	beq	a5,a4,80013f36 <.L39>
80013c6c:	06f76763          	bltu	a4,a5,80013cda <.L40>
80013c70:	c7c1                	beqz	a5,80013cf8 <.L41>
80013c72:	02500713          	li	a4,37
80013c76:	02500593          	li	a1,37
80013c7a:	ece781e3          	beq	a5,a4,80013b3c <.L362>
80013c7e:	a005                	j	80013c9e <.L4>

80013c80 <.L29>:
80013c80:	07400713          	li	a4,116
80013c84:	00e78663          	beq	a5,a4,80013c90 <.L346>
80013c88:	07a00713          	li	a4,122
80013c8c:	2ae79ae3          	bne	a5,a4,80014740 <.L34>

80013c90 <.L346>:
80013c90:	000a4783          	lbu	a5,0(s4)
80013c94:	0a05                	add	s4,s4,1

80013c96 <.L35>:
80013c96:	07800713          	li	a4,120
80013c9a:	fcf771e3          	bgeu	a4,a5,80013c5c <.L32>

80013c9e <.L4>:
80013c9e:	85d2                	mv	a1,s4
80013ca0:	b59d                	j	80013b06 <.L2>

80013ca2 <.L31>:
80013ca2:	002beb93          	or	s7,s7,2
80013ca6:	b7ed                	j	80013c90 <.L346>

80013ca8 <.L28>:
80013ca8:	000a4783          	lbu	a5,0(s4)
80013cac:	00e79863          	bne	a5,a4,80013cbc <.L36>
80013cb0:	002beb93          	or	s7,s7,2

80013cb4 <.L347>:
80013cb4:	001a4783          	lbu	a5,1(s4)
80013cb8:	0a09                	add	s4,s4,2
80013cba:	bff1                	j	80013c96 <.L35>

80013cbc <.L36>:
80013cbc:	0a05                	add	s4,s4,1
80013cbe:	001beb93          	or	s7,s7,1
80013cc2:	bfd1                	j	80013c96 <.L35>

80013cc4 <.L30>:
80013cc4:	000a4783          	lbu	a5,0(s4)
80013cc8:	00e79563          	bne	a5,a4,80013cd2 <.L37>
80013ccc:	008beb93          	or	s7,s7,8
80013cd0:	b7d5                	j	80013cb4 <.L347>

80013cd2 <.L37>:
80013cd2:	0a05                	add	s4,s4,1
80013cd4:	004beb93          	or	s7,s7,4
80013cd8:	bf7d                	j	80013c96 <.L35>

80013cda <.L40>:
80013cda:	04600713          	li	a4,70
80013cde:	2ce78663          	beq	a5,a4,80013faa <.L57>
80013ce2:	04700713          	li	a4,71
80013ce6:	fae79ce3          	bne	a5,a4,80013c9e <.L4>
80013cea:	6789                	lui	a5,0x2
80013cec:	00fbebb3          	or	s7,s7,a5

80013cf0 <.L52>:
80013cf0:	6905                	lui	s2,0x1
80013cf2:	c0090913          	add	s2,s2,-1024 # c00 <__NOR_CFG_OPTION_segment_size__>
80013cf6:	a4c1                	j	80013fb6 <.L353>

80013cf8 <.L41>:
80013cf8:	854e                	mv	a0,s3
80013cfa:	842fa0ef          	jal	8000dd3c <__SEGGER_RTL_prin_flush>
80013cfe:	557d                	li	a0,-1

80013d00 <.L338>:
80013d00:	40ba                	lw	ra,140(sp)
80013d02:	442a                	lw	s0,136(sp)
80013d04:	449a                	lw	s1,132(sp)
80013d06:	490a                	lw	s2,128(sp)
80013d08:	59f6                	lw	s3,124(sp)
80013d0a:	5a66                	lw	s4,120(sp)
80013d0c:	5ad6                	lw	s5,116(sp)
80013d0e:	5b46                	lw	s6,112(sp)
80013d10:	5bb6                	lw	s7,108(sp)
80013d12:	5c26                	lw	s8,104(sp)
80013d14:	5c96                	lw	s9,100(sp)
80013d16:	5d06                	lw	s10,96(sp)
80013d18:	4df6                	lw	s11,92(sp)
80013d1a:	6149                	add	sp,sp,144
80013d1c:	8082                	ret

80013d1e <.L55>:
80013d1e:	000aa483          	lw	s1,0(s5)
80013d22:	1b7d                	add	s6,s6,-1
80013d24:	865a                	mv	a2,s6
80013d26:	85de                	mv	a1,s7
80013d28:	854e                	mv	a0,s3
80013d2a:	834fa0ef          	jal	8000dd5e <__SEGGER_RTL_pre_padding>
80013d2e:	004a8413          	add	s0,s5,4
80013d32:	0ff4f593          	zext.b	a1,s1
80013d36:	854e                	mv	a0,s3
80013d38:	3989                	jal	8001398a <__SEGGER_RTL_putc>
80013d3a:	8aa2                	mv	s5,s0

80013d3c <.L371>:
80013d3c:	010bfb93          	and	s7,s7,16
80013d40:	f40b8fe3          	beqz	s7,80013c9e <.L4>
80013d44:	865a                	mv	a2,s6
80013d46:	02000593          	li	a1,32
80013d4a:	854e                	mv	a0,s3
80013d4c:	39e9                	jal	80013a26 <__SEGGER_RTL_print_padding>
80013d4e:	bf81                	j	80013c9e <.L4>

80013d50 <.L50>:
80013d50:	008bf693          	and	a3,s7,8
80013d54:	000aa783          	lw	a5,0(s5)
80013d58:	0009a703          	lw	a4,0(s3)
80013d5c:	0a91                	add	s5,s5,4
80013d5e:	c681                	beqz	a3,80013d66 <.L62>
80013d60:	00e78023          	sb	a4,0(a5) # 2000 <__BOOT_HEADER_segment_size__>
80013d64:	bf2d                	j	80013c9e <.L4>

80013d66 <.L62>:
80013d66:	002bfb93          	and	s7,s7,2
80013d6a:	c398                	sw	a4,0(a5)
80013d6c:	f20b89e3          	beqz	s7,80013c9e <.L4>
80013d70:	0007a223          	sw	zero,4(a5)
80013d74:	b72d                	j	80013c9e <.L4>

80013d76 <.L47>:
80013d76:	000aa403          	lw	s0,0(s5)
80013d7a:	895e                	mv	s2,s7
80013d7c:	0a91                	add	s5,s5,4

80013d7e <.L65>:
80013d7e:	e409                	bnez	s0,80013d88 <.L66>
80013d80:	80006437          	lui	s0,0x80006
80013d84:	ad040413          	add	s0,s0,-1328 # 80005ad0 <.LC0>

80013d88 <.L66>:
80013d88:	dff97b93          	and	s7,s2,-513
80013d8c:	10097913          	and	s2,s2,256
80013d90:	02090563          	beqz	s2,80013dba <.L67>
80013d94:	85a6                	mv	a1,s1
80013d96:	8522                	mv	a0,s0
80013d98:	36b9                	jal	800138e6 <strnlen>

80013d9a <.L348>:
80013d9a:	40ab0b33          	sub	s6,s6,a0
80013d9e:	84aa                	mv	s1,a0
80013da0:	865a                	mv	a2,s6
80013da2:	85de                	mv	a1,s7
80013da4:	854e                	mv	a0,s3
80013da6:	fb9f90ef          	jal	8000dd5e <__SEGGER_RTL_pre_padding>

80013daa <.L69>:
80013daa:	d8c9                	beqz	s1,80013d3c <.L371>
80013dac:	00044583          	lbu	a1,0(s0)
80013db0:	854e                	mv	a0,s3
80013db2:	0405                	add	s0,s0,1
80013db4:	3ed9                	jal	8001398a <__SEGGER_RTL_putc>
80013db6:	14fd                	add	s1,s1,-1
80013db8:	bfcd                	j	80013daa <.L69>

80013dba <.L67>:
80013dba:	8522                	mv	a0,s0
80013dbc:	38fd                	jal	800136ba <strlen>
80013dbe:	bff1                	j	80013d9a <.L348>

80013dc0 <.L48>:
80013dc0:	080bf713          	and	a4,s7,128
80013dc4:	000aa403          	lw	s0,0(s5)
80013dc8:	004a8693          	add	a3,s5,4
80013dcc:	4581                	li	a1,0
80013dce:	02300c93          	li	s9,35
80013dd2:	e311                	bnez	a4,80013dd6 <.L71>
80013dd4:	4c81                	li	s9,0

80013dd6 <.L71>:
80013dd6:	100beb93          	or	s7,s7,256
80013dda:	8ab6                	mv	s5,a3
80013ddc:	44a1                	li	s1,8

80013dde <.L72>:
80013dde:	100bf713          	and	a4,s7,256
80013de2:	e311                	bnez	a4,80013de6 <.L203>
80013de4:	4485                	li	s1,1

80013de6 <.L203>:
80013de6:	05800713          	li	a4,88
80013dea:	08e788e3          	beq	a5,a4,8001467a <.L204>
80013dee:	f9c78693          	add	a3,a5,-100
80013df2:	4705                	li	a4,1
80013df4:	00d71733          	sll	a4,a4,a3
80013df8:	01b776b3          	and	a3,a4,s11
80013dfc:	00069ae3          	bnez	a3,80014610 <.L205>
80013e00:	00c75693          	srl	a3,a4,0xc
80013e04:	1016f693          	and	a3,a3,257
80013e08:	060699e3          	bnez	a3,8001467a <.L204>
80013e0c:	06f00713          	li	a4,111
80013e10:	4c01                	li	s8,0
80013e12:	08e793e3          	bne	a5,a4,80014698 <.L206>

80013e16 <.L207>:
80013e16:	00b467b3          	or	a5,s0,a1
80013e1a:	06078fe3          	beqz	a5,80014698 <.L206>
80013e1e:	183c                	add	a5,sp,56
80013e20:	01878733          	add	a4,a5,s8
80013e24:	00747793          	and	a5,s0,7
80013e28:	03078793          	add	a5,a5,48
80013e2c:	00f70023          	sb	a5,0(a4)
80013e30:	800d                	srl	s0,s0,0x3
80013e32:	01d59793          	sll	a5,a1,0x1d
80013e36:	0c05                	add	s8,s8,1
80013e38:	8c5d                	or	s0,s0,a5
80013e3a:	818d                	srl	a1,a1,0x3
80013e3c:	bfe9                	j	80013e16 <.L207>

80013e3e <.L56>:
80013e3e:	6709                	lui	a4,0x2
80013e40:	00ebebb3          	or	s7,s7,a4

80013e44 <.L44>:
80013e44:	080bf713          	and	a4,s7,128
80013e48:	4c81                	li	s9,0
80013e4a:	cb19                	beqz	a4,80013e60 <.L75>
80013e4c:	6c8d                	lui	s9,0x3
80013e4e:	07800713          	li	a4,120
80013e52:	058c8c93          	add	s9,s9,88 # 3058 <__BOOT_HEADER_segment_size__+0x1058>
80013e56:	00e79563          	bne	a5,a4,80013e60 <.L75>
80013e5a:	6c8d                	lui	s9,0x3
80013e5c:	078c8c93          	add	s9,s9,120 # 3078 <__BOOT_HEADER_segment_size__+0x1078>

80013e60 <.L75>:
80013e60:	100bf713          	and	a4,s7,256

80013e64 <.L365>:
80013e64:	c319                	beqz	a4,80013e6a <.L74>
80013e66:	dffbfb93          	and	s7,s7,-513

80013e6a <.L74>:
80013e6a:	011b9613          	sll	a2,s7,0x11
80013e6e:	002bf713          	and	a4,s7,2
80013e72:	004bf693          	and	a3,s7,4
80013e76:	08065563          	bgez	a2,80013f00 <.L76>
80013e7a:	cf31                	beqz	a4,80013ed6 <.L77>
80013e7c:	007a8713          	add	a4,s5,7
80013e80:	9b61                	and	a4,a4,-8
80013e82:	4300                	lw	s0,0(a4)
80013e84:	434c                	lw	a1,4(a4)
80013e86:	00870a93          	add	s5,a4,8 # 2008 <__BOOT_HEADER_segment_size__+0x8>

80013e8a <.L78>:
80013e8a:	cea1                	beqz	a3,80013ee2 <.L79>
80013e8c:	0442                	sll	s0,s0,0x10
80013e8e:	8441                	sra	s0,s0,0x10

80013e90 <.L351>:
80013e90:	41f45593          	sra	a1,s0,0x1f

80013e94 <.L80>:
80013e94:	0405dd63          	bgez	a1,80013eee <.L82>
80013e98:	00803733          	snez	a4,s0
80013e9c:	40b005b3          	neg	a1,a1
80013ea0:	8d99                	sub	a1,a1,a4
80013ea2:	40800433          	neg	s0,s0
80013ea6:	02d00c93          	li	s9,45

80013eaa <.L84>:
80013eaa:	100bf713          	and	a4,s7,256
80013eae:	db05                	beqz	a4,80013dde <.L72>
80013eb0:	dffbfb93          	and	s7,s7,-513
80013eb4:	b72d                	j	80013dde <.L72>

80013eb6 <.L49>:
80013eb6:	080bf713          	and	a4,s7,128
80013eba:	03000c93          	li	s9,48
80013ebe:	f34d                	bnez	a4,80013e60 <.L75>
80013ec0:	4c81                	li	s9,0
80013ec2:	bf79                	j	80013e60 <.L75>

80013ec4 <.L46>:
80013ec4:	100bf713          	and	a4,s7,256
80013ec8:	4c81                	li	s9,0
80013eca:	bf69                	j	80013e64 <.L365>

80013ecc <.L51>:
80013ecc:	6711                	lui	a4,0x4
80013ece:	00ebebb3          	or	s7,s7,a4
80013ed2:	4c81                	li	s9,0
80013ed4:	bf59                	j	80013e6a <.L74>

80013ed6 <.L77>:
80013ed6:	000aa403          	lw	s0,0(s5)
80013eda:	0a91                	add	s5,s5,4
80013edc:	41f45593          	sra	a1,s0,0x1f
80013ee0:	b76d                	j	80013e8a <.L78>

80013ee2 <.L79>:
80013ee2:	008bf713          	and	a4,s7,8
80013ee6:	d75d                	beqz	a4,80013e94 <.L80>
80013ee8:	0462                	sll	s0,s0,0x18
80013eea:	8461                	sra	s0,s0,0x18
80013eec:	b755                	j	80013e90 <.L351>

80013eee <.L82>:
80013eee:	020bf713          	and	a4,s7,32
80013ef2:	ef1d                	bnez	a4,80013f30 <.L239>
80013ef4:	040bf713          	and	a4,s7,64
80013ef8:	db4d                	beqz	a4,80013eaa <.L84>
80013efa:	02000c93          	li	s9,32
80013efe:	b775                	j	80013eaa <.L84>

80013f00 <.L76>:
80013f00:	cf09                	beqz	a4,80013f1a <.L85>
80013f02:	007a8713          	add	a4,s5,7
80013f06:	9b61                	and	a4,a4,-8
80013f08:	4300                	lw	s0,0(a4)
80013f0a:	434c                	lw	a1,4(a4)
80013f0c:	00870a93          	add	s5,a4,8 # 4008 <__HEAPSIZE__+0x8>

80013f10 <.L86>:
80013f10:	ca91                	beqz	a3,80013f24 <.L87>
80013f12:	0442                	sll	s0,s0,0x10
80013f14:	8041                	srl	s0,s0,0x10

80013f16 <.L352>:
80013f16:	4581                	li	a1,0
80013f18:	bf49                	j	80013eaa <.L84>

80013f1a <.L85>:
80013f1a:	000aa403          	lw	s0,0(s5)
80013f1e:	4581                	li	a1,0
80013f20:	0a91                	add	s5,s5,4
80013f22:	b7fd                	j	80013f10 <.L86>

80013f24 <.L87>:
80013f24:	008bf713          	and	a4,s7,8
80013f28:	d349                	beqz	a4,80013eaa <.L84>
80013f2a:	0ff47413          	zext.b	s0,s0
80013f2e:	b7e5                	j	80013f16 <.L352>

80013f30 <.L239>:
80013f30:	02b00c93          	li	s9,43
80013f34:	bf9d                	j	80013eaa <.L84>

80013f36 <.L39>:
80013f36:	6789                	lui	a5,0x2
80013f38:	00fbebb3          	or	s7,s7,a5

80013f3c <.L54>:
80013f3c:	400be913          	or	s2,s7,1024

80013f40 <.L91>:
80013f40:	00297793          	and	a5,s2,2
80013f44:	cfa5                	beqz	a5,80013fbc <.L92>
80013f46:	000aa783          	lw	a5,0(s5)
80013f4a:	1008                	add	a0,sp,32
80013f4c:	004a8413          	add	s0,s5,4
80013f50:	4398                	lw	a4,0(a5)
80013f52:	8aa2                	mv	s5,s0
80013f54:	d03a                	sw	a4,32(sp)
80013f56:	43d8                	lw	a4,4(a5)
80013f58:	d23a                	sw	a4,36(sp)
80013f5a:	4798                	lw	a4,8(a5)
80013f5c:	d43a                	sw	a4,40(sp)
80013f5e:	47dc                	lw	a5,12(a5)
80013f60:	d63e                	sw	a5,44(sp)
80013f62:	d54ff0ef          	jal	800134b6 <__trunctfsf2>
80013f66:	8baa                	mv	s7,a0

80013f68 <.L93>:
80013f68:	10097793          	and	a5,s2,256
80013f6c:	c3bd                	beqz	a5,80013fd2 <.L240>
80013f6e:	e889                	bnez	s1,80013f80 <.L94>
80013f70:	6785                	lui	a5,0x1
80013f72:	c0078793          	add	a5,a5,-1024 # c00 <__NOR_CFG_OPTION_segment_size__>
80013f76:	00f974b3          	and	s1,s2,a5
80013f7a:	8c9d                	sub	s1,s1,a5
80013f7c:	0014b493          	seqz	s1,s1

80013f80 <.L94>:
80013f80:	855e                	mv	a0,s7
80013f82:	bc4f90ef          	jal	8000d346 <__SEGGER_RTL_float32_isinf>
80013f86:	c921                	beqz	a0,80013fd6 <.L95>

80013f88 <.L117>:
80013f88:	6409                	lui	s0,0x2
80013f8a:	00000593          	li	a1,0
80013f8e:	855e                	mv	a0,s7
80013f90:	00897433          	and	s0,s2,s0
80013f94:	916f90ef          	jal	8000d0aa <__ltsf2>
80013f98:	40055b63          	bgez	a0,800143ae <.L341>
80013f9c:	40040463          	beqz	s0,800143a4 <.L244>
80013fa0:	80006437          	lui	s0,0x80006
80013fa4:	ad840413          	add	s0,s0,-1320 # 80005ad8 <.LC1>
80013fa8:	a099                	j	80013fee <.L122>

80013faa <.L57>:
80013faa:	6789                	lui	a5,0x2
80013fac:	00fbebb3          	or	s7,s7,a5

80013fb0 <.L53>:
80013fb0:	6905                	lui	s2,0x1
80013fb2:	80090913          	add	s2,s2,-2048 # 800 <.L13+0x26>

80013fb6 <.L353>:
80013fb6:	012be933          	or	s2,s7,s2
80013fba:	b759                	j	80013f40 <.L91>

80013fbc <.L92>:
80013fbc:	007a8793          	add	a5,s5,7
80013fc0:	9be1                	and	a5,a5,-8
80013fc2:	4388                	lw	a0,0(a5)
80013fc4:	43cc                	lw	a1,4(a5)
80013fc6:	00878a93          	add	s5,a5,8 # 2008 <__BOOT_HEADER_segment_size__+0x8>
80013fca:	a6af90ef          	jal	8000d234 <__truncdfsf2>
80013fce:	8baa                	mv	s7,a0
80013fd0:	bf61                	j	80013f68 <.L93>

80013fd2 <.L240>:
80013fd2:	4499                	li	s1,6
80013fd4:	b775                	j	80013f80 <.L94>

80013fd6 <.L95>:
80013fd6:	855e                	mv	a0,s7
80013fd8:	b5cf90ef          	jal	8000d334 <__SEGGER_RTL_float32_isnan>
80013fdc:	c10d                	beqz	a0,80013ffe <.L101>
80013fde:	01291793          	sll	a5,s2,0x12
80013fe2:	0007d963          	bgez	a5,80013ff4 <.L243>
80013fe6:	80006437          	lui	s0,0x80006
80013fea:	af840413          	add	s0,s0,-1288 # 80005af8 <.LC5>

80013fee <.L122>:
80013fee:	eff97913          	and	s2,s2,-257
80013ff2:	b371                	j	80013d7e <.L65>

80013ff4 <.L243>:
80013ff4:	80006437          	lui	s0,0x80006
80013ff8:	afc40413          	add	s0,s0,-1284 # 80005afc <.LC6>
80013ffc:	bfcd                	j	80013fee <.L122>

80013ffe <.L101>:
80013ffe:	855e                	mv	a0,s7
80014000:	b54f90ef          	jal	8000d354 <__SEGGER_RTL_float32_isnormal>
80014004:	e119                	bnez	a0,8001400a <.L103>
80014006:	00000b93          	li	s7,0

8001400a <.L103>:
8001400a:	855e                	mv	a0,s7
8001400c:	845e                	mv	s0,s7
8001400e:	cccff0ef          	jal	800134da <__SEGGER_RTL_float32_signbit>
80014012:	c519                	beqz	a0,80014020 <.L104>
80014014:	80000437          	lui	s0,0x80000
80014018:	06096913          	or	s2,s2,96
8001401c:	01744433          	xor	s0,s0,s7

80014020 <.L104>:
80014020:	184c                	add	a1,sp,52
80014022:	8522                	mv	a0,s0
80014024:	cfeff0ef          	jal	80013522 <frexpf>
80014028:	5752                	lw	a4,52(sp)
8001402a:	478d                	li	a5,3
8001402c:	00000593          	li	a1,0
80014030:	02e787b3          	mul	a5,a5,a4
80014034:	4729                	li	a4,10
80014036:	8522                	mv	a0,s0
80014038:	8ba2                	mv	s7,s0
8001403a:	02e7c7b3          	div	a5,a5,a4
8001403e:	da3e                	sw	a5,52(sp)
80014040:	beaff0ef          	jal	8001342a <__eqsf2>
80014044:	24051a63          	bnez	a0,80014298 <.L105>

80014048 <.L111>:
80014048:	6785                	lui	a5,0x1
8001404a:	c0078793          	add	a5,a5,-1024 # c00 <__NOR_CFG_OPTION_segment_size__>
8001404e:	00f97c33          	and	s8,s2,a5
80014052:	40000713          	li	a4,1024
80014056:	5552                	lw	a0,52(sp)
80014058:	26ec1763          	bne	s8,a4,800142c6 <.L340>

8001405c <.L106>:
8001405c:	02600793          	li	a5,38
80014060:	32f51963          	bne	a0,a5,80014392 <.L113>
80014064:	800067b7          	lui	a5,0x80006
80014068:	cdc7a583          	lw	a1,-804(a5) # 80005cdc <.Lmerged_single+0x10>
8001406c:	855e                	mv	a0,s7
8001406e:	ab8ff0ef          	jal	80013326 <__divsf3>

80014072 <.L354>:
80014072:	00000593          	li	a1,0
80014076:	8baa                	mv	s7,a0
80014078:	842a                	mv	s0,a0
8001407a:	bb0ff0ef          	jal	8001342a <__eqsf2>
8001407e:	c52d                	beqz	a0,800140e8 <.L116>
80014080:	855e                	mv	a0,s7
80014082:	ac4f90ef          	jal	8000d346 <__SEGGER_RTL_float32_isinf>
80014086:	f00511e3          	bnez	a0,80013f88 <.L117>
8001408a:	57d2                	lw	a5,52(sp)
8001408c:	4701                	li	a4,0

8001408e <.L118>:
8001408e:	80006cb7          	lui	s9,0x80006
80014092:	c63e                	sw	a5,12(sp)
80014094:	00178d13          	add	s10,a5,1
80014098:	800067b7          	lui	a5,0x80006
8001409c:	cd47a583          	lw	a1,-812(a5) # 80005cd4 <.Lmerged_single+0x8>
800140a0:	855e                	mv	a0,s7
800140a2:	cc3a                	sw	a4,24(sp)
800140a4:	8a8f90ef          	jal	8000d14c <__gesf2>
800140a8:	47b2                	lw	a5,12(sp)
800140aa:	4762                	lw	a4,24(sp)
800140ac:	32055163          	bgez	a0,800143ce <.L124>
800140b0:	c319                	beqz	a4,800140b6 <.L125>
800140b2:	845e                	mv	s0,s7
800140b4:	da3e                	sw	a5,52(sp)

800140b6 <.L125>:
800140b6:	80006637          	lui	a2,0x80006
800140ba:	cd062703          	lw	a4,-816(a2) # 80005cd0 <.Lmerged_single+0x4>
800140be:	5d52                	lw	s10,52(sp)
800140c0:	cd4cac83          	lw	s9,-812(s9) # 80005cd4 <.Lmerged_single+0x8>
800140c4:	87a2                	mv	a5,s0
800140c6:	4681                	li	a3,0
800140c8:	c63a                	sw	a4,12(sp)

800140ca <.L126>:
800140ca:	45b2                	lw	a1,12(sp)
800140cc:	853e                	mv	a0,a5
800140ce:	ce36                	sw	a3,28(sp)
800140d0:	cc3e                	sw	a5,24(sp)
800140d2:	fd9f80ef          	jal	8000d0aa <__ltsf2>
800140d6:	47e2                	lw	a5,24(sp)
800140d8:	46f2                	lw	a3,28(sp)
800140da:	fffd0b93          	add	s7,s10,-1
800140de:	30054363          	bltz	a0,800143e4 <.L127>
800140e2:	c299                	beqz	a3,800140e8 <.L116>
800140e4:	843e                	mv	s0,a5
800140e6:	da6a                	sw	s10,52(sp)

800140e8 <.L116>:
800140e8:	c499                	beqz	s1,800140f6 <.L129>
800140ea:	6785                	lui	a5,0x1
800140ec:	c0078793          	add	a5,a5,-1024 # c00 <__NOR_CFG_OPTION_segment_size__>
800140f0:	00fc1363          	bne	s8,a5,800140f6 <.L129>
800140f4:	14fd                	add	s1,s1,-1

800140f6 <.L129>:
800140f6:	40900533          	neg	a0,s1
800140fa:	be9f90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
800140fe:	55fd                	li	a1,-1
80014100:	bdeff0ef          	jal	800134de <ldexpf>
80014104:	85a2                	mv	a1,s0
80014106:	df7f80ef          	jal	8000cefc <__addsf3>
8001410a:	80006cb7          	lui	s9,0x80006
8001410e:	cd4ca583          	lw	a1,-812(s9) # 80005cd4 <.Lmerged_single+0x8>
80014112:	8baa                	mv	s7,a0
80014114:	842a                	mv	s0,a0
80014116:	836f90ef          	jal	8000d14c <__gesf2>
8001411a:	00054b63          	bltz	a0,80014130 <.L130>
8001411e:	57d2                	lw	a5,52(sp)
80014120:	cd4ca583          	lw	a1,-812(s9)
80014124:	855e                	mv	a0,s7
80014126:	0785                	add	a5,a5,1
80014128:	da3e                	sw	a5,52(sp)
8001412a:	9fcff0ef          	jal	80013326 <__divsf3>
8001412e:	842a                	mv	s0,a0

80014130 <.L130>:
80014130:	c622                	sw	s0,12(sp)
80014132:	2c049163          	bnez	s1,800143f4 <.L132>

80014136 <.L135>:
80014136:	4481                	li	s1,0

80014138 <.L133>:
80014138:	00548793          	add	a5,s1,5
8001413c:	7c7d                	lui	s8,0xfffff
8001413e:	40fb0b33          	sub	s6,s6,a5
80014142:	08097793          	and	a5,s2,128
80014146:	7ffc0c13          	add	s8,s8,2047 # fffff7ff <__AHB_SRAM_segment_end__+0xfdf77ff>
8001414a:	8fc5                	or	a5,a5,s1
8001414c:	01897c33          	and	s8,s2,s8
80014150:	c391                	beqz	a5,80014154 <.L139>
80014152:	1b7d                	add	s6,s6,-1

80014154 <.L139>:
80014154:	01391793          	sll	a5,s2,0x13
80014158:	4d05                	li	s10,1
8001415a:	0207dc63          	bgez	a5,80014192 <.L140>
8001415e:	5bd2                	lw	s7,52(sp)
80014160:	470d                	li	a4,3
80014162:	02ebe733          	rem	a4,s7,a4
80014166:	c31d                	beqz	a4,8001418c <.L141>
80014168:	0709                	add	a4,a4,2
8001416a:	56b5                	li	a3,-19
8001416c:	40e6d733          	sra	a4,a3,a4
80014170:	8b05                	and	a4,a4,1
80014172:	2c070e63          	beqz	a4,8001444e <.L142>
80014176:	cd4ca583          	lw	a1,-812(s9)
8001417a:	4532                	lw	a0,12(sp)
8001417c:	1b7d                	add	s6,s6,-1
8001417e:	4d09                	li	s10,2
80014180:	8f6ff0ef          	jal	80013276 <__mulsf3>
80014184:	fffb8793          	add	a5,s7,-1
80014188:	842a                	mv	s0,a0
8001418a:	da3e                	sw	a5,52(sp)

8001418c <.L141>:
8001418c:	0004d363          	bgez	s1,80014192 <.L140>
80014190:	4481                	li	s1,0

80014192 <.L140>:
80014192:	06097913          	and	s2,s2,96
80014196:	00090363          	beqz	s2,8001419c <.L144>
8001419a:	1b7d                	add	s6,s6,-1

8001419c <.L144>:
8001419c:	5552                	lw	a0,52(sp)
8001419e:	ab5f90ef          	jal	8000dc52 <abs>
800141a2:	06300793          	li	a5,99
800141a6:	00a7d363          	bge	a5,a0,800141ac <.L145>
800141aa:	1b7d                	add	s6,s6,-1

800141ac <.L145>:
800141ac:	8522                	mv	a0,s0
800141ae:	aa8ff0ef          	jal	80013456 <__fixunssfdi>
800141b2:	8bae                	mv	s7,a1
800141b4:	8caa                	mv	s9,a0
800141b6:	fd5f80ef          	jal	8000d18a <__floatundisf>
800141ba:	85aa                	mv	a1,a0
800141bc:	8522                	mv	a0,s0
800141be:	d37f80ef          	jal	8000cef4 <__subsf3>
800141c2:	842a                	mv	s0,a0

800141c4 <.L146>:
800141c4:	895a                	mv	s2,s6
800141c6:	000b5363          	bgez	s6,800141cc <.L165>
800141ca:	4901                	li	s2,0

800141cc <.L165>:
800141cc:	210c7793          	and	a5,s8,528
800141d0:	e399                	bnez	a5,800141d6 <.L167>

800141d2 <.L166>:
800141d2:	30091b63          	bnez	s2,800144e8 <.L168>

800141d6 <.L167>:
800141d6:	020c7713          	and	a4,s8,32
800141da:	040c7793          	and	a5,s8,64
800141de:	30070c63          	beqz	a4,800144f6 <.L169>
800141e2:	02b00593          	li	a1,43
800141e6:	c399                	beqz	a5,800141ec <.L358>
800141e8:	02d00593          	li	a1,45

800141ec <.L358>:
800141ec:	854e                	mv	a0,s3
800141ee:	f9cff0ef          	jal	8001398a <__SEGGER_RTL_putc>

800141f2 <.L171>:
800141f2:	010c7793          	and	a5,s8,16
800141f6:	e399                	bnez	a5,800141fc <.L173>

800141f8 <.L172>:
800141f8:	30091463          	bnez	s2,80014500 <.L174>

800141fc <.L173>:
800141fc:	80003b37          	lui	s6,0x80003
80014200:	068b0b13          	add	s6,s6,104 # 80003068 <__SEGGER_RTL_ipow10>

80014204 <.L178>:
80014204:	1d7d                	add	s10,s10,-1
80014206:	003d1793          	sll	a5,s10,0x3
8001420a:	97da                	add	a5,a5,s6
8001420c:	4398                	lw	a4,0(a5)
8001420e:	43dc                	lw	a5,4(a5)
80014210:	03000593          	li	a1,48

80014214 <.L175>:
80014214:	00fbe663          	bltu	s7,a5,80014220 <.L258>
80014218:	2f779b63          	bne	a5,s7,8001450e <.L176>
8001421c:	2eecf963          	bgeu	s9,a4,8001450e <.L176>

80014220 <.L258>:
80014220:	854e                	mv	a0,s3
80014222:	f68ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
80014226:	fc0d1fe3          	bnez	s10,80014204 <.L178>
8001422a:	6b85                	lui	s7,0x1
8001422c:	800b8b93          	add	s7,s7,-2048 # 800 <.L13+0x26>
80014230:	017c7bb3          	and	s7,s8,s7
80014234:	300b9163          	bnez	s7,80014536 <.L179>

80014238 <.L183>:
80014238:	080c7793          	and	a5,s8,128
8001423c:	8fc5                	or	a5,a5,s1
8001423e:	c3a1                	beqz	a5,8001427e <.L181>
80014240:	02e00593          	li	a1,46
80014244:	854e                	mv	a0,s3
80014246:	f44ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
8001424a:	47c1                	li	a5,16
8001424c:	8ca6                	mv	s9,s1
8001424e:	2e97d863          	bge	a5,s1,8001453e <.L186>
80014252:	4cc1                	li	s9,16

80014254 <.L187>:
80014254:	419484b3          	sub	s1,s1,s9
80014258:	8566                	mv	a0,s9
8001425a:	000b8563          	beqz	s7,80014264 <.L359>
8001425e:	5552                	lw	a0,52(sp)
80014260:	40ac8533          	sub	a0,s9,a0

80014264 <.L359>:
80014264:	a7ff90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
80014268:	85a2                	mv	a1,s0
8001426a:	80cff0ef          	jal	80013276 <__mulsf3>
8001426e:	9e8ff0ef          	jal	80013456 <__fixunssfdi>
80014272:	8baa                	mv	s7,a0
80014274:	842e                	mv	s0,a1

80014276 <.L193>:
80014276:	2c0c9863          	bnez	s9,80014546 <.L194>

8001427a <.L195>:
8001427a:	30049363          	bnez	s1,80014580 <.L196>

8001427e <.L181>:
8001427e:	400c7793          	and	a5,s8,1024
80014282:	30079663          	bnez	a5,8001458e <.L184>

80014286 <.L201>:
80014286:	a0090ce3          	beqz	s2,80013c9e <.L4>
8001428a:	197d                	add	s2,s2,-1
8001428c:	02000593          	li	a1,32
80014290:	a6b5                	j	800145fc <.L360>

80014292 <.L108>:
80014292:	57d2                	lw	a5,52(sp)
80014294:	0785                	add	a5,a5,1
80014296:	da3e                	sw	a5,52(sp)

80014298 <.L105>:
80014298:	5552                	lw	a0,52(sp)
8001429a:	0505                	add	a0,a0,1 # 1001 <.L76+0x3b>
8001429c:	a47f90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
800142a0:	85aa                	mv	a1,a0
800142a2:	855e                	mv	a0,s7
800142a4:	e77f80ef          	jal	8000d11a <__gtsf2>
800142a8:	fea045e3          	bgtz	a0,80014292 <.L108>

800142ac <.L109>:
800142ac:	5552                	lw	a0,52(sp)
800142ae:	a35f90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
800142b2:	85aa                	mv	a1,a0
800142b4:	855e                	mv	a0,s7
800142b6:	df5f80ef          	jal	8000d0aa <__ltsf2>
800142ba:	d80557e3          	bgez	a0,80014048 <.L111>
800142be:	57d2                	lw	a5,52(sp)
800142c0:	17fd                	add	a5,a5,-1
800142c2:	da3e                	sw	a5,52(sp)
800142c4:	b7e5                	j	800142ac <.L109>

800142c6 <.L340>:
800142c6:	00fc1763          	bne	s8,a5,800142d4 <.L112>
800142ca:	d89559e3          	bge	a0,s1,8001405c <.L106>
800142ce:	57f1                	li	a5,-4
800142d0:	0cf54163          	blt	a0,a5,80014392 <.L113>

800142d4 <.L112>:
800142d4:	08097793          	and	a5,s2,128
800142d8:	c63e                	sw	a5,12(sp)
800142da:	40097793          	and	a5,s2,1024
800142de:	c789                	beqz	a5,800142e8 <.L147>
800142e0:	47b9                	li	a5,14
800142e2:	18a7d463          	bge	a5,a0,8001446a <.L148>

800142e6 <.L153>:
800142e6:	4481                	li	s1,0

800142e8 <.L147>:
800142e8:	57d2                	lw	a5,52(sp)
800142ea:	40900533          	neg	a0,s1
800142ee:	bff97c13          	and	s8,s2,-1025
800142f2:	ff178713          	add	a4,a5,-15
800142f6:	00e55463          	bge	a0,a4,800142fe <.L154>
800142fa:	ff078513          	add	a0,a5,-16

800142fe <.L154>:
800142fe:	9e5f90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
80014302:	55fd                	li	a1,-1
80014304:	9daff0ef          	jal	800134de <ldexpf>
80014308:	85aa                	mv	a1,a0
8001430a:	855e                	mv	a0,s7
8001430c:	bf1f80ef          	jal	8000cefc <__addsf3>
80014310:	8d2a                	mv	s10,a0
80014312:	842a                	mv	s0,a0
80014314:	5552                	lw	a0,52(sp)
80014316:	0505                	add	a0,a0,1
80014318:	9cbf90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
8001431c:	85ea                	mv	a1,s10
8001431e:	dc7f80ef          	jal	8000d0e4 <__lesf2>
80014322:	00a04563          	bgtz	a0,8001432c <.L156>
80014326:	57d2                	lw	a5,52(sp)
80014328:	0785                	add	a5,a5,1
8001432a:	da3e                	sw	a5,52(sp)

8001432c <.L156>:
8001432c:	57d2                	lw	a5,52(sp)
8001432e:	1a07c763          	bltz	a5,800144dc <.L158>
80014332:	4541                	li	a0,16
80014334:	18f55663          	bge	a0,a5,800144c0 <.L159>
80014338:	ff078713          	add	a4,a5,-16
8001433c:	8d1d                	sub	a0,a0,a5
8001433e:	da3a                	sw	a4,52(sp)
80014340:	9a3f90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
80014344:	85ea                	mv	a1,s10
80014346:	f31fe0ef          	jal	80013276 <__mulsf3>
8001434a:	90cff0ef          	jal	80013456 <__fixunssfdi>
8001434e:	8caa                	mv	s9,a0
80014350:	8bae                	mv	s7,a1
80014352:	00000413          	li	s0,0

80014356 <.L160>:
80014356:	800037b7          	lui	a5,0x80003
8001435a:	06878793          	add	a5,a5,104 # 80003068 <__SEGGER_RTL_ipow10>
8001435e:	4d05                	li	s10,1

80014360 <.L161>:
80014360:	47d8                	lw	a4,12(a5)
80014362:	07a1                	add	a5,a5,8
80014364:	00ebe763          	bltu	s7,a4,80014372 <.L257>
80014368:	17771e63          	bne	a4,s7,800144e4 <.L162>
8001436c:	4398                	lw	a4,0(a5)
8001436e:	16ecfb63          	bgeu	s9,a4,800144e4 <.L162>

80014372 <.L257>:
80014372:	5752                	lw	a4,52(sp)
80014374:	009d07b3          	add	a5,s10,s1
80014378:	97ba                	add	a5,a5,a4
8001437a:	40fb0b33          	sub	s6,s6,a5
8001437e:	47b2                	lw	a5,12(sp)
80014380:	8fc5                	or	a5,a5,s1
80014382:	c391                	beqz	a5,80014386 <.L164>
80014384:	1b7d                	add	s6,s6,-1

80014386 <.L164>:
80014386:	06097793          	and	a5,s2,96
8001438a:	e2078de3          	beqz	a5,800141c4 <.L146>
8001438e:	1b7d                	add	s6,s6,-1
80014390:	bd15                	j	800141c4 <.L146>

80014392 <.L113>:
80014392:	40a00533          	neg	a0,a0
80014396:	94df90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
8001439a:	85aa                	mv	a1,a0
8001439c:	855e                	mv	a0,s7
8001439e:	ed9fe0ef          	jal	80013276 <__mulsf3>
800143a2:	b9c1                	j	80014072 <.L354>

800143a4 <.L244>:
800143a4:	80006437          	lui	s0,0x80006
800143a8:	ae040413          	add	s0,s0,-1312 # 80005ae0 <.LC2>
800143ac:	b189                	j	80013fee <.L122>

800143ae <.L341>:
800143ae:	c819                	beqz	s0,800143c4 <.L245>
800143b0:	80006437          	lui	s0,0x80006
800143b4:	ae840413          	add	s0,s0,-1304 # 80005ae8 <.LC3>

800143b8 <.L123>:
800143b8:	02097793          	and	a5,s2,32
800143bc:	c20799e3          	bnez	a5,80013fee <.L122>
800143c0:	0405                	add	s0,s0,1
800143c2:	b135                	j	80013fee <.L122>

800143c4 <.L245>:
800143c4:	80006437          	lui	s0,0x80006
800143c8:	af040413          	add	s0,s0,-1296 # 80005af0 <.LC4>
800143cc:	b7f5                	j	800143b8 <.L123>

800143ce <.L124>:
800143ce:	800067b7          	lui	a5,0x80006
800143d2:	cd47a583          	lw	a1,-812(a5) # 80005cd4 <.Lmerged_single+0x8>
800143d6:	855e                	mv	a0,s7
800143d8:	f4ffe0ef          	jal	80013326 <__divsf3>
800143dc:	8baa                	mv	s7,a0
800143de:	87ea                	mv	a5,s10
800143e0:	4705                	li	a4,1
800143e2:	b175                	j	8001408e <.L118>

800143e4 <.L127>:
800143e4:	853e                	mv	a0,a5
800143e6:	85e6                	mv	a1,s9
800143e8:	e8ffe0ef          	jal	80013276 <__mulsf3>
800143ec:	87aa                	mv	a5,a0
800143ee:	8d5e                	mv	s10,s7
800143f0:	4685                	li	a3,1
800143f2:	b9e1                	j	800140ca <.L126>

800143f4 <.L132>:
800143f4:	6785                	lui	a5,0x1
800143f6:	88078793          	add	a5,a5,-1920 # 880 <e2p_format+0x1c>
800143fa:	00f977b3          	and	a5,s2,a5
800143fe:	80078793          	add	a5,a5,-2048
80014402:	d2079be3          	bnez	a5,80014138 <.L133>
80014406:	47c1                	li	a5,16
80014408:	0097d363          	bge	a5,s1,8001440e <.L134>
8001440c:	44c1                	li	s1,16

8001440e <.L134>:
8001440e:	8526                	mv	a0,s1
80014410:	8d3f90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
80014414:	85a2                	mv	a1,s0
80014416:	e61fe0ef          	jal	80013276 <__mulsf3>
8001441a:	83cff0ef          	jal	80013456 <__fixunssfdi>
8001441e:	00a5e7b3          	or	a5,a1,a0
80014422:	8c2a                	mv	s8,a0
80014424:	8d2e                	mv	s10,a1
80014426:	d00788e3          	beqz	a5,80014136 <.L135>

8001442a <.L357>:
8001442a:	4629                	li	a2,10
8001442c:	4681                	li	a3,0
8001442e:	be8f90ef          	jal	8000d816 <__umoddi3>
80014432:	8d4d                	or	a0,a0,a1
80014434:	d00512e3          	bnez	a0,80014138 <.L133>
80014438:	8562                	mv	a0,s8
8001443a:	85ea                	mv	a1,s10
8001443c:	4629                	li	a2,10
8001443e:	4681                	li	a3,0
80014440:	fb7f80ef          	jal	8000d3f6 <__udivdi3>
80014444:	14fd                	add	s1,s1,-1
80014446:	8c2a                	mv	s8,a0
80014448:	8d2e                	mv	s10,a1
8001444a:	f0e5                	bnez	s1,8001442a <.L357>
8001444c:	b1ed                	j	80014136 <.L135>

8001444e <.L142>:
8001444e:	80006737          	lui	a4,0x80006
80014452:	cd872583          	lw	a1,-808(a4) # 80005cd8 <.Lmerged_single+0xc>
80014456:	4532                	lw	a0,12(sp)
80014458:	1b79                	add	s6,s6,-2
8001445a:	4d0d                	li	s10,3
8001445c:	e1bfe0ef          	jal	80013276 <__mulsf3>
80014460:	ffeb8793          	add	a5,s7,-2
80014464:	842a                	mv	s0,a0
80014466:	da3e                	sw	a5,52(sp)
80014468:	b315                	j	8001418c <.L141>

8001446a <.L148>:
8001446a:	0505                	add	a0,a0,1
8001446c:	8c89                	sub	s1,s1,a0
8001446e:	47c1                	li	a5,16
80014470:	0097d363          	bge	a5,s1,80014476 <.L149>
80014474:	44c1                	li	s1,16

80014476 <.L149>:
80014476:	08097793          	and	a5,s2,128
8001447a:	e60797e3          	bnez	a5,800142e8 <.L147>
8001447e:	800067b7          	lui	a5,0x80006
80014482:	ccc7ac03          	lw	s8,-820(a5) # 80005ccc <.Lmerged_single>
80014486:	800067b7          	lui	a5,0x80006
8001448a:	cd47a403          	lw	s0,-812(a5) # 80005cd4 <.Lmerged_single+0x8>

8001448e <.L150>:
8001448e:	e4048ce3          	beqz	s1,800142e6 <.L153>
80014492:	8526                	mv	a0,s1
80014494:	84ff90ef          	jal	8000dce2 <__SEGGER_RTL_pow10f>
80014498:	85aa                	mv	a1,a0
8001449a:	855e                	mv	a0,s7
8001449c:	ddbfe0ef          	jal	80013276 <__mulsf3>
800144a0:	85e2                	mv	a1,s8
800144a2:	a5bf80ef          	jal	8000cefc <__addsf3>
800144a6:	ec1f80ef          	jal	8000d366 <floorf>
800144aa:	85a2                	mv	a1,s0
800144ac:	8a2ff0ef          	jal	8001354e <fmodf>
800144b0:	00000593          	li	a1,0
800144b4:	f77fe0ef          	jal	8001342a <__eqsf2>
800144b8:	e20518e3          	bnez	a0,800142e8 <.L147>
800144bc:	14fd                	add	s1,s1,-1
800144be:	bfc1                	j	8001448e <.L150>

800144c0 <.L159>:
800144c0:	856a                	mv	a0,s10
800144c2:	da02                	sw	zero,52(sp)
800144c4:	f93fe0ef          	jal	80013456 <__fixunssfdi>
800144c8:	8bae                	mv	s7,a1
800144ca:	8caa                	mv	s9,a0
800144cc:	cbff80ef          	jal	8000d18a <__floatundisf>
800144d0:	85aa                	mv	a1,a0
800144d2:	856a                	mv	a0,s10
800144d4:	a21f80ef          	jal	8000cef4 <__subsf3>
800144d8:	842a                	mv	s0,a0
800144da:	bdb5                	j	80014356 <.L160>

800144dc <.L158>:
800144dc:	da02                	sw	zero,52(sp)
800144de:	4c81                	li	s9,0
800144e0:	4b81                	li	s7,0
800144e2:	bd95                	j	80014356 <.L160>

800144e4 <.L162>:
800144e4:	0d05                	add	s10,s10,1
800144e6:	bdad                	j	80014360 <.L161>

800144e8 <.L168>:
800144e8:	02000593          	li	a1,32
800144ec:	854e                	mv	a0,s3
800144ee:	197d                	add	s2,s2,-1
800144f0:	c9aff0ef          	jal	8001398a <__SEGGER_RTL_putc>
800144f4:	b9f9                	j	800141d2 <.L166>

800144f6 <.L169>:
800144f6:	ce078ee3          	beqz	a5,800141f2 <.L171>
800144fa:	02000593          	li	a1,32
800144fe:	b1fd                	j	800141ec <.L358>

80014500 <.L174>:
80014500:	03000593          	li	a1,48
80014504:	854e                	mv	a0,s3
80014506:	197d                	add	s2,s2,-1
80014508:	c82ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
8001450c:	b1f5                	j	800141f8 <.L172>

8001450e <.L176>:
8001450e:	40ec86b3          	sub	a3,s9,a4
80014512:	00dcb633          	sltu	a2,s9,a3
80014516:	0585                	add	a1,a1,1
80014518:	40fb8bb3          	sub	s7,s7,a5
8001451c:	0ff5f593          	zext.b	a1,a1
80014520:	8cb6                	mv	s9,a3
80014522:	40cb8bb3          	sub	s7,s7,a2
80014526:	b1fd                	j	80014214 <.L175>

80014528 <.L182>:
80014528:	17fd                	add	a5,a5,-1
8001452a:	03000593          	li	a1,48
8001452e:	854e                	mv	a0,s3
80014530:	da3e                	sw	a5,52(sp)
80014532:	c58ff0ef          	jal	8001398a <__SEGGER_RTL_putc>

80014536 <.L179>:
80014536:	57d2                	lw	a5,52(sp)
80014538:	fef048e3          	bgtz	a5,80014528 <.L182>
8001453c:	b9f5                	j	80014238 <.L183>

8001453e <.L186>:
8001453e:	d004dbe3          	bgez	s1,80014254 <.L187>
80014542:	4c81                	li	s9,0
80014544:	bb01                	j	80014254 <.L187>

80014546 <.L194>:
80014546:	1cfd                	add	s9,s9,-1
80014548:	003c9793          	sll	a5,s9,0x3
8001454c:	97da                	add	a5,a5,s6
8001454e:	4398                	lw	a4,0(a5)
80014550:	43dc                	lw	a5,4(a5)
80014552:	03000593          	li	a1,48

80014556 <.L190>:
80014556:	00f46663          	bltu	s0,a5,80014562 <.L259>
8001455a:	00879863          	bne	a5,s0,8001456a <.L191>
8001455e:	00ebf663          	bgeu	s7,a4,8001456a <.L191>

80014562 <.L259>:
80014562:	854e                	mv	a0,s3
80014564:	c26ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
80014568:	b339                	j	80014276 <.L193>

8001456a <.L191>:
8001456a:	40eb86b3          	sub	a3,s7,a4
8001456e:	00dbb633          	sltu	a2,s7,a3
80014572:	0585                	add	a1,a1,1
80014574:	8c1d                	sub	s0,s0,a5
80014576:	0ff5f593          	zext.b	a1,a1
8001457a:	8bb6                	mv	s7,a3
8001457c:	8c11                	sub	s0,s0,a2
8001457e:	bfe1                	j	80014556 <.L190>

80014580 <.L196>:
80014580:	03000593          	li	a1,48
80014584:	854e                	mv	a0,s3
80014586:	14fd                	add	s1,s1,-1
80014588:	c02ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
8001458c:	b1fd                	j	8001427a <.L195>

8001458e <.L184>:
8001458e:	012c1793          	sll	a5,s8,0x12
80014592:	06500593          	li	a1,101
80014596:	0007d463          	bgez	a5,8001459e <.L197>
8001459a:	04500593          	li	a1,69

8001459e <.L197>:
8001459e:	854e                	mv	a0,s3
800145a0:	beaff0ef          	jal	8001398a <__SEGGER_RTL_putc>
800145a4:	57d2                	lw	a5,52(sp)
800145a6:	0407df63          	bgez	a5,80014604 <.L198>
800145aa:	02d00593          	li	a1,45
800145ae:	854e                	mv	a0,s3
800145b0:	bdaff0ef          	jal	8001398a <__SEGGER_RTL_putc>
800145b4:	57d2                	lw	a5,52(sp)
800145b6:	40f007b3          	neg	a5,a5
800145ba:	da3e                	sw	a5,52(sp)

800145bc <.L199>:
800145bc:	55d2                	lw	a1,52(sp)
800145be:	06300793          	li	a5,99
800145c2:	00b7df63          	bge	a5,a1,800145e0 <.L200>
800145c6:	06400413          	li	s0,100
800145ca:	0285c5b3          	div	a1,a1,s0
800145ce:	854e                	mv	a0,s3
800145d0:	03058593          	add	a1,a1,48
800145d4:	bb6ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
800145d8:	57d2                	lw	a5,52(sp)
800145da:	0287e7b3          	rem	a5,a5,s0
800145de:	da3e                	sw	a5,52(sp)

800145e0 <.L200>:
800145e0:	55d2                	lw	a1,52(sp)
800145e2:	4429                	li	s0,10
800145e4:	854e                	mv	a0,s3
800145e6:	0285c5b3          	div	a1,a1,s0
800145ea:	03058593          	add	a1,a1,48
800145ee:	b9cff0ef          	jal	8001398a <__SEGGER_RTL_putc>
800145f2:	55d2                	lw	a1,52(sp)
800145f4:	0285e5b3          	rem	a1,a1,s0
800145f8:	03058593          	add	a1,a1,48

800145fc <.L360>:
800145fc:	854e                	mv	a0,s3
800145fe:	b8cff0ef          	jal	8001398a <__SEGGER_RTL_putc>
80014602:	b151                	j	80014286 <.L201>

80014604 <.L198>:
80014604:	02b00593          	li	a1,43
80014608:	854e                	mv	a0,s3
8001460a:	b80ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
8001460e:	b77d                	j	800145bc <.L199>

80014610 <.L205>:
80014610:	6d21                	lui	s10,0x8
80014612:	892e                	mv	s2,a1
80014614:	4c01                	li	s8,0
80014616:	01abfd33          	and	s10,s7,s10
8001461a:	470d                	li	a4,3
8001461c:	02c00813          	li	a6,44

80014620 <.L208>:
80014620:	012467b3          	or	a5,s0,s2
80014624:	cbb5                	beqz	a5,80014698 <.L206>
80014626:	000d0d63          	beqz	s10,80014640 <.L214>
8001462a:	003c7793          	and	a5,s8,3
8001462e:	00e79963          	bne	a5,a4,80014640 <.L214>
80014632:	030c0793          	add	a5,s8,48
80014636:	1018                	add	a4,sp,32
80014638:	97ba                	add	a5,a5,a4
8001463a:	ff078423          	sb	a6,-24(a5)
8001463e:	0c05                	add	s8,s8,1

80014640 <.L214>:
80014640:	1018                	add	a4,sp,32
80014642:	030c0793          	add	a5,s8,48
80014646:	97ba                	add	a5,a5,a4
80014648:	4629                	li	a2,10
8001464a:	4681                	li	a3,0
8001464c:	8522                	mv	a0,s0
8001464e:	85ca                	mv	a1,s2
80014650:	c63e                	sw	a5,12(sp)
80014652:	9c4f90ef          	jal	8000d816 <__umoddi3>
80014656:	47b2                	lw	a5,12(sp)
80014658:	03050513          	add	a0,a0,48
8001465c:	85ca                	mv	a1,s2
8001465e:	fea78423          	sb	a0,-24(a5)
80014662:	4629                	li	a2,10
80014664:	8522                	mv	a0,s0
80014666:	4681                	li	a3,0
80014668:	d8ff80ef          	jal	8000d3f6 <__udivdi3>
8001466c:	0c05                	add	s8,s8,1
8001466e:	842a                	mv	s0,a0
80014670:	892e                	mv	s2,a1
80014672:	02c00813          	li	a6,44
80014676:	470d                	li	a4,3
80014678:	b765                	j	80014620 <.L208>

8001467a <.L204>:
8001467a:	6709                	lui	a4,0x2
8001467c:	800066b7          	lui	a3,0x80006
80014680:	80006637          	lui	a2,0x80006
80014684:	4c01                	li	s8,0
80014686:	00ebf733          	and	a4,s7,a4
8001468a:	ab068693          	add	a3,a3,-1360 # 80005ab0 <__SEGGER_RTL_hex_lc>
8001468e:	ac060613          	add	a2,a2,-1344 # 80005ac0 <__SEGGER_RTL_hex_uc>

80014692 <.L209>:
80014692:	00b467b3          	or	a5,s0,a1
80014696:	e38d                	bnez	a5,800146b8 <.L212>

80014698 <.L206>:
80014698:	418484b3          	sub	s1,s1,s8
8001469c:	0004d363          	bgez	s1,800146a2 <.L216>
800146a0:	4481                	li	s1,0

800146a2 <.L216>:
800146a2:	409b0b33          	sub	s6,s6,s1
800146a6:	0ff00793          	li	a5,255
800146aa:	418b0b33          	sub	s6,s6,s8
800146ae:	0397f863          	bgeu	a5,s9,800146de <.L217>
800146b2:	1b7d                	add	s6,s6,-1

800146b4 <.L218>:
800146b4:	1b7d                	add	s6,s6,-1
800146b6:	a035                	j	800146e2 <.L219>

800146b8 <.L212>:
800146b8:	00f47793          	and	a5,s0,15
800146bc:	cf19                	beqz	a4,800146da <.L210>
800146be:	97b2                	add	a5,a5,a2

800146c0 <.L361>:
800146c0:	0007c783          	lbu	a5,0(a5)
800146c4:	1828                	add	a0,sp,56
800146c6:	9562                	add	a0,a0,s8
800146c8:	00f50023          	sb	a5,0(a0)
800146cc:	8011                	srl	s0,s0,0x4
800146ce:	01c59793          	sll	a5,a1,0x1c
800146d2:	0c05                	add	s8,s8,1
800146d4:	8c5d                	or	s0,s0,a5
800146d6:	8191                	srl	a1,a1,0x4
800146d8:	bf6d                	j	80014692 <.L209>

800146da <.L210>:
800146da:	97b6                	add	a5,a5,a3
800146dc:	b7d5                	j	800146c0 <.L361>

800146de <.L217>:
800146de:	fc0c9be3          	bnez	s9,800146b4 <.L218>

800146e2 <.L219>:
800146e2:	200bf793          	and	a5,s7,512
800146e6:	e799                	bnez	a5,800146f4 <.L220>
800146e8:	865a                	mv	a2,s6
800146ea:	85de                	mv	a1,s7
800146ec:	854e                	mv	a0,s3
800146ee:	e70f90ef          	jal	8000dd5e <__SEGGER_RTL_pre_padding>
800146f2:	4b01                	li	s6,0

800146f4 <.L220>:
800146f4:	0ff00793          	li	a5,255
800146f8:	0197fc63          	bgeu	a5,s9,80014710 <.L221>
800146fc:	03000593          	li	a1,48
80014700:	854e                	mv	a0,s3
80014702:	a88ff0ef          	jal	8001398a <__SEGGER_RTL_putc>

80014706 <.L222>:
80014706:	85e6                	mv	a1,s9
80014708:	854e                	mv	a0,s3
8001470a:	a80ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
8001470e:	a019                	j	80014714 <.L223>

80014710 <.L221>:
80014710:	fe0c9be3          	bnez	s9,80014706 <.L222>

80014714 <.L223>:
80014714:	865a                	mv	a2,s6
80014716:	85de                	mv	a1,s7
80014718:	854e                	mv	a0,s3
8001471a:	e44f90ef          	jal	8000dd5e <__SEGGER_RTL_pre_padding>
8001471e:	8626                	mv	a2,s1
80014720:	03000593          	li	a1,48
80014724:	854e                	mv	a0,s3
80014726:	b00ff0ef          	jal	80013a26 <__SEGGER_RTL_print_padding>

8001472a <.L224>:
8001472a:	1c7d                	add	s8,s8,-1
8001472c:	e00c4863          	bltz	s8,80013d3c <.L371>
80014730:	183c                	add	a5,sp,56
80014732:	97e2                	add	a5,a5,s8
80014734:	0007c583          	lbu	a1,0(a5)
80014738:	854e                	mv	a0,s3
8001473a:	a50ff0ef          	jal	8001398a <__SEGGER_RTL_putc>
8001473e:	b7f5                	j	8001472a <.L224>

80014740 <.L34>:
80014740:	07800713          	li	a4,120
80014744:	d4f76d63          	bltu	a4,a5,80013c9e <.L4>

80014748 <.L38>:
80014748:	fa878713          	add	a4,a5,-88
8001474c:	0ff77713          	zext.b	a4,a4
80014750:	02000693          	li	a3,32
80014754:	d4e6e563          	bltu	a3,a4,80013c9e <.L4>
80014758:	46d2                	lw	a3,20(sp)
8001475a:	070a                	sll	a4,a4,0x2
8001475c:	9736                	add	a4,a4,a3
8001475e:	4318                	lw	a4,0(a4)
80014760:	8702                	jr	a4

Disassembly of section .text.libc.__SEGGER_RTL_alloc:

80014762 <__SEGGER_RTL_alloc>:
80014762:	1441a703          	lw	a4,324(gp) # 12094bc <__SEGGER_RTL_heap_globals>
80014766:	00f50793          	add	a5,a0,15
8001476a:	9be1                	and	a5,a5,-8
8001476c:	56fd                	li	a3,-1
8001476e:	4501                	li	a0,0
80014770:	4581                	li	a1,0

80014772 <.L2>:
80014772:	eb11                	bnez	a4,80014786 <.L8>
80014774:	c901                	beqz	a0,80014784 <.L1>
80014776:	4158                	lw	a4,4(a0)
80014778:	8e9d                	sub	a3,a3,a5
8001477a:	8f1d                	sub	a4,a4,a5
8001477c:	c158                	sw	a4,4(a0)
8001477e:	9536                	add	a0,a0,a3
80014780:	c11c                	sw	a5,0(a0)
80014782:	0521                	add	a0,a0,8

80014784 <.L1>:
80014784:	8082                	ret

80014786 <.L8>:
80014786:	4350                	lw	a2,4(a4)
80014788:	00072803          	lw	a6,0(a4) # 2000 <__BOOT_HEADER_segment_size__>
8001478c:	00f61c63          	bne	a2,a5,800147a4 <.L3>
80014790:	c599                	beqz	a1,8001479e <.L4>
80014792:	0105a023          	sw	a6,0(a1)

80014796 <.L5>:
80014796:	c31c                	sw	a5,0(a4)
80014798:	00870513          	add	a0,a4,8
8001479c:	8082                	ret

8001479e <.L4>:
8001479e:	1501a223          	sw	a6,324(gp) # 12094bc <__SEGGER_RTL_heap_globals>
800147a2:	bfd5                	j	80014796 <.L5>

800147a4 <.L3>:
800147a4:	00c7f663          	bgeu	a5,a2,800147b0 <.L7>
800147a8:	00d67463          	bgeu	a2,a3,800147b0 <.L7>
800147ac:	86b2                	mv	a3,a2
800147ae:	853a                	mv	a0,a4

800147b0 <.L7>:
800147b0:	85ba                	mv	a1,a4
800147b2:	8742                	mv	a4,a6
800147b4:	bf7d                	j	80014772 <.L2>

Disassembly of section .text.libc.__SEGGER_RTL_free:

800147b6 <__SEGGER_RTL_free>:
800147b6:	c939                	beqz	a0,8001480c <.L29>
800147b8:	ff852783          	lw	a5,-8(a0)
800147bc:	0017f713          	and	a4,a5,1
800147c0:	c701                	beqz	a4,800147c8 <.L32>
800147c2:	ffe7f513          	and	a0,a5,-2
800147c6:	c139                	beqz	a0,8001480c <.L29>

800147c8 <.L32>:
800147c8:	1441a783          	lw	a5,324(gp) # 12094bc <__SEGGER_RTL_heap_globals>
800147cc:	ff852603          	lw	a2,-8(a0)
800147d0:	ff850693          	add	a3,a0,-8
800147d4:	cf8d                	beqz	a5,8001480e <.L34>
800147d6:	4701                	li	a4,0
800147d8:	00d7f763          	bgeu	a5,a3,800147e6 <.L36>

800147dc <.L35>:
800147dc:	873e                	mv	a4,a5
800147de:	439c                	lw	a5,0(a5)
800147e0:	c399                	beqz	a5,800147e6 <.L36>
800147e2:	fed7ede3          	bltu	a5,a3,800147dc <.L35>

800147e6 <.L36>:
800147e6:	fef52c23          	sw	a5,-8(a0)
800147ea:	fec52e23          	sw	a2,-4(a0)
800147ee:	c721                	beqz	a4,80014836 <.L37>
800147f0:	c314                	sw	a3,0(a4)
800147f2:	e78d                	bnez	a5,8001481c <.L38>

800147f4 <.L42>:
800147f4:	4350                	lw	a2,4(a4)
800147f6:	00c707b3          	add	a5,a4,a2
800147fa:	00f69963          	bne	a3,a5,8001480c <.L29>
800147fe:	ffc52783          	lw	a5,-4(a0)
80014802:	97b2                	add	a5,a5,a2
80014804:	c35c                	sw	a5,4(a4)
80014806:	ff852783          	lw	a5,-8(a0)
8001480a:	c31c                	sw	a5,0(a4)

8001480c <.L29>:
8001480c:	8082                	ret

8001480e <.L34>:
8001480e:	14d1a223          	sw	a3,324(gp) # 12094bc <__SEGGER_RTL_heap_globals>
80014812:	fe052c23          	sw	zero,-8(a0)
80014816:	fec52e23          	sw	a2,-4(a0)
8001481a:	8082                	ret

8001481c <.L38>:
8001481c:	00c685b3          	add	a1,a3,a2
80014820:	00b79963          	bne	a5,a1,80014832 <.L41>
80014824:	43cc                	lw	a1,4(a5)
80014826:	439c                	lw	a5,0(a5)
80014828:	962e                	add	a2,a2,a1
8001482a:	fec52e23          	sw	a2,-4(a0)
8001482e:	fef52c23          	sw	a5,-8(a0)

80014832 <.L41>:
80014832:	f369                	bnez	a4,800147f4 <.L42>
80014834:	8082                	ret

80014836 <.L37>:
80014836:	14d1a223          	sw	a3,324(gp) # 12094bc <__SEGGER_RTL_heap_globals>
8001483a:	f3ed                	bnez	a5,8001481c <.L38>
8001483c:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_X_heap_lock:

8001483e <__SEGGER_RTL_X_heap_lock>:
8001483e:	300027f3          	csrr	a5,mstatus
80014842:	ff77f713          	and	a4,a5,-9
80014846:	30071073          	csrw	mstatus,a4
8001484a:	8ba1                	and	a5,a5,8
8001484c:	12f1ae23          	sw	a5,316(gp) # 12094b4 <en>
80014850:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_X_heap_unlock:

80014852 <__SEGGER_RTL_X_heap_unlock>:
80014852:	13c1a783          	lw	a5,316(gp) # 12094b4 <en>
80014856:	c799                	beqz	a5,80014864 <.L2>
80014858:	300027f3          	csrr	a5,mstatus
8001485c:	0087e713          	or	a4,a5,8
80014860:	30071073          	csrw	mstatus,a4

80014864 <.L2>:
80014864:	8082                	ret

Disassembly of section .text.libc.free:

80014866 <free>:
80014866:	1101                	add	sp,sp,-32
80014868:	ce06                	sw	ra,28(sp)
8001486a:	c62a                	sw	a0,12(sp)
8001486c:	3fc9                	jal	8001483e <__SEGGER_RTL_X_heap_lock>
8001486e:	4532                	lw	a0,12(sp)
80014870:	3799                	jal	800147b6 <__SEGGER_RTL_free>
80014872:	40f2                	lw	ra,28(sp)
80014874:	6105                	add	sp,sp,32
80014876:	bff1                	j	80014852 <__SEGGER_RTL_X_heap_unlock>

Disassembly of section .text.libc.__SEGGER_RTL_ascii_isctype:

80014878 <__SEGGER_RTL_ascii_isctype>:
80014878:	07f00793          	li	a5,127
8001487c:	02a7e263          	bltu	a5,a0,800148a0 <.L3>
80014880:	800067b7          	lui	a5,0x80006
80014884:	c4c78793          	add	a5,a5,-948 # 80005c4c <__SEGGER_RTL_ascii_ctype_map>
80014888:	953e                	add	a0,a0,a5
8001488a:	800087b7          	lui	a5,0x80008
8001488e:	82c78793          	add	a5,a5,-2004 # 8000782c <__SEGGER_RTL_ascii_ctype_mask>
80014892:	95be                	add	a1,a1,a5
80014894:	00054503          	lbu	a0,0(a0)
80014898:	0005c783          	lbu	a5,0(a1)
8001489c:	8d7d                	and	a0,a0,a5
8001489e:	8082                	ret

800148a0 <.L3>:
800148a0:	4501                	li	a0,0
800148a2:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ascii_tolower:

800148a4 <__SEGGER_RTL_ascii_tolower>:
800148a4:	fbf50713          	add	a4,a0,-65
800148a8:	47e5                	li	a5,25
800148aa:	00e7e463          	bltu	a5,a4,800148b2 <.L7>
800148ae:	02050513          	add	a0,a0,32

800148b2 <.L7>:
800148b2:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ascii_iswctype:

800148b4 <__SEGGER_RTL_ascii_iswctype>:
800148b4:	07f00793          	li	a5,127
800148b8:	02a7e263          	bltu	a5,a0,800148dc <.L10>
800148bc:	800067b7          	lui	a5,0x80006
800148c0:	c4c78793          	add	a5,a5,-948 # 80005c4c <__SEGGER_RTL_ascii_ctype_map>
800148c4:	953e                	add	a0,a0,a5
800148c6:	800087b7          	lui	a5,0x80008
800148ca:	82c78793          	add	a5,a5,-2004 # 8000782c <__SEGGER_RTL_ascii_ctype_mask>
800148ce:	95be                	add	a1,a1,a5
800148d0:	00054503          	lbu	a0,0(a0)
800148d4:	0005c783          	lbu	a5,0(a1)
800148d8:	8d7d                	and	a0,a0,a5
800148da:	8082                	ret

800148dc <.L10>:
800148dc:	4501                	li	a0,0
800148de:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ascii_towlower:

800148e0 <__SEGGER_RTL_ascii_towlower>:
800148e0:	fbf50713          	add	a4,a0,-65
800148e4:	47e5                	li	a5,25
800148e6:	00e7e463          	bltu	a5,a4,800148ee <.L14>
800148ea:	02050513          	add	a0,a0,32

800148ee <.L14>:
800148ee:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_ascii_wctomb:

800148f0 <__SEGGER_RTL_ascii_wctomb>:
800148f0:	07f00793          	li	a5,127
800148f4:	00b7e663          	bltu	a5,a1,80014900 <.L66>
800148f8:	00b50023          	sb	a1,0(a0)
800148fc:	4505                	li	a0,1
800148fe:	8082                	ret

80014900 <.L66>:
80014900:	5579                	li	a0,-2
80014902:	8082                	ret

Disassembly of section .text.libc.__SEGGER_RTL_current_locale:

80014904 <__SEGGER_RTL_current_locale>:
80014904:	1401a503          	lw	a0,320(gp) # 12094b8 <__SEGGER_RTL_locale_ptr>
80014908:	e119                	bnez	a0,8001490e <.L155>
8001490a:	32020513          	add	a0,tp,800 # 320 <default_isr_62+0x2a>

8001490e <.L155>:
8001490e:	8082                	ret

Disassembly of section .segger.init.__SEGGER_init_lzss:

80016c00 <__SEGGER_init_lzss>:
80016c00:	4008                	lw	a0,0(s0)
80016c02:	404c                	lw	a1,4(s0)
80016c04:	0421                	add	s0,s0,8
80016c06:	08000793          	li	a5,128

80016c0a <.L__SEGGER_init_lzss_NextByte>:
80016c0a:	0005c603          	lbu	a2,0(a1)
80016c0e:	0585                	add	a1,a1,1
80016c10:	c631                	beqz	a2,80016c5c <.L__SEGGER_init_lzss_Done>
80016c12:	02f66c63          	bltu	a2,a5,80016c4a <.L__SEGGER_init_lzss_LoopLiteral>
80016c16:	f8060613          	add	a2,a2,-128
80016c1a:	c231                	beqz	a2,80016c5e <.L__SEGGER_init_lzss_Error>
80016c1c:	0005c683          	lbu	a3,0(a1)
80016c20:	0585                	add	a1,a1,1
80016c22:	00f6e963          	bltu	a3,a5,80016c34 <.L__SEGGER_init_lzss_ShortRun>
80016c26:	f8068693          	add	a3,a3,-128
80016c2a:	06a2                	sll	a3,a3,0x8
80016c2c:	0005c703          	lbu	a4,0(a1)
80016c30:	0585                	add	a1,a1,1
80016c32:	96ba                	add	a3,a3,a4

80016c34 <.L__SEGGER_init_lzss_ShortRun>:
80016c34:	40d50733          	sub	a4,a0,a3

80016c38 <.L__SEGGER_init_lzss_LoopShort>:
80016c38:	00074683          	lbu	a3,0(a4)
80016c3c:	00d50023          	sb	a3,0(a0)
80016c40:	0705                	add	a4,a4,1
80016c42:	0505                	add	a0,a0,1
80016c44:	167d                	add	a2,a2,-1
80016c46:	fa6d                	bnez	a2,80016c38 <.L__SEGGER_init_lzss_LoopShort>
80016c48:	b7c9                	j	80016c0a <.L__SEGGER_init_lzss_NextByte>

80016c4a <.L__SEGGER_init_lzss_LoopLiteral>:
80016c4a:	0005c683          	lbu	a3,0(a1)
80016c4e:	0585                	add	a1,a1,1
80016c50:	00d50023          	sb	a3,0(a0)
80016c54:	0505                	add	a0,a0,1
80016c56:	167d                	add	a2,a2,-1
80016c58:	fa6d                	bnez	a2,80016c4a <.L__SEGGER_init_lzss_LoopLiteral>
80016c5a:	bf45                	j	80016c0a <.L__SEGGER_init_lzss_NextByte>

80016c5c <.L__SEGGER_init_lzss_Done>:
80016c5c:	8082                	ret

80016c5e <.L__SEGGER_init_lzss_Error>:
80016c5e:	a001                	j	80016c5e <.L__SEGGER_init_lzss_Error>

Disassembly of section .segger.init.__SEGGER_init_zero:

80016c60 <__SEGGER_init_zero>:
80016c60:	4008                	lw	a0,0(s0)
80016c62:	404c                	lw	a1,4(s0)
80016c64:	0421                	add	s0,s0,8
80016c66:	c591                	beqz	a1,80016c72 <.L__SEGGER_init_zero_Done>

80016c68 <.L__SEGGER_init_zero_Loop>:
80016c68:	00050023          	sb	zero,0(a0)
80016c6c:	0505                	add	a0,a0,1
80016c6e:	15fd                	add	a1,a1,-1
80016c70:	fde5                	bnez	a1,80016c68 <.L__SEGGER_init_zero_Loop>

80016c72 <.L__SEGGER_init_zero_Done>:
80016c72:	8082                	ret

Disassembly of section .segger.init.__SEGGER_init_copy:

80016c74 <__SEGGER_init_copy>:
80016c74:	4008                	lw	a0,0(s0)
80016c76:	404c                	lw	a1,4(s0)
80016c78:	4410                	lw	a2,8(s0)
80016c7a:	0431                	add	s0,s0,12
80016c7c:	ca09                	beqz	a2,80016c8e <.L__SEGGER_init_copy_Done>

80016c7e <.L__SEGGER_init_copy_Loop>:
80016c7e:	00058683          	lb	a3,0(a1)
80016c82:	00d50023          	sb	a3,0(a0)
80016c86:	0505                	add	a0,a0,1
80016c88:	0585                	add	a1,a1,1
80016c8a:	167d                	add	a2,a2,-1
80016c8c:	fa6d                	bnez	a2,80016c7e <.L__SEGGER_init_copy_Loop>

80016c8e <.L__SEGGER_init_copy_Done>:
80016c8e:	8082                	ret
